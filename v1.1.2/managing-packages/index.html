<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>3. Managing Packages · Pkg.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>Pkg.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../"><strong>1.</strong> Introduction</a></li><li><a class="toctext" href="../getting-started/"><strong>2.</strong> Getting Started</a></li><li class="current"><a class="toctext" href=""><strong>3.</strong> Managing Packages</a><ul class="internal"><li><a class="toctext" href="#Adding-packages-1">Adding packages</a></li><li><a class="toctext" href="#Removing-packages-1">Removing packages</a></li><li><a class="toctext" href="#Updating-packages-1">Updating packages</a></li><li><a class="toctext" href="#Pinning-a-package-1">Pinning a package</a></li><li><a class="toctext" href="#Testing-packages-1">Testing packages</a></li><li><a class="toctext" href="#Building-packages-1">Building packages</a></li><li><a class="toctext" href="#Garbage-collecting-old,-unused-packages-1">Garbage collecting old, unused packages</a></li><li><a class="toctext" href="#Preview-mode-1">Preview mode</a></li></ul></li><li><a class="toctext" href="../environments/"><strong>4.</strong> Working with Environments</a></li><li><a class="toctext" href="../creating-packages/"><strong>5.</strong> Creating Packages</a></li><li><a class="toctext" href="../compatibility/"><strong>6.</strong> Compatibility</a></li><li><a class="toctext" href="../registries/"><strong>7.</strong> Registries</a></li><li><a class="toctext" href="../glossary/"><strong>9.</strong> Glossary</a></li><li><a class="toctext" href="../api/"><strong>10.</strong> API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href=""><strong>3.</strong> Managing Packages</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/managing-packages.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>3. Managing Packages</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#**3.**-Managing-Packages-1" id="**3.**-Managing-Packages-1"><strong>3.</strong> Managing Packages</a></h1><h2><a class="nav-anchor" href="#Adding-packages-1" id="Adding-packages-1">Adding packages</a></h2><p>There are two ways of adding packages, either using the <code>add</code> command or the <code>dev</code> command. The most frequently used one is <code>add</code> and its usage is described first.</p><h3><a class="nav-anchor" href="#Adding-registered-packages-1" id="Adding-registered-packages-1">Adding registered packages</a></h3><p>In the Pkg REPL packages can be added with the <code>add</code> command followed by the name of the package, for example:</p><pre><code class="language-none">(v1.0) pkg&gt; add Example
   Cloning default registries into /Users/kristoffer/.julia/registries
   Cloning registry General from "https://github.com/JuliaRegistries/General.git"
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] + Example v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test</code></pre><p>Here we added the package Example to the current project. In this example, we are using a fresh Julia installation, and this is our first time adding a package using Pkg. By default, Pkg clones Julia's General registry, and uses this registry to look up packages requested for inclusion in the current environment. The status update shows a short form of the package UUID to the left, then the package name, and the version. Since standard libraries (e.g. <code>Test</code>) are shipped with Julia, they do not have a version. The project status contains the packages you have added yourself, in this case, <code>Example</code>:</p><pre><code class="language-none">(v1.0) pkg&gt; st
    Status `Project.toml`
  [7876af07] Example v0.5.1</code></pre><p>The manifest status, in addition, includes the dependencies of explicitly added packages.</p><pre><code class="language-none">(v1.0) pkg&gt; st --manifest
    Status `Manifest.toml`
  [7876af07] Example v0.5.1
  [8dfed614] Test</code></pre><p>It is possible to add multiple packages in one command as <code>pkg&gt; add A B C</code>.</p><p>After a package is added to the project, it can be loaded in Julia:</p><pre><code class="language-none">julia&gt; using Example

julia&gt; Example.hello("User")
"Hello, User"</code></pre><p>A specific version can be installed by appending a version after a <code>@</code> symbol, e.g. <code>@v0.4</code>, to the package name:</p><pre><code class="language-none">(v1.0) pkg&gt; add Example@0.4
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] + Example v0.4.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] + Example v0.4.1</code></pre><p>If the master branch (or a certain commit SHA) of <code>Example</code> has a hotfix that has not yet included in a registered version, we can explicitly track a branch (or commit) by appending <code>#branch</code> (or <code>#commit</code>) to the package name:</p><pre><code class="language-none">(v1.0) pkg&gt; add Example#master
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)</code></pre><p>The status output now shows that we are tracking the <code>master</code> branch of <code>Example</code>. When updating packages, we will pull updates from that branch.</p><p>To go back to tracking the registry version of <code>Example</code>, the command <code>free</code> is used:</p><pre><code class="language-none">(v1.0) pkg&gt; free Example
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1</code></pre><h3><a class="nav-anchor" href="#Adding-unregistered-packages-1" id="Adding-unregistered-packages-1">Adding unregistered packages</a></h3><p>If a package is not in a registry, it can still be added by instead of the package name giving the URL to the repository to <code>add</code>.</p><pre><code class="language-none">(v1.0) pkg&gt; add https://github.com/fredrikekre/ImportMacros.jl
  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`
 Resolving package versions...
Downloaded MacroTools ─ v0.4.1
  Updating `~/.julia/environments/v1.0/Project.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  [1914dd2f] + MacroTools v0.4.1</code></pre><p>The dependencies of the unregistered package (here <code>MacroTools</code>) got installed. For unregistered packages we could have given a branch (or commit SHA) to track using <code>#</code>, just like for registered packages.</p><h3><a class="nav-anchor" href="#Adding-a-local-package-1" id="Adding-a-local-package-1">Adding a local package</a></h3><p>Instead of giving a URL of a git repo to <code>add</code> we could instead have given a local path to a git repo. This works similarly to adding a URL. The local repository will be tracked (at some branch) and updates from that local repo are pulled when packages are updated. Note that changes to files in the local package repository will not immediately be reflected when loading that package. The changes would have to be committed and the packages updated in order to pull in the changes.</p><h3><a class="nav-anchor" href="#Developing-packages-1" id="Developing-packages-1">Developing packages</a></h3><p>By only using <code>add</code> your Manifest will always have a "reproducible state", in other words, as long as the repositories and registries used are still accessible it is possible to retrieve the exact state of all the dependencies in the project. This has the advantage that you can send your project (<code>Project.toml</code> and <code>Manifest.toml</code>) to someone else and they can "instantiate" that project in the same state as you had it locally. However, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the <code>dev</code> command exists.</p><p>Let's try to <code>dev</code> a registered package:</p><pre><code class="language-none">(v1.0) pkg&gt; dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]</code></pre><p>The <code>dev</code> command fetches a full clone of the package to <code>~/.julia/dev/</code> (the path can be changed by setting the environment variable <code>JULIA_PKG_DEVDIR</code>). When importing <code>Example</code> julia will now import it from <code>~/.julia/dev/Example</code> and whatever local changes have been made to the files in that path are consequently reflected in the code loaded. When we used <code>add</code> we said that we tracked the package repository, we here say that we track the path itself. Note that the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches etc. If we try to <code>dev</code> a package at some branch that already exists at <code>~/.julia/dev/</code> the package manager we will simply use the existing path. For example:</p><pre><code class="language-none">(v1.0) pkg&gt; dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloning</code></pre><p>Note the info message saying that it is using the existing path. As a general rule, the package manager will never touch files that are tracking a path.</p><p>If <code>dev</code> is used on a local path, that path to that package is recorded and used when loading that package. The path will be recorded relative to the project file, unless it is given as an absolute path.</p><p>To stop tracking a path and use the registered version again, use <code>free</code></p><pre><code class="language-none">(v1.0) pkg&gt; free Example
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1</code></pre><p>It should be pointed out that by using <code>dev</code> your project is now inherently stateful. Its state depends on the current content of the files at the path and the manifest cannot be "instantiated" by someone else without knowing the exact content of all the packages that are tracking a path.</p><p>Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To update sync the Manifest, use the REPL command <code>resolve</code>.</p><h2><a class="nav-anchor" href="#Removing-packages-1" id="Removing-packages-1">Removing packages</a></h2><p>Packages can be removed from the current project by using <code>pkg&gt; rm Package</code>. This will only remove packages that exist in the project, to remove a package that only exists as a dependency use <code>pkg&gt; rm --manifest DepPackage</code>. Note that this will remove all packages that depends on <code>DepPackage</code>.</p><h2><a class="nav-anchor" href="#Updating-packages-1" id="Updating-packages-1">Updating packages</a></h2><p>When new versions of packages the project is using are released, it is a good idea to update. Simply calling <code>up</code> will try to update <em>all</em> the dependencies of the project to the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to <code>up</code>, e.g:</p><pre><code class="language-none">(v1.0) pkg&gt; up Example</code></pre><p>The version of all other packages direct dependencies will stay the same. If you only want to update the minor version of packages, to reduce the risk that your project breaks, you can give the <code>--minor</code> flag, e.g:</p><pre><code class="language-none">(v1.0) pkg&gt; up --minor Example</code></pre><p>Packages that track a repository are not updated when a minor upgrade is done. Packages that track a path are never touched by the package manager.</p><h2><a class="nav-anchor" href="#Pinning-a-package-1" id="Pinning-a-package-1">Pinning a package</a></h2><p>A pinned package will never be updated. A package can be pinned using <code>pin</code> as for example</p><pre><code class="language-none">(v1.0) pkg&gt; pin Example
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲</code></pre><p>Note the pin symbol <code>⚲</code> showing that the package is pinned. Removing the pin is done using <code>free</code></p><pre><code class="language-none">(v1.0) pkg&gt; free Example
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1</code></pre><h2><a class="nav-anchor" href="#Testing-packages-1" id="Testing-packages-1">Testing packages</a></h2><p>The tests for a package can be run using <code>test</code>command:</p><pre><code class="language-none">(v1.0) pkg&gt; test Example
   Testing Example
   Testing Example tests passed</code></pre><h2><a class="nav-anchor" href="#Building-packages-1" id="Building-packages-1">Building packages</a></h2><p>The build step of a package is automatically run when a package is first installed. The output of the build process is directed to a file. To explicitly run the build step for a package the <code>build</code> command is used:</p><pre><code class="language-none">(v1.0) pkg&gt; build MbedTLS
  Building MbedTLS → `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`

shell&gt; cat ~/.julia/packages/MbedTLS/h1Vu/deps/build.log
┌ Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.
│   caller = macro expansion at OutputCollector.jl:63 [inlined]
└ @ Core OutputCollector.jl:63
...
[ Info: using prebuilt binaries</code></pre><h2><a class="nav-anchor" href="#Garbage-collecting-old,-unused-packages-1" id="Garbage-collecting-old,-unused-packages-1">Garbage collecting old, unused packages</a></h2><p>As packages are updated and projects are deleted, installed packages that were once used will inevitably become old and not used from any existing project. Pkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist and what packages those projects used. The rest can be deleted. This is done with the <code>gc</code> command:</p><pre><code class="language-none">(v1.0) pkg&gt; gc
    Active manifests at:
        `/Users/kristoffer/BinaryProvider/Manifest.toml`
        ...
        `/Users/kristoffer/Compat.jl/Manifest.toml`
   Deleted /Users/kristoffer/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB
   Deleted /Users/kristoffer/.julia/packages/Cassette/BXVB: 795.557 KiB
   ...
   Deleted /Users/kristoffer/.julia/packages/WeakRefStrings/YrK6: 27.328 KiB
   Deleted 36 package installations: 113.205 MiB</code></pre><p>Note that only packages in <code>~/.julia/packages</code> are deleted.</p><h2><a class="nav-anchor" href="#Preview-mode-1" id="Preview-mode-1">Preview mode</a></h2><p>If you just want to see the effects of running a command, but not change your state you can <code>preview</code> a command. For example:</p><pre><code class="language-none">(HelloWorld) pkg&gt; preview add Plots</code></pre><p>or</p><pre><code class="language-none">(HelloWorld) pkg&gt; preview up</code></pre><p>will show you the effects of adding <code>Plots</code>, or doing a full upgrade, respectively, would have on your project. However, nothing would be installed and your <code>Project.toml</code> and <code>Manifest.toml</code> are untouched.</p><footer><hr/><a class="previous" href="../getting-started/"><span class="direction">Previous</span><span class="title"><strong>2.</strong> Getting Started</span></a><a class="next" href="../environments/"><span class="direction">Next</span><span class="title"><strong>4.</strong> Working with Environments</span></a></footer></article></body></HTML>