var documenterSearchIndex = {"docs":
[{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Project-and-Manifest","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Two files that are central to Pkg are Project.toml and Manifest.toml. Project.toml and Manifest.toml are written in TOML (hence the .toml extension) and include information about dependencies, versions, package names, UUIDs etc."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"note: Note\nThe Project.toml and Manifest.toml files are not only used by the package manager; they are also used by Julia's code loading, and determine e.g. what using Example should do. For more details see the section about Code Loading in the Julia manual."},{"title":"Project.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Project.toml","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The project file describes the project on a high level, for example, the package/project dependencies and compatibility constraints are listed in the project file. The file entries are described below."},{"title":"The authors field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-authors-field","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"For a package, the optional authors field is a TOML array describing the package authors. Entries in the array can either be a string in the form \"NAME\" or \"NAME <EMAIL>\", or a table keys following the Citation File Format schema for either a person or an entity."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"For example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"authors = [\n  \"Some One <someone@email.com>\",\n  \"Foo Bar <foo@bar.com>\",\n  {given-names = \"Baz\", family-names = \"Qux\", email = \"bazqux@example.com\", orcid = \"https://orcid.org/0000-0000-0000-0000\", website = \"https://github.com/bazqux\"},\n]"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"If all authors are specified by tables, it is possible to use the TOML Array of Tables syntax"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[authors]]\ngiven-names = \"Some\"\nfamily-names = \"One\"\nemail = \"someone@email.com\"\n\n[[authors]]\ngiven-names = \"Foo\"\nfamily-names = \"Bar\"\nemail = \"foo@bar.com\"\n\n[[authors]]\ngiven-names = \"Baz\"\nfamily-names = \"Qux\"\nemail = \"bazqux@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0000\"\nwebsite = \"https://github.com/bazqux\""},{"title":"The name field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-name-field","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The name of the package/project is determined by the name field, for example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"name = \"Example\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The name must be a valid identifier (a sequence of Unicode characters that does not start with a number and is neither true nor false). For packages, it is recommended to follow the package naming rules. The name field is mandatory for packages."},{"title":"The uuid field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-uuid-field","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"uuid is a string with a universally unique identifier for the package/project, for example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The uuid field is mandatory for packages."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"note: Note\nIt is recommended that UUIDs.uuid4() is used to generate random UUIDs."},{"title":"The version field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-version-field","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"version is a string with the version number for the package/project. It should consist of three numbers, major version, minor version, and patch number, separated with a ., for example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"version = \"1.2.5\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Julia uses Semantic Versioning (SemVer) and the version field should follow SemVer. The basic rules are:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Before 1.0.0, anything goes, but when you make breaking changes the minor version should be incremented.\nAfter 1.0.0 only make breaking changes when incrementing the major version.\nAfter 1.0.0 no new public API should be added without incrementing the minor version. This includes, in particular, new types, functions, methods, and method overloads, from Base or other packages."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"See also the section on Compatibility."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Note that Pkg.jl deviates from the SemVer specification when it comes to versions pre-1.0.0. See the section on pre-1.0 behavior for more details."},{"title":"The readonly field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-readonly-field","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The readonly field is a boolean that, when set to true, marks the environment as read-only. This prevents any modifications to the environment, including adding, removing, or updating packages. For example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"readonly = true"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"When an environment is marked as readonly, Pkg will throw an error if any operation that would modify the environment is attempted. If the readonly field is not present or set to false (the default), the environment can be modified normally."},{"title":"The [deps] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[deps]-section","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"All dependencies of the package/project are listed in the [deps] section. Each dependency is listed as a name-uuid pair, for example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Typically it is not needed to manually add entries to the [deps] section; this is instead handled by Pkg operations such as add."},{"title":"The [sources] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[sources]-section","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Specifying a path or repo (+ branch) for a dependency is done in the [sources] section. These are especially useful for controlling unregistered dependencies without having to bundle a corresponding manifest file."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Each entry in the [sources] section supports the following keys:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"url: The URL of the Git repository. Cannot be used with path.\nrev: The Git revision (branch name, tag, or commit hash) to use. Only valid with url.\nsubdir: A subdirectory within the repository containing the package.\npath: A local filesystem path to the package. Cannot be used with url or rev."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"This might in practice look something like:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[sources]\nExample = {url = \"https://github.com/JuliaLang/Example.jl\", rev = \"custom_branch\"}\nWithinMonorepo = {url = \"https://github.org/author/BigProject\", subdir = \"SubPackage\"}\nSomeDependency = {path = \"deps/SomeDependency.jl\"}"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Note that this information is only used when this environment is active, i.e. it is not used if this project is a package that is being used as a dependency."},{"title":"The [compat] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[compat]-section","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Compatibility constraints for the dependencies listed under [deps] can be listed in the [compat] section. Example:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]\nExample = \"1.2\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The Compatibility section describes the different possible compatibility constraints in detail. It is also possible to list constraints on julia itself, although julia is not listed as a dependency in the [deps] section:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[compat]\njulia = \"1.1\""},{"title":"The [workspace] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[workspace]-section","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"A project file can define a workspace by giving a set of projects that is part of that workspace. Each project in a workspace can include their own dependencies, compatibility information, and even function as full packages."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"When the package manager resolves dependencies, it considers the requirements of all the projects in the workspace. The compatible versions identified during this process are recorded in a single manifest file located next to the base project file."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"A workspace is defined in the base project by giving a list of the projects in it:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[workspace]\nprojects = [\"test\", \"docs\", \"benchmarks\", \"PrivatePackage\"]"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"This structure is particularly beneficial for developers using a monorepo approach, where a large number of unregistered packages may be involved. It's also useful for adding documentation or benchmarks to a package by including additional dependencies beyond those of the package itself."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Workspace can be nested: a project that itself defines a workspace can also be part of another workspace. In this case, the workspaces are \"merged\" with a single manifest being stored alongside the \"root project\" (the project that doesn't have another workspace including it)."},{"title":"Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Manifest.toml","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The manifest file is an absolute record of the state of the packages in the environment. It includes exact information about (direct and indirect) dependencies of the project. Given a Project.toml + Manifest.toml pair, it is possible to instantiate the exact same package environment, which is very useful for reproducibility. For the details, see Pkg.instantiate."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"note: Note\nThe Manifest.toml file is generated and maintained by Pkg and, in general, this file should never be modified manually."},{"title":"Different Manifests for Different Julia versions","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Different-Manifests-for-Different-Julia-versions","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Starting from Julia v1.10.8, there is an option to name manifest files in the format Manifest-v{major}.{minor}.toml. Julia will then preferentially use the version-specific manifest file if available. For example, if both Manifest-v1.11.toml and Manifest.toml exist, Julia 1.11 will prioritize using Manifest-v1.11.toml. However, Julia versions 1.10, 1.12, and all others will default to using Manifest.toml. This feature allows for easier management of different instantiated versions of dependencies for various Julia versions. Note that there can only be one Project.toml file. While Manifest-v{major}.{minor}.toml files are not automatically created by Pkg, users can manually rename a Manifest.toml file to match the versioned format, and Pkg will subsequently maintain it through its operations."},{"title":"Manifest.toml entries","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Manifest.toml-entries","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"There are three top-level entries in the manifest which could look like this:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"julia_version = \"1.8.2\"\nmanifest_format = \"2.0\"\nproject_hash = \"4d9d5b552a1236d3c1171abf88d59da3aaac328a\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"This shows the Julia version the manifest was created on, the \"format\" of the manifest and a hash of the project file, so that it is possible to see when the manifest is stale compared to the project file."},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Each dependency has its own section in the manifest file, and its content varies depending on how the dependency was added to the environment. Every dependency section includes a combination of the following entries:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"uuid: the UUID for the dependency, for example uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\".\ndeps: a vector listing the dependencies of the dependency, for example deps = [\"Example\", \"JSON\"].\nversion: a version number, for example version = \"1.2.6\".\npath: a file path to the source code, for example path = /home/user/Example.\nrepo-url: a URL to the repository where the source code was found, for example repo-url = \"https://github.com/JuliaLang/Example.jl.git\".\nrepo-rev: a git revision, for example a branch repo-rev = \"master\" or a commit repo-rev = \"66607a62a83cb07ab18c0b35c038fcd62987c9b1\".\ngit-tree-sha1: a content hash of the source tree, for example git-tree-sha1 = \"ca3820cc4e66f473467d912c4b2b3ae5dc968444\"."},{"title":"Added package","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Added-package","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"When a package is added from a package registry, for example by invoking pkg> add Example or with a specific version pkg> add Example@1.2, the resulting Manifest.toml entry looks like:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.3\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Note, in particular, that no repo-url is present, since that information is included in the registry where this package was found."},{"title":"Added package by branch","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Added-package-by-branch","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The resulting dependency section when adding a package specified by a branch, e.g. pkg> add Example#master or pkg> add https://github.com/JuliaLang/Example.jl.git, looks like:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"master\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Note that both the branch we are tracking (master) and the remote repository url (\"https://github.com/JuliaLang/Example.jl.git\") are stored in the manifest."},{"title":"Added package by commit","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Added-package-by-commit","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The resulting dependency section when adding a package specified by a commit, e.g. pkg> add Example#cf6ba6cc0be0bb5f56840188563579d67048be34, looks like:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"cf6ba6cc0be0bb5f56840188563579d67048be34\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The only difference from tracking a branch is the content of repo-rev."},{"title":"Developed package","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Developed-package","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The resulting dependency section when adding a package with develop, e.g. pkg> develop Example or pkg> develop /path/to/local/folder/Example, looks like:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\npath = \"/home/user/.julia/dev/Example/\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Note that the path to the source code is included, and changes made to that source tree is directly reflected."},{"title":"Pinned package","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Pinned-package","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Pinned packages are also recorded in the manifest file; the resulting dependency section e.g. pkg> add Example; pin Example looks like:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\npinned = true\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"The only difference is the addition of the pinned = true entry."},{"title":"Multiple packages with the same name","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Multiple-packages-with-the-same-name","category":"section","text":""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"Julia differentiates packages based on UUID, which means that the name alone is not enough to identify a package. It is possible to have multiple packages in the same environment with the same name, but with different UUID. In such a situation the Manifest.toml file looks a bit different. Consider for example the situation where you have added A and B to your environment, and the Project.toml file looks as follows:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[deps]\nA = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\nB = \"edca9bc6-334e-11e9-3554-9595dbb4349c\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"If A now depends on B = \"f41f7b98-334e-11e9-1257-49272045fb24\", i.e. another package named B there will be two different B packages in the Manifest.toml file. In this case, the full Manifest.toml file, with git-tree-sha1 and version fields removed for clarity, looks like this:"},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"[[deps.A]]\nuuid = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\n\n    [deps.A.deps]\n    B = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n\n[[deps.B]]\nuuid = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n[[deps.B]]\nuuid = \"edca9bc6-334e-11e9-3554-9595dbb4349c\""},{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/","category":"page","text":"There is now an array of the two B packages, and the [deps] section for A has been expanded to be explicit about which B package A depends on."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/#Managing-Packages","category":"section","text":""},{"title":"Adding packages","page":"3. Managing Packages","location":"managing-packages/#Adding-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"There are two ways of adding packages, either using the add command or the dev command. The most frequently used is add and its usage is described first."},{"title":"Adding registered packages","page":"3. Managing Packages","location":"managing-packages/#Adding-registered-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"In the Pkg REPL, packages can be added with the add command followed by the name of the package, for example:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.13) pkg> add JSON\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.13/Project.toml`\n  [682c06a0] + JSON v0.21.4\n    Updating `~/.julia/environments/v1.13/Manifest.toml`\n  [682c06a0] + JSON v0.21.4\n  [69de0a69] + Parsers v2.8.3\n  [aea7be01] + PrecompileTools v1.3.2\n  [21216c6a] + Preferences v1.5.0\n  [ade2ca70] + Dates v1.11.0\n  [a63ad114] + Mmap v1.11.0\n  [de0858da] + Printf v1.11.0\n  [9a3f8284] + Random v1.11.0\n  [ea8e919c] + SHA v0.7.0\n  [fa267f1f] + TOML v1.0.3\n  [cf7118a7] + UUIDs v1.11.0\n  [4ec0a83e] + Unicode v1.11.0"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Here we added the package JSON to the current environment (which is the default @v1.10 environment). In this example, we are using a fresh Julia installation, and this is our first time adding a package using Pkg. By default, Pkg installs the General registry and uses this registry to look up packages requested for inclusion in the current environment. The status update shows a short form of the package UUID to the left, then the package name, and the version. Finally, the newly installed packages are \"precompiled\"."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"It is possible to add multiple packages in one command as pkg> add A B C."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The status output contains the packages you have added yourself, in this case, JSON:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.13) pkg> st\nStatus `~/.julia/environments/v1.13/Project.toml`\n  [682c06a0] JSON v0.21.4"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The manifest status shows all the packages in the environment, including recursive dependencies:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.13) pkg> st -m\nStatus `~/.julia/environments/v1.13/Manifest.toml`\n  [682c06a0] JSON v0.21.4\n  [69de0a69] Parsers v2.8.3\n  [aea7be01] PrecompileTools v1.3.2\n  [21216c6a] Preferences v1.5.0\n  [ade2ca70] Dates v1.11.0\n  [a63ad114] Mmap v1.11.0\n  [de0858da] Printf v1.11.0\n  [9a3f8284] Random v1.11.0\n  [ea8e919c] SHA v0.7.0\n  [fa267f1f] TOML v1.0.3\n  [cf7118a7] UUIDs v1.11.0\n  [4ec0a83e] Unicode v1.11.0"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Note that before 1.11 standard libraries (e.g. Dates) did not have dedicated version numbers."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"To specify that you want a particular version (or set of versions) of a package, use the compat command. For example, to require any patch release of the v0.21 series of JSON after v0.21.4, call compat JSON 0.21.4:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> compat JSON 0.21.4\n      Compat entry set:\n  JSON = \"0.21.4\"\n     Resolve checking for compliance with the new compat rules...\n       Error empty intersection between JSON@0.21.3 and project compatibility 0.21.4 - 0.21\n  Suggestion Call `update` to attempt to meet the compatibility requirements.\n\n(@v1.10) pkg> update\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"See the section on Compatibility for more on using the compat system."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"After a package is added to the project, it can be loaded in Julia:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"julia> using JSON\n\njulia> JSON.json(Dict(\"foo\" => [1, \"bar\"])) |> print\n{\"foo\":[1,\"bar\"]}"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"note: Note\nOnly packages that have been added with add can be loaded (which are packages that are shown when using st in the Pkg REPL). Packages that are pulled in only as dependencies (for example the Parsers package above) can not be loaded."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"A specific version of a package can be installed by appending a version after a @ symbol to the package name:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> add JSON@0.21.1\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n⌃ [682c06a0] + JSON v0.21.1\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n⌃ [682c06a0] + JSON v0.21.1\n⌅ [69de0a69] + Parsers v1.1.2\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"As seen above, Pkg gives some information when a package is not installed at its latest version."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"If not all three numbers are given for the version, for example, 0.21, then the latest registered version of 0.21.x would be installed."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"If a branch (or a certain commit) of Example has a hotfix that is not yet included in a registered version, we can explicitly track that branch (or commit) by appending #branchname (or #commitSHA1) to the package name:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> add Example#master\n     Cloning git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The status output now shows that we are tracking the master branch of Example. When updating packages, updates are pulled from that branch."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"note: Note\nIf we would specify a commit id instead of a branch name, e.g. add Example#025cf7e, then we would effectively \"pin\" the package to that commit. This is because the commit id always points to the same thing unlike a branch, which may be updated."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"To go back to tracking the registry version of Example, the command free is used:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> free Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3"},{"title":"Adding unregistered packages","page":"3. Managing Packages","location":"managing-packages/#Adding-unregistered-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"If a package is not in a registry, it can be added by specifying a URL to the Git repository:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> add https://github.com/fredrikekre/ImportMacros.jl\n     Cloning git-repo `https://github.com/fredrikekre/ImportMacros.jl`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The dependencies of the unregistered package (here MacroTools) got installed. For unregistered packages, we could have given a branch name (or commit SHA1) to track using #, just like for registered packages."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"If you want to add a package using the SSH-based git protocol, you have to use quotes because the URL contains a @. For example,"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> add \"git@github.com:fredrikekre/ImportMacros.jl.git\"\n    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nUpdating `~/.julia/environments/v1/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\nUpdating `~/.julia/environments/v1/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`"},{"title":"Adding a package in a subdirectory of a repository","page":"3. Managing Packages","location":"managing-packages/#Adding-a-package-in-a-subdirectory-of-a-repository","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"If the package you want to add by URL is not in the root of the repository, then you need pass that subdirectory using :. For instance, to add the SnoopCompileCore package in the SnoopCompile repository:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"pkg> add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore\n    Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n  [9e88b42a] + Serialization"},{"title":"Adding a local package","page":"3. Managing Packages","location":"managing-packages/#Adding-a-local-package","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Instead of giving a URL of a git repo to add we could instead have given a local path to a git repo. This works similar to adding a URL. The local repository will be tracked (at some branch) and updates from that local repo are pulled when packages are updated."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"warning: Warning\nNote that tracking a package through add is distinct from develop (which is described in the next section). When using add on a local git repository, changes to files in the local package repository will not immediately be reflected when loading that package. The changes would have to be committed and the packages updated in order to pull in the changes. In the majority of cases, you want to use develop on a local path, not add."},{"title":"Developing packages","page":"3. Managing Packages","location":"managing-packages/#developing","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"By only using add your environment always has a \"reproducible state\", in other words, as long as the repositories and registries used are still accessible it is possible to retrieve the exact state of all the dependencies in the environment. This has the advantage that you can send your environment (Project.toml and Manifest.toml) to someone else and they can Pkg.instantiate that environment in the same state as you had it locally. However, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the dev command exists."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Let's try to dev a registered package:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The dev command fetches a full clone of the package to ~/.julia/dev/ (the path can be changed by setting the environment variable JULIA_PKG_DEVDIR, the default being joinpath(DEPOT_PATH[1],\"dev\")). When importing Example julia will now import it from ~/.julia/dev/Example and whatever local changes have been made to the files in that path are consequently reflected in the code loaded. When we used add we said that we tracked the package repository; we here say that we track the path itself. Note the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches, etc. If we try to dev a package at some branch that already exists at ~/.julia/dev/ the package manager will simply re-use the existing path. If dev is used on a local path, that path to that package is recorded and used when loading that package. The path will be recorded relative to the project file, unless it is given as an absolute path."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Let's try modify the file at  ~/.julia/dev/Example/src/Example.jl and add a simple function:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"plusone(x::Int) = x + 1"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Now we can go back to the Julia REPL and load the package and run the new function:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"julia> import Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\njulia> Example.plusone(1)\n2"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"warning: Warning\nA package can only be loaded once per Julia session. If you have run import Example in the current Julia session, you will have to restart Julia to see the changes to Example. Revise.jl can make this process significantly more pleasant, but setting it up is beyond the scope of this guide."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"To stop tracking a path and use the registered version again, use free:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> free Example\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"It should be pointed out that by using dev your project is now inherently stateful. Its state depends on the current content of the files at the path and the manifest cannot be \"instantiated\" by someone else without knowing the exact content of all the packages that are tracking a path."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To synchronize the Manifest, use the REPL command resolve."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"In addition to absolute paths, add and dev can accept relative paths to packages. In this case, the relative path from the active project to the package is stored. This approach is useful when the relative location of tracked dependencies is more important than their absolute location. For example, the tracked dependencies can be stored inside of the active project directory. The whole directory can be moved and Pkg will still be able to find the dependencies because their path relative to the active project is preserved even though their absolute path has changed."},{"title":"Removing packages","page":"3. Managing Packages","location":"managing-packages/#Removing-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Packages can be removed from the current project by using pkg> rm Package. This will only remove packages that exist in the project; to remove a package that only exists as a dependency use pkg> rm --manifest DepPackage. Note that this will remove all packages that (recursively) depend on DepPackage."},{"title":"Updating packages","page":"3. Managing Packages","location":"managing-packages/#updating","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"When new versions of packages are released, it is a good idea to update. Simply calling up will try to update all the dependencies of the project to the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to up, e.g:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> up Example"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"This will only allow Example do upgrade. If you also want to allow dependencies of Example to upgrade (with the exception of packages that are in the project) you can pass the --preserve=direct flag."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> up --preserve=direct Example"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"And if you also want to allow dependencies of Example that are also in the project to upgrade, you can use --preserve=none:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> up --preserve=none Example"},{"title":"Pinning a package","page":"3. Managing Packages","location":"managing-packages/#Pinning-a-package","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"A pinned package will never be updated. A package can be pinned using pin, for example:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> pin Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Note the pin symbol ⚲ showing that the package is pinned. Removing the pin is done using free"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> free Example\n  Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3"},{"title":"Testing packages","page":"3. Managing Packages","location":"managing-packages/#Testing-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The tests for a package can be run using test command:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> test Example\n...\n   Testing Example\n   Testing Example tests passed"},{"title":"Building packages","page":"3. Managing Packages","location":"managing-packages/#Building-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The build step of a package is automatically run when a package is first installed. The output of the build process is directed to a file. To explicitly run the build step for a package, the build command is used:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> build IJulia\n    Building Conda ─→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/6e47d11ea2776bc5627421d59cdcc1296c058071/build.log`\n    Building IJulia → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log`\n\njulia> print(read(joinpath(homedir(), \".julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log\"), String))\n[ Info: Installing Julia kernelspec in /home/kc/.local/share/jupyter/kernels/julia-1.8"},{"title":"Interpreting and resolving version conflicts","page":"3. Managing Packages","location":"managing-packages/#conflicts","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"An environment consists of a set of mutually-compatible packages. Sometimes, you can find yourself in a situation in which two packages you'd like to use simultaneously have incompatible requirements. In such cases you'll get an \"Unsatisfiable requirements\" error:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"print(\"pkg> add A\\n\", try resolve_tst(deps_data, reqs_data) catch e sprint(showerror, e) end)   # hide"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"This message means that a package named D has a version conflict. Even if you have never added D directly, this kind of error can arise if D is required by other packages that you are trying to use."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"note: Note\nWhen tackling these conflicts, first consider that the bigger a project gets, the more likely this is to happen. Using targeted projects for a given task is highly recommended, and removing unused dependencies is a good first step when hitting these issues. For instance, a common pitfall is having more than a few packages in your default (i.e. (@1.8)) environment, and using that as an environment for all tasks you're using julia for. It's better to create a dedicated project for the task you're working on, and keep the dependencies there minimal. To read more see Working with Environments"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The error message has a lot of crucial information. It may be easiest to interpret piecewise:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Unsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"means that D has three released versions, v0.1.0, v0.2.0, and v0.2.1. You also have the option of not having it installed at all. Each of these options might have different implications for the set of other packages that can be installed."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Crucially, notice the stroke characters (vertical and horizontal lines) and their indentation. Together, these connect messages to specific packages. For instance the right stroke of ├─ indicates that the message to its right (possible versions...) is connected to the package pointed to by its vertical stroke (D). This same principle applies to the next line:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":" ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The vertical stroke here is also aligned under D, and thus this message is in reference to D. Specifically, there's some other package B that depends on version v0.1.0 of D. Notice that this is not the newest version of D."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Next comes some information about B:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":" │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The two lines below the first have a vertical stroke that aligns with B, and thus they provide information about B. They tell you that B has just one release, v1.0.0. You've not specified a particular version of B (restricted to versions * means that any version will do), but the explicit requirement means that you've asked for B to be part of your environment, for example by pkg> add B. You might have asked for B previously, and the requirement is still active."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The conflict becomes clear with the line"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Here again, the vertical stroke aligns with D: this means that D is also required by another package, C. C requires v0.2.0 of D, and this conflicts with B's need for v0.1.0 of D. This explains the conflict."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"But wait, you might ask, what is C and why do I need it at all? The next few lines introduce the problem:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"   └─C [c99a7cb2] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"These provide more information about C, revealing that it has 3 released versions: v0.1.0, v0.1.1, and v0.2.0. Moreover, C is required by another package A. Indeed, A's requirements are such that we need v0.2.0 of C. A's origin is revealed on the next lines:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"So we can see that A was explicitly required, and in this case, it's because we were trying to add it to our environment."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"In summary, we explicitly asked to use A and B, but this gave a conflict for D. The reason was that B and C require conflicting versions of D. Even though C isn't something we asked for explicitly, it was needed by A."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"To fix such errors, you have a number of options:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"try updating your packages. It's possible the developers of these packages have recently released new versions that are mutually compatible.\nremove either A or B from your environment. Perhaps B is left over from something you were previously working on, and you don't need it anymore. If you don't need A and B at the same time, this is the easiest way to fix the problem.\ntry reporting your conflict. In this case, we were able to deduce that B requires an outdated version of D. You could thus report an issue in the development repository of B.jl asking for an updated version.\ntry fixing the problem yourself. This becomes easier once you understand Project.toml files and how they declare their compatibility requirements. We'll return to this example in Fixing conflicts."},{"title":"Yanked packages","page":"3. Managing Packages","location":"managing-packages/#Yanked-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Package registries can mark specific versions of packages as \"yanked\". A yanked package version is one that should no longer be used, typically because it contains serious bugs, security vulnerabilities, or other critical issues. When a package version is yanked, it becomes unavailable for new installations but remains accessible (i.e. via instantiate) to maintain reproducibility of existing environments."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"When you run pkg> status, yanked packages are clearly marked with a warning symbol:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.13) pkg> status\n    Status `~/.julia/environments/v1.13/Project.toml`\n  [682c06a0] JSON v0.21.3\n  [f4259836] Example v1.2.0 [yanked]"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The [yanked] annotation indicate that version v1.2.0 of the Example package has been yanked and should be updated or replaced."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"When resolving dependencies, Pkg will warn you if yanked packages are present and may provide guidance on how to resolve the situation. It's important to address yanked packages promptly to ensure the security and stability of your Julia environment."},{"title":"Garbage collecting old, unused packages","page":"3. Managing Packages","location":"managing-packages/#Garbage-collecting-old,-unused-packages","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"As packages are updated and projects are deleted, installed package versions and artifacts that were once used will inevitably become old and not used from any existing project. Pkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist and what packages/artifacts those projects used. If a package or artifact is not marked as used by any project, it is added to a list of orphaned packages. Packages and artifacts that are in the orphan list for 30 days without being used again are deleted from the system on the next garbage collection. This timing is configurable via the collect_delay keyword argument to Pkg.gc(). A value of 0 will cause anything currently not in use to be collected immediately, skipping the orphans list entirely; If you are short on disk space and want to clean out as many unused packages and artifacts as possible, you may want to try this, but if you need these versions again, you will have to download them again. To run a typical garbage collection with default arguments, simply use the gc command at the pkg> REPL:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"(@v1.10) pkg> gc\n    Active manifests at:\n        `~/BinaryProvider/Manifest.toml`\n        ...\n        `~/Compat.jl/Manifest.toml`\n    Active artifacts:\n        `~/src/MyProject/Artifacts.toml`\n\n    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\n    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB\n   ...\n   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)\n   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)\n\n   Deleted 36 package installations (113.205 MiB)\n   Deleted 15 artifact installations (20.759 GiB)"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Note that only packages in ~/.julia/packages are deleted."},{"title":"Offline Mode","page":"3. Managing Packages","location":"managing-packages/#Offline-Mode","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"In offline mode, Pkg tries to do as much as possible without connecting to internet. For example, when adding a package Pkg only considers versions that are already downloaded in version resolution."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"To work in offline mode use import Pkg; Pkg.offline(true) or set the environment variable JULIA_PKG_OFFLINE to \"true\"."},{"title":"Pkg client/server","page":"3. Managing Packages","location":"managing-packages/#Pkg-client/server","category":"section","text":""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"When you add a new registered package, usually three things would happen:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"update registries,\ndownload the source code of the package,\nif not available, download artifacts required by the package."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"The General registry and most packages in it are developed on GitHub, while the artifacts data are hosted on various platforms. When the network connection to GitHub and AWS S3 is not stable, it is usually not a good experience to install or update packages. Fortunately, the pkg client/server feature improves the experience in the sense that:"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"If set, the pkg client would first try to download data from the pkg server,\nif that fails, then it falls back to downloading from the original sources (e.g., GitHub)."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"By default, the client makes upto 8 concurrent requests to the server. This can set by the environment variable JULIA_PKG_CONCURRENT_DOWNLOADS."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"Since Julia 1.5, https://pkg.julialang.org provided by the JuliaLang organization is used as the default pkg server. In most cases, this should be transparent, but users can still set/unset a pkg server upstream via the environment variable JULIA_PKG_SERVER."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"# manually set it to some pkg server\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"pkg.julialang.org\"\n\"pkg.julialang.org\"\n\n# unset to always download data from original sources\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"\"\n\"\""},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"For clarification, some sources are not provided by Pkg server"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"packages/registries fetched via git\n]add https://github.com/JuliaLang/Example.jl.git\n]add Example#v0.5.3 (Note that this is different from ]add Example@0.5.3)\n]registry add https://github.com/JuliaRegistries/General.git, including registries installed by Julia before 1.4.\nartifacts without download info\nTestImages"},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"note: Note\nIf you have a new registry installed via pkg server, then it's impossible for old Julia versions to update the registry because Julia before 1.4 doesn't know how to fetch new data. Hence, for users that frequently switch between multiple Julia versions, it is recommended to still use git-controlled registries."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/","category":"page","text":"For the deployment of pkg server, please refer to PkgServer.jl."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/#creating-packages-tutorial","category":"section","text":""},{"title":"Generating files for a package","page":"5. Creating Packages","location":"creating-packages/#Generating-files-for-a-package","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nThe PkgTemplates package offers an easy, repeatable, and customizable way to generate the files for a new package. It can also generate files needed for Documentation, CI, etc. We recommend that you use PkgTemplates for creating new packages instead of using the minimal pkg> generate functionality described below."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"To generate the bare minimum files for a new package, use pkg> generate."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"(@v1.10) pkg> generate HelloWorld"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"This creates a new project HelloWorld in a subdirectory by the same name, with the following files (visualized with the external tree command):"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"shell> tree HelloWorld/\nHelloWorld/\n├── Project.toml\n└── src\n    └── HelloWorld.jl\n\n2 directories, 2 files"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"The Project.toml file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"name = \"HelloWorld\"\nuuid = \"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\"\nversion = \"0.1.0\"\nauthors = [\"Some One <someone@email.com>\"]\n\n[deps]"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"The content of src/HelloWorld.jl is:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"module HelloWorld\n\ngreet() = print(\"Hello World!\")\n\nend # module"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"We can now activate the project by using the path to the directory where it is installed, and load the package:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"pkg> activate ./HelloWorld\n\njulia> import HelloWorld\n\njulia> HelloWorld.greet()\nHello World!"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"For the rest of the tutorial we enter inside the directory of the project, for convenience:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"julia> cd(\"HelloWorld\")"},{"title":"Adding dependencies to the project","page":"5. Creating Packages","location":"creating-packages/#Adding-dependencies-to-the-project","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Let’s say we want to use the standard library package Random and the registered package JSON in our project. We simply add these packages (note how the prompt now shows the name of the newly generated project, since we activated it):"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"(HelloWorld) pkg> add Random JSON\n   Resolving package versions...\n    Updating `~/HelloWorld/Project.toml`\n  [682c06a0] + JSON v0.21.3\n  [9a3f8284] + Random\n    Updating `~/HelloWorld/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n ..."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Both Random and JSON got added to the project’s Project.toml file, and the resulting dependencies got added to the Manifest.toml file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"We can now use both Random and JSON in our project. Changing src/HelloWorld.jl to"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"module HelloWorld\n\nimport Random\nimport JSON\n\ngreet() = print(\"Hello World!\")\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"and reloading the package, the new greet_alien function that uses Random can be called:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"julia> HelloWorld.greet_alien()\nHello aT157rHV"},{"title":"Defining a public API","page":"5. Creating Packages","location":"creating-packages/#Defining-a-public-API","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"If you want your package to be useful to other packages and you want folks to be able to easily update to newer version of your package when they come out, it is important to document what behavior will stay consistent across updates."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Unless you note otherwise, the public API of your package is defined as all the behavior you describe about public symbols. A public symbol is a symbol that is exported from your package with the export keyword or marked as public with the public keyword. When you change the behavior of something that was previously public so that the new version no longer conforms to the specifications provided in the old version, you should adjust your package version number according to Julia's variant on SemVer. If you would like to include a symbol in your public API without exporting it into the global namespace of folks who call using YourPackage, you should mark that symbol as public with public that_symbol. Symbols marked as public with the public keyword are just as public as those marked as public with the export keyword, but when folks call using YourPackage, they will still have to qualify access to those symbols with YourPackage.that_symbol."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Let's say we would like our greet function to be part of the public API, but not the greet_alien function. We could then write the following and release it as version 1.0.0."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"module HelloWorld\n\nexport greet\n\nimport Random\nimport JSON\n\n\"Writes a friendly message.\"\ngreet() = print(\"Hello World!\")\n\n\"Greet an alien by a randomly generated name.\"\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Then, if we change greet to"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"\"Writes a friendly message that is exactly three words long.\"\ngreet() = print(\"Hello Lovely World!\")"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"We would release the new version as 1.1.0. This is not breaking because the new implementation conforms to the old documentation, but it does add a new feature, that the message must be three words long."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Later, we may wish to change greet_alien to"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"\"Greet an alien by the name of \\\"Zork\\\".\"\ngreet_alien() = print(\"Hello Zork\")"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"And also export it by changing"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"export greet"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"to"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"export greet, greet_alien"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"We should release this new version as 1.2.0 because it adds a new feature greet_alien to the public API. Even though greet_alien was documented before and the new version does not conform to the old documentation, this is not breaking because the old documentation was not attached to a symbol that was exported at the time so that documentation does not apply across released versions."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"However, if we now wish to change greet to"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"\"Writes a friendly message that is exactly four words long.\"\ngreet() = print(\"Hello very lovely world\")"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"we would need to release the new version as 2.0.0. In version 1.1.0, we specified that the greeting would be three words long, and because greet was exported, that description also applies to all future versions until the next breaking release. Because this new version does not conform to the old specification, it must be tagged as a breaking change."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Please note that version numbers are free and unlimited. It is okay to use lots of them (e.g. version 6.62.8)."},{"title":"Adding a build step to the package","page":"5. Creating Packages","location":"creating-packages/#Adding-a-build-step-to-the-package","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"The build step is executed the first time a package is installed or when explicitly invoked with build. A package is built by executing the file deps/build.jl."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"julia> mkpath(\"deps\");\n\njulia> write(\"deps/build.jl\",\n             \"\"\"\n             println(\"I am being built...\")\n             \"\"\");\n\n(HelloWorld) pkg> build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n\njulia> print(readchomp(\"deps/build.log\"))\nI am being built..."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"If the build step fails, the output of the build step is printed to the console"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"julia> write(\"deps/build.jl\",\n             \"\"\"\n             error(\"Ooops\")\n             \"\"\");\n\n(HelloWorld) pkg> build\n    Building HelloWorld → `~/HelloWorld/deps/build.log`\nERROR: Error building `HelloWorld`:\nERROR: LoadError: Ooops\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] top-level scope\n   @ ~/HelloWorld/deps/build.jl:1\n [3] include(fname::String)\n   @ Base.MainInclude ./client.jl:476\n [4] top-level scope\n   @ none:5\nin expression starting at /home/kc/HelloWorld/deps/build.jl:1"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"warning: Warning\nA build step should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the Scratch.jl package."},{"title":"Adding tests to the package","page":"5. Creating Packages","location":"creating-packages/#adding-tests-to-packages","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"When a package is tested the file test/runtests.jl is executed:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"julia> mkpath(\"test\");\n\njulia> write(\"test/runtests.jl\",\n             \"\"\"\n             println(\"Testing...\")\n             \"\"\");\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\nTesting...\n   Testing HelloWorld tests passed"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Tests are run in a new Julia process, where the package itself, and any test-specific dependencies, are available, see below."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"warning: Warning\nTests should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the Scratch.jl package."},{"title":"Test-specific dependencies","page":"5. Creating Packages","location":"creating-packages/#Test-specific-dependencies","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"There are two ways of adding test-specific dependencies (dependencies that are not dependencies of the package but will still be available to load when the package is tested)."},{"title":"target based test specific dependencies","page":"5. Creating Packages","location":"creating-packages/#target-based-test-specific-dependencies","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Using this method of adding test-specific dependencies, the packages are added under an [extras] section and to a test target, e.g. to add Markdown and Test as test dependencies, add the following to the Project.toml file:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"[extras]\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Markdown\", \"Test\"]"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Note that the only supported targets are test and build, the latter of which (not recommended) can be used for any deps/build.jl scripts."},{"title":"Alternative approach: test/Project.toml file test specific dependencies","page":"5. Creating Packages","location":"creating-packages/#Alternative-approach:-test/Project.toml-file-test-specific-dependencies","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nThe exact interaction between Project.toml, test/Project.toml and their corresponding Manifest.tomls are not fully worked out and may be subject to change in future versions. The older method of adding test-specific dependencies, described in the previous section, will therefore be supported throughout all Julia 1.X releases."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"In Julia 1.2 and later test dependencies can be declared in test/Project.toml. When running tests, Pkg will automatically merge this and the package Projects to create the test environment."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nIf no test/Project.toml exists Pkg will use the target based test specific dependencies."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"To add a test-specific dependency, i.e. a dependency that is available only when testing, it is thus enough to add this dependency to the test/Project.toml project. This can be done from the Pkg REPL by activating this environment, and then use add as one normally does. Let's add the Test standard library as a test dependency:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"(HelloWorld) pkg> activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(test) pkg> add Test\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n  Updating `~/HelloWorld/test/Manifest.toml`\n  [...]"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"We can now use Test in the test script and we can see that it gets installed when testing:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"julia> write(\"test/runtests.jl\",\n             \"\"\"\n             using Test\n             @test 1 == 1\n             \"\"\");\n\n(test) pkg> activate .\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n  [8dfed614] + Test\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n   Testing HelloWorld tests passed```"},{"title":"Compatibility on dependencies","page":"5. Creating Packages","location":"creating-packages/#Compatibility-on-dependencies","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Every dependency should in general have a compatibility constraint on it. This is an important topic so there is a separate chapter about it: Compatibility."},{"title":"Weak dependencies","page":"5. Creating Packages","location":"creating-packages/#Weak-dependencies","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nThis is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"compat: Compat\nThe described feature requires Julia 1.9+."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"A weak dependency is a dependency that will not automatically install when the package is installed but you can still control what versions of that package are allowed to be installed by setting compatibility on it. These are listed in the project file under the [weakdeps] section:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"[weakdeps]\nSomePackage = \"b3785f31-9d33-4cdf-bc73-f646780f1739\"\n\n[compat]\nSomePackage = \"1.2\""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"The current usage of this is almost solely limited to \"extensions\" which is described in the next section."},{"title":"Conditional loading of code in packages (Extensions)","page":"5. Creating Packages","location":"creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nThis is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"compat: Compat\nThe described feature requires Julia 1.9+."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Sometimes one wants to make two or more packages work well together, but may be reluctant (perhaps due to increased load times) to make one an unconditional dependency of the other. A package extension is a module in a file (similar to a package) that is automatically loaded when some other set of packages are loaded into the Julia session. This is very similar to functionality that the external package Requires.jl provides, but which is now available directly through Julia, and provides added benefits such as being able to precompile the extension."},{"title":"Code structure","page":"5. Creating Packages","location":"creating-packages/#Code-structure","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"A useful application of extensions could be for a plotting package that should be able to plot objects from a wide variety of different Julia packages. Adding all those different Julia packages as dependencies of the plotting package could be expensive since they would end up getting loaded even if they were never used. Instead, the code required to plot objects for specific packages can be put into separate files (extensions) and these are loaded only when the packages that define the type(s) we want to plot are loaded."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Below is an example of how the code can be structured for a use case in which a Plotting package wants to be able to display objects defined in the external package Contour. The file and folder structure shown below is found in the Plotting package."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Project.toml:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"name = \"Plotting\"\nversion = \"0.1.0\"\nuuid = \"...\"\n\n[weakdeps]\nContour = \"d38c429a-6771-53c6-b99e-75d170b6e991\"\n\n[extensions]\n# name of extension to the left\n# extension dependencies required to load the extension to the right\n# use a list for multiple extension dependencies\nContourExt = \"Contour\"\n\n[compat]\nContour = \"0.6.2\""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"src/Plotting.jl:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"module Plotting\n\nfunction plot(x::Vector)\n    # Some functionality for plotting a vector here\nend\n\nend # module"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"ext/ContourExt.jl (can also be in ext/ContourExt/ContourExt.jl):"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"module ContourExt # Should be same name as the file (just like a normal package)\n\nusing Plotting, Contour\n\nfunction Plotting.plot(c::Contour.ContourCollection)\n    # Some functionality for plotting a contour here\nend\n\nend # module"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Extensions can have arbitrary names (here ContourExt), following the format of this example is likely a good idea for extensions with a single dependency. In Pkg output, extension names are always shown together with their parent package name."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"compat: Compat\nOften you will put the extension dependencies into the test target so they are loaded when running e.g. Pkg.test(). On earlier Julia versions this requires you to also put the package in the [extras] section. This is unfortunate but the project verifier on older Julia versions will complain if this is not done."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nIf you use a manifest generated by a Julia version that does not know about extensions with a Julia version that does know about them, the extensions will not load. This is because the manifest lacks some information that tells Julia when it should load these packages. So make sure you use a manifest generated at least the Julia version you are using."},{"title":"Behavior of extensions","page":"5. Creating Packages","location":"creating-packages/#Behavior-of-extensions","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"A user that depends only on Plotting will not pay the cost of the \"extension\" inside the ContourExt module. It is only when the Contour package actually gets loaded that the ContourExt extension is loaded too and provides the new functionality."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"In our example, the new functionality is an additional method, which we add to an existing function from the parent package Plotting. Implementing such methods is among the most standard use cases of package extensions. Within the parent package, the function to extend can even be defined with zero methods, as follows:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"function plot end"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"note: Note\nIf one considers ContourExt as a completely separate package, it could be argued that defining Plotting.plot(c::Contour.ContourCollection) is type piracy since ContourExt owns neither the function Plotting.plot nor the type Contour.ContourCollection. However, for extensions, it is ok to assume that the extension owns the functions in its parent package."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"In other situations, one may need to define new symbols in the extension (types, structs, functions, etc.) instead of reusing those from the parent package. Such symbols are created in a separate module corresponding to the extension, namely ContourExt, and thus not in Plotting itself. If extension symbols are needed in the parent package, one must call Base.get_extension to retrieve them. Here is an example showing how a custom type defined in ContourExt can be accessed in Plotting:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"ext = Base.get_extension(@__MODULE__, :ContourExt)\nif !isnothing(ext)\n    ContourPlotType = ext.ContourPlotType\nend"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"On the other hand, accessing extension symbols from a third-party package (i.e. not the parent) is not a recommended practice at the moment."},{"title":"Backwards compatibility","page":"5. Creating Packages","location":"creating-packages/#Backwards-compatibility","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"This section discusses various methods for using extensions on Julia versions that support them, while simultaneously providing similar functionality on older Julia versions."},{"title":"Requires.jl","page":"5. Creating Packages","location":"creating-packages/#Requires.jl","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"This section is relevant if you are currently using Requires.jl but want to transition to using extensions (while still having Requires be used on Julia versions that do not support extensions). This is done by making the following changes (using the example above):"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Add the following to the package file. This makes it so that Requires.jl loads and inserts the callback only when extensions are not supported\n# This symbol is only defined on Julia versions that support extensions\nif !isdefined(Base, :get_extension)\nusing Requires\nend\n\n@static if !isdefined(Base, :get_extension)\nfunction __init__()\n    @require Contour = \"d38c429a-6771-53c6-b99e-75d170b6e991\" include(\"../ext/ContourExt.jl\")\nend\nend\nor if you have other things in your __init__() function:\nif !isdefined(Base, :get_extension)\nusing Requires\nend\n\nfunction __init__()\n    # Other init functionality here\n\n    @static if !isdefined(Base, :get_extension)\n        @require Contour = \"d38c429a-6771-53c6-b99e-75d170b6e991\" include(\"../ext/ContourExt.jl\")\n    end\nend\nMake the following change in the conditionally-loaded code in ContourExt.jl:\nisdefined(Base, :get_extension) ? (using Contour) : (using ..Contour)\nAdd Requires to [weakdeps] in your Project.toml file, so that it is listed in both [deps] and [weakdeps]. Julia 1.9+ knows to not install it as a regular dependency, whereas earlier versions will consider it a dependency."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"The package should now work with Requires.jl on Julia versions before extensions were introduced and with extensions on more recent Julia versions."},{"title":"Transition from normal dependency to extension","page":"5. Creating Packages","location":"creating-packages/#Transition-from-normal-dependency-to-extension","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"This section is relevant if you have a normal dependency that you want to transition be an extension (while still having the dependency be a normal dependency on Julia versions that do not support extensions). This is done by making the following changes (using the example above):"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Make sure that the package is both in the [deps] and [weakdeps] section. Newer Julia versions will ignore dependencies in [deps] that are also in [weakdeps].\nAdd the following to your main package file (typically at the bottom):\nif !isdefined(Base, :get_extension)\n  include(\"../ext/ContourExt.jl\")\nend"},{"title":"Using an extension while supporting older Julia versions","page":"5. Creating Packages","location":"creating-packages/#Using-an-extension-while-supporting-older-Julia-versions","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"In the case where one wants to use an extension (without worrying about the feature of the extension being available on older Julia versions) while still supporting older Julia versions the packages under [weakdeps] should be duplicated into [extras]. This is an unfortunate duplication, but without doing this the project verifier under older Julia versions will throw an error if it finds packages under [compat] that is not listed in [extras]."},{"title":"Package naming guidelines","page":"5. Creating Packages","location":"creating-packages/#Package-naming-guidelines","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Package names should be sensible to most Julia users, even to those who are not domain experts. The following guidelines apply to the General registry but may be useful for other package registries as well."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Since the General registry belongs to the entire community, people may have opinions about your package name when you publish it, especially if it's ambiguous or can be confused with something other than what it is. Usually, you will then get suggestions for a new name that may fit your package better."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.\nIt's ok for package names to contain DNA if you're talking about the DNA, which has a universally agreed upon definition.\nIt's more difficult to justify package names containing the acronym CI for instance, which may mean continuous integration, confidence interval, etc.\nIf there is risk of confusion it may be best to disambiguate an acronym with additional words such as a lab group or field.\nIf your acronym is unambiguous, easily searchable, and/or unlikely to be confused across domains a good justification is often enough for approval.\nAvoid using Julia in your package name or prefixing it with Ju.\nIt is usually clear from context and to your users that the package is a Julia package.\nPackage names already have a .jl extension, which communicates to users that Package.jl is a Julia package.\nHaving Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.\nPackages that provide most of their functionality in association with a new type should have pluralized names.\nDataFrames provides the DataFrame type.\nBloomFilters provides the BloomFilter type.\nIn contrast, JuliaParser provides no new type, but instead new functionality in the JuliaParser.parse() function.\nErr on the side of clarity, even if clarity seems long-winded to you.\nRandomMatrices is a less ambiguous name than RndMat or RMT, even though the latter are shorter.\nGenerally package names should be at least 5 characters long not including the .jl extension\nA less systematic name may suit a package that implements one of several possible approaches to its domain.\nJulia does not have a single comprehensive plotting package. Instead, Gadfly, PyPlot, Winston and other packages each implement a unique approach based on a particular design philosophy.\nIn contrast, SortingAlgorithms provides a consistent interface to use many well-established sorting algorithms.\nPackages that wrap external libraries or programs can be named after those libraries or programs.\nCPLEX.jl wraps the CPLEX library, which can be identified easily in a web search.\nMATLAB.jl provides an interface to call the MATLAB engine from within Julia.\nAvoid naming a package closely to an existing package\nWebsocket is too close to WebSockets and can be confusing to users. Rather use a new name such as SimpleWebsockets.\nAvoid using a distinctive name that is already in use in a well known, unrelated project.\nDon't use the names Tkinter.jl, TkinterGUI.jl, etc. for a package that is unrelated to the popular tkinter python package, even if it provides bindings to Tcl/Tk. A package name of Tkinter.jl would only be appropriate if the package used Python's library to accomplish its work or was spearheaded by the same community of developers.\nIt's okay to name a package HTTP.jl even though it is unrelated to the popular rust crate http because in most usages the name \"http\" refers to the hypertext transfer protocol, not to the http rust crate.\nIt's okay to name a package OpenSSL.jl if it provides an interface to the OpenSSL library, even without explicit affiliation with the creators of the OpenSSL (provided there's no copyright or trademark infringement etc.)\nPackages should follow the Stylistic Conventions.\nThe package name should begin with a capital letter and word separation is shown with upper camel case\nPackages that provide the functionality of a project from another language should use the Julia convention\nPackages that provide pre-built libraries and executables can keep their original name, but should get _jllas a suffix. For example pandoc_jll wraps pandoc. However, note that the generation and release of most JLL packages is handled by the Yggdrasil system.\nFor the complete list of rules for automatic merging into the General registry, see these guidelines."},{"title":"Registering packages","page":"5. Creating Packages","location":"creating-packages/#Registering-packages","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Once a package is ready it can be registered with the General Registry (see also the FAQ). Currently, packages are submitted via Registrator. In addition to Registrator, TagBot helps manage the process of tagging releases."},{"title":"Best Practices","page":"5. Creating Packages","location":"creating-packages/#Best-Practices","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Packages should avoid mutating their own state (writing to files within their package directory). Packages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by PackageCompiler.jl). To support the various use cases in the Julia package ecosystem, the Pkg developers have created a number of auxiliary packages and techniques to help package authors create self-contained, immutable, and relocatable packages:"},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Artifacts can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand. Prefer artifacts over attempting to open a file via a path such as joinpath(@__DIR__, \"data\", \"my_dataset.csv\") as this is non-relocatable. Once your package has been precompiled, the result of @__DIR__ will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location. Artifacts can be bundled and accessed easily using the artifact\"name\" string macro.\nScratch.jl provides the notion of \"scratch spaces\", mutable containers of data for packages. Scratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled. For important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg.\nPreferences.jl allows packages to read and write preferences to the top-level Project.toml. These preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior. Packages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that Preferences is available."},{"title":"See Also","page":"5. Creating Packages","location":"creating-packages/#See-Also","category":"section","text":""},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/","category":"page","text":"Managing Packages - Learn how to add, update, and manage package dependencies\nWorking with Environments - Understand environments and reproducible development\nCompatibility - Specify version constraints for dependencies\nAPI Reference - Functional API for non-interactive package management"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/#Compatibility","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Compatibility refers to the ability to restrict the versions of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Compatibility for a dependency is entered in the Project.toml file as for example:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\njulia = \"1.6\"\nExample = \"0.5\""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"After a compatibility entry is put into the project file, up can be used to apply it."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"The format of the version specifier is described in detail below."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"info: Info\nUse the command compat to edit the compat entries in the Pkg REPL, or manually edit the project file."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"info: Info\nThe rules below apply to the Project.toml file; for registries, see Registry Compat.toml."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"info: Info\nNote that registration into Julia's General Registry requires each dependency to have a [compat] entry with an upper bound."},{"title":"Version specifier format","page":"7. Compatibility","location":"compatibility/#Version-specifier-format","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Similar to other package managers, the Julia package manager respects semantic versioning (semver), with an exception for leading zeros. As an example, a version specifier given as e.g. 1.2.3 is therefore assumed to be compatible with the versions [1.2.3 - 2.0.0) where ) is a non-inclusive upper bound. More specifically, a version specifier is either given as a caret specifier, e.g. ^1.2.3  or as a tilde specifier, e.g. ~1.2.3. Caret specifiers are the default and hence 1.2.3 == ^1.2.3. The difference between a caret and tilde is described in the next section. The union of multiple version specifiers can be formed by comma separating individual version specifiers, e.g."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nExample = \"1.2, 2\""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"will result in [1.2.0, 3.0.0).  Note leading zeros are treated differently, e.g. Example = \"0.2, 1\" would only result in [0.2.0 - 0.3.0) ∪ [1.0.0 - 2.0.0). See the next section for more information on versions with leading zeros."},{"title":"Behavior of versions with leading zeros (0.0.x and 0.x.y)","page":"7. Compatibility","location":"compatibility/#compat-pre-1.0","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"While the semver specification says that all versions with a major version of 0 (versions before 1.0.0) are incompatible with each other, we have decided to only apply that for when both the major and minor versions are zero. In other words, 0.0.1 and 0.0.2 are considered incompatible. A pre-1.0 version with non-zero minor version (0.a.b with a != 0) is considered compatible with versions with the same minor version and smaller or equal patch versions (0.a.c with c <= b); i.e., the versions 0.2.2 and 0.2.3 are compatible with 0.2.1 and 0.2.0. Versions with a major version of 0 and different minor versions are not considered compatible, so the version 0.3.0 might have breaking changes from 0.2.0. To that end, the [compat] entry:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nExample = \"0.0.1\""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"results in a versionbound on Example as [0.0.1, 0.0.2) (which is equivalent to only the version 0.0.1), while the [compat] entry:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nExample = \"0.2.1\""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"results in a versionbound on Example as [0.2.1, 0.3.0)."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"In particular, a package may set version = \"0.2.4\" when it has feature additions compared to 0.2.3 as long as it remains backward compatible with 0.2.0.  See also The version field."},{"title":"Caret specifiers","page":"7. Compatibility","location":"compatibility/#Caret-specifiers","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"A caret (^) specifier allows upgrade that would be compatible according to semver. This is the default behavior if no specifier is used. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Some examples are shown below."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgA = \"^1.2.3\" # [1.2.3, 2.0.0)\nPkgB = \"^1.2\"   # [1.2.0, 2.0.0)\nPkgC = \"^1\"     # [1.0.0, 2.0.0)\nPkgD = \"^0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"^0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"^0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"^0\"     # [0.0.0, 1.0.0)"},{"title":"Tilde specifiers","page":"7. Compatibility","location":"compatibility/#Tilde-specifiers","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"A tilde specifier provides more limited upgrade possibilities. When specifying major, minor and patch versions, or when specifying major and minor versions, only the patch version is allowed to change. If you only specify a major version, then both minor and patch versions are allowed to be upgraded (~1 is thus equivalent to ^1). For example:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgA = \"~1.2.3\" # [1.2.3, 1.3.0)\nPkgB = \"~1.2\"   # [1.2.0, 1.3.0)\nPkgC = \"~1\"     # [1.0.0, 2.0.0)\nPkgD = \"~0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"~0.0.3\" # [0.0.3, 0.1.0)\nPkgF = \"~0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"~0\"     # [0.0.0, 1.0.0)"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"For all versions with a major version of 0 the tilde and caret specifiers are equivalent."},{"title":"Equality specifier","page":"7. Compatibility","location":"compatibility/#Equality-specifier","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Equality can be used to specify exact versions:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgA = \"=1.2.3\"           # [1.2.3, 1.2.3]\nPkgA = \"=0.10.1, =0.10.3\" # 0.10.1 or 0.10.3"},{"title":"Inequality specifiers","page":"7. Compatibility","location":"compatibility/#Inequality-specifiers","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Inequalities can also be used to specify version ranges:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgB = \">= 1.2.3\" # [1.2.3,  ∞)\nPkgC = \"≥ 1.2.3\"  # [1.2.3,  ∞)\nPkgD = \"< 1.2.3\"  # [0.0.0, 1.2.3) = [0.0.0, 1.2.2]"},{"title":"Hyphen specifiers","page":"7. Compatibility","location":"compatibility/#Hyphen-specifiers","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Hyphen syntax can also be used to specify version ranges. Make sure that you have a space on both sides of the hyphen."},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgA = \"1.2.3 - 4.5.6\" # [1.2.3, 4.5.6]\nPkgA = \"0.2.3 - 4.5.6\" # [0.2.3, 4.5.6]"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Any unspecified trailing numbers in the first end-point are considered to be zero:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgA = \"1.2 - 4.5.6\"   # [1.2.0, 4.5.6]\nPkgA = \"1 - 4.5.6\"     # [1.0.0, 4.5.6]\nPkgA = \"0.2 - 4.5.6\"   # [0.2.0, 4.5.6]\nPkgA = \"0.2 - 0.5.6\"   # [0.2.0, 0.5.6]"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Any unspecified trailing numbers in the second end-point will be considered to be wildcards:"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nPkgA = \"1.2.3 - 4.5\"   # 1.2.3 - 4.5.* = [1.2.3, 4.6.0)\nPkgA = \"1.2.3 - 4\"     # 1.2.3 - 4.*.* = [1.2.3, 5.0.0)\nPkgA = \"1.2 - 4.5\"     # 1.2.0 - 4.5.* = [1.2.0, 4.6.0)\nPkgA = \"1.2 - 4\"       # 1.2.0 - 4.*.* = [1.2.0, 5.0.0)\nPkgA = \"1 - 4.5\"       # 1.0.0 - 4.5.* = [1.0.0, 4.6.0)\nPkgA = \"1 - 4\"         # 1.0.0 - 4.*.* = [1.0.0, 5.0.0)\nPkgA = \"0.2.3 - 4.5\"   # 0.2.3 - 4.5.* = [0.2.3, 4.6.0)\nPkgA = \"0.2.3 - 4\"     # 0.2.3 - 4.*.* = [0.2.3, 5.0.0)\nPkgA = \"0.2 - 4.5\"     # 0.2.0 - 4.5.* = [0.2.0, 4.6.0)\nPkgA = \"0.2 - 4\"       # 0.2.0 - 4.*.* = [0.2.0, 5.0.0)\nPkgA = \"0.2 - 0.5\"     # 0.2.0 - 0.5.* = [0.2.0, 0.6.0)\nPkgA = \"0.2 - 0\"       # 0.2.0 - 0.*.* = [0.2.0, 1.0.0)"},{"title":"Fixing conflicts","page":"7. Compatibility","location":"compatibility/#Fixing-conflicts","category":"section","text":""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Version conflicts were introduced previously with an example of a conflict arising in a package D used by two other packages, B and C. Our analysis of the error message revealed that B is using an outdated version of D. To fix it, the first thing to try is to pkg> dev B so that you can modify B and its compatibility requirements. If you open its Project.toml file in an editor, you would probably notice something like"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nD = \"0.1\""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"Usually the first step is to modify this to something like"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"[compat]\nD = \"0.1, 0.2\""},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/","category":"page","text":"This indicates that B is compatible with both versions 0.1 and version 0.2; if you pkg> up this would fix the package error. However, there is one major concern you need to address first: perhaps there was an incompatible change in v0.2 of D that breaks B. Before proceeding further, you should update all packages and then run B's tests, scanning the output of pkg> test B to be sure that v0.2 of D is in fact being used. (It is possible that an additional dependency of D pins it to v0.1, and you wouldn't want to be misled into thinking that you had tested B on the newer version.) If the new version was used and the tests still pass, you can assume that B didn't need any further updating to accommodate v0.2 of D; you can safely submit this change as a pull request to B so that a new release is made. If instead an error is thrown, it indicates that B requires more extensive updates to be compatible with the latest version of D; those updates will need to be completed before it becomes possible to use both A and B simultaneously. You can, though, continue to use them independently of one another."},{"title":"15. Depots","page":"15. Depots","location":"depots/#**15.**-Depots","category":"section","text":""},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"The packages installed for a particular environment, defined in the files Project.toml and Manifest.toml within the directory structure, are not actually installed within that directory but into a \"depot\". The location of the depots are set by the variable DEPOT_PATH."},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"For details on the default depot locations and how they vary by installation method, see the DEPOT_PATH documentation."},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"Packages which are installed by a user go into the first depot and the Julia standard library is in the last depot."},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"You should not need to manage the user depot directly. Pkg will automatically clean up the depots when packages are removed after a delay. However you may want to manually remove old .julia/compiled/ subdirectories if you have any that reside for older Julia versions that you no longer use (hence have not been run to tidy themselves up)."},{"title":"Configuring the depot path with JULIA_DEPOT_PATH","page":"15. Depots","location":"depots/#Configuring-the-depot-path-with-JULIA_DEPOT_PATH","category":"section","text":""},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"The depot path can be configured using the JULIA_DEPOT_PATH environment variable, which is used to populate the global Julia DEPOT_PATH variable at startup. For complete details on the behavior of this environment variable, see the environment variables documentation."},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"Unlike the shell PATH variable, empty entries in JULIA_DEPOT_PATH have special behavior for easy overriding of the user depot while retaining access to system resources. For example, to switch the user depot to /custom/depot while still accessing bundled resources, use a trailing path separator:"},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"export JULIA_DEPOT_PATH=\"/custom/depot:\""},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"note: Note\nThe trailing path separator (: on Unix, ; on Windows) is crucial for including the default system depots, which contain the standard library and other bundled resources. Without it, Julia will only use the specified depot and will have to precompile standard library packages, which can be time-consuming and inefficient."},{"title":"Shared depots for distributed computing","page":"15. Depots","location":"depots/#Shared-depots-for-distributed-computing","category":"section","text":""},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"When using Julia in distributed computing environments, such as high-performance computing (HPC) clusters, it's recommended to use a shared depot via JULIA_DEPOT_PATH. This allows multiple Julia processes to share precompiled packages and reduces redundant compilation."},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"Since Julia v1.10, multiple processes using the same depot coordinate via pidfile locks to ensure only one process precompiles a package while others wait. However, due to the caching of native code in pkgimages since v1.9, you may need to set the JULIA_CPU_TARGET environment variable appropriately to ensure cache compatibility across different worker nodes with varying CPU capabilities."},{"title":"15. Depots","page":"15. Depots","location":"depots/","category":"page","text":"For more details, see the FAQ section on distributed computing and the environment variables documentation."},{"title":"13. API Reference","page":"13. API Reference","location":"api/#API-Reference","category":"section","text":""},{"title":"13. API Reference","page":"13. API Reference","location":"api/","category":"page","text":"This section describes the functional API for interacting with Pkg.jl. It is recommended to use the functional API, rather than the Pkg REPL mode, for non-interactive usage, for example in scripts."},{"title":"General API Reference","page":"13. API Reference","location":"api/#General-API-Reference","category":"section","text":""},{"title":"13. API Reference","page":"13. API Reference","location":"api/","category":"page","text":"Certain options are generally useful and can be specified in any API call. You can specify these options by setting keyword arguments."},{"title":"Redirecting output","page":"13. API Reference","location":"api/#Redirecting-output","category":"section","text":""},{"title":"13. API Reference","page":"13. API Reference","location":"api/","category":"page","text":"Use the io::IOBuffer keyword argument to redirect Pkg output. For example, Pkg.add(\"Example\"; io=devnull) will discard any output produced by the add call."},{"title":"Package API Reference","page":"13. API Reference","location":"api/#Package-API-Reference","category":"section","text":""},{"title":"13. API Reference","page":"13. API Reference","location":"api/","category":"page","text":"In the Pkg REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings, for example \"Package#master\",\"Package@v0.1\", \"www.mypkg.com/MyPkg#my/feature\"."},{"title":"13. API Reference","page":"13. API Reference","location":"api/","category":"page","text":"In the functional API, it is possible to use strings as arguments for simple commands (like Pkg.add([\"PackageA\", \"PackageB\"]), but more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings. This is done by creating an instance of PackageSpec which is passed in to functions."},{"title":"Pkg.add","page":"13. API Reference","location":"api/#Pkg.add","category":"function","text":"Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED, target::Symbol=:deps)\nPkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED, target::Symbol=:deps)\n\nAdd a package to the current project. This package will be available by using the import and using keywords in the Julia REPL, and if the current project is a package, also inside that package.\n\nIf the active environment is a package (the Project has both name and uuid fields) compat entries will be added automatically with a lower bound of the added version.\n\nTo add as a weak dependency (in the [weakdeps] field) set the kwarg target=:weakdeps. To add as an extra dep (in the [extras] field) set target=:extras.\n\nResolution Tiers\n\nPkg resolves the set of packages in your environment using a tiered algorithm. The preserve keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for preserve (in order of strictness):\n\nValue Description\nPRESERVE_ALL_INSTALLED Like PRESERVE_ALL and only add those already installed\nPRESERVE_ALL Preserve the state of all existing dependencies (including recursive dependencies)\nPRESERVE_DIRECT Preserve the state of all existing direct dependencies\nPRESERVE_SEMVER Preserve semver-compatible versions of direct dependencies\nPRESERVE_NONE Do not attempt to preserve any version information\nPRESERVE_TIERED_INSTALLED Like PRESERVE_TIERED except PRESERVE_ALL_INSTALLED is tried first\nPRESERVE_TIERED Use the tier that will preserve the most version information while\n allowing version resolution to succeed (this is the default)\n\nnote: Note\nTo change the default strategy to PRESERVE_TIERED_INSTALLED set the env var JULIA_PKG_PRESERVE_TIERED_INSTALLED to true.\n\nAfter the installation of new packages the project will be precompiled. For more information see pkg> ?precompile.\n\nWith the PRESERVE_ALL_INSTALLED strategy the newly added packages will likely already be precompiled, but if not this may be because either the combination of package versions resolved in this environment has not been resolved and precompiled before, or the precompile cache has been deleted by the LRU cache storage (see JULIA_MAX_NUM_PRECOMPILE_FILES).\n\ncompat: Julia 1.9\nThe PRESERVE_TIERED_INSTALLED and PRESERVE_ALL_INSTALLED strategies requires at least Julia 1.9.\n\ncompat: Julia 1.11\nThe target kwarg requires at least Julia 1.11.\n\nExamples\n\nPkg.add(\"Example\") # Add a package from registry\nPkg.add(\"Example\", target=:weakdeps) # Add a package as a weak dependency\nPkg.add(\"Example\", target=:extras) # Add a package to the `[extras]` list\nPkg.add(\"Example\"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and strictly preserve existing dependencies\nPkg.add(name=\"Example\", version=\"0.3\") # Specify version; latest release in the 0.3 series\nPkg.add(name=\"Example\", version=\"0.3.1\") # Specify version; exact release\nPkg.add(url=\"https://github.com/JuliaLang/Example.jl\", rev=\"master\") # From url to remote gitrepo\nPkg.add(url=\"/remote/mycompany/juliapackages/OurPackage\") # From path to local gitrepo\nPkg.add(url=\"https://github.com/Company/MonoRepo\", subdir=\"juliapkgs/Package.jl)\") # With subdir\n\nAfter the installation of new packages the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, Pkg.develop.\n\n\n\n\n\n"},{"title":"Pkg.develop","page":"13. API Reference","location":"api/#Pkg.develop","category":"function","text":"Pkg.develop(pkg::Union{String, Vector{String}}; io::IO=stderr, preserve=PRESERVE_TIERED, installed=false)\nPkg.develop(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, preserve=PRESERVE_TIERED, installed=false)\n\nMake a package available for development by tracking it by path. If pkg is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable JULIA_PKG_DEVDIR, with joinpath(DEPOT_PATH[1],\"dev\") being the default.\n\nIf pkg is given as a local path, the package at that path will be tracked.\n\nThe preserve strategies offered by Pkg.add are also available via the preserve kwarg. See Pkg.add for more information.\n\nExamples\n\n# By name\nPkg.develop(\"Example\")\n\n# By url\nPkg.develop(url=\"https://github.com/JuliaLang/Compat.jl\")\n\n# By path\nPkg.develop(path=\"MyJuliaPackages/Package.jl\")\n\nSee also PackageSpec, Pkg.add.\n\n\n\n\n\n"},{"title":"Pkg.activate","page":"13. API Reference","location":"api/#Pkg.activate","category":"function","text":"Pkg.activate([s::String]; shared::Bool=false, io::IO=stderr)\nPkg.activate(; temp::Bool=false, shared::Bool=false, io::IO=stderr)\n\nActivate the environment at s. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:\n\nIf shared is true, the first existing environment named s from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.\nIf temp is true this will create and activate a temporary environment which will be deleted when the julia process is exited.\nIf s is an existing path, then activate the environment at that path.\nIf s is a package in the current project and s is tracking a path, then activate the environment at the tracked path.\nOtherwise, s is interpreted as a non-existing path, which is then activated.\n\nIf no argument is given to activate, then use the first project found in LOAD_PATH (ignoring \"@\"). For the default value of LOAD_PATH, the result is to activate the @v#.# environment.\n\nExamples\n\nPkg.activate()\nPkg.activate(\"local/path\")\nPkg.activate(\"MyDependency\")\nPkg.activate(; temp=true)\n\nSee also LOAD_PATH.\n\n\n\n\n\n"},{"title":"Pkg.rm","page":"13. API Reference","location":"api/#Pkg.rm","category":"function","text":"Pkg.rm(pkg::Union{String, Vector{String}}; mode::PackageMode = PKGMODE_PROJECT)\nPkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}}; mode::PackageMode = PKGMODE_PROJECT)\n\nRemove a package from the current project. If mode is equal to PKGMODE_MANIFEST also remove it from the manifest including all recursive dependencies of pkg.\n\nSee also PackageSpec, PackageMode.\n\n\n\n\n\n"},{"title":"Pkg.update","page":"13. API Reference","location":"api/#Pkg.update","category":"function","text":"Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT, preserve::PreserveLevel)\nPkg.update(pkg::Union{String, Vector{String}})\nPkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nIf no positional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT. If no positional argument is given, level can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).\n\nIf packages are given as positional arguments, the preserve argument can be used to control what other packages are allowed to update:\n\nPRESERVE_ALL (default): Only allow pkg to update.\nPRESERVE_DIRECT: Only allow pkg and indirect dependencies that are not a direct dependency in the project to update.\nPRESERVE_NONE: Allow pkg and all its indirect dependencies to update.\n\nAfter any package updates the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, PackageMode, UpgradeLevel.\n\n\n\n\n\n"},{"title":"Pkg.test","page":"13. API Reference","location":"api/#Pkg.test","category":"function","text":"Pkg.test(; kwargs...)\nPkg.test(pkg::Union{String, Vector{String}; kwargs...)\nPkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)\n\nKeyword arguments:\n\ncoverage::Union{Bool,String}=false: enable or disable generation of coverage statistics for the tested package. If a string is passed it is passed directly to --code-coverage in the test process so e.g. \"user\" will test all user code.\nallow_reresolve::Bool=true: allow Pkg to reresolve the package versions in the test environment\njulia_args::Union{Cmd, Vector{String}}: options to be passed the test process.\ntest_args::Union{Cmd, Vector{String}}: test arguments (ARGS) available in the test process.\n\ncompat: Julia 1.9\nallow_reresolve requires at least Julia 1.9.\n\ncompat: Julia 1.9\nPassing a string to coverage requires at least Julia 1.9.\n\nRun the tests for the given package(s), or for the current project if no positional argument is given to Pkg.test (the current project would need to be a package). The package is tested by running its test/runtests.jl file.\n\nThe tests are run in a temporary environment that also includes the test specific dependencies of the package. The versions of dependencies in the current project are used for the test environment unless there is a compatibility conflict between the version of the dependencies and the test-specific dependencies. In that case, if allow_reresolve is false an error is thrown and if allow_reresolve is true a feasible set of versions of the dependencies is resolved and used.\n\nTest-specific dependnecies are declared in the project file as:\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\n\nThe tests are executed in a new process with check-bounds=yes and by default startup-file=no. If using the startup file (~/.julia/config/startup.jl) is desired, start julia with --startup-file=yes.\n\nInlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with --inline=no. The tests can be run as if different command line arguments were passed to julia by passing the arguments instead to the julia_args keyword argument, e.g.\n\nPkg.test(\"foo\"; julia_args=[\"--inline\"])\n\nTo pass some command line arguments to be used in the tests themselves, pass the arguments to the test_args keyword argument. These could be used to control the code being tested, or to control the tests in some way. For example, the tests could have optional additional tests:\n\nif \"--extended\" in ARGS\n    @test some_function()\nend\n\nwhich could be enabled by testing with\n\nPkg.test(\"foo\"; test_args=[\"--extended\"])\n\n\n\n\n\n"},{"title":"Pkg.build","page":"13. API Reference","location":"api/#Pkg.build","category":"function","text":"Pkg.build(; verbose = false, io::IO=stderr)\nPkg.build(pkg::Union{String, Vector{String}}; verbose = false, io::IO=stderr)\nPkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false, io::IO=stderr)\n\nKeyword arguments:\n\nverbose::Bool=false: print the build output to stdout/stderr instead of redirecting to the build.log file.\nallow_reresolve::Bool=true: allow Pkg to reresolve the package versions in the build environment\n\ncompat: Julia 1.13\nallow_reresolve requires at least Julia 1.13.\n\nRun the build script in deps/build.jl for pkg and all of its dependencies in depth-first recursive order. If no argument is given to build, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time.\n\nThe build takes place in a new process matching the current process with default of startup-file=no. If using the startup file (~/.julia/config/startup.jl) is desired, start julia with an explicit --startup-file=yes.\n\n\n\n\n\n"},{"title":"Pkg.pin","page":"13. API Reference","location":"api/#Pkg.pin","category":"function","text":"Pkg.pin(pkg::Union{String, Vector{String}}; io::IO=stderr, all_pkgs::Bool=false)\nPkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, all_pkgs::Bool=false)\n\nPin a package to the current version (or the one given in the PackageSpec) or to a certain git revision. A pinned package is never automatically updated: if pkg is tracking a path, or a repository, those remain tracked but will not update. To get updates from the origin path or remote repository the package must first be freed.\n\ncompat: Julia 1.7\nThe all_pkgs kwarg was introduced in julia 1.7.\n\nExamples\n\n# Pin a package to its current version\nPkg.pin(\"Example\")\n\n# Pin a package to a specific version\nPkg.pin(name=\"Example\", version=\"0.3.1\")\n\n# Pin all packages in the project\nPkg.pin(all_pkgs = true)\n\n\n\n\n\n"},{"title":"Pkg.free","page":"13. API Reference","location":"api/#Pkg.free","category":"function","text":"Pkg.free(pkg::Union{String, Vector{String}}; io::IO=stderr, all_pkgs::Bool=false)\nPkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, all_pkgs::Bool=false)\n\nIf pkg is pinned, remove the pin. If pkg is tracking a path, e.g. after Pkg.develop, go back to tracking registered versions. To free all dependencies set all_pkgs=true.\n\ncompat: Julia 1.7\nThe all_pkgs kwarg was introduced in julia 1.7.\n\nExamples\n\n# Free a single package (remove pin or stop tracking path)\nPkg.free(\"Package\")\n\n# Free multiple packages\nPkg.free([\"PackageA\", \"PackageB\"])\n\n# Free all packages in the project\nPkg.free(all_pkgs = true)\n\n\n\n\n\n"},{"title":"Pkg.instantiate","page":"13. API Reference","location":"api/#Pkg.instantiate","category":"function","text":"Pkg.instantiate(; verbose = false, workspace=false, io::IO=stderr, julia_version_strict=false)\n\nIf a Manifest.toml file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the Project.toml files and install them. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file. workspace=true will also instantiate all projects in the workspace. If no Project.toml exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project. julia_version_strict=true will turn manifest version check failures into errors instead of logging warnings.\n\nAfter packages have been installed the project will be precompiled. See more and how to disable auto-precompilation at Environment Precompilation.\n\ncompat: Julia 1.12\nThe julia_version_strict keyword argument requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Pkg.resolve","page":"13. API Reference","location":"api/#Pkg.resolve","category":"function","text":"Pkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n\n\n\n\n\n"},{"title":"Pkg.gc","page":"13. API Reference","location":"api/#Pkg.gc","category":"function","text":"Pkg.gc(; collect_delay::Period=Day(7), io::IO=stderr)\n\nGarbage-collect package and artifact installations by sweeping over all known Manifest.toml and Artifacts.toml files, noting those that have been deleted, and then finding artifacts and packages that are thereafter not used by any other projects, marking them as \"orphaned\".  This method will only remove orphaned objects (package versions, artifacts, and scratch spaces) that have been continually un-used for a period of collect_delay; which defaults to seven days.\n\nTo disable automatic garbage collection, you can set the environment variable JULIA_PKG_GC_AUTO to \"false\" before starting Julia or call API.auto_gc(false).\n\n\n\n\n\n"},{"title":"Pkg.status","page":"13. API Reference","location":"api/#Pkg.status","category":"function","text":"Pkg.status([pkgs...]; outdated::Bool=false, mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false,\n           compat::Bool=false, extensions::Bool=false, workspace::Bool=false, io::IO=stdout)\n\nPrint out the status of the project/manifest.\n\nPackages marked with ⌃ have new versions that can be installed, e.g. via Pkg.update. Those marked with ⌅ have new versions available, but cannot be installed due to compatibility conflicts with other packages. To see why, set the keyword argument outdated=true. Packages marked with [yanked] are yanked versions that should be updated or replaced as they may contain bugs or security vulnerabilities.\n\nSetting outdated=true will only show packages that are not on the latest version, their maximum version and why they are not on the latest version (either due to other packages holding them back due to compatibility constraints, or due to compatibility in the project file). As an example, a status output like:\n\njulia> Pkg.status(; outdated=true)\nStatus `Manifest.toml`\n⌃ [a8cc5b0e] Crayons v2.0.0 [<v3.0.0], (<v4.0.4)\n⌅ [b8a86587] NearestNeighbors v0.4.8 (<v0.4.9) [compat]\n⌅ [2ab3a3ac] LogExpFunctions v0.2.5 (<v0.3.0): SpecialFunctions\n\nmeans that the latest version of Crayons is 4.0.4 but the latest version compatible with the [compat] section in the current project is 3.0.0. The latest version of NearestNeighbors is 0.4.9 but due to compat constrains in the project it is held back to 0.4.8. The latest version of LogExpFunctions is 0.3.0 but SpecialFunctions is holding it back to 0.2.5.\n\nIf mode is PKGMODE_PROJECT, print out status only about the packages that are in the project (explicitly added). If mode is PKGMODE_MANIFEST, print status also about those in the manifest (recursive dependencies). If there are any packages listed as arguments, the output will be limited to those packages.\n\nSetting ext=true will show dependencies with extensions and what extension dependencies of those that are currently loaded.\n\nSetting diff=true will, if the environment is in a git repository, limit the output to the difference as compared to the last git commit.\n\nSetting workspace=true will show the (merged) status of packages in the workspace.\n\nSee Pkg.project and Pkg.dependencies to get the project/manifest status as a Julia object instead of printing it.\n\ncompat: Julia 1.8\nThe ⌃ and ⌅ indicators were added in Julia 1.8. The outdated keyword argument requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Pkg.compat","page":"13. API Reference","location":"api/#Pkg.compat","category":"function","text":"Pkg.compat()\n\nInteractively edit the [compat] entries within the current Project.\n\nPkg.compat(pkg::String, compat::String)\n\nSet the [compat] string for the given package within the current Project.\n\nSee Compatibility for more information on the project [compat] section.\n\n\n\n\n\n"},{"title":"Pkg.precompile","page":"13. API Reference","location":"api/#Pkg.precompile","category":"function","text":"Pkg.precompile(; strict::Bool=false, timing::Bool=false)\nPkg.precompile(pkg; strict::Bool=false, timing::Bool=false)\nPkg.precompile(pkgs; strict::Bool=false, timing::Bool=false)\nPkg.precompile(f, args...; kwargs...)\n\nPrecompile all or specific dependencies of the project in parallel.\n\nSet timing=true to show the duration of the precompilation of each dependency.\n\nTo delay autoprecompilation of multiple Pkg actions until the end use. This may be most efficient while manipulating the environment in various ways.\n\nPkg.precompile() do\n    # Pkg actions here\nend\n\nnote: Note\nErrors will only throw when precompiling the top-level dependencies, given that not all manifest dependencies may be loaded by the top-level dependencies on the given system. This can be overridden to make errors in all dependencies throw by setting the kwarg strict to true\n\nnote: Note\nThis method is called automatically after any Pkg action that changes the manifest. Any packages that have previously errored during precompilation won't be retried in auto mode until they have changed. To disable automatic precompilation set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0. To manually control the number of tasks used set ENV[\"JULIA_NUM_PRECOMPILE_TASKS\"].\n\ncompat: Julia 1.8\nSpecifying packages to precompile requires at least Julia 1.8.\n\ncompat: Julia 1.9\nTiming mode requires at least Julia 1.9.\n\ncompat: Julia 1.13\nThe Pkg.precompile(f, args...; kwargs...) do-block syntax requires at least Julia 1.13.\n\nExamples\n\nPkg.precompile()\nPkg.precompile(\"Foo\")\nPkg.precompile([\"Foo\", \"Bar\"])\n\n\n\n\n\n"},{"title":"Pkg.autoprecompilation_enabled","page":"13. API Reference","location":"api/#Pkg.autoprecompilation_enabled","category":"function","text":"Pkg.autoprecompilation_enabled(state::Bool)\n\nEnable or disable automatic precompilation for Pkg operations.\n\nWhen state is true (default), Pkg operations that modify the project environment will automatically trigger precompilation of affected packages. When state is false, automatic precompilation is disabled and packages will only be precompiled when explicitly requested via Pkg.precompile.\n\nThis setting affects the global state and persists across Pkg operations in the same Julia session. It can be used in combination with Pkg.precompile do-syntax for more fine-grained control over when precompilation occurs.\n\ncompat: Julia 1.13\nThis function requires at least Julia 1.13.\n\nExamples\n\n# Disable automatic precompilation\nPkg.autoprecompilation_enabled(false)\nPkg.add(\"Example\")  # Will not trigger auto-precompilation\nPkg.precompile()    # Manual precompilation\n\n# Re-enable automatic precompilation\nPkg.autoprecompilation_enabled(true)\nPkg.add(\"AnotherPackage\")  # Will trigger auto-precompilation\n\nSee also Pkg.precompile.\n\n\n\n\n\n"},{"title":"Pkg.offline","page":"13. API Reference","location":"api/#Pkg.offline","category":"function","text":"Pkg.offline(b::Bool=true)\n\nEnable (b=true) or disable (b=false) offline mode.\n\nIn offline mode Pkg tries to do as much as possible without connecting to internet. For example, when adding a package Pkg only considers versions that are already downloaded in version resolution.\n\nTo work in offline mode across Julia sessions you can set the environment variable JULIA_PKG_OFFLINE to \"true\" before starting Julia.\n\n\n\n\n\n"},{"title":"Pkg.why","page":"13. API Reference","location":"api/#Pkg.why","category":"function","text":"Pkg.why(pkg::Union{String, Vector{String}}; workspace::Bool=false)\nPkg.why(pkg::Union{PackageSpec, Vector{PackageSpec}}; workspace::Bool=false)\n\nShow the reason why this package is in the manifest. The output is all the different ways to reach the package through the dependency graph starting from the dependencies. If workspace is true, this will consider all projects in the workspace and not just the active one.\n\ncompat: Julia 1.9\nThis function requires at least Julia 1.9.\n\n\n\n\n\n"},{"title":"Pkg.dependencies","page":"13. API Reference","location":"api/#Pkg.dependencies","category":"function","text":"Pkg.dependencies()::Dict{UUID, PackageInfo}\n\nThis feature is considered experimental.\n\nQuery the dependency graph of the active project. The result is a Dict that maps a package UUID to a PackageInfo struct representing the dependency (a package).\n\nPackageInfo fields\n\nField Description\nname The name of the package\nversion The version of the package (this is Nothing for stdlibs)\ntree_hash A file hash of the package directory tree\nis_direct_dep The package is a direct dependency\nis_pinned Whether a package is pinned\nis_tracking_path Whether a package is tracking a path\nis_tracking_repo Whether a package is tracking a repository\nis_tracking_registry Whether a package is being tracked by registry i.e. not by path nor by repository\ngit_revision The git revision when tracking by repository\ngit_source The git source when tracking by repository\nsource The directory containing the source code for that package\ndependencies The dependencies of that package as a vector of UUIDs\n\n\n\n\n\n"},{"title":"Pkg.respect_sysimage_versions","page":"13. API Reference","location":"api/#Pkg.respect_sysimage_versions","category":"function","text":"Pkg.respect_sysimage_versions(b::Bool=true)\n\nEnable (b=true) or disable (b=false) respecting versions that are in the sysimage (enabled by default).\n\nIf this option is enabled, Pkg will only install packages that have been put into the sysimage (e.g. via PackageCompiler) at the version of the package in the sysimage. Also, trying to add a package at a URL or develop a package that is in the sysimage will error.\n\n\n\n\n\n"},{"title":"Pkg.project","page":"13. API Reference","location":"api/#Pkg.project","category":"function","text":"Pkg.project()::ProjectInfo\n\nThis feature is considered experimental.\n\nRequest a ProjectInfo struct which contains information about the active project.\n\nProjectInfo fields\n\nField Description\nname The project's name\nuuid The project's UUID\nversion The project's version\nispackage Whether the project is a package (has a name and uuid)\ndependencies The project's direct dependencies as a Dict which maps dependency name to dependency UUID\npath The location of the project file which defines the active project\n\n\n\n\n\n"},{"title":"Pkg.undo","page":"13. API Reference","location":"api/#Pkg.undo","category":"function","text":"undo()\n\nUndoes the latest change to the active project. Only states in the current session are stored, up to a maximum of 50 states.\n\nSee also: redo.\n\n\n\n\n\n"},{"title":"Pkg.redo","page":"13. API Reference","location":"api/#Pkg.redo","category":"function","text":"redo()\n\nRedoes the changes from the latest undo.\n\n\n\n\n\n"},{"title":"Pkg.setprotocol!","page":"13. API Reference","location":"api/#Pkg.setprotocol!","category":"function","text":"setprotocol!(;\n    domain::AbstractString = \"github.com\",\n    protocol::Union{Nothing, AbstractString}=nothing\n)\n\nSet the protocol used to access hosted packages when adding a url or developing a package. Defaults to delegating the choice to the package developer (protocol === nothing). Other choices for protocol are \"https\" or \"git\".\n\nExamples\n\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"ssh\")\n\n# Use HTTPS for GitHub (default, good for most users)\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"https\")\n\n# Reset to default (let package developer decide)\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = nothing)\n\n# Set protocol for custom domain without specifying protocol\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\")\n\n# Use Git protocol for a custom domain\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\", protocol = \"git\")\n\n\n\n\n\n"},{"title":"Pkg.PackageSpec","page":"13. API Reference","location":"api/#Pkg.PackageSpec","category":"type","text":"PackageSpec(name::String, [uuid::UUID, version::VersionNumber])\nPackageSpec(; name, url, path, subdir, rev, version, mode, level)\n\nA PackageSpec is a representation of a package with various metadata. This includes:\n\nThe name of the package.\nThe package's unique uuid.\nA version (for example when adding a package). When upgrading, can also be an instance of the enum UpgradeLevel. If the version is given as a String this means that unspecified versions are \"free\", for example version=\"0.5\" allows any version 0.5.x to be installed. If given as a VersionNumber, the exact version is used, for example version=v\"0.5.3\".\nA url and an optional git revision. rev can be a branch name or a git commit SHA1.\nA local path. This is equivalent to using the url argument but can be more descriptive.\nA subdir which can be used when adding a package that is not in the root of a repository.\n\nMost functions in Pkg take a Vector of PackageSpec and do the operation on all the packages in the vector.\n\nMany functions that take a PackageSpec or a Vector{PackageSpec} can be called with a more concise notation with NamedTuples. For example, Pkg.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.add(PackageSpec(name=\"Package\")) Pkg.add(name = \"Package\")\nPkg.add(PackageSpec(url=\"www.myhost.com/MyPkg\"))) Pkg.add(url=\"www.myhost.com/MyPkg\")\nPkg.add([PackageSpec(name=\"Package\"), PackageSpec(path=\"/MyPkg\"]) Pkg.add([(;name=\"Package\"), (;path=\"/MyPkg\")])\n\nBelow is a comparison between the REPL mode and the functional API:\n\nREPL API\nPackage PackageSpec(\"Package\")\nPackage@0.2 PackageSpec(name=\"Package\", version=\"0.2\")\n- PackageSpec(name=\"Package\", version=v\"0.2.1\")\nPackage=a67d... PackageSpec(name=\"Package\", uuid=\"a67d...\")\nPackage#master PackageSpec(name=\"Package\", rev=\"master\")\nlocal/path#feature PackageSpec(path=\"local/path\"; rev=\"feature\")\nwww.mypkg.com PackageSpec(url=\"www.mypkg.com\")\n--major Package PackageSpec(name=\"Package\", version=UPLEVEL_MAJOR)\n\n\n\n\n\n"},{"title":"Pkg.PackageMode","page":"13. API Reference","location":"api/#Pkg.PackageMode","category":"type","text":"PackageMode\n\nAn enum with the instances\n\nPKGMODE_MANIFEST\nPKGMODE_PROJECT\n\nDetermines if operations should be made on a project or manifest level. Used as an argument to Pkg.rm, Pkg.update and Pkg.status.\n\n\n\n\n\n"},{"title":"Pkg.UpgradeLevel","page":"13. API Reference","location":"api/#Pkg.UpgradeLevel","category":"type","text":"UpgradeLevel\n\nAn enum with the instances\n\nUPLEVEL_FIXED\nUPLEVEL_PATCH\nUPLEVEL_MINOR\nUPLEVEL_MAJOR\n\nDetermines how much a package is allowed to be updated. Used as an argument to  PackageSpec or as an argument to Pkg.update.\n\n\n\n\n\n"},{"title":"Registry API Reference","page":"13. API Reference","location":"api/#Registry-API-Reference","category":"section","text":""},{"title":"13. API Reference","page":"13. API Reference","location":"api/","category":"page","text":"The functional API for registries uses RegistrySpecs, similar to PackageSpec."},{"title":"Pkg.RegistrySpec","page":"13. API Reference","location":"api/#Pkg.RegistrySpec","category":"type","text":"RegistrySpec(name::String)\nRegistrySpec(; name, uuid, url, path)\n\nA RegistrySpec is a representation of a registry with various metadata, much like PackageSpec. This includes:\n\nThe name of the registry.\nThe registry's unique uuid.\nThe url to the registry.\nA local path.\n\nMost registry functions in Pkg take a Vector of RegistrySpec and do the operation on all the registries in the vector.\n\nMany functions that take a RegistrySpec can be called with a more concise notation with keyword arguments. For example, Pkg.Registry.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.Registry.add(RegistrySpec(name=\"General\")) Pkg.Registry.add(name = \"General\")\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/JuliaRegistries/General.git\"))) Pkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")\n\nBelow is a comparison between the REPL mode and the functional API::\n\nREPL API\nMyRegistry RegistrySpec(\"MyRegistry\")\nMyRegistry=a67d... RegistrySpec(name=\"MyRegistry\", uuid=\"a67d...\")\nlocal/path RegistrySpec(path=\"local/path\")\nwww.myregistry.com RegistrySpec(url=\"www.myregistry.com\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.add","page":"13. API Reference","location":"api/#Pkg.Registry.add","category":"function","text":"Pkg.Registry.add(registry::RegistrySpec)\n\nAdd new package registries.\n\nThe no-argument Pkg.Registry.add() will install the default registries.\n\nExamples\n\nPkg.Registry.add(\"General\")\nPkg.Registry.add(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\nPkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.rm","page":"13. API Reference","location":"api/#Pkg.Registry.rm","category":"function","text":"Pkg.Registry.rm(registry::String)\nPkg.Registry.rm(registry::RegistrySpec)\n\nRemove registries.\n\nExamples\n\nPkg.Registry.rm(\"General\")\nPkg.Registry.rm(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.update","page":"13. API Reference","location":"api/#Pkg.Registry.update","category":"function","text":"Pkg.Registry.update()\nPkg.Registry.update(registry::RegistrySpec)\nPkg.Registry.update(registry::Vector{RegistrySpec})\n\nUpdate registries. If no registries are given, update all available registries.\n\nExamples\n\nPkg.Registry.update()\nPkg.Registry.update(\"General\")\nPkg.Registry.update(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.status","page":"13. API Reference","location":"api/#Pkg.Registry.status","category":"function","text":"Pkg.Registry.status()\n\nDisplay information about available registries.\n\nExamples\n\nPkg.Registry.status()\n\n\n\n\n\n"},{"title":"Artifacts API Reference","page":"13. API Reference","location":"api/#Artifacts-Reference","category":"section","text":""},{"title":"Pkg.PkgArtifacts.create_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.create_artifact","category":"function","text":"create_artifact(f::Function)\n\nCreates a new artifact by running f(artifact_path), hashing the result, and moving it to the artifact store (~/.julia/artifacts on a typical installation).  Returns the identifying tree hash of this artifact.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.remove_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.remove_artifact","category":"function","text":"remove_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nRemoves the given artifact (identified by its SHA1 git tree hash) from disk.  Note that if an artifact is installed in multiple depots, it will be removed from all of them.  If an overridden artifact is requested for removal, it will be silently ignored; this method will never attempt to remove an overridden artifact.\n\nIn general, we recommend that you use Pkg.gc() to manage artifact installations and do not use remove_artifact() directly, as it can be difficult to know if an artifact is being used by another package.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.verify_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.verify_artifact","category":"function","text":"verify_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nVerifies that the given artifact (identified by its SHA1 git tree hash) is installed on- disk, and retains its integrity.  If the given artifact is overridden, skips the verification unless honor_overrides is set to true.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.bind_artifact!","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.bind_artifact!","category":"function","text":"bind_artifact!(artifacts_toml::String, name::String, hash::SHA1;\n                platform::Union{AbstractPlatform,Nothing} = nothing,\n                download_info::Union{Vector{Tuple},Nothing} = nothing,\n                lazy::Bool = false,\n                force::Bool = false)\n\nWrites a mapping of name -> hash within the given (Julia)Artifacts.toml file. If platform is not nothing, this artifact is marked as platform-specific, and will be a multi-mapping.  It is valid to bind multiple artifacts with the same name, but different platforms and hash'es within the same artifacts_toml.  If force is set to true, this will overwrite a pre-existant mapping, otherwise an error is raised.\n\ndownload_info is an optional vector that contains tuples of URLs and a hash.  These URLs will be listed as possible locations where this artifact can be obtained.  If lazy is set to true, even if download information is available, this artifact will not be downloaded until it is accessed via the artifact\"name\" syntax, or ensure_artifact_installed() is called upon it.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.unbind_artifact!","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.unbind_artifact!","category":"function","text":"unbind_artifact!(artifacts_toml::String, name::String; platform = nothing)\n\nUnbind the given name from an (Julia)Artifacts.toml file. Silently fails if no such binding exists within the file.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.download_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.download_artifact","category":"function","text":"download_artifact(tree_hash::SHA1, tarball_url::String, tarball_hash::String;\n                    verbose::Bool = false, io::IO=stderr)\n\nDownload/install an artifact into the artifact store.  Returns true on success, returns an error object on failure.\n\ncompat: Julia 1.8\nAs of Julia 1.8 this function returns the error object rather than false when failure occurs\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.ensure_artifact_installed","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.ensure_artifact_installed","category":"function","text":"ensure_artifact_installed(name::String, artifacts_toml::String;\n                            platform::AbstractPlatform = HostPlatform(),\n                            pkg_uuid::Union{Base.UUID,Nothing}=nothing,\n                            verbose::Bool = false,\n                            quiet_download::Bool = false,\n                            io::IO=stderr)\n\nEnsures an artifact is installed, downloading it via the download information stored in artifacts_toml if necessary.  Throws an error if unable to install.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.ensure_all_artifacts_installed","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.ensure_all_artifacts_installed","category":"function","text":"ensure_all_artifacts_installed(artifacts_toml::String;\n                                platform = HostPlatform(),\n                                pkg_uuid = nothing,\n                                include_lazy = false,\n                                verbose = false,\n                                quiet_download = false,\n                                io::IO=stderr)\n\nInstalls all non-lazy artifacts from a given (Julia)Artifacts.toml file. package_uuid must be provided to properly support overrides from Overrides.toml entries in depots.\n\nIf include_lazy is set to true, then lazy packages will be installed as well.\n\nThis function is deprecated and should be replaced with the following snippet:\n\nartifacts = select_downloadable_artifacts(artifacts_toml; platform, include_lazy)\nfor name in keys(artifacts)\n    ensure_artifact_installed(name, artifacts[name], artifacts_toml; platform=platform)\nend\n\nwarning: Warning\nThis function is deprecated in Julia 1.6 and will be removed in a future version. Use select_downloadable_artifacts() and ensure_artifact_installed() instead.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.archive_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.archive_artifact","category":"function","text":"archive_artifact(hash::SHA1, tarball_path::String; honor_overrides::Bool=false)\n\nArchive an artifact into a tarball stored at tarball_path, returns the SHA256 of the resultant tarball as a hexadecimal string. Throws an error if the artifact does not exist.  If the artifact is overridden, throws an error unless honor_overrides is set.\n\n\n\n\n\n"},{"title":"Package Server Authentication Hooks","page":"13. API Reference","location":"api/#Package-Server-Authentication-Hooks","category":"section","text":""},{"title":"Pkg.PlatformEngines.register_auth_error_handler","page":"13. API Reference","location":"api/#Pkg.PlatformEngines.register_auth_error_handler","category":"function","text":"register_auth_error_handler(urlscheme::Union{AbstractString, Regex}, f)\n\nRegisters f as the topmost handler for failures in package server authentication.\n\nA handler is only invoked if occursin(urlscheme, url) is true (where url is the URL Pkg is currently trying to download.)\n\nf must be a function that takes three input arguments (url, pkgserver, err), where url is the URL currently being downloaded, pkgserver = Pkg.pkg_server() the current package server, and err is one of no-auth-file, insecure-connection, malformed-file, no-access-token, no-refresh-key or insecure-refresh-url.\n\nThe handler f needs to return a tuple of Bools (handled, should_retry). If handled is false, the next handler in the stack will be called, otherwise handling terminates; get_auth_header is called again if should_retry is true.\n\nregister_auth_error_handler returns a zero-arg function that can be called to deregister the handler.\n\n\n\n\n\n"},{"title":"Pkg.PlatformEngines.deregister_auth_error_handler","page":"13. API Reference","location":"api/#Pkg.PlatformEngines.deregister_auth_error_handler","category":"function","text":"deregister_auth_error_handler(urlscheme::Union{AbstractString, Regex}, f)\n\nRemoves f from the stack of authentication error handlers.\n\n\n\n\n\n"},{"title":"6. Apps","page":"6. Apps","location":"apps/#Apps","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"note: Note\nThe app support in Pkg is currently considered experimental and some functionality and API may change.Some inconveniences that can be encountered are:You need to manually make ~/.julia/bin available on the PATH environment.\nThe path to the julia executable used is the same as the one used to install the app. If this julia installation gets removed, you might need to reinstall the app."},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"Apps are Julia packages that are intended to be run as \"standalone programs\" (by e.g. typing the name of the app in the terminal possibly together with some arguments or flags/options). This is in contrast to most Julia packages that are used as \"libraries\" and are loaded by other files or in the Julia REPL."},{"title":"Creating a Julia app","page":"6. Apps","location":"apps/#Creating-a-Julia-app","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"A Julia app is structured similar to a standard Julia library with the following additions:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"A @main entry point in the package module (see the Julia help on @main for details)\nAn [apps] section in the Project.toml file listing the executable names that the package provides."},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"A very simple example of an app that prints the reversed input arguments would be:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# src/MyReverseApp.jl\nmodule MyReverseApp\n\nfunction (@main)(ARGS)\n    for arg in ARGS\n        print(stdout, reverse(arg), \" \")\n    end\n    return\nend\n\nend # module"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# Project.toml\n\n# standard fields here\n\n[apps]\nreverse = {}"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"The empty table {} is to allow for giving metadata about the app."},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"After installing this app one could run:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"$ reverse some input string\n emos tupni gnirts"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"directly in the terminal."},{"title":"Multiple Apps per Package","page":"6. Apps","location":"apps/#Multiple-Apps-per-Package","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"A single package can define multiple apps by using submodules. Each app can have its own entry point in a different submodule of the package."},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# src/MyMultiApp.jl\nmodule MyMultiApp\n\nfunction (@main)(ARGS)\n    println(\"Main app: \", join(ARGS, \" \"))\nend\n\ninclude(\"CLI.jl\")\n\nend # module"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# src/CLI.jl\nmodule CLI\n\nfunction (@main)(ARGS)\n    println(\"CLI submodule: \", join(ARGS, \" \"))\nend\n\nend # module CLI"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# Project.toml\n\n# standard fields here\n\n[apps]\nmain-app = {}\ncli-app = { submodule = \"CLI\" }"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"This will create two executables:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"main-app that runs julia -m MyMultiApp\ncli-app that runs julia -m MyMultiApp.CLI"},{"title":"Configuring Julia Flags","page":"6. Apps","location":"apps/#Configuring-Julia-Flags","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"Apps can specify default Julia command-line flags that will be passed to the Julia process when the app is run. This is useful for configuring performance settings, threading, or other Julia options specific to your application."},{"title":"Default Julia Flags","page":"6. Apps","location":"apps/#Default-Julia-Flags","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"You can specify default Julia flags in the Project.toml file using the julia_flags field:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# Project.toml\n\n[apps]\nmyapp = { julia_flags = [\"--threads=4\", \"--optimize=2\"] }\nperformance-app = { julia_flags = [\"--threads=auto\", \"--startup-file=yes\", \"--depwarn=no\"] }\ndebug-app = { submodule = \"Debug\", julia_flags = [\"--check-bounds=yes\", \"--optimize=0\"] }"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"With this configuration:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"myapp will run with 4 threads and optimization level 2\nperformance-app will run with automatic thread detection, startup file enabled, and deprecation warnings disabled\ndebug-app will run with bounds checking enabled and no optimization"},{"title":"Runtime Julia Flags","page":"6. Apps","location":"apps/#Runtime-Julia-Flags","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"You can override or add to the default Julia flags at runtime using the -- separator. Everything before -- will be passed as flags to Julia, and everything after -- will be passed as arguments to your app:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"# Uses default flags from Project.toml\nmyapp input.txt output.txt\n\n# Override thread count, keep other defaults\nmyapp --threads=8 -- input.txt output.txt\n\n# Add additional flags\nmyapp --threads=2 --optimize=3 --check-bounds=yes -- input.txt output.txt\n\n# Only Julia flags, no app arguments\nmyapp --threads=1 --"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"The final Julia command will combine:"},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"Fixed flags (like --startup-file=no and -m ModuleName)\nDefault flags from julia_flags in Project.toml\nRuntime flags specified before --\nApp arguments specified after --"},{"title":"Installing Julia apps","page":"6. Apps","location":"apps/#Installing-Julia-apps","category":"section","text":""},{"title":"6. Apps","page":"6. Apps","location":"apps/","category":"page","text":"The installation of Julia apps is similar to installing Julia libraries but instead of using e.g. Pkg.add or pkg> add one uses Pkg.Apps.add or pkg> app add (develop is also available)."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Pkg-Server-Protocols","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The Julia Package Server Protocol (Pkg Protocol) and the Package Storage Server Protocol (Storage Protocol) define how Julia's package manager, Pkg, obtains and manages packages and their associated resources. They aim to enhance the Julia package ecosystem, making it more efficient, reliable, and user-friendly, avoiding potential points of failure, and ensuring the permanent availability of package versions and artifacts, which is paramount for the stability and reproducibility of Julia projects."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The Pkg client, by default, gets all resources over HTTPS from a single open source service run by the Julia community. This service for serving packages is additionally backed by multiple independent storage services which interface with proprietary origin services (GitHub, etc.) and guarantee persistent availability of resources into the future."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The protocols also aim to address some of the limitations that existed prior to its introduction."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Vanishing Resources. It is possible for authors to delete code repositories of registered Julia packages. Without some kind of package server, no one can install a package which has been deleted. If someone happens to have a current fork of a deleted package, that can be made the new official repository for the package, but the chances of them having no or outdated forks are high. An even worse situation could happen for artifacts since they tend not to be kept in version control and are much more likely to be served from \"random\" web servers at a fixed URL with content changing over time. Artifact publishers are unlikely to retain all past versions of artifacts, so old versions of packages that depend on specific artifact content will not be reproducible in the future unless we do something to ensure that they are kept around after the publisher has stopped hosting them. By storing all package versions and artifacts in a single place, we can ensure that they are available forever.\nUsage Insights. It is valuable for the Julia community to know how many people are using Julia or what the relative popularity of different packages and operating systems is. Julia uses GitHub to host its ecosystem. GitHub - a commercial, proprietary service - has this information but does not make it available to the Julia community. We are of course using GitHub for free, so we can't complain, but it seems unfortunate that a commercial entity has this valuable information while the open source community remains in the dark. The Julia community really could use insight into who is using Julia and how, so that we can prioritize packages and platforms, and give real numbers when people ask \"how many people are using Julia?\"\nDecoupling from Git and GitHub. Prior to this, Julia package ecosystem was very deeply coupled to git and was even specialized on GitHub specifically in many ways. The Pkg and Storage Protocols allowed us to decouple ourselves from git as the primary mechanism for getting packages. Now Julia continues to support using git, but does not require it just to install packages from the default public registry anymore. This decoupling also paves the way for supporting other version control systems in the future, making git no longer so special. Special treatment of GitHub will also go away since we get the benefits of specializing for GitHub (fast tarball downloads) directly from the Pkg protocols.\nFirewall problems. Prior to this, Pkg's need to connect to arbitrary servers using a miscellany of protocols caused several problems with firewalls. A large set of protocols and an unbounded list of servers needed to be whitelisted just to support default Pkg operation. If Pkg only needed to talk to a single service over a single, secure protocol (i.e. HTTPS), then whitelisting Pkg for standard use would be dead simple."},{"title":"Protocols & Services","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Protocols-and-Services","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Pkg Protocol: what Julia Pkg Clients speak to Pkg Servers. The Pkg Server serves all resources that Pkg Clients need to install and use registered packages, including registry data, packages and artifacts. It is designed to be easily horizontally scalable and not to have any hard operational requirements: if service is slow, just start more servers; if a Pkg Server crashes, forget it and boot up a new one.\nStorage Protocol: what Pkg Servers speak to get resources from Storage Services. Julia clients do not interact with Storage services directly and multiple independent Storage Services can symmetrically (all are treated equally) provide their service to a given Pkg Server. Since Pkg Servers cache what they serve to Clients and handle convenient content presentation, Storage Services can expose a much simpler protocol: all they do is serve up complete versions of registries, packages and artifacts, while guaranteeing persistence and completeness. Persistence means: once a version of a resource has been served, that version can be served forever. Completeness means: if the service serves a registry, it can serve all package versions referenced by that registry; if it serves a package version, it can serve all artifacts used by that package."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Both protocols work over HTTPS, using only GET and HEAD requests. As is normal for HTTP, HEAD requests are used to get information about a resource, including whether it would be served, without actually downloading it. As described in what follows, the Pkg Protocol is client-to-server and may be unauthenticated, use basic auth, or OpenID; the Storage Protocol is server-to-server only and uses mutual authentication with TLS certificates."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The following diagram shows how these services interact with each other and with external services such as GitHub, GitLab and BitBucket for source control, and S3 and HDFS for long-term persistence:"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"                                        ┌───────────┐\n\n                                        │ Amazon S3 │\n\n                                        │  Storage  │\n\n                                        └───────────┘\n\n                                              ▲\n\n                                              ║\n\n                                              ▼\n\n                              Storage   ╔═══════════╗       ┌───────────┐\n\n               Pkg            Protocol  ║  Storage  ║   ┌──▶│  GitHub   │\n\n             Protocol               ┌──▶║ Service A ║───┤   └───────────┘\n\n┏━━━━━━━━━━━━┓     ┏━━━━━━━━━━━━┓   │   ╚═══════════╝   │   ┌───────────┐\n\n┃ Pkg Client ┃────▶┃ Pkg Server ┃───┤   ╔═══════════╗   ├──▶│  GitLab   │\n\n┗━━━━━━━━━━━━┛     ┗━━━━━━━━━━━━┛   │   ║  Storage  ║   │   └───────────┘\n\n                                    └──▶║ Service B ║───┤   ┌───────────┐\n\n                                        ╚═══════════╝   └──▶│ BitBucket │\n\n                                              ▲             └───────────┘\n\n                                              ║\n\n                                              ▼\n\n                                        ┌───────────┐\n\n                                        │   HDFS    │\n\n                                        │  Cluster  │\n\n                                        └───────────┘"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Each Julia Pkg Client is configured to talk to a Pkg Server. By default, they talk to pkg.julialang.org, a public, unauthenticated Pkg Server. If the environment variable JULIA_PKG_SERVER is set, the Pkg Client connects to that host instead. For example, if JULIA_PKG_SERVER is set to pkg.company.com then the Pkg Client will connect to https://pkg.company.com. So in typical operation, a Pkg Client will no longer rely on libgit2 or a git command-line client, both of which have been an ongoing headache, especially behind firewalls and on Windows. If fact, git will only be necessary when working with git-hosted registries and unregistered packages - those will continue to work as they have previously, fetched using git."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"While the default Pkg Server at pkg.julialang.org is unauthenticated, other parties may host Pkg Server instances elsewhere, authenticated or unauthenticated, public or private, as they wish. People can connect to those servers by setting the JULIA_PKG_SERVER variable. There will be a configuration file for providing authentication information to Pkg Servers using either basic auth or OpenID. The Pkg Server implementation will be open source and have minimal operational requirements. Specifically, it needs:"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The ability to accept incoming connections on port 443;\nThe ability to connect to a configurable set of Storage Services;\nTemporary disk storage for caching resources (registries, packages, artifacts)."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"A Pkg Service may be backed by more than one actual server, as is typical for web services. The Pkg Service is stateless, so this kind of horizontal scaling is straightforward. Each Pkg Server serves registry, package and artifact resources to Pkg Clients and caches whatever it serves. Each Pkg Server, in turn, gets those resources from one or more Storage Services. Storage services are responsible for fetching resources from code hosting sites like GitHub, GitLab and BitBucket, and for persisting everything that they have ever served to long-term storage systems like Amazon S3, hosted HDFS clusters - or whatever an implementor wants to use. If the original copies of resources vanish, Pkg Servers must always serve up all previously served versions of resources."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The Storage Protocol is designed to be extremely simple so that multiple independent implementations can coexist, and each Pkg Server may be symmetrically backed by multiple different Storage Services, providing both redundant backup and ensuring that no single implementation has a \"choke hold\" on the ecosystem - anyone can implement a new Storage Service and add it to the set of services backing the default Pkg Server at pkg.julialang.org. The simplest possible version of a Storage Service is a static HTTPS site serving files generated from a snapshot of a registry. Although this does not provide adequate long-term backup capabilities, and would need to be regenerated whenever a registry changes, it may be sufficient for some private uses. Having multiple independently operated Storage Services helps ensure that even if one Storage Service becomes unavailable or unreliable - for technical, financial, or political reasons - others will keep operating and so will the Pkg ecosystem."},{"title":"The Pkg Protocol","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#The-Pkg-Protocol","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"This section describes the protocol used by Pkg Clients to get resources from Pkg Servers, including the latest versions of registries, package source trees, and artifacts. There is also a standard system for asking for diffs of all of these from previous versions, to minimize how much data the client needs to download in order to update itself. There is additionally a bundle mechanism for requesting and receiving a set of resources in a single request."},{"title":"Authentication","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Authentication","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The authentication scheme between a Pkg client and server will be HTTP authorization with bearer tokens, as standardized in RFC6750. This means that authenticated access is accomplished by the client by making an HTTPS request including a Authorization: Bearer $access_token header."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The format of the token, its contents and validation mechanism are not specified by the Pkg Protocol. They are left to the server to define. The server is expected to validate the token and determine whether the client is authorized to access the requested resource. Similarly at the client side, the implementation of the token acquisition is not specified by the Pkg Protocol. However Pkg provides hooks that can be implemented at the client side to trigger the token acquisition process. Tokens thus acquired are expected to be stored in a local file, the format of which is specified by the Pkg Protocol. Pkg will be able to read the token from this file and include it in the request to the server. Pkg can also, optionally, detect when the token is about to expire and trigger a refresh. The Pkg client also supports automatic token refresh, since bearer tokens are recommended to be short-lived (no more than a day)."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The authorization information is saved locally in $(DEPOT_PATH[1])/servers/$server/auth.toml which is a TOML file with the following fields:"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"access_token (REQUIRED): the bearer token used to authorize normal requests\nexpires_at (OPTIONAL): an absolute expiration time\nexpires_in (OPTIONAL): a relative expiration time\nrefresh_token (OPTIONAL): bearer token used to authorize refresh requests\nrefresh_url (OPTIONAL): URL to fetch a new token from"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The auth.toml file may contain other fields (e.g. user name, user email), but they are ignored by Pkg. The two other fields mentioned in RFC6750 are token_type and scope: these are omitted since only tokens of type Bearer are supported currently and the scope is always implicitly to provide access to Pkg protocol URLs. Pkg servers should, however, not send auth.toml files with token_type or scope fields, as these names may be used in the future, e.g. to support other kinds of tokens or to limit the scope of an authorization to a subset of Pkg protocol URLs."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Initially, the user or user agent (IDE) must acquire a auth.toml file and save it to the correct location. After that, Pkg will determine whether the access token needs to be refreshed by examining the expires_at and/or expires_in fields of the auth file. The expiration time is the minimum of expires_at and mtime(auth_file) + expires_in. When the Pkg client downloads a new auth.toml file, if there is a relative expires_in field, an absolute expires_at value is computed based on the client's current clock time. This combination of policies allows expiration to work gracefully even in the presence of clock skew between the server and the client."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"If the access token is expired and there are refresh_token and refresh_url fields in auth.toml, a new auth file is requested by making a request to refresh_url with an Authorization: Bearer $refresh_token header. Pkg will refuse to make a refresh request unless refresh_url is an HTTPS URL. Note that refresh_url need not be a URL on the Pkg server: token refresh can be handled by a separate server. If the request is successful and the returned auth.toml file is a well-formed TOML file with at least an access_token field, it is saved to $(DEPOT_PATH[1])/servers/$server/auth.toml."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Checking for access token expiry and refreshing auth.toml is done before each Pkg client request to a Pkg server, and if the auth file is updated the new access token is used, so the token should in theory always be up to date. Practice is different from theory, of course, and if the Pkg server considers the access token expired, it may return an HTTP 401 Unauthorized response, and the Pkg client should attempt to refresh the auth token. If, after attempting to refresh the access token, the server still returns HTTP 401 Unauthorized, the Pkg client will present the body of the error response to the user or user agent (IDE)."},{"title":"Authentication Hooks","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Authentication-Hooks","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"A mechanism to register a hook at the client is provided to allow the user agent to handle an auth failure. It can, for example, present a login page and take the user through the necessary authentication flow to get a new auth token and store it in auth.toml."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"A handler can also be registered using register_auth_error_handler. It returns a function that can be called to deregister the handler.\nA handler can also be deregistered using deregister_auth_error_handler."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Example:"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"# register a handler\ndispose = Pkg.PlatformEngines.register_auth_error_handler((url, svr, err) -> begin\n    PkgAuth.authenticate(svr*\"/auth\")\n    return true, true\nend)\n\n# ... client code ...\n\n# deregister the handler\ndispose()\n# or\nPkg.PlatformEngines.deregister_auth_error_handler(url, svr)"},{"title":"Resources","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Resources","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The client can make GET or HEAD requests to the following resources:"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"/registries: map of registry uuids at this server to their current tree hashes, each line of the response data is of the form /registry/$uuid/$hash representing a resource pointing to particular version of a registry\n/registry/$uuid/$hash: tarball of registry uuid at the given tree hash\n/package/$uuid/$hash: tarball of package uuid at the given tree hash\n/artifact/$hash: tarball of an artifact with the given tree hash"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Only the /registries changes - all other resources can be cached forever and the server will indicate this with the appropriate HTTP headers."},{"title":"Reference Implementation","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Reference-Implementation","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"A reference implementation of the Pkg Server protocol is available at PkgServer.jl."},{"title":"The Storage Protocol","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#The-Storage-Protocol","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"This section describes the protocol used by Pkg Servers to get resources from Storage Servers, including the latest versions of registries, package source trees, and artifacts. The Pkg Server requests each type of resource when it needs it and caches it for as long as it can, so Storage Services should not have to serve the same resources to the same Pkg Server instance many times."},{"title":"Authentication","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Authentication-2","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Since the Storage protocol is a server-to-server protocol, it uses certificate-based mutual authentication: each side of the connection presents certificates of identity to the other. The operator of a Storage Service must issue a client certificate to the operator of a Pkg Service certifying that it is authorized to use the Storage Service."},{"title":"Resources","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Resources-2","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The Storage Protocol is similar to the Pkg Protocol:"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"/registries: map of registry uuids at this server to their current tree hashes\n/registry/$uuid/$hash: tarball of registry uuid at the given tree hash\n/package/$uuid/$hash: tarball of package uuid at the given tree hash\n/artifact/$hash: tarball of an artifact with the given tree hash"},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"As is the case with the Pkg Server protocol, only the /registries resource changes over time—all other resources are permanently cacheable and Pkg Servers are expected to cache resources indefinitely, only deleting them if they need to reclaim storage space."},{"title":"Interaction","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Interaction","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Fetching resources from a single Storage Server is straightforward: the Pkg Server asks for a version of a registry by UUID and hash and the Storage Server returns a tarball of that registry tree if it knows about that registry and version, or an HTTP 404 error if it doesn't."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Each Pkg Server may use multiple Storage Services for availability and depth of backup. For a given resource, the Pkg Server makes a HEAD request to each Storage Service requesting the resource, and then makes a GET request for the resource to the first Storage Server that replies to the HEAD request with a 200 OK. If no Storage Service responds with a 200 OK in enough time, the Pkg Server should respond to the request for the corresponding resource with a 404 error. Each Storage Service which responds with a 200 OK must behave as if it had served the resource, regardless of whether it does so or not - i.e. persist the resource to long-term storage."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"One subtlety is how the Pkg Server determines what the latest version of each registry is. It can get a map from registry UUIDs to version hashes from each Storage Server, but hashes are unordered - if multiple Storage Servers reply with different hashes, which one should the Pkg Server use? When Storage Servers disagree on the latest hash of a registry, the Pkg Server should ask each Storage Server about the hashes that the other servers returned: if Service A knows about Service B's hash but B doesn't know about A's hash, then A's hash is more recent and should be used. If each server doesn't know about the other's hash, then neither hash is strictly newer than the other one and either could be used. The Pkg Server can break the tie any way it wants, e.g. randomly or by using the lexicographically earlier hash."},{"title":"Guarantees","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Guarantees","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The primary guarantee that a Storage Server makes is that if it has ever successfully served a resource—registry tree, package source tree, artifact tree — it must be able to serve that same resource version forever."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"It's tempting to also require it to guarantee that if a Storage Server serves a registry tree, it can also serve every package source tree referred to within that registry tree. Similarly, it is tempting to require that if a Storage Server can serve a package source tree that it should be able to serve any artifacts referenced by that version of the package. However, this could fail for reasons entirely beyond the control of the server: what if the registry is published with wrong package hashes? What if someone registers a package version, doesn't git tag it, then force pushes the branch that the version was on? In both of these cases, the Storage Server may not be able to fetch a version of a package through no fault of its own. Similarly, artifact hashes in packages might be incorrect or vanish before the Storage Server can retrieve them."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Therefore, we don't strictly require that Storage Servers guarantee this kind of closure under resource references. We do, however, recommend that Storage Servers proactively fetch resources referred to by other resources as soon as possible. When a new version of a registry is available, the Storage Server should fetch all the new package versions in the registry immediately. When a package version is fetched—for any reason, whether because it was included in a new registry snapshot or because an upstream Pkg Server requested it by hash—all artifacts that it references should be fetched immediately."},{"title":"Verification","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Verification","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Since all resources are content addressed, the Pkg Clients and Pkg Server can and should verify that resources that they receive from upstream have the correct content hash. If a resource does not have the right hash, it should not be used and not be served further downstream. Pkg Servers should try to fetch the resource from other Storage Services and serve one that has the correct content. Pkg Clients should error if they get a resource with an incorrect content hash."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Git uses SHA1 for content hashing. There is a pure Julia implementation of git's content hashing algorithm, which is being used to verify artifacts in Julia 1.3 (among other things). The SHA1 hashing algorithm is considered to be cryptographically compromised at this point, and while it's not completely broken, git is already starting to plan how to move away from using SHA1 hashes. To that end, we should consider getting ahead of this problem by using a stronger hash like SHA3-256 in these protocols. Having control over these protocols actually makes this considerably easier than if we were continuing to rely on git for resource acquisition."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"The first step to using SHA3-256 instead of SHA1 is to populate registries with additional hashes for package versions. Currently each package version is identified by a git-tree-sha1 entry. We would add git-tree-sha3-256 entries that give the SHA3-256 hashes computed using the same git tree hashing logic. From this origin, the Pkg Client, Pkg Server and Storage Servers all just need to use SHA3-256 hashes rather than SHA1 hashes."},{"title":"References","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#References","category":"section","text":""},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/","category":"page","text":"Pkg & Storage Protocols https://github.com/JuliaLang/Pkg.jl/issues/1377\nAuthenticated Pkg Client Support: https://github.com/JuliaLang/Pkg.jl/pull/1538\nAuthentication Hooks: https://github.com/JuliaLang/Pkg.jl/pull/1630"},{"title":"8. Registries","page":"8. Registries","location":"registries/#**8.**-Registries","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Registries contain information about packages, such as available releases and dependencies, and where they can be downloaded. The General registry is the default one, and is installed automatically if there are no other registries installed."},{"title":"Managing registries","page":"8. Registries","location":"registries/#Managing-registries","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Registries can be added, removed and updated from either the Pkg REPL or by using the functional API. In this section we will describe the REPL interface. The registry API is documented in the Registry API Reference section."},{"title":"Adding registries","page":"8. Registries","location":"registries/#Adding-registries","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"A custom registry can be added with the registry add command from the Pkg REPL. Usually this will be done with a URL to the registry."},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"If a custom registry has been installed causing the General registry to not be automatically installed, it is easy to add it manually:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"pkg> registry add General"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"and now all the packages registered in General are available for e.g. adding. To see which registries are currently installed you can use the registry status (or registry st) command"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"pkg> registry st\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Registries are always added to the user depot, which is the first entry in DEPOT_PATH (cf. the Glossary section)."},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"note: Registries from a package server\nIt is possible for a package server to be advertising additional available package registries. When Pkg runs with a clean Julia depot (e.g. after a fresh install), with a custom package server configured with JULIA_PKG_SERVER, it will automatically add all such available registries. If the depot already has some registries installed (e.g. General), the additional ones can easily be installed with the no-argument registry add command."},{"title":"Removing registries","page":"8. Registries","location":"registries/#Removing-registries","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Registries can be removed with the registry remove (or registry rm) command. Here we remove the General registry"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"pkg> registry rm General\n  Removing registry `General` from ~/.julia/registries/General\n\npkg> registry st\nRegistry Status\n  (no registries found)"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"In case there are multiple registries named General installed you have to disambiguate with the uuid, just as when manipulating packages, e.g."},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"pkg> registry rm General=23338594-aafe-5451-b93e-139f81909106\n  Removing registry `General` from ~/.julia/registries/General"},{"title":"Updating registries","page":"8. Registries","location":"registries/#Updating-registries","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"The registry update (or registry up) command is available to update registries. Here we update the General registry:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"pkg> registry up General\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"and to update all installed registries just do:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"pkg> registry up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Registries automatically update once per session when a package operation is performed so it rarely has to be done manually."},{"title":"Registry format","page":"8. Registries","location":"registries/#Registry-format","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"In a registry, each package gets its own directory; in that directory are the following files: Compat.toml, Deps.toml, Package.toml, and Versions.toml. The formats of these files are described below."},{"title":"Registry Compat.toml","page":"8. Registries","location":"registries/#Registry-Compat.toml","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"The Compat.toml file has a series of blocks specifying version numbers, with a set of dependencies listed below. For example, part of such a file might look like this:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"[\"0.8-0.8.3\"]\nDependencyA = \"0.4-0.5\"\nDependencyB = \"0.3-0.5\"\n\n[\"0.8.2-0.8.5\"]\nDependencyC = \"0.7-0\""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Dependencies that are unchanged across a range of versions are grouped together in these blocks. The interpretation of these ranges is given by the comment after each line below:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"\"0.7-0.8\"  # [0.7.0, 0.9.0)\n\"0.7-0\"    # [0.7.0, 1.0.0)\n\"0.8.6-0\"  # [0.8.6, 1.0.0)\n\"0.7-*\"    # [0.7.0, ∞)"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"So for this package, versions [0.8.0, 0.8.3] depend on versions [0.4.0, 0.6.0) of DependencyA and version [0.3.0, 0.6.0) of DependencyB. Meanwhile, it is also true that versions [0.8.2, 0.8.5] require specific versions of DependencyC (so that all three are required for versions 0.8.2 and 0.8.3)."},{"title":"Registry flavors","page":"8. Registries","location":"registries/#Registry-flavors","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"The default Pkg Server (pkg.julialang.org) offers two different \"flavors\" of registry."},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"compat: Julia 1.8\nRegistry flavors are only available starting with Julia 1.8."},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"conservative: suitable for most users; all packages and artifacts in this registry flavor are available from the Pkg Server, with no need to download from other sources\neager: this registry offers the latest versions of packages, even if the Pkg and Storage Servers have not finished processing them; thus, some packages and artifacts may not be available from the Pkg Server, and thus may need to be downloaded from other sources (such as GitHub)"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"The default registry flavor is conservative. We recommend that most users stick to the conservative flavor unless they know that they need to use the eager flavor."},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"To select the eager flavor:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"ENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"eager\"\n\nimport Pkg\n\nPkg.Registry.update()"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"To select the conservative flavor:"},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"ENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"conservative\"\n\nimport Pkg\n\nPkg.Registry.update()"},{"title":"Creating and maintaining registries","page":"8. Registries","location":"registries/#Creating-and-maintaining-registries","category":"section","text":""},{"title":"8. Registries","page":"8. Registries","location":"registries/","category":"page","text":"Pkg only provides client facilities for registries, rather than functionality to create or maintain them. However, Registrator.jl and LocalRegistry.jl provide ways to create and update registries, and RegistryCI.jl provides automated testing and merging functionality for maintaining a registry."},{"title":"1. Introduction","page":"1. Introduction","location":"#**1.**-Introduction","category":"section","text":""},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"Welcome to the documentation for Pkg, Julia's package manager. The documentation covers many things, for example managing package installations, developing packages, working with package registries and more."},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"import Markdown\n# For Pkg, we need to determine the appropriate Julia version for the PDF\n# Since Pkg docs are versioned by Julia version, we'll use a similar approach to Julia docs\njulia_patch = if VERSION.prerelease == ()\n    \"v$(VERSION.major).$(VERSION.minor).$(VERSION.patch)\"\nelseif VERSION.prerelease[1] == \"DEV\"\n    \"dev\"\nend\nfile = \"Pkg.jl.pdf\"\nurl = \"https://raw.githubusercontent.com/JuliaLang/Pkg.jl/gh-pages-pdf/$(julia_patch)/$(file)\"\nMarkdown.parse(\"\"\"\n!!! note\n    The documentation is also available in PDF format: [$file]($url).\n\"\"\")"},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"Throughout the manual the REPL interface to Pkg, the Pkg REPL mode, is used in the examples. There is also a functional API, which is preferred when not working interactively. This API is documented in the API Reference section."},{"title":"Background and Design","page":"1. Introduction","location":"#Background-and-Design","category":"section","text":""},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around “environments”: independent sets of packages that can be local to an individual project or shared and selected by name. The exact set of packages and versions in an environment is captured in a manifest file which can be checked into a project repository and tracked in version control, significantly improving reproducibility of projects. If you’ve ever tried to run code you haven’t used in a while only to find that you can’t get anything to work because you’ve updated or uninstalled some of the packages your project was using, you’ll understand the motivation for this approach. In Pkg, since each project maintains its own independent set of package versions, you’ll never have this problem again. Moreover, if you check out a project on a new system, you can simply materialize the environment described by its manifest file and immediately be up and running with a known-good set of dependencies."},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"Since environments are managed and updated independently from each other, “dependency hell” is significantly alleviated in Pkg. If you want to use the latest and greatest version of some package in a new project but you’re stuck on an older version in a different project, that’s no problem – since they have separate environments they can just use different versions, which are both installed at the same time in different locations on your system. The location of each package version is canonical, so when environments use the same versions of packages, they can share installations, avoiding unnecessary duplication of the package. Old package versions that are no longer used by any environments are periodically “garbage collected” by the package manager."},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"Pkg’s approach to local environments may be familiar to people who have used Python’s virtualenv or Ruby’s bundler. In Julia, instead of hacking the language’s code loading mechanisms to support environments, we have the benefit that Julia natively understands them. In addition, Julia environments are “stackable”: you can overlay one environment with another and thereby have access to additional packages outside of the primary environment. This makes it easy to work on a project, which provides the primary environment, while still having access from the REPL to all your usual dev tools like profilers, debuggers, and so on, just by having an environment including these dev tools later in the load path."},{"title":"1. Introduction","page":"1. Introduction","location":"","category":"page","text":"Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you'll be back on an official release again."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/#Glossary","category":"section","text":""},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Project: a source tree with a standard layout, including a src directory for the main body of Julia code, a test directory for testing the project, a docs directory for documentation files, and optionally a deps directory for a build script and its outputs. A project will typically also have a project file and may optionally have a manifest file:"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Project file: a file in the root directory of a project, named Project.toml (or JuliaProject.toml), describing metadata about the project, including its name, UUID (for packages), authors, license, and the names and UUIDs of packages and libraries that it depends on.\nManifest file: a file in the root directory of a project, named Manifest.toml (or JuliaManifest.toml), describing a complete dependency graph and exact versions of each package and library used by a project. The file name may also be suffixed by -v{major}.{minor}.toml which Julia will prefer if the version matches VERSION, allowing multiple environments to be maintained for different Julia versions."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Package: a project which provides reusable functionality that can be used by other Julia projects via import X or using X. A package should have a project file with a uuid entry giving its package UUID. This UUID is used to identify the package in projects that depend on it."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"note: Note\nFor legacy reasons, it is possible to load a package without a project file or UUID from the REPL or the top-level of a script. It is not possible, however, to load a package without a project file or UUID from a project with them. Once you've loaded from a project file, everything needs a project file and UUID."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Application: a project which provides standalone functionality not intended to be reused by other Julia projects. For example a web application or a command-line utility, or simulation/analytics code accompanying a scientific paper. An application may have a UUID but does not need one. An application may also set and change the global configurations of packages it depends on. Packages, on the other hand, may not change the global state of their dependencies since that could conflict with the configuration of the main application."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"note: Note\nProjects vs. Packages vs. Applications:Project is an umbrella term: packages and applications are kinds of projects.\nPackages should have UUIDs, applications can have UUIDs but don't need them.\nApplications can provide global configuration, whereas packages cannot."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Environment: the combination of the top-level name map provided by a project file combined with the dependency graph and map from packages to their entry points provided by a manifest file. For more detail see the manual section on code loading."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Explicit environment: an environment in the form of an explicit project file and an optional corresponding manifest file together in a directory. If the manifest file is absent then the implied dependency graph and location maps are empty.\nImplicit environment: an environment provided as a directory (without a project file or manifest file) containing packages with entry points of the form X.jl, X.jl/src/X.jl or X/src/X.jl. The top-level name map is implied by these entry points. The dependency graph is implied by the existence of project files inside of these package directories, e.g. X.jl/Project.toml or X/Project.toml. The dependencies of the X package are the dependencies in the corresponding project file if there is one. The location map is implied by the entry points themselves."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Registry: a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"name – e.g. DataFrames\nUUID – e.g. a93c6f00-e57d-5684-b7b6-d8193f3e46c0\nrepository – e.g. https://github.com/JuliaData/DataFrames.jl.git\nversions – a list of all registered version tags"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"For each registered version of a package, the following information is provided:"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"its semantic version number – e.g. v1.2.3\nits git tree SHA-1 hash – e.g. 7ffb18ea3245ef98e368b02b81e8a86543a11103\na map from names to UUIDs of dependencies\nwhich versions of other packages it is compatible/incompatible with"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Dependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Depot: a directory on a system where various package-related resources live, including:"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"environments: shared named environments (e.g. v1.0, devtools)\nclones: bare clones of package repositories\ncompiled: cached compiled package images (.ji files)\nconfig: global configuration files (e.g. startup.jl)\ndev: default directory for package development\nlogs: log files (e.g. manifest_usage.toml, repl_history.jl)\npackages: installed package versions\nregistries: clones of registries (e.g. General)"},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Load path: a stack of environments where package identities, their dependencies, and entry points are searched for. The load path is controlled in Julia by the LOAD_PATH global variable which is populated at startup based on the value of the JULIA_LOAD_PATH environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/","category":"page","text":"Depot path: a stack of depot locations where the package manager, as well as Julia's code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia DEPOT_PATH global variable which is populated at startup based on the value of the JULIA_DEPOT_PATH environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repositories are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators."},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/#REPL-Mode-Reference","category":"section","text":""},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"This section describes available commands in the Pkg REPL. The Pkg REPL mode is mostly meant for interactive use, and for non-interactive use it is recommended to use the functional API, see API Reference."},{"title":"package commands","page":"11. REPL Mode Reference","location":"repl/#package-commands","category":"section","text":""},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-add\" href=\"#repl-add\">\n            <code>add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"add\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-build\" href=\"#repl-build\">\n            <code>build</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"build\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-compat\" href=\"#repl-compat\">\n            <code>compat</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"compat\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-develop\" href=\"#repl-develop\">\n            <code>develop</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"develop\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-free\" href=\"#repl-free\">\n            <code>free</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"free\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-generate\" href=\"#repl-generate\">\n            <code>generate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"generate\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-pin\" href=\"#repl-pin\">\n            <code>pin</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"pin\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-remove\" href=\"#repl-remove\">\n            <code>remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"remove\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-test\" href=\"#repl-test\">\n            <code>test</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"test\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-update\" href=\"#repl-update\">\n            <code>update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"update\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"registry commands","page":"11. REPL Mode Reference","location":"repl/#registry-commands","category":"section","text":""},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-add\" href=\"#repl-registry-add\">\n            <code>registry add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry add\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-remove\" href=\"#repl-registry-remove\">\n            <code>registry remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry remove\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-status\" href=\"#repl-registry-status\">\n            <code>registry status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry status\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-update\" href=\"#repl-registry-update\">\n            <code>registry update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry update\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"Other commands","page":"11. REPL Mode Reference","location":"repl/#Other-commands","category":"section","text":""},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-activate\" href=\"#repl-activate\">\n            <code>activate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"activate\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-gc\" href=\"#repl-gc\">\n            <code>gc</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"gc\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-help\" href=\"#repl-help\">\n            <code>help</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"help\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-instantiate\" href=\"#repl-instantiate\">\n            <code>instantiate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"instantiate\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-precompile\" href=\"#repl-precompile\">\n            <code>precompile</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"precompile\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-resolve\" href=\"#repl-resolve\">\n            <code>resolve</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"resolve\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-status\" href=\"#repl-status\">\n            <code>status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"status\"].help"},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/","category":"page","text":"    </section>\n</article>"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/#**2.**-Getting-Started","category":"section","text":""},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"What follows is a quick overview of the basic features of Pkg. It should help new users become familiar with basic Pkg features such as adding and removing packages and working with environments."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"note: Note\nSome Pkg output is omitted in this section in order to keep this basic guide focused. This will help maintain a good pace and not get bogged down in details. If you require more details, refer to subsequent sections of the Pkg manual."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"note: Note\nThis guide uses the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the API Reference section of the Pkg documentation."},{"title":"Basic Usage","page":"2. Getting Started","location":"getting-started/#Basic-Usage","category":"section","text":""},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Pkg comes with a REPL. Enter the Pkg REPL by pressing ] from the Julia REPL. To get back to the Julia REPL, press Ctrl+C or backspace (when the REPL cursor is at the beginning of the input)."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Upon entering the Pkg REPL, you should see the following prompt:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg>"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"To add a package, use add:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [7876af07] + Example v0.5.3"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"After the package is installed, it can be loaded into the Julia session:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"julia> import Example\n\njulia> Example.hello(\"friend\")\n\"Hello, friend\""},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"We can also specify multiple packages at once to install:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> add JSON StaticArrays"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"The status command (or the shorter st command) can be used to see installed packages."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> st\nStatus `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n  [90137ffa] StaticArrays v1.5.9"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"note: Note\nSome Pkg REPL commands have a short and a long version of the command, for example status and st."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"To remove packages, use rm (or remove):"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> rm JSON StaticArrays"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Use up (or update) to update the installed packages"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> up"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"If you have been following this guide it is likely that the packages installed are at the latest version so up will not do anything. Below we show the status output in the case where we deliberately have installed an old version of the Example package and then upgrade it:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> st\nStatus `~/.julia/environments/v1.10/Project.toml`\n⌃ [7876af07] Example v0.5.1\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.10) pkg> up\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ↑ Example v0.5.1 ⇒ v0.5.3"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"We can see that the status output tells us that there is a newer version available and that up upgrades the package."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"For more information about managing packages, see the Managing Packages section of the documentation."},{"title":"Getting Started with Environments","page":"2. Getting Started","location":"getting-started/#Getting-Started-with-Environments","category":"section","text":""},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Up to this point, we have covered basic package management: adding, updating, and removing packages."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"You may have noticed the (@v1.10) in the REPL prompt. This lets us know that v1.10 is the active environment. Different environments can have totally different packages and versions installed from another environment. The active environment is the environment that will be modified by Pkg commands such as add, rm and update."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Let's set up a new environment so we may experiment. To set the active environment, use activate:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> activate tutorial\n[ Info: activating new environment at `~/tutorial/Project.toml`."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Pkg lets us know we are creating a new environment and that this environment will be stored in the ~/tutorial directory. The path to the environment is created relative to the current working directory of the REPL."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"Pkg has also updated the REPL prompt in order to reflect the new active environment:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(tutorial) pkg>"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"We can ask for information about the active environment by using status:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n   (empty environment)"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"~/tutorial/Project.toml is the location of the active environment's project file. A project file is a TOML file where Pkg stores the packages that have been explicitly installed. Notice this new environment is empty. Let us add some packages and observe:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(tutorial) pkg> add Example JSON\n...\n\n(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"We can see that the tutorial environment now contains Example and JSON."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"note: Note\nIf you have the same package (at the same version) installed in multiple environments, the package will only be downloaded and stored on the hard drive once. This makes environments very lightweight and effectively free to create. Using only the default environment with a huge number of packages in it is a common beginners mistake in Julia. Learning how to use environments effectively will improve your experience with Julia packages."},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"For more information about environments, see the Working with Environments section of the documentation."},{"title":"Asking for Help","page":"2. Getting Started","location":"getting-started/#Asking-for-Help","category":"section","text":""},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"If you are ever stuck, you can ask Pkg for help:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> ?"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"You should see a list of available commands along with short descriptions. You can ask for more detailed help by specifying a command:"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"(@v1.10) pkg> ?develop"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/","category":"page","text":"This guide should help you get started with Pkg. Pkg has much more to offer in terms of powerful package management. For more advanced topics, see Managing Packages, Working with Environments, and Creating Packages."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/#Artifacts","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Pkg can install and manage containers of data that are not Julia packages.  These containers can contain platform-specific binaries, datasets, text, or any other kind of data that would be convenient to place within an immutable, life-cycled datastore. These containers, (called \"Artifacts\") can be created locally, hosted anywhere, and automatically downloaded and unpacked upon installation of your Julia package. This mechanism is also used to provide the binary dependencies for packages built with BinaryBuilder.jl."},{"title":"Basic Usage","page":"9. Artifacts","location":"artifacts/#Basic-Usage","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Pkg artifacts are declared in an Artifacts.toml file, which can be placed in your current directory or in the root of your package. Currently, Pkg supports downloading of tarfiles (which can be compressed) from a URL. Following is a minimal Artifacts.toml file which will permit the downloading of a socrates.tar.gz file from github.com. In this example, a single artifact, given the name socrates, is defined."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"# a simple Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"If this Artifacts.toml file is placed in your current directory, then socrates.tar.gz can be downloaded, unpacked and used with artifact\"socrates\". Since this tarball contains a folder bin, and a text file named socrates within that folder, we could access the content of that file as follows."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"using Pkg.Artifacts\n\nrootpath = artifact\"socrates\"\nopen(joinpath(rootpath, \"bin\", \"socrates\")) do file\n    println(read(file, String))\nend"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"If you have an existing tarball that is accessible via a url, it could also be accessed in this manner. To create the Artifacts.toml you must compute two hashes: the sha256 hash of the download file, and the git-tree-sha1 of the unpacked content. These can be computed as follows."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"using Tar, Inflate, SHA\n\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"To access this artifact from within a package you create, place the Artifacts.toml at the root of your package, adjacent to Project.toml. Then, make sure to add Pkg in your deps and set julia = \"1.3\" or higher in your compat section."},{"title":"Artifacts.toml files","page":"9. Artifacts","location":"artifacts/#Artifacts.toml-files","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Pkg provides an API for working with artifacts, as well as a TOML file format for recording artifact usage in your packages, and to automate downloading of artifacts at package install time. Artifacts can always be referred to by content hash, but are typically accessed by a name that is bound to a content hash in an Artifacts.toml file that lives in a project's source tree."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"note: Note\nIt is possible to use the alternate name JuliaArtifacts.toml, similar to how it is possible to use JuliaProject.toml and JuliaManifest.toml instead of Project.toml and Manifest.toml, respectively."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"An example Artifacts.toml file is shown here:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"# Example Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\nlazy = true\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2\"\n    sha256 = \"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"4bdf4556050cb55b67b211d4e78009aaec378cbc\"\nlibc = \"musl\"\nos = \"linux\"\n\n    [[c_simple.download]]\n    sha256 = \"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"51264dbc770cd38aeb15f93536c29dc38c727e4c\"\nos = \"macos\"\n\n    [[c_simple.download]]\n    sha256 = \"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz\"\n\n[processed_output]\ngit-tree-sha1 = \"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200\""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"This Artifacts.toml binds three artifacts; one named socrates, one named c_simple and one named processed_output. The single required piece of information for an artifact is its git-tree-sha1. Because artifacts are addressed only by their content hash, the purpose of an Artifacts.toml file is to provide metadata about these artifacts, such as binding a human-readable name to a content hash, providing information about where an artifact may be downloaded from, or even binding a single name to multiple hashes, keyed by platform-specific constraints such as operating system or libgfortran version."},{"title":"Artifact types and properties","page":"9. Artifacts","location":"artifacts/#Artifact-types-and-properties","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"In the above example, the socrates artifact showcases a platform-independent artifact with multiple download locations. When downloading and installing the socrates artifact, URLs will be attempted in order until one succeeds. The socrates artifact is marked as lazy, which means that it will not be automatically downloaded when the containing package is installed, but rather will be downloaded on-demand when the package first attempts to use it."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"The c_simple artifact showcases a platform-dependent artifact, where each entry in the c_simple array contains keys that help the calling package choose the appropriate download based on the particulars of the host machine. Note that each artifact contains both a git-tree-sha1 and a sha256 for each download entry.  This is to ensure that the downloaded tarball is secure before attempting to unpack it, as well as enforcing that all tarballs must expand to the same overall tree hash."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"The processed_output artifact contains no download stanza, and so cannot be installed. An artifact such as this would be the result of code that was previously run, generating a new artifact and binding the resultant hash to a name within this project."},{"title":"Using Artifacts","page":"9. Artifacts","location":"artifacts/#Using-Artifacts","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Artifacts can be manipulated using convenient APIs exposed from the Pkg.Artifacts namespace. As a motivating example, let us imagine that we are writing a package that needs to load the Iris machine learning dataset. While we could just download the dataset during a build step into the package directory, and many packages currently do precisely this, that has some significant drawbacks:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"First, it modifies the package directory, making package installation stateful, which we want to avoid. In the future, we would like to reach the point where packages can be installed completely read-only, instead of being able to modify themselves after installation.\nSecond, the downloaded data is not shared across different versions of our package. If we have three different versions of the package installed for use by various projects, then we need three different copies of the data, even if it hasn't changed between those versions. Moreover, each time we upgrade or downgrade the package unless we do something clever (and probably brittle), we have to download the data again."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"With artifacts, we will instead check to see if our iris artifact already exists on-disk and only if it doesn't will we download and install it, after which we can bind the result into our Artifacts.toml file:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"using Pkg.Artifacts\n\n# This is the path to the Artifacts.toml we will manipulate\nartifact_toml = joinpath(@__DIR__, \"Artifacts.toml\")\n\n# Query the `Artifacts.toml` file for the hash bound to the name \"iris\"\n# (returns `nothing` if no such binding exists)\niris_hash = artifact_hash(\"iris\", artifact_toml)\n\n# If the name was not bound, or the hash it was bound to does not exist, create it!\nif iris_hash == nothing || !artifact_exists(iris_hash)\n    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n    iris_hash = create_artifact() do artifact_dir\n        # We create the artifact by simply downloading a few files into the new artifact directory\n        iris_url_base = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris\"\n        download(\"$(iris_url_base)/iris.data\", joinpath(artifact_dir, \"iris.csv\"))\n        download(\"$(iris_url_base)/bezdekIris.data\", joinpath(artifact_dir, \"bezdekIris.csv\"))\n        download(\"$(iris_url_base)/iris.names\", joinpath(artifact_dir, \"iris.names\"))\n    end\n\n    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n    # the content hash to change, so this should not cause unnecessary version control churn.\n    bind_artifact!(artifact_toml, \"iris\", iris_hash)\nend\n\n# Get the path of the iris dataset, either newly created or previously generated.\n# this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`\niris_dataset_path = artifact_path(iris_hash)"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"For the specific use case of using artifacts that were previously bound, we have the shorthand notation artifact\"name\" which will automatically search for the Artifacts.toml file contained within the current package, look up the given artifact by name, install it if it is not yet installed, then return the path to that given artifact. An example of this shorthand notation is given below:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"using Pkg.Artifacts\n\n# For this to work, an `Artifacts.toml` file must be in the current working directory\n# (or in the root of the current package) and must define a mapping for the \"iris\"\n# artifact.  If it does not exist on-disk, it will be downloaded.\niris_dataset_path = artifact\"iris\""},{"title":"The Pkg.Artifacts API","page":"9. Artifacts","location":"artifacts/#The-Pkg.Artifacts-API","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"The Artifacts API is broken up into three levels: hash-aware functions, name-aware functions and utility functions."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Hash-aware functions deal with content-hashes and essentially nothing else. These methods allow you to query whether an artifact exists, what its path is, verify that an artifact satisfies its content hash on-disk, etc.  Hash-aware functions include: artifact_exists(), artifact_path(), remove_artifact(), verify_artifact() and archive_artifact().  Note that in general you should not use remove_artifact() and should instead use Pkg.gc() to cleanup artifact installations.\nName-aware functions deal with bound names within an Artifacts.toml file, and as such, typically require both a path to an Artifacts.toml file as well as the artifact name.  Name-aware functions include: artifact_meta(), artifact_hash(), bind_artifact!(), unbind_artifact!(), download_artifact() and ensure_artifact_installed().\nUtility functions deal with miscellaneous aspects of artifact life, such as create_artifact(), ensure_all_artifacts_installed(), and even the @artifact_str string macro."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"For a full listing of docstrings and methods, see the Artifacts Reference section."},{"title":"Overriding artifact locations","page":"9. Artifacts","location":"artifacts/#Overriding-artifact-locations","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"It is occasionally necessary to be able to override the location and content of an artifact. A common use case is a computing environment where certain versions of a binary dependency must be used, regardless of what version of this dependency a package was published with. While a typical Julia configuration would download, unpack and link against a generic library, a system administrator may wish to disable this and instead use a library already installed on the local machine. To enable this, Pkg supports a per-depot Overrides.toml file placed within the artifacts depot directory (e.g. ~/.julia/artifacts/Overrides.toml for the default user depot) that can override the location of an artifact either by content-hash or by package UUID and bound artifact name. Additionally, the destination location can be either an absolute path, or a replacement artifact content hash. This allows sysadmins to create their own artifacts which they can then use by overriding other packages to use the new artifact."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"# Override single hash to an absolute path\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/replacement\"\n\n# Override single hash to new artifact content-hash\n683942669b4639019be7631caa28c38f3e1924fe = \"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3\"\n\n# Override package bindings by specifying the package UUID and bound artifact name\n# For demonstration purposes we assume this package is called `Foo`\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"/path/to/libfoo\"\nlibbar = \"683942669b4639019be7631caa28c38f3e1924fe\""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Due to the layered nature of Pkg depots, multiple Overrides.toml files may be in effect at once. This allows the \"inner\" Overrides.toml files to override the overrides placed within the \"outer\" Overrides.toml files. To remove an override and re-enable default location logic for an artifact, insert an entry mapping to the empty string:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/new/replacement\"\n683942669b4639019be7631caa28c38f3e1924fe = \"\"\n\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"\""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"If the two Overrides.toml snippets as given above are layered on top of each other, the end result will be mapping the content-hash 78f35e74ff113f02274ce60dab6e92b4546ef806 to \"/path/to/new/replacement\", and mapping Foo.libbar to the artifact identified by the content-hash 683942669b4639019be7631caa28c38f3e1924fe. Note that while that hash was previously overridden, it is no longer, and therefore Foo.libbar will look directly at locations such as ~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Most methods that are affected by overrides can ignore overrides by setting honor_overrides=false as a keyword argument within them. For UUID/name-based overrides to work, Artifacts.toml files must be loaded with the knowledge of the UUID of the loading package. This is deduced automatically by the artifacts\"\" string macro, however, if you are for some reason manually using the Pkg.Artifacts API within your package and you wish to honor overrides, you must provide the package UUID to API calls like artifact_meta() and ensure_artifact_installed() via the pkg_uuid keyword argument."},{"title":"Extending Platform Selection","page":"9. Artifacts","location":"artifacts/#Extending-Platform-Selection","category":"section","text":""},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"compat: Julia 1.7\nPkg's extended platform selection requires at least Julia 1.7, and is considered experimental."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"New in Julia 1.7, Platform objects can have extended attributes applied to them, allowing artifacts to be tagged with things such as CUDA driver version compatibility, microarchitectural compatibility, julia version compatibility and more! Note that this feature is considered experimental and may change in the future. If you as a package developer find yourself needing this feature, please get in contact with us so it can evolve for the benefit of the whole ecosystem. In order to support artifact selection at Pkg.add() time, Pkg will run the specially-named file <project_root>/.pkg/select_artifacts.jl, passing the current platform triplet as the first argument. This artifact selection script should print a TOML-serialized dictionary representing the artifacts that this package needs according to the given platform, and perform any inspection of the system as necessary to auto-detect platform capabilities if they are not explicitly provided by the given platform triplet. The format of the dictionary should match that returned from Artifacts.select_downloadable_artifacts(), and indeed most packages should simply call that function with an augmented Platform object. An example artifact selection hook definition might look like the following, split across two files:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"# .pkg/platform_augmentation.jl\nusing Libdl, Base.BinaryPlatforms\nfunction augment_platform!(p::Platform)\n    # If this platform object already has a `cuda` tag set, don't augment\n    if haskey(p, \"cuda\")\n        return p\n    end\n\n    # Open libcuda explicitly, so it gets `dlclose()`'ed after we're done\n    dlopen(\"libcuda\") do lib\n        # find symbol to ask for driver version; if we can't find it, just silently continue\n        cuDriverGetVersion = dlsym(lib, \"cuDriverGetVersion\"; throw_error=false)\n        if cuDriverGetVersion !== nothing\n            # Interrogate CUDA driver for driver version:\n            driverVersion = Ref{Cint}()\n            ccall(cuDriverGetVersion, UInt32, (Ptr{Cint},), driverVersion)\n\n            # Store only the major version\n            p[\"cuda\"] = div(driverVersion, 1000)\n        end\n    end\n\n    # Return possibly-altered `Platform` object\n    return p\nend"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"using TOML, Artifacts, Base.BinaryPlatforms\ninclude(\"./platform_augmentation.jl\")\nartifacts_toml = joinpath(dirname(@__DIR__), \"Artifacts.toml\")\n\n# Get \"target triplet\" from ARGS, if given (defaulting to the host triplet otherwise)\ntarget_triplet = get(ARGS, 1, Base.BinaryPlatforms.host_triplet())\n\n# Augment this platform object with any special tags we require\nplatform = augment_platform!(HostPlatform(parse(Platform, target_triplet)))\n\n# Select all downloadable artifacts that match that platform\nartifacts = select_downloadable_artifacts(artifacts_toml; platform)\n\n# Output the result to `stdout` as a TOML dictionary\nTOML.print(stdout, artifacts)"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"In this hook definition, our platform augmentation routine opens a system library (libcuda), searches it for a symbol to give us the CUDA driver version, then embeds the major version of that version number into the cuda property of the Platform object we are augmenting. While it is not critical for this code to actually attempt to close the loaded library (as it will most likely be opened again by the CUDA package immediately after the package operations are completed) it is best practice to make hooks as lightweight and transparent as possible, as they may be used by other Pkg utilities in the future. In your own package, you should also use augmented platform objects when using the @artifact_str macro, as follows:"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"include(\"../.pkg/platform_augmentation.jl\")\n\nfunction __init__()\n    p = augment_platform!(HostPlatform())\n    global my_artifact_dir = @artifact_str(\"MyArtifact\", p)\nend"},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"This ensures that the same artifact is used by your code as Pkg attempted to install."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/","category":"page","text":"Artifact selection hooks are only allowed to use Base, Artifacts, Libdl, and TOML. They are not allowed to use any other standard libraries, and they are not allowed to use any packages (including the package to which they belong)."},{"title":"Pkg","page":"Pkg","location":"basedocs/#Pkg","category":"section","text":""},{"title":"Pkg","page":"Pkg","location":"basedocs/","category":"page","text":"Pkg is Julia's built-in package manager, and handles operations such as installing, updating and removing packages."},{"title":"Pkg","page":"Pkg","location":"basedocs/","category":"page","text":"note: Note\nWhat follows is a very brief introduction to Pkg. For more information on Project.toml files, Manifest.toml files, package version compatibility ([compat]), environments, registries, etc., it is highly recommended to read the full manual, which is available here: https://pkgdocs.julialang.org."},{"title":"Pkg","page":"Pkg","location":"basedocs/","category":"page","text":"import Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" => \"[API Reference](https://pkgdocs.julialang.org/v1/api/)\")\nstr = replace(str, \"(@ref Working-with-Environments)\" => \"(https://pkgdocs.julialang.org/v1/environments/)\")\nstr = replace(str, \"(@ref Managing-Packages)\" => \"(https://pkgdocs.julialang.org/v1/managing-packages/)\")\nMarkdown.parse(str)"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/#Working-with-Environments","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"The following discusses Pkg's interaction with environments. For more on the role, environments play in code loading, including the \"stack\" of environments from which code can be loaded, see this section in the Julia manual."},{"title":"Creating your own environments","page":"4. Working with Environments","location":"environments/#Creating-your-own-environments","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"So far we have added packages to the default environment at ~/.julia/environments/v1.10. It is however easy to create other, independent, projects. This approach has the benefit of allowing you to check in a Project.toml, and even a Manifest.toml if you wish, into version control (e.g. git) alongside your code. It should be pointed out that when two projects use the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the \"active project\", which package operations manipulate:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"(@v1.10) pkg> activate MyProject\nActivating new environment at `~/MyProject/Project.toml`\n\n(MyProject) pkg> st\n    Status `~/MyProject/Project.toml` (empty project)"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Note that the REPL prompt changes when the new project is activated. Until a package is added, there are no files in this environment and the directory to the environment might not even be created:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"julia> isdir(\"MyProject\")\nfalse\n\n(MyProject) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/MyProject/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/MyProject/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling environment...\n  1 dependency successfully precompiled in 2 seconds\n\njulia> readdir(\"MyProject\")\n2-element Vector{String}:\n \"Manifest.toml\"\n \"Project.toml\"\n\njulia> print(read(joinpath(\"MyProject\", \"Project.toml\"), String))\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\njulia> print(read(joinpath(\"MyProject\", \"Manifest.toml\"), String))\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.10.0\"\nmanifest_format = \"2.0\"\nproject_hash = \"2ca1c6c58cb30e79e021fb54e5626c96d05d5fdc\"\n\n[[deps.Example]]\ngit-tree-sha1 = \"46e44e869b4d90b96bd8ed1fdcf32244fddfb6cc\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"0.5.3\""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"This new environment is completely separate from the one we used earlier. See Project.toml and Manifest.toml for a more detailed explanation."},{"title":"Using someone else's project","page":"4. Working with Environments","location":"environments/#Using-someone-else's-project","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Simply clone their project using e.g. git clone, cd to the project directory and call"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"shell> git clone https://github.com/JuliaLang/Example.jl.git\nCloning into 'Example.jl'...\n...\n\n(@v1.10) pkg> activate Example.jl\nActivating project at `~/Example.jl`\n\n(Example) pkg> instantiate\n  No packages added to or removed from `~/Example.jl/Project.toml`\n  No packages added to or removed from `~/Example.jl/Manifest.toml`"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"If the project contains a manifest, this will install the packages in the same state that is given by that manifest. Otherwise, it will resolve the latest versions of the dependencies compatible with the project."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Note that activate by itself does not install missing dependencies. If you only have a Project.toml, a Manifest.toml must be generated by \"resolving\" the environment, then any missing packages must be installed and precompiled. instantiate does all this for you."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"If you already have a resolved Manifest.toml, then you will still need to ensure that the packages are installed and with the correct versions. Again instantiate does this for you."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"In short, instantiate is your friend to make sure an environment is ready to use. If there's nothing to do, instantiate does nothing."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"note: Specifying project on startup\nInstead of using activate from within Julia, you can specify the project on startup using the --project=<path> flag. For example, to run a script from the command line using the environment in the current directory you can run$ julia --project=. myscript.jl"},{"title":"Temporary environments","page":"4. Working with Environments","location":"environments/#Temporary-environments","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Temporary environments make it easy to start an environment from a blank slate to test a package or set of packages, and have Pkg automatically delete the environment when you're done. For instance, when writing a bug report, you may want to test your minimal reproducible example in a 'clean' environment to ensure it's actually reproducible as written. You might also want a scratch space to try out a new package, or a sandbox to resolve version conflicts between several incompatible packages."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"(@v1.10) pkg> activate --temp # requires Julia 1.5 or later\n  Activating new environment at `/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n\n(jl_a31egx) pkg> add Example\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Manifest.toml`\n  [7876af07] + Example v0.5.3"},{"title":"Shared environments","page":"4. Working with Environments","location":"environments/#Shared-environments","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"A \"shared\" environment is simply an environment that exists in ~/.julia/environments. The default v1.10 environment is therefore a shared environment:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"(@v1.10) pkg> st\nStatus `~/.julia/environments/v1.10/Project.toml`"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Shared environments can be activated with the --shared flag to activate:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"(@v1.10) pkg> activate --shared mysharedenv\n  Activating project at `~/.julia/environments/mysharedenv`\n\n(@mysharedenv) pkg>"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Shared environments have a @ before their name in the Pkg REPL prompt."},{"title":"Environment Precompilation","page":"4. Working with Environments","location":"environments/#Environment-Precompilation","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Before a package can be imported, Julia will \"precompile\" the source code into an intermediate more efficient cache on disc. This precompilation can be triggered via code loading if the un-imported package is new or has changed since the last cache"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"julia> using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"or using Pkg's precompile option, which can precompile the entire environment, or a given dependency, and do so in parallel, which can be significantly faster than the code-load route above."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"(@v1.10) pkg> precompile\nPrecompiling environment...\n  23 dependencies successfully precompiled in 36 seconds"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"However, neither of these should be routinely required thanks to Pkg's automatic precompilation."},{"title":"Automatic Precompilation","page":"4. Working with Environments","location":"environments/#Automatic-Precompilation","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"By default, any package that is added to a project or updated in a Pkg action will be automatically precompiled, along with its dependencies."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"(@v1.10) pkg> add Images\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [916415d5] + Images v0.25.2\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n    ...\nPrecompiling environment...\n  Progress [===================>                     ]  45/97\n  ✓ NaNMath\n  ✓ IntervalSets\n  ◐ CoordinateTransformations\n  ◑ ArnoldiMethod\n  ◑ IntegralArrays\n  ◒ RegionTrees\n  ◐ ChangesOfVariables\n  ◓ PaddedViews"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"The exception is the develop command, which neither builds nor precompiles the package. When that happens is left up to the user to decide."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"If a given package version errors during auto-precompilation, Pkg will remember for the following times it automatically tries and will skip that package with a brief warning. Manual precompilation can be used to force these packages to be retried, as pkg> precompile will always retry all packages."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"The indicators next to the package names displayed during precompilation indicate the status of that package's precompilation."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"[◐, ◓, ◑, ◒] Animated \"clock\" characters indicate that the package is currently being precompiled.\n✓ A green checkmark indicates that the package has been successfully precompiled (after which that package will disappear from the list). If the checkmark is yellow it means that the package is currently loaded so the session will need to be restarted to access the version that was just precompiled.\n? A question mark character indicates that a PrecompilableError was thrown, indicating that precompilation was disallowed, i.e. __precompile__(false) in that package.\n✗ A cross indicates that the package failed to precompile."},{"title":"Controlling Auto-precompilation","page":"4. Working with Environments","location":"environments/#Controlling-Auto-precompilation","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Auto-precompilation can be controlled in several ways:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Environment variable: Set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 to disable auto-precompilation globally.\nProgrammatically: Use Pkg.autoprecompilation_enabled(false) to disable auto-precompilation for the current session, or Pkg.autoprecompilation_enabled(true) to re-enable it.\nScoped control: Use Pkg.precompile(f, args...; kwargs...) to execute a function f with auto-precompilation temporarily disabled, then automatically trigger precompilation afterward if any packages were modified during the execution."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"compat: Julia 1.13\nThe Pkg.autoprecompilation_enabled() function and Pkg.precompile() do-block syntax require at least Julia 1.13."},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"For example, to add multiple packages without triggering precompilation after each one:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"julia> Pkg.precompile() do\n           Pkg.add(\"Example\")\n           Pkg.dev(\"JSON\")\n           Pkg.update(\"HTTP\")\n       end\n   Resolving package versions...\n   ...\nPrecompiling environment...\n  14 dependencies successfully precompiled in 25 seconds"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"Or to temporarily disable auto-precompilation:"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"julia> Pkg.autoprecompilation_enabled(false)\nfalse\n\njulia> Pkg.add(\"Example\")  # No precompilation happens\n   Resolving package versions...\n   ...\n\njulia> Pkg.autoprecompilation_enabled(true)\ntrue"},{"title":"Precompiling new versions of loaded packages","page":"4. Working with Environments","location":"environments/#Precompiling-new-versions-of-loaded-packages","category":"section","text":""},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/","category":"page","text":"If a package that has been updated is already loaded in the session, the precompilation process will go ahead and precompile the new version, and any packages that depend on it, but will note that the package cannot be used until session restart."}]
}
