var documenterSearchIndex = {"docs":
[{"title":"11. Project.toml and Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Project-and-Manifest","category":"section","text":"Two files that are central to Pkg are Project.toml and Manifest.toml. Project.toml\nand Manifest.toml are written in TOML (hence the\n.toml extension) and include information about dependencies, versions, package names,\nUUIDs etc.\n\nnote: Note\nThe Project.toml and Manifest.toml files are not only used by the package manager;\nthey are also used by Julia's code loading, and determine e.g. what using Example\nshould do. For more details see the section about\nCode Loading\nin the Julia manual."},{"title":"Project.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Project.toml","category":"section","text":"The project file describes the project on a high level, for example, the package/project\ndependencies and compatibility constraints are listed in the project file. The file entries\nare described below."},{"title":"The authors field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-authors-field","category":"section","text":"For a package, the optional authors field is a TOML array describing the package authors.\nEntries in the array can either be a string in the form \"NAME\" or \"NAME <EMAIL>\", or a table keys following the Citation File Format schema for either a\nperson or an entity.\n\nFor example:\n\nauthors = [\n  \"Some One <someone@email.com>\",\n  \"Foo Bar <foo@bar.com>\",\n  {given-names = \"Baz\", family-names = \"Qux\", email = \"bazqux@example.com\", orcid = \"https://orcid.org/0000-0000-0000-0000\", website = \"https://github.com/bazqux\"},\n]\n\nIf all authors are specified by tables, it is possible to use the TOML Array of Tables syntax\n\n[[authors]]\ngiven-names = \"Some\"\nfamily-names = \"One\"\nemail = \"someone@email.com\"\n\n[[authors]]\ngiven-names = \"Foo\"\nfamily-names = \"Bar\"\nemail = \"foo@bar.com\"\n\n[[authors]]\ngiven-names = \"Baz\"\nfamily-names = \"Qux\"\nemail = \"bazqux@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0000\"\nwebsite = \"https://github.com/bazqux\""},{"title":"The name field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-name-field","category":"section","text":"The name of the package/project is determined by the name field, for example:\n\nname = \"Example\"\n\nThe name must be a valid identifier\n(a sequence of Unicode characters that does not start with a number and is neither true nor false).\nFor packages, it is recommended to follow the\npackage naming rules. The name field is mandatory\nfor packages."},{"title":"The uuid field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-uuid-field","category":"section","text":"uuid is a string with a [universally unique identifier]\n(https://en.wikipedia.org/wiki/Universallyuniqueidentifier) for the package/project, for example:\n\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\nThe uuid field is mandatory for packages.\n\nnote: Note\nIt is recommended that UUIDs.uuid4() is used to generate random UUIDs."},{"title":"Why UUIDs are important","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Why-UUIDs-are-important","category":"section","text":"UUIDs serve several critical purposes in the Julia package ecosystem:\n\nUnique identification: UUIDs uniquely identify packages across all registries and repositories, preventing naming conflicts. Two different packages can have the same name (e.g., in different registries), but their UUIDs will always be different.\nMultiple registries: UUIDs enable the use of multiple package registries (including private registries) without conflicts, as each package is uniquely identified by its UUID regardless of which registry it comes from."},{"title":"The version field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-version-field","category":"section","text":"version is a string with the version number for the package/project. It should consist of\nthree numbers, major version, minor version, and patch number, separated with a ., for example:\n\nversion = \"1.2.5\"\n\nJulia uses Semantic Versioning (SemVer) and the version field\nshould follow SemVer. The basic rules are:\n\nBefore 1.0.0, anything goes, but when you make breaking changes the minor version should\nbe incremented.\nAfter 1.0.0 only make breaking changes when incrementing the major version.\nAfter 1.0.0 no new public API should be added without incrementing the minor version.\nThis includes, in particular, new types, functions, methods, and method overloads, from\nBase or other packages.\n\nSee also the section on Compatibility.\n\nNote that Pkg.jl deviates from the SemVer specification when it comes to versions pre-1.0.0. See\nthe section on pre-1.0 behavior for more details."},{"title":"The readonly field","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-readonly-field","category":"section","text":"The readonly field is a boolean that, when set to true, marks the environment as read-only. This prevents any modifications to the environment, including adding, removing, or updating packages. For example:\n\nreadonly = true\n\nWhen an environment is marked as readonly, Pkg will throw an error if any operation that would modify the environment is attempted.\nIf the readonly field is not present or set to false (the default), the environment can be modified normally.\n\nYou can also programmatically check and modify the readonly state using the Pkg.readonly function:\n\n# Check if current environment is readonly\nis_readonly = Pkg.readonly()\n\n# Enable readonly mode\nprevious_state = Pkg.readonly(true)\n\n# Disable readonly mode\nPkg.readonly(false)\n\nWhen readonly mode is enabled, the status display will show (readonly) next to the project name to indicate the environment is protected from modifications."},{"title":"The [deps] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[deps]-section","category":"section","text":"All dependencies of the package/project are listed in the [deps] section. Each dependency\nis listed as a name-uuid pair, for example:\n\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\nTypically it is not needed to manually add entries to the [deps] section; this is instead\nhandled by Pkg operations such as add."},{"title":"The [sources] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#sources-section","category":"section","text":"Specifying a path or repo (+ branch) for a dependency is done in the [sources] section.\nThese are especially useful for controlling unregistered dependencies without having to bundle a\ncorresponding manifest file.\n\nEach entry in the [sources] section supports the following keys:\n\nurl: The URL of the Git repository. Cannot be used with path.\nrev: The Git revision (branch name, tag, or commit hash) to use. Only valid with url.\nsubdir: A subdirectory within the repository containing the package.\npath: A local filesystem path to the package. Cannot be used with url or rev. This will dev the package.\n\nThis might in practice look something like:\n\n[sources]\nExample = {url = \"https://github.com/JuliaLang/Example.jl\", rev = \"custom_branch\"}\nWithinMonorepo = {url = \"https://github.org/author/BigProject\", subdir = \"SubPackage\"}\nSomeDependency = {path = \"deps/SomeDependency.jl\"}"},{"title":"When [sources] entries are used","page":"11. Project.toml and Manifest.toml","location":"toml-files/#When-[sources]-entries-are-used","category":"section","text":"Sources are read and applied in the following situations:\n\nActive environment: When resolving dependencies for the currently active environment, sources from the environment's Project.toml override registry information for direct dependencies.\nAutomatic addition: When you add a package by URL (e.g., pkg> add https://github.com/...) or develop a package (e.g., pkg> dev Example), Pkg automatically adds an entry to [sources] for that package in your active environment's Project.toml.\nRecursive collection: When a package is added by URL or path, Pkg recursively collects [sources] entries from that package's dependencies. This allows private dependency chains to resolve without registry metadata. For example:\nIf you add Package A by URL, and Package A has a [sources] entry for Package B\nAnd Package B (also specified by URL in A's sources) has a [sources] entry for Package C\nThen all three packages' source information will be collected and used during resolution\n\nThis recursive behavior is particularly useful for managing chains of unregistered or private packages.\n\nnote: Scope of sources\nSources are only used when the environment containing them is the active environment being resolved. If a package is used as a dependency in another project, its [sources] section is not consulted (except when that package itself was added by URL or path, in which case recursive collection applies as described above).\n\ntip: Test-specific dependencies\nA use case for [sources] with path is in test/Project.toml to reference the parent package using path = \"..\". This allows test dependencies to be managed independently with their own manifest file. See Test-specific dependencies for more details on this and other approaches.\n\ncompat: Compat\nSpecifying sources requires Julia 1.11+."},{"title":"The [weakdeps] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[weakdeps]-section","category":"section","text":"Weak dependencies are optional dependencies that will not automatically install when the package is installed,\nbut for which you can still specify compatibility constraints. Weak dependencies are typically used in conjunction\nwith package extensions (see [extensions] below), which allow conditional loading of code\nwhen the weak dependency is available in the environment.\n\nExample:\n\n[weakdeps]\nSomePackage = \"b3785f31-9d33-4cdf-bc73-f646780f1739\"\n\n[compat]\nSomePackage = \"1.2\"\n\nFor more details on using weak dependencies and extensions, see the\nWeak dependencies section in the Creating Packages guide.\n\ncompat: Compat\nWeak dependencies require Julia 1.9+."},{"title":"The [extensions] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#extensions-section","category":"section","text":"Extensions allow packages to provide optional functionality that is only loaded when certain other packages\n(typically listed in [weakdeps]) are available. Each entry in the [extensions] section maps an extension\nname to one or more package dependencies required to load that extension.\n\nExample:\n\n[weakdeps]\nContour = \"d38c429a-6771-53c6-b99e-75d170b6e991\"\n\n[extensions]\nContourExt = \"Contour\"\n\nThe extension code itself should be placed in an ext/ directory at the package root, with the file name\nmatching the extension name (e.g., ext/ContourExt.jl). For more details on creating and using extensions,\nsee the Conditional loading of code in packages (Extensions) section in the Creating Packages guide.\n\ncompat: Compat\nExtensions require Julia 1.9+."},{"title":"The [compat] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[compat]-section","category":"section","text":"Compatibility constraints for dependencies can be listed in the [compat] section. This applies to\npackages listed under [deps], [weakdeps], and [extras].\n\nExample:\n\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]\nExample = \"1.2\"\n\nThe Compatibility section describes the different possible compatibility\nconstraints in detail. It is also possible to list constraints on julia itself, although\njulia is not listed as a dependency in the [deps] section:\n\n[compat]\njulia = \"1.1\""},{"title":"The [workspace] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Workspaces","category":"section","text":"A project file can define a workspace by giving a set of projects that is part of that workspace.\nEach project in a workspace can include their own dependencies, compatibility information, and even function as full packages.\n\nWhen the package manager resolves dependencies, it considers the requirements of all the projects in the workspace. The compatible versions identified during this process are recorded in a single manifest file located next to the base project file.\n\nA workspace is defined in the base project by giving a list of the projects in it:\n\n[workspace]\nprojects = [\"test\", \"docs\", \"benchmarks\", \"PrivatePackage\"]\n\nThis structure is particularly beneficial for developers using a monorepo approach, where a large number of unregistered packages may be involved. It's also useful for adding test-specific dependencies to a package by including a test project in the workspace (see Test-specific dependencies), or for adding documentation or benchmarks with their own dependencies.\n\nWorkspace can be nested: a project that itself defines a workspace can also be part of another workspace.\nIn this case, the workspaces are \"merged\" with a single manifest being stored alongside the \"root project\" (the project that doesn't have another workspace including it)."},{"title":"The [extras] section (legacy)","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[extras]-section-(legacy)","category":"section","text":"warning: Warning\nThe [extras] section is a legacy feature maintained for compatibility. For Julia 1.13+,\nusing workspaces is the recommended approach for managing test-specific\nand other optional dependencies.\n\nThe [extras] section lists additional dependencies that are not regular dependencies of the package,\nbut may be used in specific contexts like testing. These are typically used in conjunction with the\n[targets] section.\n\nExample:\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\n\nFor more information, see the Test-specific dependencies section."},{"title":"The [targets] section (legacy)","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[targets]-section-(legacy)","category":"section","text":"warning: Warning\nThe [targets] section is a legacy feature maintained for compatibility. For Julia 1.13+,\nusing workspaces is the recommended approach for managing test-specific\nand build dependencies.\n\nThe [targets] section specifies which packages from [extras] should be available in specific\ncontexts. The only supported targets are test (for test dependencies) and build (for build-time\ndependencies used by deps/build.jl scripts).\n\nExample:\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\n\n[targets]\ntest = [\"Test\", \"Markdown\"]\n\nFor more information, see the Test-specific dependencies section."},{"title":"Manifest.toml","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Manifest.toml","category":"section","text":"The manifest file is an absolute record of the state of the packages in the environment.\nIt includes exact information about (direct and indirect) dependencies of the project.\nGiven a Project.toml + Manifest.toml pair, it is possible to instantiate the exact same\npackage environment, which is very useful for reproducibility.\nFor the details, see Pkg.instantiate.\n\nnote: Note\nThe Manifest.toml file is generated and maintained by Pkg and, in general, this file\nshould never be modified manually."},{"title":"Different Manifests for Different Julia versions","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Different-Manifests-for-Different-Julia-versions","category":"section","text":"Starting from Julia v1.10.8, there is an option to name manifest files in the format Manifest-v{major}.{minor}.toml.\nJulia will then preferentially use the version-specific manifest file if available.\nFor example, if both Manifest-v1.11.toml and Manifest.toml exist, Julia 1.11 will prioritize using Manifest-v1.11.toml.\nHowever, Julia versions 1.10, 1.12, and all others will default to using Manifest.toml.\nThis feature allows for easier management of different instantiated versions of dependencies for various Julia versions.\nNote that there can only be one Project.toml file. While Manifest-v{major}.{minor}.toml files are not automatically\ncreated by Pkg, users can manually rename a Manifest.toml file to match\nthe versioned format, and Pkg will subsequently maintain it through its operations."},{"title":"Manifest.toml entries","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Manifest.toml-entries","category":"section","text":"There are three top-level entries in the manifest which could look like this:\n\njulia_version = \"1.8.2\"\nmanifest_format = \"2.0\"\nproject_hash = \"4d9d5b552a1236d3c1171abf88d59da3aaac328a\"\n\nThis shows the Julia version the manifest was created on, the \"format\" of the manifest\nand a hash of the project file, so that it is possible to see when the manifest is stale\ncompared to the project file."},{"title":"Manifest format versions","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Manifest-format-versions","category":"section","text":"The manifest_format field indicates the structure version of the manifest file:\n\n\"2.0\": The standard format for Julia 1.7+\n\"2.1\": The current format (requires Julia 1.13+). This format introduced registry tracking in the [registries] section."},{"title":"The [registries] section","page":"11. Project.toml and Manifest.toml","location":"toml-files/#The-[registries]-section","category":"section","text":"compat: Compat\nRegistry tracking in manifests requires Julia 1.13+ and manifest format \"2.1\".\n\nStarting with manifest format 2.1, the manifest can include a [registries] section that tracks\nmetadata about the registries from which packages were obtained. This ensures that the exact source\nof each package version can be identified, which is particularly important when using multiple\nregistries or private registries.\n\nEach registry entry in the manifest looks like this:\n\n[registries.General]\nuuid = \"23338594-aafe-5451-b93e-139f81909106\"\nurl = \"https://github.com/JuliaRegistries/General.git\"\n\nThe registry entries include:\n\nuuid (required): The unique identifier for the registry.\nurl (optional): The URL where the registry can be found. This enables automatic installation\nof registries when instantiating an environment on a new machine.\n\nThe section key (e.g., General in the example above) is the registry name."},{"title":"Package entries","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Package-entries","category":"section","text":"Each dependency has its own section in the manifest file, and its content varies depending\non how the dependency was added to the environment. Every\ndependency section includes a combination of the following entries:\n\nuuid: the UUID\nfor the dependency, for example uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\".\ndeps: a vector listing the dependencies of the dependency, for example\ndeps = [\"Example\", \"JSON\"].\nversion: a version number, for example version = \"1.2.6\".\npath: a file path to the source code, for example path = /home/user/Example.\nrepo-url: a URL to the repository where the source code was found,\nfor example repo-url = \"https://github.com/JuliaLang/Example.jl.git\".\nrepo-rev: a git revision, for example a branch repo-rev = \"master\"\nor a commit repo-rev = \"66607a62a83cb07ab18c0b35c038fcd62987c9b1\".\ngit-tree-sha1: a content hash of the source tree, for example\ngit-tree-sha1 = \"ca3820cc4e66f473467d912c4b2b3ae5dc968444\".\nregistries: a reference to the registry IDs from which this package version was obtained. This can be either\na single string (e.g., registries = \"General\") or a vector of strings if the package is available in multiple\nregistries (e.g., registries = [\"General\", \"MyRegistry\"]). All registries containing this package version\nare recorded. This field is only present in manifest format 2.1 or later, and only for packages that were\nadded from a registry (not for developed or git-tracked packages)."},{"title":"Added package","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Added-package","category":"section","text":"When a package is added from a package registry, for example by invoking pkg> add Example\nor with a specific version pkg> add Example@1.2, the resulting Manifest.toml entry looks\nlike:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.3\"\nregistries = \"General\"\n\nNote, in particular, that no repo-url is present, since that information is included in\nthe registry where this package was found. The registries field (present in manifest format 2.1+)\nreferences an entry in the [registries] section that contains the registry metadata."},{"title":"Added package by branch","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Added-package-by-branch","category":"section","text":"The resulting dependency section when adding a package specified by a branch, e.g.\npkg> add Example#master or pkg> add https://github.com/JuliaLang/Example.jl.git,\nlooks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"master\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nNote that both the branch we are tracking (master) and the remote repository url\n(\"https://github.com/JuliaLang/Example.jl.git\") are stored in the manifest."},{"title":"Added package by commit","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Added-package-by-commit","category":"section","text":"The resulting dependency section when adding a package specified by a commit, e.g.\npkg> add Example#cf6ba6cc0be0bb5f56840188563579d67048be34, looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"cf6ba6cc0be0bb5f56840188563579d67048be34\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nThe only difference from tracking a branch is the content of repo-rev."},{"title":"Developed package","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Developed-package","category":"section","text":"The resulting dependency section when adding a package with develop,\ne.g. pkg> develop Example or pkg> develop /path/to/local/folder/Example,\nlooks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\npath = \"/home/user/.julia/dev/Example/\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nNote that the path to the source code is included, and changes made to that\nsource tree is directly reflected."},{"title":"Pinned package","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Pinned-package","category":"section","text":"Pinned packages are also recorded in the manifest file; the resulting\ndependency section e.g. pkg> add Example; pin Example looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\npinned = true\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nThe only difference is the addition of the pinned = true entry."},{"title":"Multiple packages with the same name","page":"11. Project.toml and Manifest.toml","location":"toml-files/#Multiple-packages-with-the-same-name","category":"section","text":"Julia differentiates packages based on UUID, which means that the name alone is not enough\nto identify a package. It is possible to have multiple packages in the same environment\nwith the same name, but with different UUID. In such a situation the Manifest.toml file\nlooks a bit different. Consider for example the situation where you have added A and B\nto your environment, and the Project.toml file looks as follows:\n\n[deps]\nA = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\nB = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"\n\nIf A now depends on B = \"f41f7b98-334e-11e9-1257-49272045fb24\", i.e. another package\nnamed B there will be two different B packages in the Manifest.toml file. In this\ncase, the full Manifest.toml file, with git-tree-sha1 and version fields removed for\nclarity, looks like this:\n\n[[deps.A]]\nuuid = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\n\n    [deps.A.deps]\n    B = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n\n[[deps.B]]\nuuid = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n[[deps.B]]\nuuid = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"\n\nThere is now an array of the two B packages, and the [deps] section for A has been\nexpanded to be explicit about which B package A depends on."},{"title":"3. Managing Packages","page":"3. Managing Packages","location":"managing-packages/#Managing-Packages","category":"section","text":""},{"title":"Adding packages","page":"3. Managing Packages","location":"managing-packages/#Adding-packages","category":"section","text":"There are two ways of adding packages, either using the add command or the dev command.\nThe most frequently used is add and its usage is described first."},{"title":"Adding registered packages","page":"3. Managing Packages","location":"managing-packages/#Adding-registered-packages","category":"section","text":"In the Pkg REPL, packages can be added with the add command followed by the name of the package, for example:\n\n(@v1.13) pkg> add JSON\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.13/Project.toml`\n  [682c06a0] + JSON v0.21.4\n    Updating `~/.julia/environments/v1.13/Manifest.toml`\n  [682c06a0] + JSON v0.21.4\n  [69de0a69] + Parsers v2.8.3\n  [aea7be01] + PrecompileTools v1.3.2\n  [21216c6a] + Preferences v1.5.0\n  [ade2ca70] + Dates v1.11.0\n  [a63ad114] + Mmap v1.11.0\n  [de0858da] + Printf v1.11.0\n  [9a3f8284] + Random v1.11.0\n  [ea8e919c] + SHA v0.7.0\n  [fa267f1f] + TOML v1.0.3\n  [cf7118a7] + UUIDs v1.11.0\n  [4ec0a83e] + Unicode v1.11.0\n\nHere we added the package JSON to the current environment (which is the default @v1.10 environment).\nIn this example, we are using a fresh Julia installation,\nand this is our first time adding a package using Pkg. By default, Pkg installs the General registry\nand uses this registry to look up packages requested for inclusion in the current environment.\nThe status update shows a short form of the package UUID to the left, then the package name, and the version.\nFinally, the newly installed packages are \"precompiled\".\n\nIt is possible to add multiple packages in one command as pkg> add A B C.\n\nThe status output contains the packages you have added yourself, in this case, JSON:\n\n(@v1.13) pkg> st\nStatus `~/.julia/environments/v1.13/Project.toml`\n  [682c06a0] JSON v0.21.4\n\nThe manifest status shows all the packages in the environment, including recursive dependencies:\n\n(@v1.13) pkg> st -m\nStatus `~/.julia/environments/v1.13/Manifest.toml`\n  [682c06a0] JSON v0.21.4\n  [69de0a69] Parsers v2.8.3\n  [aea7be01] PrecompileTools v1.3.2\n  [21216c6a] Preferences v1.5.0\n  [ade2ca70] Dates v1.11.0\n  [a63ad114] Mmap v1.11.0\n  [de0858da] Printf v1.11.0\n  [9a3f8284] Random v1.11.0\n  [ea8e919c] SHA v0.7.0\n  [fa267f1f] TOML v1.0.3\n  [cf7118a7] UUIDs v1.11.0\n  [4ec0a83e] Unicode v1.11.0\n\nNote that before 1.11 standard libraries (e.g. Dates) did not have dedicated version numbers.\n\nTo specify that you want a particular version (or set of versions) of a package, use the compat command. For example,\nto require any patch release of the v0.21 series of JSON after v0.21.4, call compat JSON 0.21.4:\n\n(@v1.10) pkg> compat JSON 0.21.4\n      Compat entry set:\n  JSON = \"0.21.4\"\n     Resolve checking for compliance with the new compat rules...\n       Error empty intersection between JSON@0.21.3 and project compatibility 0.21.4 - 0.21\n  Suggestion Call `update` to attempt to meet the compatibility requirements.\n\n(@v1.10) pkg> update\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\n\nSee the section on Compatibility for more on using the compat system.\n\nAfter a package is added to the project, it can be loaded in Julia:\n\njulia> using JSON\n\njulia> JSON.json(Dict(\"foo\" => [1, \"bar\"])) |> print\n{\"foo\":[1,\"bar\"]}\n\nnote: Note\nOnly packages that have been added with add can be loaded (which are packages that are shown when using st in the Pkg REPL). Packages that are pulled in only as dependencies (for example the Parsers package above) can not be loaded.\n\nA specific version of a package can be installed by appending a version after a @ symbol to the package name:\n\n(@v1.10) pkg> add JSON@0.21.1\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n⌃ [682c06a0] + JSON v0.21.1\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n⌃ [682c06a0] + JSON v0.21.1\n⌅ [69de0a69] + Parsers v1.1.2\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`\n\nAs seen above, Pkg gives some information when a package is not installed at its latest version.\n\nIf not all three numbers are given for the version, for example, 0.21, then the latest registered version of 0.21.x would be installed.\n\nIf a branch (or a certain commit) of Example has a hotfix that is not yet included in a registered version,\nwe can explicitly track that branch (or commit) by appending #branchname (or #commitSHA1) to the package name:\n\n(@v1.10) pkg> add Example#master\n     Cloning git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n\nThe status output now shows that we are tracking the master branch of Example.\nWhen updating packages, updates are pulled from that branch.\n\nnote: Note\nIf we would specify a commit id instead of a branch name, e.g.\nadd Example#025cf7e, then we would effectively \"pin\" the package\nto that commit. This is because the commit id always points to the same\nthing unlike a branch, which may be updated.\n\nTo go back to tracking the registry version of Example, the command free is used:\n\n(@v1.10) pkg> free Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3"},{"title":"Adding unregistered packages","page":"3. Managing Packages","location":"managing-packages/#Adding-unregistered-packages","category":"section","text":"If a package is not in a registry, it can be added by specifying a URL to the Git repository:\n\n(@v1.10) pkg> add https://github.com/fredrikekre/ImportMacros.jl\n     Cloning git-repo `https://github.com/fredrikekre/ImportMacros.jl`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n\nThe dependencies of the unregistered package (here MacroTools) got installed.\nFor unregistered packages, we could have given a branch name (or commit SHA1) to track using #, just like for registered packages.\n\nIf you want to add a package using the SSH-based git protocol, you have to use quotes because the URL contains a @. For example,\n\n(@v1.10) pkg> add \"git@github.com:fredrikekre/ImportMacros.jl.git\"\n    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nUpdating `~/.julia/environments/v1/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\nUpdating `~/.julia/environments/v1/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`"},{"title":"Adding a package in a subdirectory of a repository","page":"3. Managing Packages","location":"managing-packages/#Adding-a-package-in-a-subdirectory-of-a-repository","category":"section","text":"If the package you want to add by URL is not in the root of the repository, then you need pass that subdirectory using :.\nFor instance, to add the SnoopCompileCore package in the SnoopCompile\nrepository:\n\npkg> add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore\n    Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n  [9e88b42a] + Serialization"},{"title":"Adding a local package","page":"3. Managing Packages","location":"managing-packages/#Adding-a-local-package","category":"section","text":"Instead of giving a URL of a git repo to add we could instead have given a local path to a git repo.\nThis works similar to adding a URL. The local repository will be tracked (at some branch) and updates\nfrom that local repo are pulled when packages are updated.\n\nwarning: Warning\nNote that tracking a package through add is distinct from\ndevelop (which is described in the next section). When using add on a local\ngit repository, changes to files in the local package repository will not\nimmediately be reflected when loading that package. The changes would have to be\ncommitted and the packages updated in order to pull in the changes. In the\nmajority of cases, you want to use develop on a local path, not add."},{"title":"Developing packages","page":"3. Managing Packages","location":"managing-packages/#developing","category":"section","text":"By only using add your environment always has a \"reproducible state\", in other words, as long as the repositories and registries used are still accessible\nit is possible to retrieve the exact state of all the dependencies in the environment. This has the advantage that you can send your environment (Project.toml\nand Manifest.toml) to someone else and they can Pkg.instantiate that environment in the same state as you had it locally.\nHowever, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the dev command exists.\n\nLet's try to dev a registered package:\n\n(@v1.10) pkg> dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n\nThe dev command fetches a full clone of the package to ~/.julia/dev/ (the path can be changed by setting the environment variable JULIA_PKG_DEVDIR, the default being joinpath(DEPOT_PATH[1],\"dev\")).\nWhen importing Example julia will now import it from ~/.julia/dev/Example and whatever local changes have been made to the files in that path are consequently\nreflected in the code loaded. When we used add we said that we tracked the package repository; we here say that we track the path itself.\nNote the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches, etc.\nIf we try to dev a package at some branch that already exists at ~/.julia/dev/ the package manager will simply re-use the existing path.\nIf dev is used on a local path, that path to that package is recorded and used when loading that package.\nThe path will be recorded relative to the project file, unless it is given as an absolute path.\n\nLet's try modify the file at  ~/.julia/dev/Example/src/Example.jl and add a simple function:\n\nplusone(x::Int) = x + 1\n\nNow we can go back to the Julia REPL and load the package and run the new function:\n\njulia> import Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\njulia> Example.plusone(1)\n2\n\nwarning: Warning\nA package can only be loaded once per Julia session.\nIf you have run import Example in the current Julia session, you will\nhave to restart Julia to see the changes to Example.\nRevise.jl can make this process\nsignificantly more pleasant, but setting it up is beyond the scope of this guide.\n\nTo stop tracking a path and use the registered version again, use free:\n\n(@v1.10) pkg> free Example\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n\nIt should be pointed out that by using dev your project is now inherently stateful.\nIts state depends on the current content of the files at the path and the manifest cannot be \"instantiated\" by someone else without\nknowing the exact content of all the packages that are tracking a path.\n\nNote that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become\nout of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded\nin the Manifest. To synchronize the Manifest, use the REPL command resolve.\n\nIn addition to absolute paths, add and dev can accept relative paths to packages.\nIn this case, the relative path from the active project to the package is stored.\nThis approach is useful when the relative location of tracked dependencies is more important than their absolute location.\nFor example, the tracked dependencies can be stored inside of the active project directory.\nThe whole directory can be moved and Pkg will still be able to find the dependencies\nbecause their path relative to the active project is preserved even though their absolute path has changed."},{"title":"Removing packages","page":"3. Managing Packages","location":"managing-packages/#Removing-packages","category":"section","text":"Packages can be removed from the current project by using pkg> rm Package.\nThis will only remove packages that exist in the project; to remove a package that only\nexists as a dependency use pkg> rm --manifest DepPackage.\nNote that this will remove all packages that (recursively) depend on DepPackage."},{"title":"Updating packages","page":"3. Managing Packages","location":"managing-packages/#updating","category":"section","text":"When new versions of packages are released, it is a good idea to update. Simply calling up will try to update all the dependencies of the project\nto the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to up, e.g:\n\n(@v1.10) pkg> up Example\n\nThis will only allow Example do upgrade. If you also want to allow dependencies of Example to upgrade (with the exception of packages that are in the project) you can pass the --preserve=direct flag.\n\n(@v1.10) pkg> up --preserve=direct Example\n\nAnd if you also want to allow dependencies of Example that are also in the project to upgrade, you can use --preserve=none:\n\n(@v1.10) pkg> up --preserve=none Example"},{"title":"Pinning a package","page":"3. Managing Packages","location":"managing-packages/#Pinning-a-package","category":"section","text":"A pinned package will never be updated. A package can be pinned using pin, for example:\n\n(@v1.10) pkg> pin Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n\nNote the pin symbol ⚲ showing that the package is pinned. Removing the pin is done using free\n\n(@v1.10) pkg> free Example\n  Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3"},{"title":"Testing packages","page":"3. Managing Packages","location":"managing-packages/#Testing-packages","category":"section","text":"The tests for a package can be run using test command:\n\n(@v1.10) pkg> test Example\n...\n   Testing Example\n   Testing Example tests passed"},{"title":"Building packages","page":"3. Managing Packages","location":"managing-packages/#Building-packages","category":"section","text":"The build step of a package is automatically run when a package is first installed.\nThe output of the build process is directed to a file.\nTo explicitly run the build step for a package, the build command is used:\n\n(@v1.10) pkg> build IJulia\n    Building Conda ─→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/6e47d11ea2776bc5627421d59cdcc1296c058071/build.log`\n    Building IJulia → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log`\n\njulia> print(read(joinpath(homedir(), \".julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log\"), String))\n[ Info: Installing Julia kernelspec in /home/kc/.local/share/jupyter/kernels/julia-1.8"},{"title":"Interpreting and resolving version conflicts","page":"3. Managing Packages","location":"managing-packages/#conflicts","category":"section","text":"An environment consists of a set of mutually-compatible packages.\nSometimes, you can find yourself in a situation in which two packages you'd like to use simultaneously\nhave incompatible requirements.\nIn such cases you'll get an \"Unsatisfiable requirements\" error:\n\nprint(\"pkg> add A\\n\", try resolve_tst(deps_data, reqs_data) catch e sprint(showerror, e) end)   # hide\n\nThis message means that a package named D has a version conflict.\nEven if you have never added D directly, this kind of error can arise\nif D is required by other packages that you are trying to use.\n\nnote: Note\nWhen tackling these conflicts, first consider that the bigger a project gets, the more likely this is to happen.\nUsing targeted projects for a given task is highly recommended, and removing unused dependencies is a good first\nstep when hitting these issues.\nFor instance, a common pitfall is having more than a few packages in your default (i.e. (@1.8)) environment,\nand using that as an environment for all tasks you're using julia for. It's better to create a dedicated project\nfor the task you're working on, and keep the dependencies there minimal. To read more see\nWorking with Environments\n\nThe error message has a lot of crucial information.\nIt may be easiest to interpret piecewise:\n\nUnsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled\n\nmeans that D has three released versions, v0.1.0, v0.2.0, and v0.2.1.\nYou also have the option of not having it installed at all.\nEach of these options might have different implications for the set of other packages that can be installed.\n\nCrucially, notice the stroke characters (vertical and horizontal lines) and their indentation.\nTogether, these connect messages to specific packages.\nFor instance the right stroke of ├─ indicates that the message to its right (possible versions...)\nis connected to the package pointed to by its vertical stroke (D).\nThis same principle applies to the next line:\n\n ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0\n\nThe vertical stroke here is also aligned under D, and thus this message\nis in reference to D.\nSpecifically, there's some other package B that depends on version v0.1.0 of D.\nNotice that this is not the newest version of D.\n\nNext comes some information about B:\n\n │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0\n\nThe two lines below the first have a vertical stroke that aligns with B,\nand thus they provide information about B.\nThey tell you that B has just one release, v1.0.0.\nYou've not specified a particular version of B (restricted to versions * means that any version will do),\nbut the explicit requirement means that you've asked for B to be part of your environment,\nfor example by pkg> add B.\nYou might have asked for B previously, and the requirement is still active.\n\nThe conflict becomes clear with the line\n\n└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left\n\nHere again, the vertical stroke aligns with D: this means that D is also required by another package, C.\nC requires v0.2.0 of D, and this conflicts with B's need for v0.1.0 of D.\nThis explains the conflict.\n\nBut wait, you might ask, what is C and why do I need it at all?\nThe next few lines introduce the problem:\n\n   └─C [c99a7cb2] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0\n\nThese provide more information about C, revealing that it has 3 released versions: v0.1.0, v0.1.1, and v0.2.0.\nMoreover, C is required by another package A.\nIndeed, A's requirements are such that we need v0.2.0 of C.\nA's origin is revealed on the next lines:\n\n       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0\n\nSo we can see that A was explicitly required, and in this case, it's because we were trying to\nadd it to our environment.\n\nIn summary, we explicitly asked to use A and B, but this gave a conflict for D.\nThe reason was that B and C require conflicting versions of D.\nEven though C isn't something we asked for explicitly, it was needed by A.\n\nTo fix such errors, you have a number of options:\n\ntry updating your packages. It's possible the developers of these packages have recently released new versions that are mutually compatible.\nremove either A or B from your environment. Perhaps B is left over from something you were previously working on, and you don't need it anymore. If you don't need A and B at the same time, this is the easiest way to fix the problem.\ntry reporting your conflict. In this case, we were able to deduce that B requires an outdated version of D. You could thus report an issue in the development repository of B.jl asking for an updated version.\ntry fixing the problem yourself.\nThis becomes easier once you understand Project.toml files and how they declare their compatibility requirements. We'll return to this example in Fixing conflicts."},{"title":"Yanked packages","page":"3. Managing Packages","location":"managing-packages/#Yanked-packages","category":"section","text":"Package registries can mark specific versions of packages as \"yanked\". A yanked package version\nis one that should no longer be used, typically because it contains serious bugs, security\nvulnerabilities, or other critical issues. When a package version is yanked, it becomes\nunavailable for new installations but remains accessible (i.e. via instantiate) to maintain reproducibility\nof existing environments.\n\nWhen you run pkg> status, yanked packages are clearly marked with a warning symbol:\n\n(@v1.13) pkg> status\n    Status `~/.julia/environments/v1.13/Project.toml`\n  [682c06a0] JSON v0.21.3\n  [f4259836] Example v1.2.0 [yanked]\n\nThe [yanked] annotation indicate that version v1.2.0 of the Example package\nhas been yanked and should be updated or replaced.\n\nWhen resolving dependencies, Pkg will warn you if yanked packages are present and may provide\nguidance on how to resolve the situation. It's important to address yanked packages promptly\nto ensure the security and stability of your Julia environment."},{"title":"Garbage collecting old, unused packages","page":"3. Managing Packages","location":"managing-packages/#Garbage-collecting-old,-unused-packages","category":"section","text":"As packages are updated and projects are deleted, installed package versions and artifacts that were\nonce used will inevitably become old and not used from any existing project.\nPkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist\nand what packages/artifacts those projects used.\nIf a package or artifact is not marked as used by any project, it is added to a list of orphaned packages.\nPackages and artifacts that are in the orphan list for 30 days without being used again are deleted from the system on the next garbage collection.\nThis timing is configurable via the collect_delay keyword argument to Pkg.gc().\nA value of 0 will cause anything currently not in use to be collected immediately, skipping the orphans list entirely;\nIf you are short on disk space and want to clean out as many unused packages and artifacts as possible, you may want to try this, but if you need these versions again, you will have to download them again.\nTo run a typical garbage collection with default arguments, simply use the gc command at the pkg> REPL:\n\n(@v1.10) pkg> gc\n    Active manifests at:\n        `~/BinaryProvider/Manifest.toml`\n        ...\n        `~/Compat.jl/Manifest.toml`\n    Active artifacts:\n        `~/src/MyProject/Artifacts.toml`\n\n    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\n    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB\n   ...\n   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)\n   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)\n\n   Deleted 36 package installations (113.205 MiB)\n   Deleted 15 artifact installations (20.759 GiB)\n\nNote that only packages in ~/.julia/packages are deleted."},{"title":"Offline Mode","page":"3. Managing Packages","location":"managing-packages/#Offline-Mode","category":"section","text":"In offline mode, Pkg tries to do as much as possible without connecting\nto internet. For example, when adding a package Pkg only considers\nversions that are already downloaded in version resolution.\n\nTo work in offline mode use import Pkg; Pkg.offline(true) or set the environment\nvariable JULIA_PKG_OFFLINE to \"true\"."},{"title":"Pkg client/server","page":"3. Managing Packages","location":"managing-packages/#Pkg-client/server","category":"section","text":"When you add a new registered package, usually three things would happen:\n\nupdate registries,\ndownload the source code of the package,\nif not available, download artifacts required by the package.\n\nThe General registry and most packages in it are\ndeveloped on GitHub, while the artifacts data are hosted on various platforms. When the network\nconnection to GitHub and AWS S3 is not stable, it is usually not a good experience to install or\nupdate packages. Fortunately, the pkg client/server feature improves the experience in the sense that:\n\nIf set, the pkg client would first try to download data from the pkg server,\nif that fails, then it falls back to downloading from the original sources (e.g., GitHub).\n\nBy default, the client makes upto 8 concurrent requests to the server. This can set by the environment variable JULIA_PKG_CONCURRENT_DOWNLOADS.\n\nSince Julia 1.5, https://pkg.julialang.org provided by the JuliaLang organization is used as the default\npkg server. In most cases, this should be transparent, but users can still set/unset a pkg server\nupstream via the environment variable JULIA_PKG_SERVER.\n\n# manually set it to some pkg server\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"pkg.julialang.org\"\n\"pkg.julialang.org\"\n\n# unset to always download data from original sources\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"\"\n\"\"\n\nFor clarification, some sources are not provided by Pkg server\n\npackages/registries fetched via git\n]add https://github.com/JuliaLang/Example.jl.git\n]add Example#v0.5.3 (Note that this is different from ]add Example@0.5.3)\n]registry add https://github.com/JuliaRegistries/General.git, including registries installed by Julia before 1.4.\nartifacts without download info\nTestImages\n\nnote: Note\nIf you have a new registry installed via pkg server, then it's impossible for old Julia versions to\nupdate the registry because Julia before 1.4 doesn't know how to fetch new data.\nHence, for users that frequently switch between multiple Julia versions, it is recommended to\nstill use git-controlled registries.\n\nFor the deployment of pkg server, please refer to PkgServer.jl."},{"title":"5. Creating Packages","page":"5. Creating Packages","location":"creating-packages/#creating-packages-tutorial","category":"section","text":""},{"title":"Generating files for a package","page":"5. Creating Packages","location":"creating-packages/#Generating-files-for-a-package","category":"section","text":"note: Note\nThe PkgTemplates package offers an easy, repeatable, and\ncustomizable way to generate the files for a new package. It can also generate files needed for Documentation, CI, etc.\nWe recommend that you use PkgTemplates for creating\nnew packages instead of using the minimal pkg> generate functionality described below.\n\nTo generate the bare minimum files for a new package, use pkg> generate.\n\n(@v1.10) pkg> generate HelloWorld\n\nThis creates a new project HelloWorld in a subdirectory by the same name, with the following files (visualized with the external tree command):\n\nshell> tree HelloWorld/\nHelloWorld/\n├── Project.toml\n└── src\n    └── HelloWorld.jl\n\n2 directories, 2 files\n\nThe Project.toml file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:\n\nname = \"HelloWorld\"\nuuid = \"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\"\nversion = \"0.1.0\"\nauthors = [\"Some One <someone@email.com>\"]\n\n[deps]\n\nThe content of src/HelloWorld.jl is:\n\nmodule HelloWorld\n\ngreet() = print(\"Hello World!\")\n\nend # module\n\nWe can now activate the project by using the path to the directory where it is installed, and load the package:\n\npkg> activate ./HelloWorld\n\njulia> import HelloWorld\n\njulia> HelloWorld.greet()\nHello World!\n\nFor the rest of the tutorial we enter inside the directory of the project, for convenience:\n\njulia> cd(\"HelloWorld\")"},{"title":"Adding dependencies to the project","page":"5. Creating Packages","location":"creating-packages/#Adding-dependencies-to-the-project","category":"section","text":"Let’s say we want to use the standard library package Random and the registered package JSON in our project.\nWe simply add these packages (note how the prompt now shows the name of the newly generated project,\nsince we activated it):\n\n(HelloWorld) pkg> add Random JSON\n   Resolving package versions...\n    Updating `~/HelloWorld/Project.toml`\n  [682c06a0] + JSON v0.21.3\n  [9a3f8284] + Random\n    Updating `~/HelloWorld/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n ...\n\nBoth Random and JSON got added to the project’s Project.toml file, and the resulting dependencies got added to the Manifest.toml file.\nThe resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies.\n\nWe can now use both Random and JSON in our project. Changing src/HelloWorld.jl to\n\nmodule HelloWorld\n\nimport Random\nimport JSON\n\ngreet() = print(\"Hello World!\")\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module\n\nand reloading the package, the new greet_alien function that uses Random can be called:\n\njulia> HelloWorld.greet_alien()\nHello aT157rHV"},{"title":"Defining a public API","page":"5. Creating Packages","location":"creating-packages/#Defining-a-public-API","category":"section","text":"If you want your package to be useful to other packages and you want folks to be able to\neasily update to newer version of your package when they come out, it is important to\ndocument what behavior will stay consistent across updates.\n\nUnless you note otherwise, the public API of your package is defined as all the behavior you\ndescribe about public symbols. A public symbol is a symbol that is exported from your\npackage with the export keyword or marked as public with the public keyword. When you\nchange the behavior of something that was previously public so that the new\nversion no longer conforms to the specifications provided in the old version, you should\nadjust your package version number according to Julia's variant on SemVer.\nIf you would like to include a symbol in your public API without exporting it into the\nglobal namespace of folks who call using YourPackage, you should mark that symbol as\npublic with public that_symbol. Symbols marked as public with the public keyword are\njust as public as those marked as public with the export keyword, but when folks call\nusing YourPackage, they will still have to qualify access to those symbols with\nYourPackage.that_symbol.\n\nLet's say we would like our greet function to be part of the public API, but not the\ngreet_alien function. We could then write the following and release it as version 1.0.0.\n\nmodule HelloWorld\n\nexport greet\n\nimport Random\nimport JSON\n\n\"Writes a friendly message.\"\ngreet() = print(\"Hello World!\")\n\n\"Greet an alien by a randomly generated name.\"\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module\n\nThen, if we change greet to\n\n\"Writes a friendly message that is exactly three words long.\"\ngreet() = print(\"Hello Lovely World!\")\n\nWe would release the new version as 1.1.0. This is not breaking\nbecause the new implementation conforms to the old documentation, but\nit does add a new feature, that the message must be three words long.\n\nLater, we may wish to change greet_alien to\n\n\"Greet an alien by the name of \\\"Zork\\\".\"\ngreet_alien() = print(\"Hello Zork\")\n\nAnd also export it by changing\n\nexport greet\n\nto\n\nexport greet, greet_alien\n\nWe should release this new version as 1.2.0 because it adds a new feature\ngreet_alien to the public API. Even though greet_alien was documented before\nand the new version does not conform to the old documentation, this is not breaking\nbecause the old documentation was not attached to a symbol that was exported\nat the time so that documentation does not apply across released versions.\n\nHowever, if we now wish to change greet to\n\n\"Writes a friendly message that is exactly four words long.\"\ngreet() = print(\"Hello very lovely world\")\n\nwe would need to release the new version as 2.0.0. In version 1.1.0, we specified that\nthe greeting would be three words long, and because greet was exported, that description\nalso applies to all future versions until the next breaking release. Because this new\nversion does not conform to the old specification, it must be tagged as a breaking change.\n\nPlease note that version numbers are free and unlimited. It is okay to use lots of them\n(e.g. version 6.62.8)."},{"title":"Adding a build step to the package","page":"5. Creating Packages","location":"creating-packages/#Adding-a-build-step-to-the-package","category":"section","text":"The build step is executed the first time a package is installed or when explicitly invoked with build.\nA package is built by executing the file deps/build.jl.\n\njulia> mkpath(\"deps\");\n\njulia> write(\"deps/build.jl\",\n             \"\"\"\n             println(\"I am being built...\")\n             \"\"\");\n\n(HelloWorld) pkg> build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n\njulia> print(readchomp(\"deps/build.log\"))\nI am being built...\n\nIf the build step fails, the output of the build step is printed to the console\n\njulia> write(\"deps/build.jl\",\n             \"\"\"\n             error(\"Ooops\")\n             \"\"\");\n\n(HelloWorld) pkg> build\n    Building HelloWorld → `~/HelloWorld/deps/build.log`\nERROR: Error building `HelloWorld`:\nERROR: LoadError: Ooops\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] top-level scope\n   @ ~/HelloWorld/deps/build.jl:1\n [3] include(fname::String)\n   @ Base.MainInclude ./client.jl:476\n [4] top-level scope\n   @ none:5\nin expression starting at /home/kc/HelloWorld/deps/build.jl:1\n\nwarning: Warning\nA build step should generally not create or modify any files in the package directory. If you need to store some files\nfrom the build step, use the Scratch.jl package."},{"title":"Adding tests to the package","page":"5. Creating Packages","location":"creating-packages/#adding-tests-to-packages","category":"section","text":"When a package is tested the file test/runtests.jl is executed:\n\njulia> mkpath(\"test\");\n\njulia> write(\"test/runtests.jl\",\n             \"\"\"\n             println(\"Testing...\")\n             \"\"\");\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\nTesting...\n   Testing HelloWorld tests passed\n\nTests are run in a new Julia process, where the package itself, and any\ntest-specific dependencies, are available, see below.\n\nwarning: Warning\nTests should generally not create or modify any files in the package directory. If you need to store some files\nfrom the build step, use the Scratch.jl package."},{"title":"Test-specific dependencies","page":"5. Creating Packages","location":"creating-packages/#Test-specific-dependencies","category":"section","text":"Test-specific dependencies are dependencies that are not dependencies of the package itself but are available when the package is tested."},{"title":"Recommended approach: Using workspaces with test/Project.toml","page":"5. Creating Packages","location":"creating-packages/#Recommended-approach:-Using-workspaces-with-test/Project.toml","category":"section","text":"compat: Compat\nWorkspaces require Julia 1.12+. For older Julia versions, see the legacy approaches below.\n\nThe recommended way to add test-specific dependencies is to use workspaces. This is done by:\n\nAdding a [workspace] section to your package's Project.toml:\n\n[workspace]\nprojects = [\"test\"]\n\nCreating a test/Project.toml file with your test dependencies:\n\n(HelloWorld) pkg> activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(HelloWorld/test) pkg> dev .  # add current package to test dependencies using its path\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + HelloWorld v0.1.0 `..`\n\n(HelloWorld/test) pkg> add Test  # add other test dependencies\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n\nWhen using workspaces, the package manager resolves dependencies for all projects in the workspace together, and creates a single Manifest.toml next to the base Project.toml. This provides better dependency resolution and makes it easier to manage test-specific dependencies.\n\ninfo: Info\nUnlike some earlier test dependency workflows, this one explicitly requires adding HelloWorld (the parent package) to your test/Project.toml.\n\nYou can now use Test in the test script:\n\njulia> write(\"test/runtests.jl\",\n             \"\"\"\n             using HelloWorld, Test\n             @test 1 == 1\n             \"\"\");\n\n(HelloWorld/test) pkg> activate .\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\n   Testing HelloWorld tests passed\n\nWorkspaces can also be used for other purposes, such as documentation or benchmarks, by adding additional projects to the workspace:\n\n[workspace]\nprojects = [\"test\", \"docs\", \"benchmarks\"]\n\nSee the section on Workspaces in the Project.toml documentation for more details."},{"title":"Alternative approach: Using [sources] with path-based dependencies","page":"5. Creating Packages","location":"creating-packages/#Alternative-approach:-Using-[sources]-with-path-based-dependencies","category":"section","text":"An alternative to workspaces is to use the [sources] section in test/Project.toml to reference the parent package. The [sources] section allows you to specify custom locations (paths or URLs) for dependencies, overriding registry information. This approach creates a separate manifest in the test/ directory (unlike workspaces which create a single shared manifest).\n\nTo use this approach:\n\nCreate a test/Project.toml file and add your test dependencies:\n\n(HelloWorld) pkg> activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(HelloWorld/test) pkg> add Test\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n\nAdd the parent package as a dependency using [sources] with a relative path:\n\n# In test/Project.toml\n[deps]\nHelloWorld = \"00000000-0000-0000-0000-000000000000\"  # Your package UUID\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[sources]\nHelloWorld = {path = \"..\"}\n\nThe [sources] section tells Pkg to use the local path for HelloWorld instead of looking it up in a registry. This creates a separate test/Manifest.toml that tracks the resolved dependencies for your test environment independently from the main package manifest. You can now run tests directly:\n\n$ julia --project=test\njulia> using HelloWorld, Test\n\njulia> include(\"test/runtests.jl\")\n\nnote: Difference from workspaces\nThe key difference from workspaces is that this approach uses a separate manifest file (test/Manifest.toml) for the test environment, while workspaces create a single shared manifest (Manifest.toml) that resolves all projects together. This means:With [sources] + path: Dependencies are resolved independently for each environment\nWith workspaces: Dependencies are resolved together, ensuring compatibility across all projects in the workspaceFor more details on [sources], see the [sources] section in the Project.toml documentation."},{"title":"Legacy approach: target based test specific dependencies","page":"5. Creating Packages","location":"creating-packages/#Legacy-approach:-target-based-test-specific-dependencies","category":"section","text":"warning: Warning\nThis approach is legacy and maintained for compatibility. New packages should use workspaces instead.\n\nUsing this method, test-specific dependencies are added under an [extras] section and to a test target:\n\n[extras]\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Markdown\", \"Test\"]\n\nNote that the only supported targets are test and build, the latter of which (not recommended) can be used for any deps/build.jl scripts."},{"title":"Legacy approach: test/Project.toml without workspace","page":"5. Creating Packages","location":"creating-packages/#Legacy-approach:-test/Project.toml-without-workspace","category":"section","text":"warning: Warning\nThis approach is legacy and maintained for compatibility. New packages should use workspaces instead.\n\nIn Julia 1.2 and later, test dependencies can be declared in test/Project.toml without using a workspace. When running tests, Pkg will automatically merge the package and test projects to create the test environment.\n\nnote: Note\nIf no test/Project.toml exists, Pkg will use the target based test specific dependencies.\n\nThis approach works similarly to the workspace approach, but without the workspace declaration in the main Project.toml."},{"title":"Compatibility on dependencies","page":"5. Creating Packages","location":"creating-packages/#Compatibility-on-dependencies","category":"section","text":"Every dependency should in general have a compatibility constraint on it.\nThis is an important topic so there is a separate chapter about it: Compatibility."},{"title":"Weak dependencies","page":"5. Creating Packages","location":"creating-packages/#Weak-dependencies","category":"section","text":"note: Note\nThis is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.\n\ncompat: Compat\nThe described feature requires Julia 1.9+.\n\nA weak dependency is a dependency that will not automatically install when the package is installed but\nyou can still control what versions of that package are allowed to be installed by setting compatibility on it.\nThese are listed in the project file under the [weakdeps] section:\n\n[weakdeps]\nSomePackage = \"b3785f31-9d33-4cdf-bc73-f646780f1739\"\n\n[compat]\nSomePackage = \"1.2\"\n\nThe current usage of this is almost solely limited to \"extensions\" which is described in the next section."},{"title":"Conditional loading of code in packages (Extensions)","page":"5. Creating Packages","location":"creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)","category":"section","text":"note: Note\nThis is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.\n\ncompat: Compat\nThe described feature requires Julia 1.9+.\n\nSometimes one wants to make two or more packages work well together, but may be reluctant (perhaps due to increased load times) to make one an unconditional dependency of the other.\nA package extension is a module in a file (similar to a package) that is automatically loaded when some other set of packages are\nloaded into the Julia session. This is very similar to functionality that the external package\nRequires.jl provides, but which is now available directly through Julia,\nand provides added benefits such as being able to precompile the extension."},{"title":"Code structure","page":"5. Creating Packages","location":"creating-packages/#Code-structure","category":"section","text":"A useful application of extensions could be for a plotting package that should be able to plot\nobjects from a wide variety of different Julia packages.\nAdding all those different Julia packages as dependencies of the plotting package\ncould be expensive since they would end up getting loaded even if they were never used.\nInstead, the code required to plot objects for specific packages can be put into separate files\n(extensions) and these are loaded only when the packages that define the type(s) we want to plot\nare loaded.\n\nBelow is an example of how the code can be structured for a use case in which a\nPlotting package wants to be able to display objects defined in the external package Contour.\nThe file and folder structure shown below is found in the Plotting package.\n\nProject.toml:\n\nname = \"Plotting\"\nversion = \"0.1.0\"\nuuid = \"...\"\n\n[weakdeps]\nContour = \"d38c429a-6771-53c6-b99e-75d170b6e991\"\n\n[extensions]\n# name of extension to the left\n# extension dependencies required to load the extension to the right\n# use a list for multiple extension dependencies\nContourExt = \"Contour\"\n\n[compat]\nContour = \"0.6.2\"\n\nsrc/Plotting.jl:\n\nmodule Plotting\n\nfunction plot(x::Vector)\n    # Some functionality for plotting a vector here\nend\n\nend # module\n\next/ContourExt.jl (can also be in ext/ContourExt/ContourExt.jl):\n\nmodule ContourExt # Should be same name as the file (just like a normal package)\n\nusing Plotting, Contour\n\nfunction Plotting.plot(c::Contour.ContourCollection)\n    # Some functionality for plotting a contour here\nend\n\nend # module\n\nExtensions can have arbitrary names (here ContourExt), following the format of this example is likely a good idea for extensions with a single dependency.\nIn Pkg output, extension names are always shown together with their parent package name.\n\ncompat: Compat\nOften you will want to load extension dependencies when testing your package. The recommended approach is to use workspaces and add the extension dependencies to your test/Project.toml (see Test-specific dependencies). For older Julia versions that don't support workspaces, you can put the extension dependencies into the test target, which requires you to also put the package in the [extras] section. The project verifier on older Julia versions will complain if this is not done.\n\nnote: Note\nIf you use a manifest generated by a Julia version that does not know about extensions with a Julia version that does\nknow about them, the extensions will not load. This is because the manifest lacks some information that tells Julia\nwhen it should load these packages. So make sure you use a manifest generated at least the Julia version you are using."},{"title":"Behavior of extensions","page":"5. Creating Packages","location":"creating-packages/#Behavior-of-extensions","category":"section","text":"A user that depends only on Plotting will not pay the cost of the \"extension\" inside the ContourExt module.\nIt is only when the Contour package actually gets loaded that the ContourExt extension is loaded too\nand provides the new functionality.\n\nIn our example, the new functionality is an additional method, which we add to an existing function from the parent package Plotting.\nImplementing such methods is among the most standard use cases of package extensions.\nWithin the parent package, the function to extend can even be defined with zero methods, as follows:\n\nfunction plot end\n\nnote: Note\nIf one considers ContourExt as a completely separate package, it could be argued that defining Plotting.plot(c::Contour.ContourCollection) is\ntype piracy since ContourExt owns neither the function Plotting.plot nor the type Contour.ContourCollection.\nHowever, for extensions, it is ok to assume that the extension owns the functions in its parent package.\n\nIn other situations, one may need to define new symbols in the extension (types, structs, functions, etc.) instead of reusing those from the parent package.\nSuch symbols are created in a separate module corresponding to the extension, namely ContourExt, and thus not in Plotting itself.\nIf extension symbols are needed in the parent package, one must call Base.get_extension to retrieve them.\nHere is an example showing how a custom type defined in ContourExt can be accessed in Plotting:\n\next = Base.get_extension(@__MODULE__, :ContourExt)\nif !isnothing(ext)\n    ContourPlotType = ext.ContourPlotType\nend\n\nOn the other hand, accessing extension symbols from a third-party package (i.e. not the parent) is not a recommended practice at the moment."},{"title":"Backwards compatibility","page":"5. Creating Packages","location":"creating-packages/#Backwards-compatibility","category":"section","text":"This section discusses various methods for using extensions on Julia versions that support them,\nwhile simultaneously providing similar functionality on older Julia versions."},{"title":"Requires.jl","page":"5. Creating Packages","location":"creating-packages/#Requires.jl","category":"section","text":"This section is relevant if you are currently using Requires.jl but want to transition to using extensions (while still having Requires be used on Julia versions that do not support extensions).\nThis is done by making the following changes (using the example above):\n\nAdd the following to the package file. This makes it so that Requires.jl loads and inserts the\ncallback only when extensions are not supported\n# This symbol is only defined on Julia versions that support extensions\nif !isdefined(Base, :get_extension)\nusing Requires\nend\n\n@static if !isdefined(Base, :get_extension)\nfunction __init__()\n    @require Contour = \"d38c429a-6771-53c6-b99e-75d170b6e991\" include(\"../ext/ContourExt.jl\")\nend\nend\nor if you have other things in your __init__() function:\nif !isdefined(Base, :get_extension)\nusing Requires\nend\n\nfunction __init__()\n    # Other init functionality here\n\n    @static if !isdefined(Base, :get_extension)\n        @require Contour = \"d38c429a-6771-53c6-b99e-75d170b6e991\" include(\"../ext/ContourExt.jl\")\n    end\nend\nMake the following change in the conditionally-loaded code in ContourExt.jl:\nisdefined(Base, :get_extension) ? (using Contour) : (using ..Contour)\nAdd Requires to [weakdeps] in your Project.toml file, so that it is listed in both [deps] and [weakdeps].\nJulia 1.9+ knows to not install it as a regular dependency, whereas earlier versions will consider it a dependency.\n\nThe package should now work with Requires.jl on Julia versions before extensions were introduced\nand with extensions on more recent Julia versions."},{"title":"Transition from normal dependency to extension","page":"5. Creating Packages","location":"creating-packages/#Transition-from-normal-dependency-to-extension","category":"section","text":"This section is relevant if you have a normal dependency that you want to transition be an extension (while still having the dependency be a normal dependency on Julia versions that do not support extensions).\nThis is done by making the following changes (using the example above):\n\nMake sure that the package is both in the [deps] and [weakdeps] section. Newer Julia versions will ignore dependencies in [deps] that are also in [weakdeps].\nAdd the following to your main package file (typically at the bottom):\nif !isdefined(Base, :get_extension)\n  include(\"../ext/ContourExt.jl\")\nend"},{"title":"Using an extension while supporting older Julia versions","page":"5. Creating Packages","location":"creating-packages/#Using-an-extension-while-supporting-older-Julia-versions","category":"section","text":"In the case where one wants to use an extension (without worrying about the\nfeature of the extension being available on older Julia versions) while still\nsupporting older Julia versions without workspace support, the packages under [weakdeps] should be\nduplicated into [extras]. This is an unfortunate duplication, but without\ndoing this the project verifier under older Julia versions will throw an error\nif it finds packages under [compat] that is not listed in [extras].\n\nFor Julia 1.13+, using workspaces is recommended and this duplication is not necessary."},{"title":"Package naming guidelines","page":"5. Creating Packages","location":"creating-packages/#Package-naming-guidelines","category":"section","text":"Package names should be sensible to most Julia users, even to those who are not domain experts.\nThe following guidelines apply to the General registry but may be useful for other package\nregistries as well.\n\nSince the General registry belongs to the entire community, people may have opinions about\nyour package name when you publish it, especially if it's ambiguous or can be confused with\nsomething other than what it is. Usually, you will then get suggestions for a new name that\nmay fit your package better.\n\nAvoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.\nIt's ok for package names to contain DNA if you're talking about the DNA, which has a universally agreed upon definition.\nIt's more difficult to justify package names containing the acronym CI for instance, which may mean continuous integration, confidence interval, etc.\nIf there is risk of confusion it may be best to disambiguate an acronym with additional words such as a lab group or field.\nIf your acronym is unambiguous, easily searchable, and/or unlikely to be confused across domains a good justification is often enough for approval.\nAvoid using Julia in your package name or prefixing it with Ju.\nIt is usually clear from context and to your users that the package is a Julia package.\nPackage names already have a .jl extension, which communicates to users that Package.jl is a Julia package.\nHaving Julia in the name can imply that the package is connected to, or endorsed by, contributors\nto the Julia language itself.\nPackages that provide most of their functionality in association with a new type should have pluralized\nnames.\nDataFrames provides the DataFrame type.\nBloomFilters provides the BloomFilter type.\nIn contrast, JuliaParser provides no new type, but instead new functionality in the JuliaParser.parse()\nfunction.\nErr on the side of clarity, even if clarity seems long-winded to you.\nRandomMatrices is a less ambiguous name than RndMat or RMT, even though the latter are shorter.\nGenerally package names should be at least 5 characters long not including the .jl extension\nA less systematic name may suit a package that implements one of several possible approaches to\nits domain.\nJulia does not have a single comprehensive plotting package. Instead, Gadfly, PyPlot, Winston\nand other packages each implement a unique approach based on a particular design philosophy.\nIn contrast, SortingAlgorithms provides a consistent interface to use many well-established\nsorting algorithms.\nPackages that wrap external libraries or programs can be named after those libraries or programs.\nCPLEX.jl wraps the CPLEX library, which can be identified easily in a web search.\nMATLAB.jl provides an interface to call the MATLAB engine from within Julia.\nAvoid naming a package closely to an existing package\nWebsocket is too close to WebSockets and can be confusing to users. Rather use a new name such as SimpleWebsockets.\nAvoid using a distinctive name that is already in use in a well known, unrelated project.\nDon't use the names Tkinter.jl, TkinterGUI.jl, etc. for a package that is unrelated\nto the popular tkinter python package, even if it provides bindings to Tcl/Tk.\nA package name of Tkinter.jl would only be appropriate if the package used Python's\nlibrary to accomplish its work or was spearheaded by the same community of developers.\nIt's okay to name a package HTTP.jl even though it is unrelated to the popular rust\ncrate http because in most usages the name \"http\" refers to the hypertext transfer\nprotocol, not to the http rust crate.\nIt's okay to name a package OpenSSL.jl if it provides an interface to the OpenSSL\nlibrary, even without explicit affiliation with the creators of the OpenSSL (provided\nthere's no copyright or trademark infringement etc.)\nPackages should follow the Stylistic Conventions.\nThe package name should begin with a capital letter and word separation is shown with upper camel case\nOnly ASCII characters are allowed in a package name\nPackages that provide the functionality of a project from another language should use the Julia convention\nPackages that provide pre-built libraries and executables can keep their original name, but should get _jllas a suffix. For example pandoc_jll wraps pandoc. However, note that the generation and release of most JLL packages is handled by the Yggdrasil system.\nFor the complete list of rules for automatic merging into the General registry, see these guidelines."},{"title":"Registering packages","page":"5. Creating Packages","location":"creating-packages/#Registering-packages","category":"section","text":"Once a package is ready it can be registered with the General Registry (see also the FAQ).\nCurrently, packages are submitted via Registrator.\nIn addition to Registrator, TagBot helps manage the process of tagging releases."},{"title":"Creating new package versions","page":"5. Creating Packages","location":"creating-packages/#Creating-new-package-versions","category":"section","text":"After registering your package, you'll want to release new versions as you add features and fix bugs. The typical workflow is:\n\nUpdate the version number in your Project.toml file according to semantic versioning rules. For example:\nIncrement the patch version (1.2.3 → 1.2.4) for bug fixes\nIncrement the minor version (1.2.3 → 1.3.0) for new features that don't break existing functionality\nIncrement the major version (1.2.3 → 2.0.0) for breaking changes\nCommit your changes to your package repository, including the updated version number.\nTag the release using Registrator. Comment @JuliaRegistrator register on a commit or pull request in your GitHub repository\nAutomated tagging: Once you've set up TagBot, it will automatically create a git tag in your repository when a new version is registered. This keeps your repository tags synchronized with registered versions.\n\nThe registration process typically takes a few minutes. Registrator will:\n\nCheck that your package meets registry requirements (has tests, proper version bounds, etc.)\nSubmit a pull request to the General registry\nAutomated checks will run, and if everything passes, the PR will be automatically merged\n\nFor private registries or more advanced workflows, see the documentation for LocalRegistry.jl and RegistryCI.jl."},{"title":"Best Practices","page":"5. Creating Packages","location":"creating-packages/#Best-Practices","category":"section","text":"Packages should avoid mutating their own state (writing to files within their package directory).\nPackages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by PackageCompiler.jl).\nTo support the various use cases in the Julia package ecosystem, the Pkg developers have created a number of auxiliary packages and techniques to help package authors create self-contained, immutable, and relocatable packages:\n\nArtifacts can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand.\nPrefer artifacts over attempting to open a file via a path such as joinpath(@__DIR__, \"data\", \"my_dataset.csv\") as this is non-relocatable.\nOnce your package has been precompiled, the result of @__DIR__ will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location.\nArtifacts can be bundled and accessed easily using the artifact\"name\" string macro.\nScratch.jl provides the notion of \"scratch spaces\", mutable containers of data for packages.\nScratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled.\nFor important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg.\nPreferences.jl allows packages to read and write preferences to the top-level Project.toml.\nThese preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior.\nPackages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that Preferences is available."},{"title":"See Also","page":"5. Creating Packages","location":"creating-packages/#See-Also","category":"section","text":"Managing Packages - Learn how to add, update, and manage package dependencies\nWorking with Environments - Understand environments and reproducible development\nCompatibility - Specify version constraints for dependencies\nAPI Reference - Functional API for non-interactive package management"},{"title":"7. Compatibility","page":"7. Compatibility","location":"compatibility/#Compatibility","category":"section","text":"Compatibility refers to the ability to restrict the versions of the dependencies that your project is compatible with.\nIf the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.\n\nCompatibility for a dependency is entered in the Project.toml file as for example:\n\n[compat]\njulia = \"1.6\"\nExample = \"0.5\"\n\nAfter a compatibility entry is put into the project file, up can be used to apply it.\n\nThe format of the version specifier is described in detail below.\n\ninfo: Info\nUse the command compat to edit the compat entries in the Pkg REPL, or manually edit the project file.\n\ninfo: Info\nThe rules below apply to the Project.toml file; for registries, see Registry Compat.toml.\n\ninfo: Info\nNote that registration into Julia's General Registry requires each dependency to have a [compat] entry with an upper bound."},{"title":"Version specifier format","page":"7. Compatibility","location":"compatibility/#Version-specifier-format","category":"section","text":"Similar to other package managers, the Julia package manager respects semantic versioning (semver), with an exception for leading zeros.\nAs an example, a version specifier given as e.g. 1.2.3 is therefore assumed to be compatible with the versions [1.2.3 - 2.0.0) where ) is a non-inclusive upper bound.\nMore specifically, a version specifier is either given as a caret specifier, e.g. ^1.2.3  or as a tilde specifier, e.g. ~1.2.3.\nCaret specifiers are the default and hence 1.2.3 == ^1.2.3. The difference between a caret and tilde is described in the next section.\nThe union of multiple version specifiers can be formed by comma separating individual version specifiers, e.g.\n\n[compat]\nExample = \"1.2, 2\"\n\nwill result in [1.2.0, 3.0.0).  Note leading zeros are treated differently, e.g. Example = \"0.2, 1\" would only result in [0.2.0 - 0.3.0) ∪ [1.0.0 - 2.0.0). See the next section for more information on versions with leading zeros."},{"title":"Behavior of versions with leading zeros (0.0.x and 0.x.y)","page":"7. Compatibility","location":"compatibility/#compat-pre-1.0","category":"section","text":"While the semver specification says that all versions with a major version of 0 (versions before 1.0.0) are incompatible\nwith each other, we have decided to only apply that for when both the major and minor versions are zero. In other words,\n0.0.1 and 0.0.2 are considered incompatible. A pre-1.0 version with non-zero minor version (0.a.b with a != 0) is\nconsidered compatible with versions with the same minor version and smaller or equal patch versions (0.a.c with c <= b);\ni.e., the versions 0.2.2 and 0.2.3 are compatible with 0.2.1 and 0.2.0. Versions with a major version of 0 and different\nminor versions are not considered compatible, so the version 0.3.0 might have breaking changes from 0.2.0. To that end, the\n[compat] entry:\n\n[compat]\nExample = \"0.0.1\"\n\nresults in a versionbound on Example as [0.0.1, 0.0.2) (which is equivalent to only the version 0.0.1), while the\n[compat] entry:\n\n[compat]\nExample = \"0.2.1\"\n\nresults in a versionbound on Example as [0.2.1, 0.3.0).\n\nIn particular, a package may set version = \"0.2.4\" when it has feature additions compared to 0.2.3 as long as it\nremains backward compatible with 0.2.0.  See also The version field."},{"title":"Caret specifiers","page":"7. Compatibility","location":"compatibility/#Caret-specifiers","category":"section","text":"A caret (^) specifier allows upgrade that would be compatible according to semver. This is the default behavior if no specifier is used.\nAn updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.\n\nSome examples are shown below.\n\n[compat]\nPkgA = \"^1.2.3\" # [1.2.3, 2.0.0)\nPkgB = \"^1.2\"   # [1.2.0, 2.0.0)\nPkgC = \"^1\"     # [1.0.0, 2.0.0)\nPkgD = \"^0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"^0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"^0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"^0\"     # [0.0.0, 1.0.0)"},{"title":"Tilde specifiers","page":"7. Compatibility","location":"compatibility/#Tilde-specifiers","category":"section","text":"A tilde specifier provides more limited upgrade possibilities. When specifying major, minor\nand patch versions, or when specifying major and minor versions, only the patch version is\nallowed to change. If you only specify a major version, then both minor and patch versions\nare allowed to be upgraded (~1 is thus equivalent to ^1).\nFor example:\n\n[compat]\nPkgA = \"~1.2.3\" # [1.2.3, 1.3.0)\nPkgB = \"~1.2\"   # [1.2.0, 1.3.0)\nPkgC = \"~1\"     # [1.0.0, 2.0.0)\nPkgD = \"~0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"~0.0.3\" # [0.0.3, 0.1.0)\nPkgF = \"~0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"~0\"     # [0.0.0, 1.0.0)\n\nFor all versions with a major version of 0 the tilde and caret specifiers are equivalent."},{"title":"Equality specifier","page":"7. Compatibility","location":"compatibility/#Equality-specifier","category":"section","text":"Equality can be used to specify exact versions:\n\n[compat]\nPkgA = \"=1.2.3\"           # [1.2.3, 1.2.3]\nPkgA = \"=0.10.1, =0.10.3\" # 0.10.1 or 0.10.3"},{"title":"Inequality specifiers","page":"7. Compatibility","location":"compatibility/#Inequality-specifiers","category":"section","text":"Inequalities can also be used to specify version ranges:\n\n[compat]\nPkgB = \">= 1.2.3\" # [1.2.3,  ∞)\nPkgC = \"≥ 1.2.3\"  # [1.2.3,  ∞)\nPkgD = \"< 1.2.3\"  # [0.0.0, 1.2.3) = [0.0.0, 1.2.2]"},{"title":"Hyphen specifiers","page":"7. Compatibility","location":"compatibility/#Hyphen-specifiers","category":"section","text":"Hyphen syntax can also be used to specify version ranges. Make sure that you have a space on both sides of the hyphen.\n\n[compat]\nPkgA = \"1.2.3 - 4.5.6\" # [1.2.3, 4.5.6]\nPkgA = \"0.2.3 - 4.5.6\" # [0.2.3, 4.5.6]\n\nAny unspecified trailing numbers in the first end-point are considered to be zero:\n\n[compat]\nPkgA = \"1.2 - 4.5.6\"   # [1.2.0, 4.5.6]\nPkgA = \"1 - 4.5.6\"     # [1.0.0, 4.5.6]\nPkgA = \"0.2 - 4.5.6\"   # [0.2.0, 4.5.6]\nPkgA = \"0.2 - 0.5.6\"   # [0.2.0, 0.5.6]\n\nAny unspecified trailing numbers in the second end-point will be considered to be wildcards:\n\n[compat]\nPkgA = \"1.2.3 - 4.5\"   # 1.2.3 - 4.5.* = [1.2.3, 4.6.0)\nPkgA = \"1.2.3 - 4\"     # 1.2.3 - 4.*.* = [1.2.3, 5.0.0)\nPkgA = \"1.2 - 4.5\"     # 1.2.0 - 4.5.* = [1.2.0, 4.6.0)\nPkgA = \"1.2 - 4\"       # 1.2.0 - 4.*.* = [1.2.0, 5.0.0)\nPkgA = \"1 - 4.5\"       # 1.0.0 - 4.5.* = [1.0.0, 4.6.0)\nPkgA = \"1 - 4\"         # 1.0.0 - 4.*.* = [1.0.0, 5.0.0)\nPkgA = \"0.2.3 - 4.5\"   # 0.2.3 - 4.5.* = [0.2.3, 4.6.0)\nPkgA = \"0.2.3 - 4\"     # 0.2.3 - 4.*.* = [0.2.3, 5.0.0)\nPkgA = \"0.2 - 4.5\"     # 0.2.0 - 4.5.* = [0.2.0, 4.6.0)\nPkgA = \"0.2 - 4\"       # 0.2.0 - 4.*.* = [0.2.0, 5.0.0)\nPkgA = \"0.2 - 0.5\"     # 0.2.0 - 0.5.* = [0.2.0, 0.6.0)\nPkgA = \"0.2 - 0\"       # 0.2.0 - 0.*.* = [0.2.0, 1.0.0)"},{"title":"Fixing conflicts","page":"7. Compatibility","location":"compatibility/#Fixing-conflicts","category":"section","text":"Version conflicts were introduced previously with an example\nof a conflict arising in a package D used by two other packages, B and C.\nOur analysis of the error message revealed that B is using an outdated\nversion of D.\nTo fix it, the first thing to try is to pkg> dev B so that\nyou can modify B and its compatibility requirements.\nIf you open its Project.toml file in an editor, you would probably notice something like\n\n[compat]\nD = \"0.1\"\n\nUsually the first step is to modify this to something like\n\n[compat]\nD = \"0.1, 0.2\"\n\nThis indicates that B is compatible with both versions 0.1 and version 0.2; if you pkg> up\nthis would fix the package error.\nHowever, there is one major concern you need to address first: perhaps there was an incompatible change\nin v0.2 of D that breaks B.\nBefore proceeding further, you should update all packages and then run B's tests, scanning the\noutput of pkg> test B to be sure that v0.2 of D is in fact being used.\n(It is possible that an additional dependency of D pins it to v0.1, and you wouldn't want to be misled into thinking that you had tested B on the newer version.)\nIf the new version was used and the tests still pass,\nyou can assume that B didn't need any further updating to accommodate v0.2 of D;\nyou can safely submit this change as a pull request to B so that a new release is made.\nIf instead an error is thrown, it indicates that B requires more extensive updates to be\ncompatible with the latest version of D; those updates will need to be completed before\nit becomes possible to use both A and B simultaneously.\nYou can, though, continue to use them independently of one another."},{"title":"15. Depots","page":"15. Depots","location":"depots/#**15.**-Depots","category":"section","text":"The packages installed for a particular environment, defined in the\nfiles Project.toml and Manifest.toml within the directory\nstructure, are not actually installed within that directory but into a\n\"depot\". The location of the depots are set by the variable\nDEPOT_PATH.\n\nFor details on the default depot locations and how they vary by installation method,\nsee the DEPOT_PATH documentation.\n\nPackages which are installed by a user go into the first depot and the Julia\nstandard library is in the last depot.\n\nYou should not need to manage the user depot directly. Pkg will automatically clean up\nthe depots when packages are removed after a delay. However you may want to manually\nremove old .julia/compiled/ subdirectories if you have any that reside for older Julia\nversions that you no longer use (hence have not been run to tidy themselves up)."},{"title":"Configuring the depot path with JULIA_DEPOT_PATH","page":"15. Depots","location":"depots/#Configuring-the-depot-path-with-JULIA_DEPOT_PATH","category":"section","text":"The depot path can be configured using the JULIA_DEPOT_PATH environment variable,\nwhich is used to populate the global Julia DEPOT_PATH variable\nat startup. For complete details on the behavior of this environment variable,\nsee the environment variables documentation."},{"title":"When to customize the depot path","page":"15. Depots","location":"depots/#When-to-customize-the-depot-path","category":"section","text":"You may want to change your depot location in several scenarios:\n\nCorporate environments: When your user folder synchronizes with a server (such as with\nActive Directory roaming profiles), storing thousands of package files in the default depot\ncan cause significant slowdowns during login/logout.\nStorage constraints: When your user directory has limited quota or is on a slow network drive.\nShared computing: When multiple users need access to the same packages on a shared system.\nCustom organization: When you prefer to organize Julia packages separately from your user directory."},{"title":"Platform-specific configuration","page":"15. Depots","location":"depots/#Platform-specific-configuration","category":"section","text":"JULIA_DEPOT_PATH is an operating system environment variable, not a Julia REPL command.\nThe method for setting it varies by platform:"},{"title":"Unix/Linux/macOS","page":"15. Depots","location":"depots/#Unix/Linux/macOS","category":"section","text":"For temporary configuration (current shell session only):\n\nexport JULIA_DEPOT_PATH=\"/custom/depot:\"\n\nFor permanent configuration, add the export command to your shell configuration file\n(e.g., ~/.bashrc, ~/.zshrc, or ~/.profile)."},{"title":"Windows","page":"15. Depots","location":"depots/#Windows","category":"section","text":"For temporary configuration in PowerShell (current session only):\n\n$env:JULIA_DEPOT_PATH = \"C:\\custom\\depot;\"\n\nFor temporary configuration in Command Prompt (current session only):\n\nset JULIA_DEPOT_PATH=C:\\custom\\depot;\n\nFor permanent system-wide or user-level configuration:\n\nPress Win+R to open the Run dialog\nType sysdm.cpl and press Enter\nGo to the \"Advanced\" tab\nClick \"Environment Variables\"\nAdd a new user or system variable named JULIA_DEPOT_PATH with your desired path\n(e.g., C:\\custom\\depot;)\n\nnote: Note\nThe trailing path separator (: on Unix, ; on Windows) is crucial for including\nthe default system depots, which contain the standard library and other bundled\nresources. Without it, Julia will only use the specified depot and will have to precompile\nstandard library packages, which can be time-consuming and inefficient."},{"title":"Alternative configuration methods","page":"15. Depots","location":"depots/#Alternative-configuration-methods","category":"section","text":"Instead of setting an operating system environment variable, you can configure the depot\npath using Julia's startup.jl file, which runs automatically when Julia starts:\n\n# In ~/.julia/config/startup.jl (Unix) or C:\\Users\\USERNAME\\.julia\\config\\startup.jl (Windows)\nempty!(DEPOT_PATH)\npush!(DEPOT_PATH, \"/custom/depot\")\npush!(DEPOT_PATH, joinpath(homedir(), \".julia\"))  # Include default depot as fallback\n\nThis approach provides per-user permanent configuration without requiring operating system\nenvironment variable changes. However, setting JULIA_DEPOT_PATH is generally preferred\nas it takes effect before Julia loads any code.\n\nwarning: Warning\nModifying DEPOT_PATH at runtime (in the REPL or in scripts) after Julia has started\nis generally not recommended, as Julia may have already loaded packages from the\noriginal depot locations."},{"title":"Shared depots for distributed computing","page":"15. Depots","location":"depots/#Shared-depots-for-distributed-computing","category":"section","text":"When using Julia in distributed computing environments, such as high-performance computing\n(HPC) clusters, it's recommended to use a shared depot via JULIA_DEPOT_PATH. This allows\nmultiple Julia processes to share precompiled packages and reduces redundant compilation.\n\nSince Julia v1.10, multiple processes using the same depot coordinate via pidfile locks\nto ensure only one process precompiles a package while others wait. However, due to\nthe caching of native code in pkgimages since v1.9, you may need to set the JULIA_CPU_TARGET\nenvironment variable appropriately to ensure cache compatibility across different\nworker nodes with varying CPU capabilities.\n\nFor more details, see the FAQ section on distributed computing\nand the environment variables documentation."},{"title":"Setting up shared depots for multi-user systems","page":"15. Depots","location":"depots/#Setting-up-shared-depots-for-multi-user-systems","category":"section","text":"In multi-user environments such as JupyterHub deployments, university computing labs, or shared servers,\nsystem administrators often want to provide a set of commonly-used packages that are available to all\nusers while still allowing individual users to install their own packages. This can be achieved by\nsetting up a layered depot structure with a read-only shared depot and user-specific writable depots."},{"title":"Overview of the approach","page":"15. Depots","location":"depots/#Overview-of-the-approach","category":"section","text":"The key concept is to use JULIA_DEPOT_PATH to create a layered depot structure where:\n\nUser depot (first in path): User-specific packages and modifications\nShared depot (middle in path): Common packages installed by administrators\nSystem depot (last in path): Julia standard library and bundled resources\n\nWhen Julia searches for packages, it looks through depots in order. This allows users to:\n\nAccess pre-installed packages from the shared depot\nInstall additional packages into their own depot\nOverride shared packages if needed by installing different versions in their user depot"},{"title":"Administrator setup","page":"15. Depots","location":"depots/#Administrator-setup","category":"section","text":""},{"title":"Step 1: Create the shared depot","page":"15. Depots","location":"depots/#Step-1:-Create-the-shared-depot","category":"section","text":"As a system administrator, create a shared depot location accessible to all users:\n\n# Create shared depot directory\nsudo mkdir -p /opt/julia/shared_depot\n\n# Create a shared user for managing the depot (optional but recommended)\nsudo useradd -r -s /bin/bash -d /opt/julia/shared_depot julia-shared\n\n# Set ownership\nsudo chown -R julia-shared:julia-shared /opt/julia/shared_depot"},{"title":"Step 2: Install shared packages","page":"15. Depots","location":"depots/#Step-2:-Install-shared-packages","category":"section","text":"Switch to the shared user account and configure Julia to use the shared depot:\n\nsudo su - julia-shared\nexport JULIA_DEPOT_PATH=\"/opt/julia/shared_depot:\"\n\nThen install commonly-used packages. You can do this interactively or by instantiating from a Project.toml:\n\n# Interactive installation\njulia -e 'using Pkg; Pkg.add([\"Plots\", \"DataFrames\", \"CSV\", \"LinearAlgebra\"])'\n\n# Or from a Project.toml file\ncd /opt/julia/shared_depot\n# Create or copy your Project.toml and Manifest.toml files here\njulia --project=. -e 'using Pkg; Pkg.instantiate()'\n\ntip: Tip\nUsing a Project.toml and Manifest.toml file to define the shared environment is\nrecommended as it provides reproducibility and version control. You can maintain these\nfiles in a git repository for tracking changes."},{"title":"Step 3: Clean the shared depot (optional)","page":"15. Depots","location":"depots/#Step-3:-Clean-the-shared-depot-(optional)","category":"section","text":"To minimize the shared depot size, you can remove registries from the shared depot:\n\nrm -rf /opt/julia/shared_depot/registries\n\nSince Pkg only writes to the first depot in JULIA_DEPOT_PATH, users will maintain their own\nregistries in their user depots anyway. Removing registries from the shared depot simply avoids\nstoring duplicate registry data."},{"title":"Step 4: Set appropriate permissions","page":"15. Depots","location":"depots/#Step-4:-Set-appropriate-permissions","category":"section","text":"Make the shared depot read-only for regular users:\n\n# Make shared depot readable by all users\nsudo chmod -R a+rX /opt/julia/shared_depot\n\n# Ensure it's not writable by others\nsudo chmod -R go-w /opt/julia/shared_depot"},{"title":"User configuration","page":"15. Depots","location":"depots/#User-configuration","category":"section","text":"Each user should configure their JULIA_DEPOT_PATH to include both their personal depot and\nthe shared depot. The exact syntax depends on where you want the user depot:"},{"title":"Using default user depot location","page":"15. Depots","location":"depots/#Using-default-user-depot-location","category":"section","text":"To use the default ~/.julia as the user depot with the shared depot as a fallback:\n\nexport JULIA_DEPOT_PATH=\"~/.julia:/opt/julia/shared_depot:\"\n\nThe trailing : ensures the system depot (with standard library) is still included."},{"title":"Using a custom user depot location","page":"15. Depots","location":"depots/#Using-a-custom-user-depot-location","category":"section","text":"If you want users to have their depot in a different location (e.g., to avoid home directory quotas):\n\nexport JULIA_DEPOT_PATH=\"/scratch/$USER/julia_depot:/opt/julia/shared_depot:\""},{"title":"System-wide configuration","page":"15. Depots","location":"depots/#System-wide-configuration","category":"section","text":"To configure this for all users automatically, add the export command to system-wide shell\nconfiguration files:\n\nOn Linux:\n\n# In /etc/profile.d/julia.sh\nexport JULIA_DEPOT_PATH=\"~/.julia:/opt/julia/shared_depot:\"\n\nOn macOS:\n\n# In /etc/zshrc or /etc/bashrc\nexport JULIA_DEPOT_PATH=\"~/.julia:/opt/julia/shared_depot:\"\n\nUsers can then further customize their individual depot paths if needed."},{"title":"Pre-seeding user environments","page":"15. Depots","location":"depots/#Pre-seeding-user-environments","category":"section","text":"In some scenarios (e.g., for student lab computers or container images), you may want to\npre-seed individual user environments. This can be done by:\n\nCreating a template environment with a Project.toml and Manifest.toml\nCopying these files to each user's Julia project directory\nHaving users (or a startup script) run Pkg.instantiate() on first use\n\nSince packages in the shared depot will be found automatically, instantiate() will only\ndownload packages that aren't already available in the shared depot.\n\n# As administrator, create template\nmkdir -p /opt/julia/template_project\n# Create Project.toml with desired packages\njulia --project=/opt/julia/template_project -e 'using Pkg; Pkg.add(\"Example\"); Pkg.add(\"Plots\")'\n\n# Users copy the template and instantiate\ncp -r /opt/julia/template_project ~/my_project\ncd ~/my_project\njulia --project=. -e 'using Pkg; Pkg.instantiate()'"},{"title":"Updating shared packages","page":"15. Depots","location":"depots/#Updating-shared-packages","category":"section","text":"To update packages in the shared depot:\n\nSwitch to the shared user account\nSet JULIA_DEPOT_PATH to point only to the shared depot\nUpdate packages as needed\nOptionally, clean up old package versions to save space\n\nsudo su - julia-shared\nexport JULIA_DEPOT_PATH=\"/opt/julia/shared_depot:\"\njulia -e 'using Pkg; Pkg.update()'\n\nnote: Note\nUpdating packages in the shared depot adds new versions alongside existing ones. Users with\nManifest.toml files remain pinned to their specific versions and won't be affected. If you\nexplicitly clean up old package versions to save disk space, users who need those versions\ncan run Pkg.instantiate() to download them to their local depot."},{"title":"Troubleshooting","page":"15. Depots","location":"depots/#Troubleshooting","category":"section","text":"Packages not found despite being in shared depot:\nVerify that JULIA_DEPOT_PATH is set correctly and includes the shared depot. Check that\nthe trailing separator is present to include system depots. Use DEPOT_PATH in the Julia\nREPL to verify the depot search path.\n\njulia> DEPOT_PATH\n3-element Vector{String}:\n \"/home/user/.julia\"\n \"/opt/julia/shared_depot\"\n \"/usr/local/share/julia\""},{"title":"13. API Reference","page":"13. API Reference","location":"api/#API-Reference","category":"section","text":"This section describes the functional API for interacting with Pkg.jl.\nIt is recommended to use the functional API, rather than the Pkg REPL mode,\nfor non-interactive usage, for example in scripts."},{"title":"General API Reference","page":"13. API Reference","location":"api/#General-API-Reference","category":"section","text":"Certain options are generally useful and can be specified in any API call.\nYou can specify these options by setting keyword arguments."},{"title":"Redirecting output","page":"13. API Reference","location":"api/#Redirecting-output","category":"section","text":"Use the io::IOBuffer keyword argument to redirect Pkg output.\nFor example, Pkg.add(\"Example\"; io=devnull) will discard any output produced by the add call."},{"title":"Package API Reference","page":"13. API Reference","location":"api/#Package-API-Reference","category":"section","text":"In the Pkg REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings,\nfor example \"Package#master\",\"Package@v0.1\", \"www.mypkg.com/MyPkg#my/feature\".\n\nIn the functional API, it is possible to use strings as arguments for simple commands (like Pkg.add([\"PackageA\", \"PackageB\"]),\nbut more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings.\nThis is done by creating an instance of PackageSpec which is passed in to functions."},{"title":"Registry API Reference","page":"13. API Reference","location":"api/#Registry-API-Reference","category":"section","text":"The functional API for registries uses RegistrySpecs, similar to\nPackageSpec."},{"title":"Artifacts API Reference","page":"13. API Reference","location":"api/#Artifacts-Reference","category":"section","text":""},{"title":"Package Server Authentication Hooks","page":"13. API Reference","location":"api/#Package-Server-Authentication-Hooks","category":"section","text":""},{"title":"Pkg.add","page":"13. API Reference","location":"api/#Pkg.add","category":"function","text":"Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED, target::Symbol=:deps)\nPkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED, target::Symbol=:deps)\n\nAdd a package to the current project. This package will be available by using the\nimport and using keywords in the Julia REPL, and if the current project is\na package, also inside that package.\n\nIf the active environment is a package (the Project has both name and uuid fields) compat entries will be\nadded automatically with a lower bound of the added version.\n\nTo add as a weak dependency (in the [weakdeps] field) set the kwarg target=:weakdeps.\nTo add as an extra dep (in the [extras] field) set target=:extras.\n\nResolution Tiers\n\nPkg resolves the set of packages in your environment using a tiered algorithm.\nThe preserve keyword argument allows you to key into a specific tier in the resolve algorithm.\nThe following table describes the argument values for preserve (in order of strictness):\n\nValue Description\nPRESERVE_ALL_INSTALLED Like PRESERVE_ALL and only add those already installed\nPRESERVE_ALL Preserve the state of all existing dependencies (including recursive dependencies)\nPRESERVE_DIRECT Preserve the state of all existing direct dependencies\nPRESERVE_SEMVER Preserve semver-compatible versions of direct dependencies\nPRESERVE_NONE Do not attempt to preserve any version information\nPRESERVE_TIERED_INSTALLED Like PRESERVE_TIERED except PRESERVE_ALL_INSTALLED is tried first\nPRESERVE_TIERED Use the tier that will preserve the most version information while\n allowing version resolution to succeed (this is the default)\n\nnote: Note\nTo change the default strategy to PRESERVE_TIERED_INSTALLED set the env var JULIA_PKG_PRESERVE_TIERED_INSTALLED\nto true.\n\nAfter the installation of new packages the project will be precompiled. For more information see pkg> ?precompile.\n\nWith the PRESERVE_ALL_INSTALLED strategy the newly added packages will likely already be precompiled, but if not this\nmay be because either the combination of package versions resolved in this environment has not been resolved and\nprecompiled before, or the precompile cache has been deleted by the LRU cache storage\n(see JULIA_MAX_NUM_PRECOMPILE_FILES).\n\ncompat: Julia 1.9\nThe PRESERVE_TIERED_INSTALLED and PRESERVE_ALL_INSTALLED strategies requires at least Julia 1.9.\n\ncompat: Julia 1.11\nThe target kwarg requires at least Julia 1.11.\n\nExamples\n\nPkg.add(\"Example\") # Add a package from registry\nPkg.add(\"Example\", target=:weakdeps) # Add a package as a weak dependency\nPkg.add(\"Example\", target=:extras) # Add a package to the `[extras]` list\nPkg.add(\"Example\"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and strictly preserve existing dependencies\nPkg.add(name=\"Example\", version=\"0.3\") # Specify version; latest release in the 0.3 series\nPkg.add(name=\"Example\", version=\"0.3.1\") # Specify version; exact release\nPkg.add(url=\"https://github.com/JuliaLang/Example.jl\", rev=\"master\") # From url to remote gitrepo\nPkg.add(url=\"/remote/mycompany/juliapackages/OurPackage\") # From path to local gitrepo\nPkg.add(url=\"https://github.com/Company/MonoRepo\", subdir=\"juliapkgs/Package.jl\") # With subdir\n\nAfter the installation of new packages the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, Pkg.develop.\n\n\n\n\n\n"},{"title":"Pkg.develop","page":"13. API Reference","location":"api/#Pkg.develop","category":"function","text":"Pkg.develop(pkg::Union{String, Vector{String}}; io::IO=stderr, preserve=PRESERVE_TIERED, installed=false)\nPkg.develop(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, preserve=PRESERVE_TIERED, installed=false)\n\nMake a package available for development by tracking it by path.\nIf pkg is given with only a name or by a URL, the package will be downloaded\nto the location specified by the environment variable JULIA_PKG_DEVDIR, with\njoinpath(DEPOT_PATH[1],\"dev\") being the default.\n\nIf pkg is given as a local path, the package at that path will be tracked.\n\nThe preserve strategies offered by Pkg.add are also available via the preserve kwarg.\nSee Pkg.add for more information.\n\nExamples\n\n# By name\nPkg.develop(\"Example\")\n\n# By url\nPkg.develop(url=\"https://github.com/JuliaLang/Compat.jl\")\n\n# By path\nPkg.develop(path=\"MyJuliaPackages/Package.jl\")\n\nSee also PackageSpec, Pkg.add.\n\n\n\n\n\n"},{"title":"Pkg.activate","page":"13. API Reference","location":"api/#Pkg.activate","category":"function","text":"Pkg.activate([s::String]; shared::Bool=false, io::IO=stderr)\nPkg.activate(; temp::Bool=false, shared::Bool=false, io::IO=stderr)\n\nActivate the environment at s, or return to the default environment if no argument is given.\nThe active environment is the environment that is modified by executing package commands.\nActivating an environment only affects the current Julia session and does not persist when\nyou restart Julia (unless you use the --project startup flag).\n\nReturning to the default environment\n\nIf no argument is given to activate, this returns you to the default shared environment\n(typically @v#.# in ~/.julia/environments/v#.#/). This is the standard way to \"deactivate\"\na project environment and return to your base package setup. There is no separate deactivate\ncommand—Pkg.activate() with no arguments serves this purpose.\n\nActivating a path\n\nWhen s is provided, the logic for what path is activated is as follows:\n\nIf shared is true, the first existing environment named s from the depots\nin the depot stack will be activated. If no such environment exists,\ncreate and activate that environment in the first depot.\nIf temp is true this will create and activate a temporary environment which will\nbe deleted when the julia process is exited.\nIf s is an existing path, then activate the environment at that path.\nIf s is a package in the current project and s is tracking a path, then\nactivate the environment at the tracked path.\nOtherwise, s is interpreted as a non-existing path, which is then activated.\n\nExamples\n\n# Return to default environment (deactivate current project)\nPkg.activate()\n\n# Activate a project in a specific directory\nPkg.activate(\"local/path\")\n\n# Activate a developed package by name\nPkg.activate(\"MyDependency\")\n\n# Create and activate a temporary environment\nPkg.activate(; temp=true)\n\nSee also LOAD_PATH.\n\n\n\n\n\n"},{"title":"Pkg.rm","page":"13. API Reference","location":"api/#Pkg.rm","category":"function","text":"Pkg.rm(pkg::Union{String, Vector{String}}; mode::PackageMode = PKGMODE_PROJECT)\nPkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}}; mode::PackageMode = PKGMODE_PROJECT)\n\nRemove a package from the current project. If mode is equal to\nPKGMODE_MANIFEST also remove it from the manifest including all\nrecursive dependencies of pkg.\n\nSee also PackageSpec, PackageMode.\n\n\n\n\n\n"},{"title":"Pkg.update","page":"13. API Reference","location":"api/#Pkg.update","category":"function","text":"Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT, preserve::PreserveLevel, workspace::Bool = false)\nPkg.update(pkg::Union{String, Vector{String}})\nPkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nIf no positional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT.\nIf no positional argument is given, level can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).\n\nIf packages are given as positional arguments, the preserve argument can be used to control what other packages are allowed to update:\n\nPRESERVE_ALL (default): Only allow pkg to update.\nPRESERVE_DIRECT: Only allow pkg and indirect dependencies that are not a direct dependency in the project to update.\nPRESERVE_NONE: Allow pkg and all its indirect dependencies to update.\n\nIf workspace is true, packages from all projects in the workspace will be included when no packages are specified.\n\nAfter any package updates the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, PackageMode, UpgradeLevel.\n\n\n\n\n\n"},{"title":"Pkg.test","page":"13. API Reference","location":"api/#Pkg.test","category":"function","text":"Pkg.test(; kwargs...)\nPkg.test(pkg::Union{String, Vector{String}; kwargs...)\nPkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)\n\nKeyword arguments:\n\ncoverage::Union{Bool,String}=false: enable or disable generation of coverage statistics for the tested package.\nIf a string is passed it is passed directly to --code-coverage in the test process so e.g. \"user\" will test all user code.\nallow_reresolve::Bool=true: allow Pkg to reresolve the package versions in the test environment\njulia_args::Union{Cmd, Vector{String}}: options to be passed the test process.\ntest_args::Union{Cmd, Vector{String}}: test arguments (ARGS) available in the test process.\n\ncompat: Julia 1.9\nallow_reresolve requires at least Julia 1.9.\n\ncompat: Julia 1.9\nPassing a string to coverage requires at least Julia 1.9.\n\nRun the tests for the given package(s), or for the current project if no positional argument is given to Pkg.test\n(the current project would need to be a package). The package is tested by running its test/runtests.jl file.\n\nThe tests are run in a temporary environment that also includes the test specific dependencies\nof the package. The versions of dependencies in the current project are used for the\ntest environment unless there is a compatibility conflict between the version of the dependencies and\nthe test-specific dependencies. In that case, if allow_reresolve is false an error is thrown and\nif allow_reresolve is true a feasible set of versions of the dependencies is resolved and used.\n\nTest-specific dependnecies are declared in the project file as:\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\n\nThe tests are executed in a new process with the same check-bounds setting as the current Julia session and by default startup-file=no.\nIf using the startup file (~/.julia/config/startup.jl) is desired, start julia with --startup-file=yes.\n\nInlining of functions during testing can be disabled (for better coverage accuracy)\nby starting julia with --inline=no. The tests can be run as if different command line arguments were\npassed to julia by passing the arguments instead to the julia_args keyword argument, e.g.\n\nPkg.test(\"foo\"; julia_args=[\"--inline\"])\n\nTo pass some command line arguments to be used in the tests themselves, pass the arguments to the\ntest_args keyword argument. These could be used to control the code being tested, or to control the\ntests in some way. For example, the tests could have optional additional tests:\n\nif \"--extended\" in ARGS\n    @test some_function()\nend\n\nwhich could be enabled by testing with\n\nPkg.test(\"foo\"; test_args=[\"--extended\"])\n\n\n\n\n\n"},{"title":"Pkg.build","page":"13. API Reference","location":"api/#Pkg.build","category":"function","text":"Pkg.build(; verbose = false, io::IO=stderr)\nPkg.build(pkg::Union{String, Vector{String}}; verbose = false, io::IO=stderr)\nPkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false, io::IO=stderr)\n\nKeyword arguments:\n\nverbose::Bool=false: print the build output to stdout/stderr instead of redirecting to the build.log file.\nallow_reresolve::Bool=true: allow Pkg to reresolve the package versions in the build environment\n\ncompat: Julia 1.13\nallow_reresolve requires at least Julia 1.13.\n\nRun the build script in deps/build.jl for pkg and all of its dependencies in\ndepth-first recursive order.\nIf no argument is given to build, the current project is built, which thus needs\nto be a package.\nThis function is called automatically on any package that gets installed\nfor the first time.\n\nThe build takes place in a new process matching the current process with default of startup-file=no.\nIf using the startup file (~/.julia/config/startup.jl) is desired, start julia with an explicit --startup-file=yes.\n\n\n\n\n\n"},{"title":"Pkg.pin","page":"13. API Reference","location":"api/#Pkg.pin","category":"function","text":"Pkg.pin(pkg::Union{String, Vector{String}}; io::IO=stderr, all_pkgs::Bool=false, workspace::Bool=false)\nPkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, all_pkgs::Bool=false, workspace::Bool=false)\n\nPin a package to the current version (or the one given in the PackageSpec) or to a certain\ngit revision. A pinned package is never automatically updated: if pkg is tracking a path,\nor a repository, those remain tracked but will not update.\nTo get updates from the origin path or remote repository the package must first be freed.\n\nIf workspace is true and all_pkgs is true, packages from all projects in the workspace\nwill be included.\n\ncompat: Julia 1.7\nThe all_pkgs kwarg was introduced in julia 1.7.\n\nExamples\n\n# Pin a package to its current version\nPkg.pin(\"Example\")\n\n# Pin a package to a specific version\nPkg.pin(name=\"Example\", version=\"0.3.1\")\n\n# Pin all packages in the project\nPkg.pin(all_pkgs = true)\n\n\n\n\n\n"},{"title":"Pkg.free","page":"13. API Reference","location":"api/#Pkg.free","category":"function","text":"Pkg.free(pkg::Union{String, Vector{String}}; io::IO=stderr, all_pkgs::Bool=false, workspace::Bool=false)\nPkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, all_pkgs::Bool=false, workspace::Bool=false)\n\nIf pkg is pinned, remove the pin.\nIf pkg is tracking a path, e.g. after Pkg.develop, go back to tracking registered versions.\nTo free all dependencies set all_pkgs=true.\n\nIf workspace is true and all_pkgs is true, packages from all projects in the workspace\nwill be included.\n\ncompat: Julia 1.7\nThe all_pkgs kwarg was introduced in julia 1.7.\n\nExamples\n\n# Free a single package (remove pin or stop tracking path)\nPkg.free(\"Package\")\n\n# Free multiple packages\nPkg.free([\"PackageA\", \"PackageB\"])\n\n# Free all packages in the project\nPkg.free(all_pkgs = true)\n\n\n\n\n\n"},{"title":"Pkg.instantiate","page":"13. API Reference","location":"api/#Pkg.instantiate","category":"function","text":"Pkg.instantiate(; verbose = false, workspace=false, io::IO=stderr, julia_version_strict=false)\n\nIf a Manifest.toml file exists in the active project, download all\nthe packages declared in that manifest.\nOtherwise, resolve a set of feasible packages from the Project.toml files\nand install them.\nverbose = true prints the build output to stdout/stderr instead of\nredirecting to the build.log file.\nworkspace=true will also instantiate all projects in the workspace.\nIf no Project.toml exist in the current active project, create one with all the\ndependencies in the manifest and instantiate the resulting project.\njulia_version_strict=true will turn manifest version check failures into errors instead of logging warnings.\n\nAfter packages have been installed the project will be precompiled.\nSee more and how to disable auto-precompilation at Environment Precompilation.\n\ncompat: Julia 1.12\nThe julia_version_strict keyword argument requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Pkg.resolve","page":"13. API Reference","location":"api/#Pkg.resolve","category":"function","text":"Pkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph\nfrom packages that are tracking a path.\n\n\n\n\n\n"},{"title":"Pkg.gc","page":"13. API Reference","location":"api/#Pkg.gc","category":"function","text":"Pkg.gc(; collect_delay::Period=Day(7), io::IO=stderr)\n\nGarbage-collect package and artifact installations by sweeping over all known\nManifest.toml and Artifacts.toml files, noting those that have been deleted, and then\nfinding artifacts and packages that are thereafter not used by any other projects,\nmarking them as \"orphaned\".  This method will only remove orphaned objects (package\nversions, artifacts, and scratch spaces) that have been continually un-used for a period\nof collect_delay; which defaults to seven days.\n\nTo disable automatic garbage collection, you can set the environment variable\nJULIA_PKG_GC_AUTO to \"false\" before starting Julia or call API.auto_gc(false).\n\n\n\n\n\n"},{"title":"Pkg.status","page":"13. API Reference","location":"api/#Pkg.status","category":"function","text":"Pkg.status([pkgs...]; outdated::Bool=false, mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false,\n           compat::Bool=false, extensions::Bool=false, workspace::Bool=false, io::IO=stdout)\n\nPrint out the status of the project/manifest.\n\nPackages marked with ⌃ have new versions that can be installed, e.g. via Pkg.update.\nThose marked with ⌅ have new versions available, but cannot be installed due to compatibility conflicts with other packages. To see why, set the\nkeyword argument outdated=true.\nPackages marked with [yanked] are yanked versions that should be updated or replaced as they may contain bugs or security vulnerabilities.\n\nSetting outdated=true will only show packages that are not on the latest version,\ntheir maximum version and why they are not on the latest version (either due to other\npackages holding them back due to compatibility constraints, or due to compatibility in the project file).\nAs an example, a status output like:\n\njulia> Pkg.status(; outdated=true)\nStatus `Manifest.toml`\n⌃ [a8cc5b0e] Crayons v2.0.0 [<v3.0.0], (<v4.0.4)\n⌅ [b8a86587] NearestNeighbors v0.4.8 (<v0.4.9) [compat]\n⌅ [2ab3a3ac] LogExpFunctions v0.2.5 (<v0.3.0): SpecialFunctions\n\nmeans that the latest version of Crayons is 4.0.4 but the latest version compatible\nwith the [compat] section in the current project is 3.0.0.\nThe latest version of NearestNeighbors is 0.4.9 but due to compat constrains in the project\nit is held back to 0.4.8.\nThe latest version of LogExpFunctions is 0.3.0 but SpecialFunctions\nis holding it back to 0.2.5.\n\nIf mode is PKGMODE_PROJECT, print out status only about the packages\nthat are in the project (explicitly added). If mode is PKGMODE_MANIFEST,\nprint status also about those in the manifest (recursive dependencies). If there are\nany packages listed as arguments, the output will be limited to those packages.\n\nSetting ext=true will show dependencies with extensions and what extension dependencies\nof those that are currently loaded.\n\nSetting diff=true will, if the environment is in a git repository, limit\nthe output to the difference as compared to the last git commit.\n\nSetting workspace=true will show the (merged) status of packages\nin the workspace.\n\nSee Pkg.project and Pkg.dependencies to get the project/manifest\nstatus as a Julia object instead of printing it.\n\ncompat: Julia 1.8\nThe ⌃ and ⌅ indicators were added in Julia 1.8.\nThe outdated keyword argument requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Pkg.compat","page":"13. API Reference","location":"api/#Pkg.compat","category":"function","text":"Pkg.compat()\n\nInteractively edit the [compat] entries within the current Project.\n\nPkg.compat(pkg::String, compat::String)\n\nSet the [compat] string for the given package within the current Project.\n\nSee Compatibility for more information on the project [compat] section.\n\n\n\n\n\n"},{"title":"Pkg.precompile","page":"13. API Reference","location":"api/#Pkg.precompile","category":"function","text":"Pkg.precompile(; strict::Bool=false, timing::Bool=false)\nPkg.precompile(pkg; strict::Bool=false, timing::Bool=false)\nPkg.precompile(pkgs; strict::Bool=false, timing::Bool=false)\nPkg.precompile(f, args...; kwargs...)\n\nPrecompile all or specific dependencies of the project in parallel.\n\nSet timing=true to show the duration of the precompilation of each dependency.\n\nTo delay autoprecompilation of multiple Pkg actions until the end use.\nThis may be most efficient while manipulating the environment in various ways.\n\nPkg.precompile() do\n    # Pkg actions here\nend\n\nnote: Note\nErrors will only throw when precompiling the top-level dependencies, given that\nnot all manifest dependencies may be loaded by the top-level dependencies on the given system.\nThis can be overridden to make errors in all dependencies throw by setting the kwarg strict to true\n\nnote: Note\nThis method is called automatically after any Pkg action that changes the manifest.\nAny packages that have previously errored during precompilation won't be retried in auto mode\nuntil they have changed. To disable automatic precompilation set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0.\nTo manually control the number of tasks used set ENV[\"JULIA_NUM_PRECOMPILE_TASKS\"].\n\ncompat: Julia 1.8\nSpecifying packages to precompile requires at least Julia 1.8.\n\ncompat: Julia 1.9\nTiming mode requires at least Julia 1.9.\n\ncompat: Julia 1.13\nThe Pkg.precompile(f, args...; kwargs...) do-block syntax requires at least Julia 1.13.\n\nExamples\n\nPkg.precompile()\nPkg.precompile(\"Foo\")\nPkg.precompile([\"Foo\", \"Bar\"])\n\n\n\n\n\n"},{"title":"Pkg.autoprecompilation_enabled","page":"13. API Reference","location":"api/#Pkg.autoprecompilation_enabled","category":"function","text":"Pkg.autoprecompilation_enabled(state::Bool)\n\nEnable or disable automatic precompilation for Pkg operations.\n\nWhen state is true (default), Pkg operations that modify the project environment\nwill automatically trigger precompilation of affected packages. When state is false,\nautomatic precompilation is disabled and packages will only be precompiled when\nexplicitly requested via Pkg.precompile.\n\nThis setting affects the global state and persists across Pkg operations in the same\nJulia session. It can be used in combination with Pkg.precompile do-syntax\nfor more fine-grained control over when precompilation occurs.\n\ncompat: Julia 1.13\nThis function requires at least Julia 1.13.\n\nExamples\n\n# Disable automatic precompilation\nPkg.autoprecompilation_enabled(false)\nPkg.add(\"Example\")  # Will not trigger auto-precompilation\nPkg.precompile()    # Manual precompilation\n\n# Re-enable automatic precompilation\nPkg.autoprecompilation_enabled(true)\nPkg.add(\"AnotherPackage\")  # Will trigger auto-precompilation\n\nSee also Pkg.precompile.\n\n\n\n\n\n"},{"title":"Pkg.offline","page":"13. API Reference","location":"api/#Pkg.offline","category":"function","text":"Pkg.offline(b::Bool=true)\n\nEnable (b=true) or disable (b=false) offline mode.\n\nIn offline mode Pkg tries to do as much as possible without connecting\nto internet. For example, when adding a package Pkg only considers\nversions that are already downloaded in version resolution.\n\nTo work in offline mode across Julia sessions you can set the environment\nvariable JULIA_PKG_OFFLINE to \"true\" before starting Julia.\n\n\n\n\n\n"},{"title":"Pkg.why","page":"13. API Reference","location":"api/#Pkg.why","category":"function","text":"Pkg.why(pkg::Union{String, Vector{String}}; workspace::Bool=false)\nPkg.why(pkg::Union{PackageSpec, Vector{PackageSpec}}; workspace::Bool=false)\n\nShow the reason why this package is in the manifest.\nThe output is all the different ways to reach the package\nthrough the dependency graph starting from the dependencies.\nIf workspace is true, this will consider all projects in the workspace and not just the active one.\n\ncompat: Julia 1.9\nThis function requires at least Julia 1.9.\n\n\n\n\n\n"},{"title":"Pkg.dependencies","page":"13. API Reference","location":"api/#Pkg.dependencies","category":"function","text":"Pkg.dependencies()::Dict{UUID, PackageInfo}\n\nThis feature is considered experimental.\n\nQuery the dependency graph of the active project.\nThe result is a Dict that maps a package UUID to a PackageInfo struct representing the dependency (a package).\n\nPackageInfo fields\n\nField Description\nname The name of the package\nversion The version of the package (this is Nothing for stdlibs)\ntree_hash A file hash of the package directory tree\nis_direct_dep The package is a direct dependency\nis_pinned Whether a package is pinned\nis_tracking_path Whether a package is tracking a path\nis_tracking_repo Whether a package is tracking a repository\nis_tracking_registry Whether a package is being tracked by registry i.e. not by path nor by repository\ngit_revision The git revision when tracking by repository\ngit_source The git source when tracking by repository\nsource The directory containing the source code for that package\ndependencies The dependencies of that package as a vector of UUIDs\n\n\n\n\n\n"},{"title":"Pkg.respect_sysimage_versions","page":"13. API Reference","location":"api/#Pkg.respect_sysimage_versions","category":"function","text":"Pkg.respect_sysimage_versions(b::Bool=true)\n\nEnable (b=true) or disable (b=false) respecting versions that are in the\nsysimage (enabled by default).\n\nIf this option is enabled, Pkg will only install packages that have been put into the sysimage\n(e.g. via PackageCompiler) at the version of the package in the sysimage.\nAlso, trying to add a package at a URL or develop a package that is in the sysimage\nwill error.\n\n\n\n\n\n"},{"title":"Pkg.project","page":"13. API Reference","location":"api/#Pkg.project","category":"function","text":"Pkg.project()::ProjectInfo\n\nThis feature is considered experimental.\n\nRequest a ProjectInfo struct which contains information about the active project.\n\nProjectInfo fields\n\nField Description\nname The project's name\nuuid The project's UUID\nversion The project's version\nispackage Whether the project is a package (has a name and uuid)\ndependencies The project's direct dependencies as a Dict which maps dependency name to dependency UUID\npath The location of the project file which defines the active project\n\n\n\n\n\n"},{"title":"Pkg.undo","page":"13. API Reference","location":"api/#Pkg.undo","category":"function","text":"undo()\n\nUndoes the latest change to the active project. Only states in the current session are stored,\nup to a maximum of 50 states.\n\nSee also: redo.\n\n\n\n\n\n"},{"title":"Pkg.redo","page":"13. API Reference","location":"api/#Pkg.redo","category":"function","text":"redo()\n\nRedoes the changes from the latest undo.\n\n\n\n\n\n"},{"title":"Pkg.setprotocol!","page":"13. API Reference","location":"api/#Pkg.setprotocol!","category":"function","text":"setprotocol!(;\n    domain::AbstractString = \"github.com\",\n    protocol::Union{Nothing, AbstractString}=nothing\n)\n\nSet the protocol used to access hosted packages when adding a url or developing a package.\nDefaults to delegating the choice to the package developer (protocol === nothing).\nOther choices for protocol are \"https\" or \"git\".\n\nExamples\n\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"ssh\")\n\n# Use HTTPS for GitHub (default, good for most users)\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"https\")\n\n# Reset to default (let package developer decide)\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = nothing)\n\n# Set protocol for custom domain without specifying protocol\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\")\n\n# Use Git protocol for a custom domain\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\", protocol = \"git\")\n\n\n\n\n\n"},{"title":"Pkg.readonly","page":"13. API Reference","location":"api/#Pkg.readonly","category":"function","text":"readonly([state::Bool], [ctx::Context])\n\nGet or set the readonly state of the current environment.\n\nExamples\n\njulia> Pkg.readonly()  # check current readonly state\nfalse\n\njulia> Pkg.readonly(true)  # enable readonly mode\nfalse  # returns previous state\n\njulia> Pkg.readonly()\ntrue\n\njulia> Pkg.readonly(false)  # disable readonly mode\ntrue\n\n\n\n\n\n"},{"title":"Pkg.PackageSpec","page":"13. API Reference","location":"api/#Pkg.PackageSpec","category":"type","text":"PackageSpec(name::String, [uuid::UUID, version::VersionNumber])\nPackageSpec(; name, url, path, subdir, rev, version, mode, level)\n\nA PackageSpec is a representation of a package with various metadata.\nThis includes:\n\nThe name of the package.\nThe package's unique uuid.\nA version (for example when adding a package). When upgrading, can also be an instance of\nthe enum UpgradeLevel. If the version is given as a String this means that unspecified versions\nare \"free\", for example version=\"0.5\" allows any version 0.5.x to be installed. If given as a VersionNumber,\nthe exact version is used, for example version=v\"0.5.3\".\nA url and an optional git revision. rev can be a branch name or a git commit SHA1.\nA local path. This is equivalent to using the url argument but can be more descriptive.\nA subdir which can be used when adding a package that is not in the root of a repository.\n\nMost functions in Pkg take a Vector of PackageSpec and do the operation on all the packages\nin the vector.\n\nMany functions that take a PackageSpec or a Vector{PackageSpec} can be called with a more concise notation with NamedTuples.\nFor example, Pkg.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.add(PackageSpec(name=\"Package\")) Pkg.add(name = \"Package\")\nPkg.add(PackageSpec(url=\"www.myhost.com/MyPkg\"))) Pkg.add(url=\"www.myhost.com/MyPkg\")\nPkg.add([PackageSpec(name=\"Package\"), PackageSpec(path=\"/MyPkg\"]) Pkg.add([(;name=\"Package\"), (;path=\"/MyPkg\")])\n\nBelow is a comparison between the REPL mode and the functional API:\n\nREPL API\nPackage PackageSpec(\"Package\")\nPackage@0.2 PackageSpec(name=\"Package\", version=\"0.2\")\n- PackageSpec(name=\"Package\", version=v\"0.2.1\")\nPackage=a67d... PackageSpec(name=\"Package\", uuid=\"a67d...\")\nPackage#master PackageSpec(name=\"Package\", rev=\"master\")\nlocal/path#feature PackageSpec(path=\"local/path\"; rev=\"feature\")\nwww.mypkg.com PackageSpec(url=\"www.mypkg.com\")\n--major Package PackageSpec(name=\"Package\", version=UPLEVEL_MAJOR)\n\n\n\n\n\n"},{"title":"Pkg.PackageMode","page":"13. API Reference","location":"api/#Pkg.PackageMode","category":"type","text":"PackageMode\n\nAn enum with the instances\n\nPKGMODE_MANIFEST\nPKGMODE_PROJECT\n\nDetermines if operations should be made on a project or manifest level.\nUsed as an argument to Pkg.rm, Pkg.update and Pkg.status.\n\n\n\n\n\n"},{"title":"Pkg.UpgradeLevel","page":"13. API Reference","location":"api/#Pkg.UpgradeLevel","category":"type","text":"UpgradeLevel\n\nAn enum with the instances\n\nUPLEVEL_FIXED\nUPLEVEL_PATCH\nUPLEVEL_MINOR\nUPLEVEL_MAJOR\n\nDetermines how much a package is allowed to be updated.\nUsed as an argument to  PackageSpec or as an argument to Pkg.update.\n\n\n\n\n\n"},{"title":"Pkg.RegistrySpec","page":"13. API Reference","location":"api/#Pkg.RegistrySpec","category":"type","text":"RegistrySpec(name::String)\nRegistrySpec(; name, uuid, url, path)\n\nA RegistrySpec is a representation of a registry with various metadata, much like\nPackageSpec.\nThis includes:\n\nThe name of the registry.\nThe registry's unique uuid.\nThe url to the registry.\nA local path.\n\nMost registry functions in Pkg take a Vector of RegistrySpec and do the operation\non all the registries in the vector.\n\nMany functions that take a RegistrySpec can be called with a more concise notation with keyword arguments.\nFor example, Pkg.Registry.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.Registry.add(RegistrySpec(name=\"General\")) Pkg.Registry.add(name = \"General\")\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/JuliaRegistries/General.git\"))) Pkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")\n\nBelow is a comparison between the REPL mode and the functional API::\n\nREPL API\nMyRegistry RegistrySpec(\"MyRegistry\")\nMyRegistry=a67d... RegistrySpec(name=\"MyRegistry\", uuid=\"a67d...\")\nlocal/path RegistrySpec(path=\"local/path\")\nwww.myregistry.com RegistrySpec(url=\"www.myregistry.com\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.add","page":"13. API Reference","location":"api/#Pkg.Registry.add","category":"function","text":"Pkg.Registry.add(registry::RegistrySpec)\n\nAdd new package registries.\n\nThe no-argument Pkg.Registry.add() will install the default registries.\n\nExamples\n\nPkg.Registry.add(\"General\")\nPkg.Registry.add(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\nPkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.rm","page":"13. API Reference","location":"api/#Pkg.Registry.rm","category":"function","text":"Pkg.Registry.rm(registry::String)\nPkg.Registry.rm(registry::RegistrySpec)\n\nRemove registries.\n\nExamples\n\nPkg.Registry.rm(\"General\")\nPkg.Registry.rm(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.update","page":"13. API Reference","location":"api/#Pkg.Registry.update","category":"function","text":"Pkg.Registry.update()\nPkg.Registry.update(registry::RegistrySpec)\nPkg.Registry.update(registry::Vector{RegistrySpec})\n\nUpdate registries. If no registries are given, update\nall available registries.\n\nExamples\n\nPkg.Registry.update()\nPkg.Registry.update(\"General\")\nPkg.Registry.update(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\n\n\n\n\n\n"},{"title":"Pkg.Registry.status","page":"13. API Reference","location":"api/#Pkg.Registry.status","category":"function","text":"Pkg.Registry.status()\n\nDisplay information about available registries.\n\nExamples\n\nPkg.Registry.status()\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.create_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.create_artifact","category":"function","text":"create_artifact(f::Function)\n\nCreates a new artifact by running f(artifact_path), hashing the result, and moving it\nto the artifact store (~/.julia/artifacts on a typical installation).  Returns the\nidentifying tree hash of this artifact.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.remove_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.remove_artifact","category":"function","text":"remove_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nRemoves the given artifact (identified by its SHA1 git tree hash) from disk.  Note that\nif an artifact is installed in multiple depots, it will be removed from all of them.  If\nan overridden artifact is requested for removal, it will be silently ignored; this method\nwill never attempt to remove an overridden artifact.\n\nIn general, we recommend that you use Pkg.gc() to manage artifact installations and do\nnot use remove_artifact() directly, as it can be difficult to know if an artifact is\nbeing used by another package.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.verify_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.verify_artifact","category":"function","text":"verify_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nVerifies that the given artifact (identified by its SHA1 git tree hash) is installed on-\ndisk, and retains its integrity.  If the given artifact is overridden, skips the\nverification unless honor_overrides is set to true.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.bind_artifact!","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.bind_artifact!","category":"function","text":"bind_artifact!(artifacts_toml::String, name::String, hash::SHA1;\n                platform::Union{AbstractPlatform,Nothing} = nothing,\n                download_info::Union{Vector{Tuple},Nothing} = nothing,\n                lazy::Bool = false,\n                force::Bool = false)\n\nWrites a mapping of name -> hash within the given (Julia)Artifacts.toml file. If\nplatform is not nothing, this artifact is marked as platform-specific, and will be\na multi-mapping.  It is valid to bind multiple artifacts with the same name, but\ndifferent platforms and hash'es within the same artifacts_toml.  If force is set\nto true, this will overwrite a pre-existant mapping, otherwise an error is raised.\n\ndownload_info is an optional vector that contains tuples of URLs and a hash.  These\nURLs will be listed as possible locations where this artifact can be obtained.  If lazy\nis set to true, even if download information is available, this artifact will not be\ndownloaded until it is accessed via the artifact\"name\" syntax, or\nensure_artifact_installed() is called upon it.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.unbind_artifact!","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.unbind_artifact!","category":"function","text":"unbind_artifact!(artifacts_toml::String, name::String; platform = nothing)\n\nUnbind the given name from an (Julia)Artifacts.toml file.\nSilently fails if no such binding exists within the file.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.download_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.download_artifact","category":"function","text":"download_artifact(tree_hash::SHA1, tarball_url::String, tarball_hash::String;\n                    verbose::Bool = false, io::IO=stderr)\n\nDownload/install an artifact into the artifact store.  Returns true on success,\nreturns an error object on failure.\n\ncompat: Julia 1.8\nAs of Julia 1.8 this function returns the error object rather than false when\nfailure occurs\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.ensure_artifact_installed","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.ensure_artifact_installed","category":"function","text":"ensure_artifact_installed(name::String, artifacts_toml::String;\n                            platform::AbstractPlatform = HostPlatform(),\n                            pkg_uuid::Union{Base.UUID,Nothing}=nothing,\n                            verbose::Bool = false,\n                            quiet_download::Bool = false,\n                            io::IO=stderr)\n\nEnsures an artifact is installed, downloading it via the download information stored in\nartifacts_toml if necessary.  Throws an error if unable to install.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.ensure_all_artifacts_installed","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.ensure_all_artifacts_installed","category":"function","text":"ensure_all_artifacts_installed(artifacts_toml::String;\n                                platform = HostPlatform(),\n                                pkg_uuid = nothing,\n                                include_lazy = false,\n                                verbose = false,\n                                quiet_download = false,\n                                io::IO=stderr)\n\nInstalls all non-lazy artifacts from a given (Julia)Artifacts.toml file. package_uuid must\nbe provided to properly support overrides from Overrides.toml entries in depots.\n\nIf include_lazy is set to true, then lazy packages will be installed as well.\n\nThis function is deprecated and should be replaced with the following snippet:\n\nartifacts = select_downloadable_artifacts(artifacts_toml; platform, include_lazy)\nfor name in keys(artifacts)\n    ensure_artifact_installed(name, artifacts[name], artifacts_toml; platform=platform)\nend\n\nwarning: Warning\nThis function is deprecated in Julia 1.6 and will be removed in a future version.\nUse select_downloadable_artifacts() and ensure_artifact_installed() instead.\n\n\n\n\n\n"},{"title":"Pkg.PkgArtifacts.archive_artifact","page":"13. API Reference","location":"api/#Pkg.PkgArtifacts.archive_artifact","category":"function","text":"archive_artifact(hash::SHA1, tarball_path::String; honor_overrides::Bool=false)\n\nArchive an artifact into a tarball stored at tarball_path, returns the SHA256 of the\nresultant tarball as a hexadecimal string. Throws an error if the artifact does not\nexist.  If the artifact is overridden, throws an error unless honor_overrides is set.\n\n\n\n\n\n"},{"title":"Pkg.PlatformEngines.register_auth_error_handler","page":"13. API Reference","location":"api/#Pkg.PlatformEngines.register_auth_error_handler","category":"function","text":"register_auth_error_handler(urlscheme::Union{AbstractString, Regex}, f)\n\nRegisters f as the topmost handler for failures in package server authentication.\n\nA handler is only invoked if occursin(urlscheme, url) is true (where url is the URL Pkg\nis currently trying to download.)\n\nf must be a function that takes three input arguments (url, pkgserver, err), where url is the\nURL currently being downloaded, pkgserver = Pkg.pkg_server() the current package server, and\nerr is one of no-auth-file, insecure-connection, malformed-file, no-access-token,\nno-refresh-key or insecure-refresh-url.\n\nThe handler f needs to return a tuple of Bools (handled, should_retry). If handled is false,\nthe next handler in the stack will be called, otherwise handling terminates; get_auth_header is called again if should_retry\nis true.\n\nregister_auth_error_handler returns a zero-arg function that can be called to deregister the handler.\n\n\n\n\n\n"},{"title":"Pkg.PlatformEngines.deregister_auth_error_handler","page":"13. API Reference","location":"api/#Pkg.PlatformEngines.deregister_auth_error_handler","category":"function","text":"deregister_auth_error_handler(urlscheme::Union{AbstractString, Regex}, f)\n\nRemoves f from the stack of authentication error handlers.\n\n\n\n\n\n"},{"title":"6. Apps","page":"6. Apps","location":"apps/#Apps","category":"section","text":"note: Note\nThe app support in Pkg is currently considered experimental and some functionality and API may change.Some inconveniences that can be encountered are:You need to manually make ~/.julia/bin available on the PATH environment.\nThe path to the julia executable used is the same as the one used to install the app. If this\njulia installation gets removed, you might need to reinstall the app.\n\nApps are Julia packages that are intended to be run as \"standalone programs\" (by e.g. typing the name of the app in the terminal possibly together with some arguments or flags/options).\nThis is in contrast to most Julia packages that are used as \"libraries\" and are loaded by other files or in the Julia REPL."},{"title":"Creating a Julia app","page":"6. Apps","location":"apps/#Creating-a-Julia-app","category":"section","text":"A Julia app is structured similar to a standard Julia library with the following additions:\n\nA @main entry point in the package module (see the Julia help on @main for details)\nAn [apps] section in the Project.toml file listing the executable names that the package provides.\n\nA very simple example of an app that prints the reversed input arguments would be:\n\n# src/MyReverseApp.jl\nmodule MyReverseApp\n\nfunction (@main)(ARGS)\n    for arg in ARGS\n        print(stdout, reverse(arg), \" \")\n    end\n    return\nend\n\nend # module\n\n# Project.toml\n\n# standard fields here\n\n[apps]\nreverse = {}\n\nThe empty table {} is to allow for giving metadata about the app.\n\nAfter installing this app one could run:\n\n$ reverse some input string\n emos tupni gnirts\n\ndirectly in the terminal."},{"title":"Multiple Apps per Package","page":"6. Apps","location":"apps/#Multiple-Apps-per-Package","category":"section","text":"A single package can define multiple apps by using submodules. Each app can have its own entry point in a different submodule of the package.\n\n# src/MyMultiApp.jl\nmodule MyMultiApp\n\nfunction (@main)(ARGS)\n    println(\"Main app: \", join(ARGS, \" \"))\nend\n\ninclude(\"CLI.jl\")\n\nend # module\n\n# src/CLI.jl\nmodule CLI\n\nfunction (@main)(ARGS)\n    println(\"CLI submodule: \", join(ARGS, \" \"))\nend\n\nend # module CLI\n\n# Project.toml\n\n# standard fields here\n\n[apps]\nmain-app = {}\ncli-app = { submodule = \"CLI\" }\n\nThis will create two executables:\n\nmain-app that runs julia -m MyMultiApp\ncli-app that runs julia -m MyMultiApp.CLI"},{"title":"Configuring Julia Flags","page":"6. Apps","location":"apps/#Configuring-Julia-Flags","category":"section","text":"Apps can specify default Julia command-line flags that will be passed to the Julia process when the app is run. This is useful for configuring performance settings, threading, or other Julia options specific to your application."},{"title":"Default Julia Flags","page":"6. Apps","location":"apps/#Default-Julia-Flags","category":"section","text":"You can specify default Julia flags in the Project.toml file using the julia_flags field:\n\n# Project.toml\n\n[apps]\nmyapp = { julia_flags = [\"--threads=4\", \"--optimize=2\"] }\nperformance-app = { julia_flags = [\"--threads=auto\", \"--startup-file=yes\", \"--depwarn=no\"] }\ndebug-app = { submodule = \"Debug\", julia_flags = [\"--check-bounds=yes\", \"--optimize=0\"] }\n\nWith this configuration:\n\nmyapp will run with 4 threads and optimization level 2\nperformance-app will run with automatic thread detection, startup file enabled, and deprecation warnings disabled\ndebug-app will run with bounds checking enabled and no optimization"},{"title":"Runtime Julia Flags","page":"6. Apps","location":"apps/#Runtime-Julia-Flags","category":"section","text":"You can override or add to the default Julia flags at runtime using the -- separator. Everything before -- will be passed as flags to Julia, and everything after -- will be passed as arguments to your app:\n\n# Uses default flags from Project.toml\nmyapp input.txt output.txt\n\n# Override thread count, keep other defaults\nmyapp --threads=8 -- input.txt output.txt\n\n# Add additional flags\nmyapp --threads=2 --optimize=3 --check-bounds=yes -- input.txt output.txt\n\n# Only Julia flags, no app arguments\nmyapp --threads=1 --\n\nThe final Julia command will combine:\n\nFixed flags (like --startup-file=no and -m ModuleName)\nDefault flags from julia_flags in Project.toml\nRuntime flags specified before --\nApp arguments specified after --"},{"title":"Overriding the Julia Executable","page":"6. Apps","location":"apps/#Overriding-the-Julia-Executable","category":"section","text":"By default, apps run with the same Julia executable that was used to install them. You can override this globally using the JULIA_APPS_JULIA_CMD environment variable:\n\n# Use a different Julia version for all apps\nexport JULIA_APPS_JULIA_CMD=/path/to/different/julia\nmyapp input.txt\n\n# On Windows\nset JULIA_APPS_JULIA_CMD=C:\\path\\to\\different\\julia.exe\nmyapp input.txt"},{"title":"Installing Julia apps","page":"6. Apps","location":"apps/#Installing-Julia-apps","category":"section","text":"The installation of Julia apps is similar to installing Julia libraries but instead of using e.g. Pkg.add or pkg> add one uses Pkg.Apps.add or pkg> app add (develop is also available)."},{"title":"14. Package and Storage Server Protocol Reference","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Pkg-Server-Protocols","category":"section","text":"The Julia Package Server Protocol (Pkg Protocol) and the Package Storage Server Protocol (Storage Protocol) define how Julia's package manager, Pkg, obtains and manages packages and their associated resources. They aim to enhance the Julia package ecosystem, making it more efficient, reliable, and user-friendly, avoiding potential points of failure, and ensuring the permanent availability of package versions and artifacts, which is paramount for the stability and reproducibility of Julia projects.\n\nThe Pkg client, by default, gets all resources over HTTPS from a single open source service run by the Julia community. This service for serving packages is additionally backed by multiple independent storage services which interface with proprietary origin services (GitHub, etc.) and guarantee persistent availability of resources into the future.\n\nThe protocols also aim to address some of the limitations that existed prior to its introduction.\n\nVanishing Resources. It is possible for authors to delete code repositories of registered Julia packages. Without some kind of package server, no one can install a package which has been deleted. If someone happens to have a current fork of a deleted package, that can be made the new official repository for the package, but the chances of them having no or outdated forks are high. An even worse situation could happen for artifacts since they tend not to be kept in version control and are much more likely to be served from \"random\" web servers at a fixed URL with content changing over time. Artifact publishers are unlikely to retain all past versions of artifacts, so old versions of packages that depend on specific artifact content will not be reproducible in the future unless we do something to ensure that they are kept around after the publisher has stopped hosting them. By storing all package versions and artifacts in a single place, we can ensure that they are available forever.\nUsage Insights. It is valuable for the Julia community to know how many people are using Julia or what the relative popularity of different packages and operating systems is. Julia uses GitHub to host its ecosystem. GitHub - a commercial, proprietary service - has this information but does not make it available to the Julia community. We are of course using GitHub for free, so we can't complain, but it seems unfortunate that a commercial entity has this valuable information while the open source community remains in the dark. The Julia community really could use insight into who is using Julia and how, so that we can prioritize packages and platforms, and give real numbers when people ask \"how many people are using Julia?\"\nDecoupling from Git and GitHub. Prior to this, Julia package ecosystem was very deeply coupled to git and was even specialized on GitHub specifically in many ways. The Pkg and Storage Protocols allowed us to decouple ourselves from git as the primary mechanism for getting packages. Now Julia continues to support using git, but does not require it just to install packages from the default public registry anymore. This decoupling also paves the way for supporting other version control systems in the future, making git no longer so special. Special treatment of GitHub will also go away since we get the benefits of specializing for GitHub (fast tarball downloads) directly from the Pkg protocols.\nFirewall problems. Prior to this, Pkg's need to connect to arbitrary servers using a miscellany of protocols caused several problems with firewalls. A large set of protocols and an unbounded list of servers needed to be whitelisted just to support default Pkg operation. If Pkg only needed to talk to a single service over a single, secure protocol (i.e. HTTPS), then whitelisting Pkg for standard use would be dead simple."},{"title":"Protocols & Services","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Protocols-and-Services","category":"section","text":"Pkg Protocol: what Julia Pkg Clients speak to Pkg Servers. The Pkg Server serves all resources that Pkg Clients need to install and use registered packages, including registry data, packages and artifacts. It is designed to be easily horizontally scalable and not to have any hard operational requirements: if service is slow, just start more servers; if a Pkg Server crashes, forget it and boot up a new one.\nStorage Protocol: what Pkg Servers speak to get resources from Storage Services. Julia clients do not interact with Storage services directly and multiple independent Storage Services can symmetrically (all are treated equally) provide their service to a given Pkg Server. Since Pkg Servers cache what they serve to Clients and handle convenient content presentation, Storage Services can expose a much simpler protocol: all they do is serve up complete versions of registries, packages and artifacts, while guaranteeing persistence and completeness. Persistence means: once a version of a resource has been served, that version can be served forever. Completeness means: if the service serves a registry, it can serve all package versions referenced by that registry; if it serves a package version, it can serve all artifacts used by that package.\n\nBoth protocols work over HTTPS, using only GET and HEAD requests. As is normal for HTTP, HEAD requests are used to get information about a resource, including whether it would be served, without actually downloading it. As described in what follows, the Pkg Protocol is client-to-server and may be unauthenticated, use basic auth, or OpenID; the Storage Protocol is server-to-server only and uses mutual authentication with TLS certificates.\n\nThe following diagram shows how these services interact with each other and with external services such as GitHub, GitLab and BitBucket for source control, and S3 and HDFS for long-term persistence:\n\n                                        ┌───────────┐\n\n                                        │ Amazon S3 │\n\n                                        │  Storage  │\n\n                                        └───────────┘\n\n                                              ▲\n\n                                              ║\n\n                                              ▼\n\n                              Storage   ╔═══════════╗       ┌───────────┐\n\n               Pkg            Protocol  ║  Storage  ║   ┌──▶│  GitHub   │\n\n             Protocol               ┌──▶║ Service A ║───┤   └───────────┘\n\n┏━━━━━━━━━━━━┓     ┏━━━━━━━━━━━━┓   │   ╚═══════════╝   │   ┌───────────┐\n\n┃ Pkg Client ┃────▶┃ Pkg Server ┃───┤   ╔═══════════╗   ├──▶│  GitLab   │\n\n┗━━━━━━━━━━━━┛     ┗━━━━━━━━━━━━┛   │   ║  Storage  ║   │   └───────────┘\n\n                                    └──▶║ Service B ║───┤   ┌───────────┐\n\n                                        ╚═══════════╝   └──▶│ BitBucket │\n\n                                              ▲             └───────────┘\n\n                                              ║\n\n                                              ▼\n\n                                        ┌───────────┐\n\n                                        │   HDFS    │\n\n                                        │  Cluster  │\n\n                                        └───────────┘\n\nEach Julia Pkg Client is configured to talk to a Pkg Server. By default, they talk to pkg.julialang.org, a public, unauthenticated Pkg Server. If the environment variable JULIA_PKG_SERVER is set, the Pkg Client connects to that host instead. For example, if JULIA_PKG_SERVER is set to pkg.company.com then the Pkg Client will connect to https://pkg.company.com. So in typical operation, a Pkg Client will no longer rely on libgit2 or a git command-line client, both of which have been an ongoing headache, especially behind firewalls and on Windows. If fact, git will only be necessary when working with git-hosted registries and unregistered packages - those will continue to work as they have previously, fetched using git.\n\nWhile the default Pkg Server at pkg.julialang.org is unauthenticated, other parties may host Pkg Server instances elsewhere, authenticated or unauthenticated, public or private, as they wish. People can connect to those servers by setting the JULIA_PKG_SERVER variable. There will be a configuration file for providing authentication information to Pkg Servers using either basic auth or OpenID. The Pkg Server implementation will be open source and have minimal operational requirements. Specifically, it needs:\n\nThe ability to accept incoming connections on port 443;\nThe ability to connect to a configurable set of Storage Services;\nTemporary disk storage for caching resources (registries, packages, artifacts).\n\nA Pkg Service may be backed by more than one actual server, as is typical for web services. The Pkg Service is stateless, so this kind of horizontal scaling is straightforward. Each Pkg Server serves registry, package and artifact resources to Pkg Clients and caches whatever it serves. Each Pkg Server, in turn, gets those resources from one or more Storage Services. Storage services are responsible for fetching resources from code hosting sites like GitHub, GitLab and BitBucket, and for persisting everything that they have ever served to long-term storage systems like Amazon S3, hosted HDFS clusters - or whatever an implementor wants to use. If the original copies of resources vanish, Pkg Servers must always serve up all previously served versions of resources.\n\nThe Storage Protocol is designed to be extremely simple so that multiple independent implementations can coexist, and each Pkg Server may be symmetrically backed by multiple different Storage Services, providing both redundant backup and ensuring that no single implementation has a \"choke hold\" on the ecosystem - anyone can implement a new Storage Service and add it to the set of services backing the default Pkg Server at pkg.julialang.org. The simplest possible version of a Storage Service is a static HTTPS site serving files generated from a snapshot of a registry. Although this does not provide adequate long-term backup capabilities, and would need to be regenerated whenever a registry changes, it may be sufficient for some private uses. Having multiple independently operated Storage Services helps ensure that even if one Storage Service becomes unavailable or unreliable - for technical, financial, or political reasons - others will keep operating and so will the Pkg ecosystem."},{"title":"The Pkg Protocol","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#The-Pkg-Protocol","category":"section","text":"This section describes the protocol used by Pkg Clients to get resources from Pkg Servers, including the latest versions of registries, package source trees, and artifacts. There is also a standard system for asking for diffs of all of these from previous versions, to minimize how much data the client needs to download in order to update itself. There is additionally a bundle mechanism for requesting and receiving a set of resources in a single request."},{"title":"Authentication","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Authentication","category":"section","text":"The authentication scheme between a Pkg client and server will be HTTP authorization with bearer tokens, as standardized in RFC6750. This means that authenticated access is accomplished by the client by making an HTTPS request including a Authorization: Bearer $access_token header.\n\nThe format of the token, its contents and validation mechanism are not specified by the Pkg Protocol. They are left to the server to define. The server is expected to validate the token and determine whether the client is authorized to access the requested resource. Similarly at the client side, the implementation of the token acquisition is not specified by the Pkg Protocol. However Pkg provides hooks that can be implemented at the client side to trigger the token acquisition process. Tokens thus acquired are expected to be stored in a local file, the format of which is specified by the Pkg Protocol. Pkg will be able to read the token from this file and include it in the request to the server. Pkg can also, optionally, detect when the token is about to expire and trigger a refresh. The Pkg client also supports automatic token refresh, since bearer tokens are recommended to be short-lived (no more than a day).\n\nThe authorization information is saved locally in $(DEPOT_PATH[1])/servers/$server/auth.toml which is a TOML file with the following fields:\n\naccess_token (REQUIRED): the bearer token used to authorize normal requests\nexpires_at (OPTIONAL): an absolute expiration time\nexpires_in (OPTIONAL): a relative expiration time\nrefresh_token (OPTIONAL): bearer token used to authorize refresh requests\nrefresh_url (OPTIONAL): URL to fetch a new token from\n\nThe auth.toml file may contain other fields (e.g. user name, user email), but they are ignored by Pkg. The two other fields mentioned in RFC6750 are token_type and scope: these are omitted since only tokens of type Bearer are supported currently and the scope is always implicitly to provide access to Pkg protocol URLs. Pkg servers should, however, not send auth.toml files with token_type or scope fields, as these names may be used in the future, e.g. to support other kinds of tokens or to limit the scope of an authorization to a subset of Pkg protocol URLs.\n\nInitially, the user or user agent (IDE) must acquire a auth.toml file and save it to the correct location. After that, Pkg will determine whether the access token needs to be refreshed by examining the expires_at and/or expires_in fields of the auth file. The expiration time is the minimum of expires_at and mtime(auth_file) + expires_in. When the Pkg client downloads a new auth.toml file, if there is a relative expires_in field, an absolute expires_at value is computed based on the client's current clock time. This combination of policies allows expiration to work gracefully even in the presence of clock skew between the server and the client.\n\nIf the access token is expired and there are refresh_token and refresh_url fields in auth.toml, a new auth file is requested by making a request to refresh_url with an Authorization: Bearer $refresh_token header. Pkg will refuse to make a refresh request unless refresh_url is an HTTPS URL. Note that refresh_url need not be a URL on the Pkg server: token refresh can be handled by a separate server. If the request is successful and the returned auth.toml file is a well-formed TOML file with at least an access_token field, it is saved to $(DEPOT_PATH[1])/servers/$server/auth.toml.\n\nChecking for access token expiry and refreshing auth.toml is done before each Pkg client request to a Pkg server, and if the auth file is updated the new access token is used, so the token should in theory always be up to date. Practice is different from theory, of course, and if the Pkg server considers the access token expired, it may return an HTTP 401 Unauthorized response, and the Pkg client should attempt to refresh the auth token. If, after attempting to refresh the access token, the server still returns HTTP 401 Unauthorized, the Pkg client will present the body of the error response to the user or user agent (IDE)."},{"title":"Authentication Hooks","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Authentication-Hooks","category":"section","text":"A mechanism to register a hook at the client is provided to allow the user agent to handle an auth failure. It can, for example, present a login page and take the user through the necessary authentication flow to get a new auth token and store it in auth.toml.\n\nA handler can also be registered using register_auth_error_handler. It returns a function that can be called to deregister the handler.\nA handler can also be deregistered using deregister_auth_error_handler.\n\nExample:\n\n# register a handler\ndispose = Pkg.PlatformEngines.register_auth_error_handler((url, svr, err) -> begin\n    PkgAuth.authenticate(svr*\"/auth\")\n    return true, true\nend)\n\n# ... client code ...\n\n# deregister the handler\ndispose()\n# or\nPkg.PlatformEngines.deregister_auth_error_handler(url, svr)"},{"title":"Resources","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Resources","category":"section","text":"The client can make GET or HEAD requests to the following resources:\n\n/registries: map of registry uuids at this server to their current tree hashes, each line of the response data is of the form /registry/$uuid/$hash representing a resource pointing to particular version of a registry\n/registry/$uuid/$hash: tarball of registry uuid at the given tree hash\n/package/$uuid/$hash: tarball of package uuid at the given tree hash\n/artifact/$hash: tarball of an artifact with the given tree hash\n\nOnly the /registries changes - all other resources can be cached forever and the server will indicate this with the appropriate HTTP headers."},{"title":"Compression Negotiation","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Compression-Negotiation","category":"section","text":"The Pkg protocol supports multiple compression formats.\n\nZstd compression (current): Modern clients send Accept-Encoding: zstd, gzip to request Zstandard-compressed resources with gzip as a fallback.\nGzip compression (legacy): Older clients that only support gzip send Accept-Encoding: gzip or omit the header entirely.\n\nClients verify the actual compression format by reading file magic bytes after download:\n\nZstd format: Magic bytes 0x28 0xB5 0x2F 0xFD (4 bytes) - decompressed with zstd (significantly faster)\nGzip format: Magic bytes 0x1F 0x8B (2 bytes) - decompressed with 7z"},{"title":"Reference Implementation","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Reference-Implementation","category":"section","text":"A reference implementation of the Pkg Server protocol is available at PkgServer.jl."},{"title":"The Storage Protocol","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#The-Storage-Protocol","category":"section","text":"This section describes the protocol used by Pkg Servers to get resources from Storage Servers, including the latest versions of registries, package source trees, and artifacts. The Pkg Server requests each type of resource when it needs it and caches it for as long as it can, so Storage Services should not have to serve the same resources to the same Pkg Server instance many times."},{"title":"Authentication","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Authentication-2","category":"section","text":"Since the Storage protocol is a server-to-server protocol, it uses certificate-based mutual authentication: each side of the connection presents certificates of identity to the other. The operator of a Storage Service must issue a client certificate to the operator of a Pkg Service certifying that it is authorized to use the Storage Service."},{"title":"Resources","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Resources-2","category":"section","text":"The Storage Protocol is similar to the Pkg Protocol:\n\n/registries: map of registry uuids at this server to their current tree hashes\n/registry/$uuid/$hash: tarball of registry uuid at the given tree hash\n/package/$uuid/$hash: tarball of package uuid at the given tree hash\n/artifact/$hash: tarball of an artifact with the given tree hash\n\nAs is the case with the Pkg Server protocol, only the /registries resource changes over time—all other resources are permanently cacheable and Pkg Servers are expected to cache resources indefinitely, only deleting them if they need to reclaim storage space."},{"title":"Interaction","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Interaction","category":"section","text":"Fetching resources from a single Storage Server is straightforward: the Pkg Server asks for a version of a registry by UUID and hash and the Storage Server returns a tarball of that registry tree if it knows about that registry and version, or an HTTP 404 error if it doesn't.\n\nEach Pkg Server may use multiple Storage Services for availability and depth of backup. For a given resource, the Pkg Server makes a HEAD request to each Storage Service requesting the resource, and then makes a GET request for the resource to the first Storage Server that replies to the HEAD request with a 200 OK. If no Storage Service responds with a 200 OK in enough time, the Pkg Server should respond to the request for the corresponding resource with a 404 error. Each Storage Service which responds with a 200 OK must behave as if it had served the resource, regardless of whether it does so or not - i.e. persist the resource to long-term storage.\n\nOne subtlety is how the Pkg Server determines what the latest version of each registry is. It can get a map from registry UUIDs to version hashes from each Storage Server, but hashes are unordered - if multiple Storage Servers reply with different hashes, which one should the Pkg Server use? When Storage Servers disagree on the latest hash of a registry, the Pkg Server should ask each Storage Server about the hashes that the other servers returned: if Service A knows about Service B's hash but B doesn't know about A's hash, then A's hash is more recent and should be used. If each server doesn't know about the other's hash, then neither hash is strictly newer than the other one and either could be used. The Pkg Server can break the tie any way it wants, e.g. randomly or by using the lexicographically earlier hash."},{"title":"Guarantees","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Guarantees","category":"section","text":"The primary guarantee that a Storage Server makes is that if it has ever successfully served a resource—registry tree, package source tree, artifact tree — it must be able to serve that same resource version forever.\n\nIt's tempting to also require it to guarantee that if a Storage Server serves a registry tree, it can also serve every package source tree referred to within that registry tree. Similarly, it is tempting to require that if a Storage Server can serve a package source tree that it should be able to serve any artifacts referenced by that version of the package. However, this could fail for reasons entirely beyond the control of the server: what if the registry is published with wrong package hashes? What if someone registers a package version, doesn't git tag it, then force pushes the branch that the version was on? In both of these cases, the Storage Server may not be able to fetch a version of a package through no fault of its own. Similarly, artifact hashes in packages might be incorrect or vanish before the Storage Server can retrieve them.\n\nTherefore, we don't strictly require that Storage Servers guarantee this kind of closure under resource references. We do, however, recommend that Storage Servers proactively fetch resources referred to by other resources as soon as possible. When a new version of a registry is available, the Storage Server should fetch all the new package versions in the registry immediately. When a package version is fetched—for any reason, whether because it was included in a new registry snapshot or because an upstream Pkg Server requested it by hash—all artifacts that it references should be fetched immediately."},{"title":"Verification","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#Verification","category":"section","text":"Since all resources are content addressed, the Pkg Clients and Pkg Server can and should verify that resources that they receive from upstream have the correct content hash. If a resource does not have the right hash, it should not be used and not be served further downstream. Pkg Servers should try to fetch the resource from other Storage Services and serve one that has the correct content. Pkg Clients should error if they get a resource with an incorrect content hash.\n\nGit uses SHA1 for content hashing. There is a pure Julia implementation of git's content hashing algorithm, which is being used to verify artifacts in Julia 1.3 (among other things). The SHA1 hashing algorithm is considered to be cryptographically compromised at this point, and while it's not completely broken, git is already starting to plan how to move away from using SHA1 hashes. To that end, we should consider getting ahead of this problem by using a stronger hash like SHA3-256 in these protocols. Having control over these protocols actually makes this considerably easier than if we were continuing to rely on git for resource acquisition.\n\nThe first step to using SHA3-256 instead of SHA1 is to populate registries with additional hashes for package versions. Currently each package version is identified by a git-tree-sha1 entry. We would add git-tree-sha3-256 entries that give the SHA3-256 hashes computed using the same git tree hashing logic. From this origin, the Pkg Client, Pkg Server and Storage Servers all just need to use SHA3-256 hashes rather than SHA1 hashes."},{"title":"References","page":"14. Package and Storage Server Protocol Reference","location":"protocol/#References","category":"section","text":"Pkg & Storage Protocols https://github.com/JuliaLang/Pkg.jl/issues/1377\nAuthenticated Pkg Client Support: https://github.com/JuliaLang/Pkg.jl/pull/1538\nAuthentication Hooks: https://github.com/JuliaLang/Pkg.jl/pull/1630"},{"title":"8. Registries","page":"8. Registries","location":"registries/#**8.**-Registries","category":"section","text":"Registries contain information about packages, such as\navailable releases and dependencies, and where they can be downloaded.\nThe General registry\nis the default one, and is installed automatically if there are no\nother registries installed."},{"title":"Managing registries","page":"8. Registries","location":"registries/#Managing-registries","category":"section","text":"Registries can be added, removed and updated from either the Pkg REPL\nor by using the functional API. In this section we will describe the\nREPL interface. The registry API is documented in\nthe Registry API Reference section."},{"title":"Adding registries","page":"8. Registries","location":"registries/#Adding-registries","category":"section","text":"A custom registry can be added with the registry add command\nfrom the Pkg REPL. Usually this will be done with a URL to the\nregistry.\n\nIf a custom registry has been installed causing the General registry\nto not be automatically installed, it is easy to add it manually:\n\npkg> registry add General\n\nand now all the packages registered in General are available for e.g. adding.\nTo see which registries are currently installed you can use the registry status\n(or registry st) command\n\npkg> registry st\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)\n\nRegistries are always added to the user depot, which is the first entry in DEPOT_PATH (cf. the Glossary section).\n\nnote: Registries from a package server\nIt is possible for a package server to be advertising additional available package\nregistries. When Pkg runs with a clean Julia depot (e.g. after a fresh install), with\na custom package server configured with JULIA_PKG_SERVER, it will automatically\nadd all such available registries. If the depot already has some registries installed\n(e.g. General), the additional ones can easily be installed with the no-argument\nregistry add command."},{"title":"Removing registries","page":"8. Registries","location":"registries/#Removing-registries","category":"section","text":"Registries can be removed with the registry remove (or registry rm) command.\nHere we remove the General registry\n\npkg> registry rm General\n  Removing registry `General` from ~/.julia/registries/General\n\npkg> registry st\nRegistry Status\n  (no registries found)\n\nIn case there are multiple registries named General installed you have to\ndisambiguate with the uuid, just as when manipulating packages, e.g.\n\npkg> registry rm General=23338594-aafe-5451-b93e-139f81909106\n  Removing registry `General` from ~/.julia/registries/General"},{"title":"Updating registries","page":"8. Registries","location":"registries/#Updating-registries","category":"section","text":"The registry update (or registry up) command is available to update registries.\nHere we update the General registry:\n\npkg> registry up General\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`\n\nand to update all installed registries just do:\n\npkg> registry up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`\n\nRegistries automatically update once per session when a package operation is performed so it\nrarely has to be done manually."},{"title":"Registry format","page":"8. Registries","location":"registries/#Registry-format","category":"section","text":"In a registry, each package gets its own directory; in that directory\nare the following files: Compat.toml, Deps.toml, Package.toml,\nand Versions.toml.\nThe formats of these files are described below."},{"title":"Registry Package.toml","page":"8. Registries","location":"registries/#Registry-Package.toml","category":"section","text":"The Package.toml file contains basic metadata about the package, such as its name, UUID, repository URL, and optional metadata."},{"title":"Package metadata","page":"8. Registries","location":"registries/#Package-metadata","category":"section","text":"The [metadata] table in Package.toml provides a location for metadata about the package that doesn't fit into the other registry files. This is an extensible framework for adding package-level metadata."},{"title":"Deprecated packages","page":"8. Registries","location":"registries/#Deprecated-packages","category":"section","text":"One use of the [metadata] table is to mark packages as deprecated using [metadata.deprecated]. Deprecated packages will:\n\nShow as [deprecated] in package status output\nBe excluded from tab-completion suggestions\nStill be installable and usable\n\nThe [metadata.deprecated] table can contain arbitrary metadata fields. Two special fields are recognized by Pkg and displayed when using pkg> status --deprecated:\n\nreason: A string explaining why the package is deprecated\nalternative: A string suggesting a replacement package\n\nExample:\n\nname = \"MyPackage\"\nuuid = \"...\"\nrepo = \"...\"\n\n[metadata.deprecated]\nreason = \"This package is no longer maintained\"\nalternative = \"ReplacementPackage\"\n\nOther fields can be added to [metadata.deprecated] for use by registries or other tools."},{"title":"Registry Compat.toml","page":"8. Registries","location":"registries/#Registry-Compat.toml","category":"section","text":"The Compat.toml file has a series of blocks specifying version\nnumbers, with a set of dependencies listed below. For example,\npart of such a file might look like this:\n\n[\"0.8-0.8.3\"]\nDependencyA = \"0.4-0.5\"\nDependencyB = \"0.3-0.5\"\n\n[\"0.8.2-0.8.5\"]\nDependencyC = \"0.7-0\"\n\nDependencies that are unchanged across a range of versions are grouped\ntogether in these blocks. The interpretation of these ranges is given by the comment after each line below:\n\n\"0.7-0.8\"  # [0.7.0, 0.9.0)\n\"0.7-0\"    # [0.7.0, 1.0.0)\n\"0.8.6-0\"  # [0.8.6, 1.0.0)\n\"0.7-*\"    # [0.7.0, ∞)\n\nSo for this package, versions [0.8.0, 0.8.3] depend on versions [0.4.0, 0.6.0) of DependencyA and version [0.3.0, 0.6.0) of DependencyB.\nMeanwhile, it is also true that versions [0.8.2, 0.8.5] require specific versions of DependencyC (so that all three are required for versions 0.8.2 and 0.8.3)."},{"title":"Registry formats","page":"8. Registries","location":"registries/#Registry-formats","category":"section","text":"compat: Julia 1.7\nCompressed registry formats are available starting with Julia 1.7.\n\nRegistries can be installed in several different formats, each with different tradeoffs:"},{"title":"Compressed registries (preferred)","page":"8. Registries","location":"registries/#Compressed-registries-(preferred)","category":"section","text":"When using a package server (the default), registries are downloaded as compressed tarballs. This is the preferred format for the General registry because it is:\n\nFast for the initial download: Only a single compressed file needs to be transferred\nFast to use: Pkg reads data directly from the packed tarball, avoiding many small filesystem reads\nLow disk usage: The registry can be read directly from the compressed file without extraction\n\nYou can check if a registry is compressed by running Pkg.Registry.status(), which will describe it as a \"packed registry\" when it remains in its tarball and an \"unpacked registry\" when the files have been extracted to disk."},{"title":"Git registries","page":"8. Registries","location":"registries/#Git-registries","category":"section","text":"Registries can also be installed as git clones. This format:\n\nProvides immediate updates: Running Pkg.Registry.update() fetches the latest changes directly from the git repository\nUses more disk space: The full git history is stored locally\nMay be slower: Cloning and updating can take longer than downloading a compressed tarball\nIntegrates with local tooling: All registry files are present on disk, so you can inspect or customize them using familiar editors and git workflows\n\nTo install a registry as a git clone, use:\n\nPkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")"},{"title":"Converting between formats","page":"8. Registries","location":"registries/#Converting-between-formats","category":"section","text":"To convert an existing registry from git to compressed (or vice versa), remove and re-add it:\n\n# Convert to compressed (uses package server if available)\npkg> registry rm General\n\npkg> registry add General\n\n# Convert to git\npkg> registry rm General\n\npkg> registry add https://github.com/JuliaRegistries/General.git\n\nnote: Note\nThe environment variable JULIA_PKG_SERVER controls whether package servers are used. Setting it to an empty string (JULIA_PKG_SERVER=\"\") disables package server usage and forces git clones. To force unpacking even when using a package server, set JULIA_PKG_UNPACK_REGISTRY=true."},{"title":"Registry flavors","page":"8. Registries","location":"registries/#Registry-flavors","category":"section","text":"The default Pkg Server (pkg.julialang.org) offers two different \"flavors\" of registry.\n\ncompat: Julia 1.8\nRegistry flavors are only available starting with Julia 1.8.\n\nconservative: suitable for most users; all packages and artifacts in this registry flavor are available from the Pkg Server, with no need to download from other sources\neager: this registry offers the latest versions of packages, even if the Pkg and Storage Servers have not finished processing them; thus, some packages and artifacts may not be available from the Pkg Server, and thus may need to be downloaded from other sources (such as GitHub)\n\nThe default registry flavor is conservative. We recommend that most users stick to the conservative flavor unless they know that they need to use the eager flavor.\n\nTo select the eager flavor:\n\nENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"eager\"\n\nimport Pkg\n\nPkg.Registry.update()\n\nTo select the conservative flavor:\n\nENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"conservative\"\n\nimport Pkg\n\nPkg.Registry.update()"},{"title":"Creating and maintaining registries","page":"8. Registries","location":"registries/#Creating-and-maintaining-registries","category":"section","text":"Pkg only provides client facilities for registries, rather than functionality to create\nor maintain them. However, Registrator.jl\nand LocalRegistry.jl provide ways to\ncreate and update registries, and RegistryCI.jl\nprovides automated testing and merging functionality for maintaining a registry."},{"title":"1. Introduction","page":"1. Introduction","location":"#**1.**-Introduction","category":"section","text":"Welcome to the documentation for Pkg, Julia's package manager.\nThe documentation covers many things, for example managing package\ninstallations, developing packages, working with package registries and more.\n\nimport Markdown\n# For Pkg, we need to determine the appropriate Julia version for the PDF\n# Since Pkg docs are versioned by Julia version, we'll use a similar approach to Julia docs\njulia_patch = if VERSION.prerelease == ()\n    \"v$(VERSION.major).$(VERSION.minor).$(VERSION.patch)\"\nelseif VERSION.prerelease[1] == \"DEV\"\n    \"dev\"\nend\nfile = \"Pkg.jl.pdf\"\nurl = \"https://raw.githubusercontent.com/JuliaLang/Pkg.jl/gh-pages-pdf/$(julia_patch)/$(file)\"\nMarkdown.parse(\"\"\"\n!!! note\n    The documentation is also available in PDF format: [$file]($url).\n\"\"\")\n\nThroughout the manual the REPL interface to Pkg, the Pkg REPL mode, is used in the examples.\nThere is also a functional API, which is preferred when not working\ninteractively. This API is documented in the API Reference section."},{"title":"Background and Design","page":"1. Introduction","location":"#Background-and-Design","category":"section","text":"Unlike traditional\npackage managers, which install and manage a single global set of packages, Pkg\nis designed around “environments”: independent sets of packages that can be\nlocal to an individual project or shared and selected by name. The exact set of\npackages and versions in an environment is captured in a manifest file which\ncan be checked into a project repository and tracked in version control,\nsignificantly improving reproducibility of projects. If you’ve ever tried to run\ncode you haven’t used in a while only to find that you can’t get anything to\nwork because you’ve updated or uninstalled some of the packages your project was\nusing, you’ll understand the motivation for this approach. In Pkg, since each\nproject maintains its own independent set of package versions, you’ll never have\nthis problem again. Moreover, if you check out a project on a new system, you\ncan simply materialize the environment described by its manifest file and\nimmediately be up and running with a known-good set of dependencies.\n\nSince environments are managed and updated independently from each other,\n“dependency hell” is significantly alleviated in Pkg. If you want to use the\nlatest and greatest version of some package in a new project but you’re stuck on\nan older version in a different project, that’s no problem – since they have\nseparate environments they can just use different versions, which are both\ninstalled at the same time in different locations on your system. The location\nof each package version is canonical, so when environments use the same versions\nof packages, they can share installations, avoiding unnecessary duplication of\nthe package. Old package versions that are no longer used by any environments\nare periodically “garbage collected” by the package manager.\n\nPkg’s approach to local environments may be familiar to people who have used\nPython’s virtualenv or Ruby’s bundler. In Julia, instead of hacking the\nlanguage’s code loading mechanisms to support environments, we have the benefit\nthat Julia natively understands them. In addition, Julia environments are\n“stackable”: you can overlay one environment with another and thereby have\naccess to additional packages outside of the primary environment. This makes it\neasy to work on a project, which provides the primary environment, while still\nhaving access from the REPL to all your usual dev tools like profilers,\ndebuggers, and so on, just by having an environment including these dev tools\nlater in the load path.\n\nLast but not least, Pkg is designed to support federated package registries.\nThis means that it allows multiple registries managed by different parties to\ninteract seamlessly. In particular, this includes private registries which can\nlive behind corporate firewalls. You can install and update your own packages\nfrom a private registry with exactly the same tools and workflows that you use\nto install and manage official Julia packages. If you urgently need to apply a\nhotfix for a public package that’s critical to your company’s product, you can\ntag a private version of it in your company’s internal registry and get a fix to\nyour developers and ops teams quickly and easily without having to wait for an\nupstream patch to be accepted and published. Once an official fix is published,\nhowever, you can just upgrade your dependencies and you'll be back on an\nofficial release again."},{"title":"10. Glossary","page":"10. Glossary","location":"glossary/#Glossary","category":"section","text":"Project: a source tree with a standard layout, including a src directory\nfor the main body of Julia code, a test directory for testing the project,\na docs directory for documentation files, and optionally a deps directory for a build\nscript and its outputs. A project will typically also have a project file and\nmay optionally have a manifest file:\n\nProject file: a file in the root directory of a project, named\nProject.toml (or JuliaProject.toml), describing metadata about the project,\nincluding its name, UUID (for packages), authors, license, and the names and\nUUIDs of packages and libraries that it depends on.\nManifest file: a file in the root directory of a project, named\nManifest.toml (or JuliaManifest.toml), describing a complete dependency graph\nand exact versions of each package and library used by a project. The file name may\nalso be suffixed by -v{major}.{minor}.toml which Julia will prefer if the version\nmatches VERSION, allowing multiple environments to be maintained for different Julia\nversions.\n\nPackage: a project which provides reusable functionality that can be used by\nother Julia projects via import X or using X. A package should have a\nproject file with a uuid entry giving its package UUID. This UUID is used to\nidentify the package in projects that depend on it.\n\nnote: Note\nFor legacy reasons, it is possible to load a package without a project file or\nUUID from the REPL or the top-level of a script. It is not possible, however,\nto load a package without a project file or UUID from a project with them. Once\nyou've loaded from a project file, everything needs a project file and UUID.\n\nnote: Note\nPackages vs. Modules: A package is a source tree with a Project.toml file\nand other components that Pkg can install and manage. A module is a Julia language\nconstruct (created with the module keyword) that provides a namespace for code.\nTypically, a package contains a module of the same name (e.g., the DataFrames package\ncontains a DataFrames module), but they are distinct concepts: the package is the\ndistributable unit that Pkg manages, while the module is the namespace that your code\ninteracts with using import or using.\n\nApplication: a project which provides standalone functionality not intended\nto be reused by other Julia projects. For example a web application or a\ncommand-line utility, or simulation/analytics code accompanying a scientific paper.\nAn application may have a UUID but does not need one.\nAn application may also set and change the global configurations of packages it\ndepends on. Packages, on the other hand, may not change the global state of their dependencies\nsince that could conflict with the configuration of the main application.\n\nnote: Note\nProjects vs. Packages vs. Applications:Project is an umbrella term: packages and applications are kinds of projects.\nPackages should have UUIDs, applications can have UUIDs but don't need them.\nApplications can provide global configuration, whereas packages cannot.\n\nEnvironment: the combination of the top-level name map provided by a project\nfile combined with the dependency graph and map from packages to their entry points\nprovided by a manifest file. For more detail see the manual section on code loading.\n\nExplicit environment: an environment in the form of an explicit project\nfile and an optional corresponding manifest file together in a directory. If the\nmanifest file is absent then the implied dependency graph and location maps are\nempty.\nImplicit environment: an environment provided as a directory (without a\nproject file or manifest file) containing packages with entry points of the form\nX.jl, X.jl/src/X.jl or X/src/X.jl. The top-level name map is implied by\nthese entry points. The dependency graph is implied by the existence of project\nfiles inside of these package directories, e.g. X.jl/Project.toml or\nX/Project.toml. The dependencies of the X package are the dependencies in\nthe corresponding project file if there is one. The location map is implied by\nthe entry points themselves.\n\nRegistry: a source tree with a standard layout recording metadata about a\nregistered set of packages, the tagged versions of them which are available, and\nwhich versions of packages are compatible or incompatible with each other. A\nregistry is indexed by package name and UUID, and has a directory for each\nregistered package providing the following metadata about it:\n\nname – e.g. DataFrames\nUUID – e.g. a93c6f00-e57d-5684-b7b6-d8193f3e46c0\nrepository – e.g. https://github.com/JuliaData/DataFrames.jl.git\nversions – a list of all registered version tags\n\nFor each registered version of a package, the following information is provided:\n\nits semantic version number – e.g. v1.2.3\nits git tree SHA-1 hash – e.g. 7ffb18ea3245ef98e368b02b81e8a86543a11103\na map from names to UUIDs of dependencies\nwhich versions of other packages it is compatible/incompatible with\n\nDependencies and compatibility are stored in a compressed but human-readable\nformat using ranges of package versions.\n\nDepot: a directory on a system where various package-related resources live,\nincluding:\n\nenvironments: shared named environments (e.g. v1.0, devtools)\nclones: bare clones of package repositories\ncompiled: cached compiled package images (.ji files)\nconfig: global configuration files (e.g. startup.jl)\ndev: default directory for package development\nlogs: log files (e.g. manifest_usage.toml, repl_history.jl)\npackages: installed package versions\nregistries: clones of registries (e.g. General)\n\nLoad path: a stack of environments where package identities, their\ndependencies, and entry points are searched for. The load path is controlled in\nJulia by the LOAD_PATH global variable which is populated at startup based on\nthe value of the JULIA_LOAD_PATH environment variable. The first entry is your\nprimary environment, often the current project, while later entries provide\nadditional packages one may want to use from the REPL or top-level scripts.\n\nDepot path: a stack of depot locations where the package manager, as well as\nJulia's code loading mechanisms, look for registries, installed packages, named\nenvironments, repo clones, cached compiled package images, and configuration\nfiles. The depot path is controlled by the Julia DEPOT_PATH global variable\nwhich is populated at startup based on the value of the JULIA_DEPOT_PATH\nenvironment variable. The first entry is the \"user depot\" and should be writable\nby and owned by the current user. The user depot is where: registries are\ncloned, new package versions are installed, named environments are created and\nupdated, package repositories are cloned, newly compiled package image files are saved,\nlog files are written, development packages are checked out by default, and\nglobal configuration data is saved. Later entries in the depot path are treated\nas read-only and are appropriate for registries, packages, etc. installed and\nmanaged by system administrators.\n\nMaterialize: the process of installing all packages and dependencies specified\nin a manifest file to recreate an exact environment state. When you\ninstantiate a project, Pkg materializes its environment by downloading and\ninstalling all the exact package versions recorded in the Manifest.toml file.\nThis ensures reproducibility across different machines and users.\n\nCanonical: refers to a single, authoritative location for each specific\nversion of a package. When the same package version is used by multiple\nenvironments, Pkg stores it in one canonical location and all environments\nreference that same location, rather than duplicating the package files. This\nsaves disk space and ensures consistency."},{"title":"11. REPL Mode Reference","page":"11. REPL Mode Reference","location":"repl/#REPL-Mode-Reference","category":"section","text":"This section describes available commands in the Pkg REPL.\nThe Pkg REPL mode is mostly meant for interactive use,\nand for non-interactive use it is recommended to use the\nfunctional API, see API Reference."},{"title":"package commands","page":"11. REPL Mode Reference","location":"repl/#package-commands","category":"section","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-add\" href=\"#repl-add\">\n            <code>add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"add\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-build\" href=\"#repl-build\">\n            <code>build</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"build\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-compat\" href=\"#repl-compat\">\n            <code>compat</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"compat\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-develop\" href=\"#repl-develop\">\n            <code>develop</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"develop\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-free\" href=\"#repl-free\">\n            <code>free</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"free\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-generate\" href=\"#repl-generate\">\n            <code>generate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"generate\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-pin\" href=\"#repl-pin\">\n            <code>pin</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"pin\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-remove\" href=\"#repl-remove\">\n            <code>remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"remove\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-test\" href=\"#repl-test\">\n            <code>test</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"test\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-update\" href=\"#repl-update\">\n            <code>update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"update\"].help\n\n    </section>\n</article>"},{"title":"registry commands","page":"11. REPL Mode Reference","location":"repl/#registry-commands","category":"section","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-add\" href=\"#repl-registry-add\">\n            <code>registry add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry add\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-remove\" href=\"#repl-registry-remove\">\n            <code>registry remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry remove\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-status\" href=\"#repl-registry-status\">\n            <code>registry status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry status\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-update\" href=\"#repl-registry-update\">\n            <code>registry update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry update\"].help\n\n    </section>\n</article>"},{"title":"Other commands","page":"11. REPL Mode Reference","location":"repl/#Other-commands","category":"section","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-activate\" href=\"#repl-activate\">\n            <code>activate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"activate\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-gc\" href=\"#repl-gc\">\n            <code>gc</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"gc\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-help\" href=\"#repl-help\">\n            <code>help</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"help\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-instantiate\" href=\"#repl-instantiate\">\n            <code>instantiate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"instantiate\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-precompile\" href=\"#repl-precompile\">\n            <code>precompile</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"precompile\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-resolve\" href=\"#repl-resolve\">\n            <code>resolve</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"resolve\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-status\" href=\"#repl-status\">\n            <code>status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"status\"].help\n\n    </section>\n</article>"},{"title":"2. Getting Started","page":"2. Getting Started","location":"getting-started/#**2.**-Getting-Started","category":"section","text":"What follows is a quick overview of the basic features of Pkg.\nIt should help new users become familiar with basic Pkg features such as adding and removing packages and\nworking with environments.\n\nnote: Note\nSome Pkg output is omitted in this section in order to keep this basic guide focused.\nThis will help maintain a good pace and not get bogged down in details.\nIf you require more details, refer to subsequent sections of the Pkg manual.\n\nnote: Note\nThis guide uses the Pkg REPL to execute Pkg commands.\nFor non-interactive use, we recommend the Pkg API.\nThe Pkg API is fully documented in the API Reference section of the Pkg documentation."},{"title":"Basic Usage","page":"2. Getting Started","location":"getting-started/#Basic-Usage","category":"section","text":"Pkg comes with a REPL.\nEnter the Pkg REPL by pressing ] from the Julia REPL.\nTo get back to the Julia REPL, press Ctrl+C or backspace (when the REPL cursor is at the beginning of the input).\n\nUpon entering the Pkg REPL, you should see the following prompt:\n\n(@v1.10) pkg>\n\nTo add a package, use add:\n\n(@v1.10) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\nAfter the package is installed, it can be loaded into the Julia session:\n\njulia> import Example\n\njulia> Example.hello(\"friend\")\n\"Hello, friend\"\n\nWe can also specify multiple packages at once to install:\n\n(@v1.10) pkg> add JSON StaticArrays\n\nThe status command (or the shorter st command) can be used to see installed packages.\n\n(@v1.10) pkg> st\nStatus `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n  [90137ffa] StaticArrays v1.5.9\n\nnote: Note\nSome Pkg REPL commands have a short and a long version of the command, for example status and st.\n\nTo remove packages, use rm (or remove):\n\n(@v1.10) pkg> rm JSON StaticArrays\n\nUse up (or update) to update the installed packages\n\n(@v1.10) pkg> up\n\nIf you have been following this guide it is likely that the packages installed are at the latest version\nso up will not do anything. Below we show the status output in the case where we deliberately have installed\nan old version of the Example package and then upgrade it:\n\n(@v1.10) pkg> st\nStatus `~/.julia/environments/v1.10/Project.toml`\n⌃ [7876af07] Example v0.5.1\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.10) pkg> up\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [7876af07] ↑ Example v0.5.1 ⇒ v0.5.3\n\nWe can see that the status output tells us that there is a newer version available and that up upgrades the package.\n\nFor more information about managing packages, see the Managing Packages section of the documentation."},{"title":"Getting Started with Environments","page":"2. Getting Started","location":"getting-started/#Getting-Started-with-Environments","category":"section","text":"Up to this point, we have covered basic package management: adding, updating, and removing packages.\n\nYou may have noticed the (@v1.10) in the REPL prompt.\nThis lets us know that v1.10 is the active environment.\nDifferent environments can have totally different packages and versions installed from another environment.\nThe active environment is the environment that will be modified by Pkg commands such as add, rm and update.\n\nLet's set up a new environment so we may experiment.\nTo set the active environment, use activate:\n\n(@v1.10) pkg> activate tutorial\n[ Info: activating new environment at `~/tutorial/Project.toml`.\n\nPkg lets us know we are creating a new environment and that this environment\nwill be stored in the ~/tutorial directory. The path to the environment\nis created relative to the current working directory of the REPL.\n\nPkg has also updated the REPL prompt in order to reflect the new\nactive environment:\n\n(tutorial) pkg>\n\nWe can ask for information about the active environment by using status:\n\n(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n   (empty environment)\n\n~/tutorial/Project.toml is the location of the active environment's project file.\nA project file is a TOML file where Pkg stores the packages that have been explicitly installed.\nNotice this new environment is empty.\nLet us add some packages and observe:\n\n(tutorial) pkg> add Example JSON\n...\n\n(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n\nWe can see that the tutorial environment now contains Example and JSON.\n\nnote: Note\nIf you have the same\npackage (at the same version) installed in multiple environments, the package\nwill only be downloaded and stored on the hard drive once. This makes environments\nvery lightweight and effectively free to create. Using only the default\nenvironment with a huge number of packages in it is a common beginners mistake in\nJulia. Learning how to use environments effectively will improve your experience with\nJulia packages.\n\nWhen you're done working in a specific environment and want to return to the default environment, use activate with no arguments:\n\n(tutorial) pkg> activate\n  Activating project at `~/.julia/environments/v1.10`\n\n(@v1.10) pkg>\n\nThis returns you to the default @v1.10 environment. There is no separate \"deactivate\" command—activate with no arguments serves this purpose.\n\nFor more information about environments, see the Working with Environments section of the documentation."},{"title":"Asking for Help","page":"2. Getting Started","location":"getting-started/#Asking-for-Help","category":"section","text":"If you are ever stuck, you can ask Pkg for help:\n\n(@v1.10) pkg> ?\n\nYou should see a list of available commands along with short descriptions.\nYou can ask for more detailed help by specifying a command:\n\n(@v1.10) pkg> ?develop\n\nThis guide should help you get started with Pkg.\nPkg has much more to offer in terms of powerful package management.\nFor more advanced topics, see Managing Packages, Working with Environments, and Creating Packages."},{"title":"9. Artifacts","page":"9. Artifacts","location":"artifacts/#Artifacts","category":"section","text":"Pkg can install and manage containers of data that are not Julia packages.  These containers can contain platform-specific binaries, datasets, text, or any other kind of data that would be convenient to place within an immutable, life-cycled datastore.\nThese containers, (called \"Artifacts\") can be created locally, hosted anywhere, and automatically downloaded and unpacked upon installation of your Julia package.\nThis mechanism is also used to provide the binary dependencies for packages built with BinaryBuilder.jl."},{"title":"Basic Usage","page":"9. Artifacts","location":"artifacts/#Basic-Usage","category":"section","text":"Pkg artifacts are declared in an Artifacts.toml file, which can be placed in your current directory or in the root of your package.\nCurrently, Pkg supports downloading of tarfiles (which can be compressed) from a URL.\nFollowing is a minimal Artifacts.toml file which will permit the downloading of a socrates.tar.gz file from github.com.\nIn this example, a single artifact, given the name socrates, is defined.\n\n# a simple Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\nIf this Artifacts.toml file is placed in your current directory, then socrates.tar.gz can be downloaded, unpacked and used with artifact\"socrates\".\nSince this tarball contains a folder bin, and a text file named socrates within that folder, we could access the content of that file as follows.\n\nusing Pkg.Artifacts\n\nrootpath = artifact\"socrates\"\nopen(joinpath(rootpath, \"bin\", \"socrates\")) do file\n    println(read(file, String))\nend\n\nIf you have an existing tarball that is accessible via a url, it could also be accessed in this manner.\nTo create the Artifacts.toml you must compute two hashes: the sha256 hash of the download file, and the git-tree-sha1 of the unpacked content.\nThese can be computed as follows.\n\nusing Tar, Inflate, SHA\n\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))\n\nTo access this artifact from within a package you create, place the Artifacts.toml at the root of your package, adjacent to Project.toml. Then, make sure to add Pkg in your deps and set julia = \"1.3\" or higher in your compat section."},{"title":"Artifacts.toml files","page":"9. Artifacts","location":"artifacts/#Artifacts.toml-files","category":"section","text":"Pkg provides an API for working with artifacts, as well as a TOML file format for recording artifact usage in your packages, and to automate downloading of artifacts at package install time.\nArtifacts can always be referred to by content hash, but are typically accessed by a name that is bound to a content hash in an Artifacts.toml file that lives in a project's source tree.\n\nnote: Note\nIt is possible to use the alternate name JuliaArtifacts.toml, similar\nto how it is possible to use JuliaProject.toml and JuliaManifest.toml\ninstead of Project.toml and Manifest.toml, respectively.\n\nAn example Artifacts.toml file is shown here:\n\n# Example Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\nlazy = true\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2\"\n    sha256 = \"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"4bdf4556050cb55b67b211d4e78009aaec378cbc\"\nlibc = \"musl\"\nos = \"linux\"\n\n    [[c_simple.download]]\n    sha256 = \"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"51264dbc770cd38aeb15f93536c29dc38c727e4c\"\nos = \"macos\"\n\n    [[c_simple.download]]\n    sha256 = \"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz\"\n\n[processed_output]\ngit-tree-sha1 = \"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200\"\n\nThis Artifacts.toml binds three artifacts; one named socrates, one named c_simple and one named processed_output.\nThe single required piece of information for an artifact is its git-tree-sha1.\nBecause artifacts are addressed only by their content hash, the purpose of an Artifacts.toml file is to provide metadata about these artifacts, such as binding a human-readable name to a content hash, providing information about where an artifact may be downloaded from, or even binding a single name to multiple hashes, keyed by platform-specific constraints such as operating system or libgfortran version."},{"title":"Artifact types and properties","page":"9. Artifacts","location":"artifacts/#Artifact-types-and-properties","category":"section","text":"In the above example, the socrates artifact showcases a platform-independent artifact with multiple download locations.\nWhen downloading and installing the socrates artifact, URLs will be attempted in order until one succeeds.\nThe socrates artifact is marked as lazy, which means that it will not be automatically downloaded when the containing package is installed, but rather will be downloaded on-demand when the package first attempts to use it.\n\nThe c_simple artifact showcases a platform-dependent artifact, where each entry in the c_simple array contains keys that help the calling package choose the appropriate download based on the particulars of the host machine.\nNote that each artifact contains both a git-tree-sha1 and a sha256 for each download entry.  This is to ensure that the downloaded tarball is secure before attempting to unpack it, as well as enforcing that all tarballs must expand to the same overall tree hash.\n\nThe processed_output artifact contains no download stanza, and so cannot be installed.\nAn artifact such as this would be the result of code that was previously run, generating a new artifact and binding the resultant hash to a name within this project."},{"title":"Using Artifacts","page":"9. Artifacts","location":"artifacts/#Using-Artifacts","category":"section","text":"Artifacts can be manipulated using convenient APIs exposed from the Pkg.Artifacts namespace.\nAs a motivating example, let us imagine that we are writing a package that needs to load the Iris machine learning dataset.\nWhile we could just download the dataset during a build step into the package directory, and many packages currently do precisely this, that has some significant drawbacks:\n\nFirst, it modifies the package directory, making package installation stateful, which we want to avoid.\nIn the future, we would like to reach the point where packages can be installed completely read-only, instead of being able to modify themselves after installation.\nSecond, the downloaded data is not shared across different versions of our package.\nIf we have three different versions of the package installed for use by various projects, then we need three different copies of the data, even if it hasn't changed between those versions.\nMoreover, each time we upgrade or downgrade the package unless we do something clever (and probably brittle), we have to download the data again.\n\nWith artifacts, we will instead check to see if our iris artifact already exists on-disk and only if it doesn't will we download and install it, after which we can bind the result into our Artifacts.toml file:\n\nusing Pkg.Artifacts\n\n# This is the path to the Artifacts.toml we will manipulate\nartifact_toml = joinpath(@__DIR__, \"Artifacts.toml\")\n\n# Query the `Artifacts.toml` file for the hash bound to the name \"iris\"\n# (returns `nothing` if no such binding exists)\niris_hash = artifact_hash(\"iris\", artifact_toml)\n\n# If the name was not bound, or the hash it was bound to does not exist, create it!\nif iris_hash == nothing || !artifact_exists(iris_hash)\n    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n    iris_hash = create_artifact() do artifact_dir\n        # We create the artifact by simply downloading a few files into the new artifact directory\n        iris_url_base = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris\"\n        download(\"$(iris_url_base)/iris.data\", joinpath(artifact_dir, \"iris.csv\"))\n        download(\"$(iris_url_base)/bezdekIris.data\", joinpath(artifact_dir, \"bezdekIris.csv\"))\n        download(\"$(iris_url_base)/iris.names\", joinpath(artifact_dir, \"iris.names\"))\n    end\n\n    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n    # the content hash to change, so this should not cause unnecessary version control churn.\n    bind_artifact!(artifact_toml, \"iris\", iris_hash)\nend\n\n# Get the path of the iris dataset, either newly created or previously generated.\n# this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`\niris_dataset_path = artifact_path(iris_hash)\n\nFor the specific use case of using artifacts that were previously bound, we have the shorthand notation artifact\"name\" which will automatically search for the Artifacts.toml file contained within the current package, look up the given artifact by name, install it if it is not yet installed, then return the path to that given artifact.\nAn example of this shorthand notation is given below:\n\nusing Pkg.Artifacts\n\n# For this to work, an `Artifacts.toml` file must be in the current working directory\n# (or in the root of the current package) and must define a mapping for the \"iris\"\n# artifact.  If it does not exist on-disk, it will be downloaded.\niris_dataset_path = artifact\"iris\""},{"title":"The Pkg.Artifacts API","page":"9. Artifacts","location":"artifacts/#The-Pkg.Artifacts-API","category":"section","text":"The Artifacts API is broken up into three levels: hash-aware functions, name-aware functions and utility functions.\n\nHash-aware functions deal with content-hashes and essentially nothing else. These methods allow you to query whether an artifact exists, what its path is, verify that an artifact satisfies its content hash on-disk, etc.  Hash-aware functions include: artifact_exists(), artifact_path(), remove_artifact(), verify_artifact() and archive_artifact().  Note that in general you should not use remove_artifact() and should instead use Pkg.gc() to cleanup artifact installations.\nName-aware functions deal with bound names within an Artifacts.toml file, and as such, typically require both a path to an Artifacts.toml file as well as the artifact name.  Name-aware functions include: artifact_meta(), artifact_hash(), bind_artifact!(), unbind_artifact!(), download_artifact() and ensure_artifact_installed().\nUtility functions deal with miscellaneous aspects of artifact life, such as create_artifact(), ensure_all_artifacts_installed(), and even the @artifact_str string macro.\n\nFor a full listing of docstrings and methods, see the Artifacts Reference section."},{"title":"Overriding artifact locations","page":"9. Artifacts","location":"artifacts/#Overriding-artifact-locations","category":"section","text":"It is occasionally necessary to be able to override the location and content of an artifact.\nA common use case is a computing environment where certain versions of a binary dependency must be used, regardless of what version of this dependency a package was published with.\nWhile a typical Julia configuration would download, unpack and link against a generic library, a system administrator may wish to disable this and instead use a library already installed on the local machine.\nTo enable this, Pkg supports a per-depot Overrides.toml file placed within the artifacts depot directory (e.g. ~/.julia/artifacts/Overrides.toml for the default user depot) that can override the location of an artifact either by content-hash or by package UUID and bound artifact name.\nAdditionally, the destination location can be either an absolute path, or a replacement artifact content hash.\nThis allows sysadmins to create their own artifacts which they can then use by overriding other packages to use the new artifact.\n\n# Override single hash to an absolute path\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/replacement\"\n\n# Override single hash to new artifact content-hash\n683942669b4639019be7631caa28c38f3e1924fe = \"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3\"\n\n# Override package bindings by specifying the package UUID and bound artifact name\n# For demonstration purposes we assume this package is called `Foo`\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"/path/to/libfoo\"\nlibbar = \"683942669b4639019be7631caa28c38f3e1924fe\"\n\nDue to the layered nature of Pkg depots, multiple Overrides.toml files may be in effect at once.\nThis allows the \"inner\" Overrides.toml files to override the overrides placed within the \"outer\" Overrides.toml files.\nTo remove an override and re-enable default location logic for an artifact, insert an entry mapping to the empty string:\n\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/new/replacement\"\n683942669b4639019be7631caa28c38f3e1924fe = \"\"\n\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"\"\n\nIf the two Overrides.toml snippets as given above are layered on top of each other, the end result will be mapping the content-hash 78f35e74ff113f02274ce60dab6e92b4546ef806 to \"/path/to/new/replacement\", and mapping Foo.libbar to the artifact identified by the content-hash 683942669b4639019be7631caa28c38f3e1924fe.\nNote that while that hash was previously overridden, it is no longer, and therefore Foo.libbar will look directly at locations such as ~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe.\n\nMost methods that are affected by overrides can ignore overrides by setting honor_overrides=false as a keyword argument within them.\nFor UUID/name-based overrides to work, Artifacts.toml files must be loaded with the knowledge of the UUID of the loading package.\nThis is deduced automatically by the artifacts\"\" string macro, however, if you are for some reason manually using the Pkg.Artifacts API within your package and you wish to honor overrides, you must provide the package UUID to API calls like artifact_meta() and ensure_artifact_installed() via the pkg_uuid keyword argument."},{"title":"Extending Platform Selection","page":"9. Artifacts","location":"artifacts/#Extending-Platform-Selection","category":"section","text":"compat: Julia 1.7\nPkg's extended platform selection requires at least Julia 1.7, and is considered experimental.\n\nNew in Julia 1.7, Platform objects can have extended attributes applied to them, allowing artifacts to be tagged with things such as CUDA driver version compatibility, microarchitectural compatibility, julia version compatibility and more!\nNote that this feature is considered experimental and may change in the future.\nIf you as a package developer find yourself needing this feature, please get in contact with us so it can evolve for the benefit of the whole ecosystem.\nIn order to support artifact selection at Pkg.add() time, Pkg will run the specially-named file <project_root>/.pkg/select_artifacts.jl, passing the current platform triplet as the first argument.\nThis artifact selection script should print a TOML-serialized dictionary representing the artifacts that this package needs according to the given platform, and perform any inspection of the system as necessary to auto-detect platform capabilities if they are not explicitly provided by the given platform triplet.\nThe format of the dictionary should match that returned from Artifacts.select_downloadable_artifacts(), and indeed most packages should simply call that function with an augmented Platform object.\nAn example artifact selection hook definition might look like the following, split across two files:\n\n# .pkg/platform_augmentation.jl\nusing Libdl, Base.BinaryPlatforms\nfunction augment_platform!(p::Platform)\n    # If this platform object already has a `cuda` tag set, don't augment\n    if haskey(p, \"cuda\")\n        return p\n    end\n\n    # Open libcuda explicitly, so it gets `dlclose()`'ed after we're done\n    dlopen(\"libcuda\") do lib\n        # find symbol to ask for driver version; if we can't find it, just silently continue\n        cuDriverGetVersion = dlsym(lib, \"cuDriverGetVersion\"; throw_error=false)\n        if cuDriverGetVersion !== nothing\n            # Interrogate CUDA driver for driver version:\n            driverVersion = Ref{Cint}()\n            ccall(cuDriverGetVersion, UInt32, (Ptr{Cint},), driverVersion)\n\n            # Store only the major version\n            p[\"cuda\"] = div(driverVersion, 1000)\n        end\n    end\n\n    # Return possibly-altered `Platform` object\n    return p\nend\n\nusing TOML, Artifacts, Base.BinaryPlatforms\ninclude(\"./platform_augmentation.jl\")\nartifacts_toml = joinpath(dirname(@__DIR__), \"Artifacts.toml\")\n\n# Get \"target triplet\" from ARGS, if given (defaulting to the host triplet otherwise)\ntarget_triplet = get(ARGS, 1, Base.BinaryPlatforms.host_triplet())\n\n# Augment this platform object with any special tags we require\nplatform = augment_platform!(HostPlatform(parse(Platform, target_triplet)))\n\n# Select all downloadable artifacts that match that platform\nartifacts = select_downloadable_artifacts(artifacts_toml; platform)\n\n# Output the result to `stdout` as a TOML dictionary\nTOML.print(stdout, artifacts)\n\nIn this hook definition, our platform augmentation routine opens a system library (libcuda), searches it for a symbol to give us the CUDA driver version, then embeds the major version of that version number into the cuda property of the Platform object we are augmenting.\nWhile it is not critical for this code to actually attempt to close the loaded library (as it will most likely be opened again by the CUDA package immediately after the package operations are completed) it is best practice to make hooks as lightweight and transparent as possible, as they may be used by other Pkg utilities in the future.\nIn your own package, you should also use augmented platform objects when using the @artifact_str macro, as follows:\n\ninclude(\"../.pkg/platform_augmentation.jl\")\n\nfunction __init__()\n    p = augment_platform!(HostPlatform())\n    global my_artifact_dir = @artifact_str(\"MyArtifact\", p)\nend\n\nThis ensures that the same artifact is used by your code as Pkg attempted to install.\n\nArtifact selection hooks are only allowed to use Base, Artifacts, Libdl, and TOML. They are not allowed to use any other standard libraries, and they are not allowed to use any packages (including the package to which they belong)."},{"title":"Pkg","page":"Pkg","location":"basedocs/#Pkg","category":"section","text":"Pkg is Julia's built-in package manager, and handles operations\nsuch as installing, updating and removing packages.\n\nnote: Note\nWhat follows is a very brief introduction to Pkg. For more\ninformation on Project.toml files, Manifest.toml files, package\nversion compatibility ([compat]), environments, registries, etc.,\nit is highly recommended to read the full manual, which is available here:\nhttps://pkgdocs.julialang.org.\n\nimport Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" => \"[API Reference](https://pkgdocs.julialang.org/v1/api/)\")\nstr = replace(str, \"(@ref Working-with-Environments)\" => \"(https://pkgdocs.julialang.org/v1/environments/)\")\nstr = replace(str, \"(@ref Managing-Packages)\" => \"(https://pkgdocs.julialang.org/v1/managing-packages/)\")\nMarkdown.parse(str)"},{"title":"4. Working with Environments","page":"4. Working with Environments","location":"environments/#Working-with-Environments","category":"section","text":"The following discusses Pkg's interaction with environments. For more on the role, environments play in code loading, including the \"stack\" of environments from which code can be loaded, see this section in the Julia manual."},{"title":"Creating your own environments","page":"4. Working with Environments","location":"environments/#Creating-your-own-environments","category":"section","text":"So far we have added packages to the default environment at ~/.julia/environments/v1.10. It is however easy to create other, independent, projects.\nThis approach has the benefit of allowing you to check in a Project.toml, and even a Manifest.toml if you wish, into version control (e.g. git) alongside your code.\nIt should be pointed out that when two projects use the same package at the same version, the content of this package is not duplicated.\nIn order to create a new project, create a directory for it and then activate that directory to make it the \"active project\", which package operations manipulate:\n\n(@v1.10) pkg> activate MyProject\nActivating new environment at `~/MyProject/Project.toml`\n\n(MyProject) pkg> st\n    Status `~/MyProject/Project.toml` (empty project)\n\nNote that the REPL prompt changes when the new project is activated. Until a package is added, there are no files in this environment and the directory to the environment might not even be created:\n\njulia> isdir(\"MyProject\")\nfalse\n\n(MyProject) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/MyProject/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/MyProject/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling environment...\n  1 dependency successfully precompiled in 2 seconds\n\njulia> readdir(\"MyProject\")\n2-element Vector{String}:\n \"Manifest.toml\"\n \"Project.toml\"\n\njulia> print(read(joinpath(\"MyProject\", \"Project.toml\"), String))\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\njulia> print(read(joinpath(\"MyProject\", \"Manifest.toml\"), String))\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.10.0\"\nmanifest_format = \"2.0\"\nproject_hash = \"2ca1c6c58cb30e79e021fb54e5626c96d05d5fdc\"\n\n[[deps.Example]]\ngit-tree-sha1 = \"46e44e869b4d90b96bd8ed1fdcf32244fddfb6cc\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"0.5.3\"\n\nThis new environment is completely separate from the one we used earlier. See Project.toml and Manifest.toml for a more detailed explanation."},{"title":"Using someone else's project","page":"4. Working with Environments","location":"environments/#Using-someone-else's-project","category":"section","text":"Simply clone their project using e.g. git clone, cd to the project directory and call\n\nshell> git clone https://github.com/JuliaLang/Example.jl.git\nCloning into 'Example.jl'...\n...\n\n(@v1.10) pkg> activate Example.jl\nActivating project at `~/Example.jl`\n\n(Example) pkg> instantiate\n  No packages added to or removed from `~/Example.jl/Project.toml`\n  No packages added to or removed from `~/Example.jl/Manifest.toml`\n\nIf the project contains a manifest, this will install the packages in the same state that is given by that manifest.\nOtherwise, it will resolve the latest versions of the dependencies compatible with the project.\n\nNote that activate by itself does not install missing dependencies.\nIf you only have a Project.toml, a Manifest.toml must be generated by \"resolving\" the environment, then any missing packages must be installed and precompiled. instantiate does all this for you.\n\nIf you already have a resolved Manifest.toml, then you will still need to ensure that the packages are installed and with the correct versions. Again instantiate does this for you.\n\nIn short, instantiate is your friend to make sure an environment is ready to use. If there's nothing to do, instantiate does nothing."},{"title":"Returning to the default environment","page":"4. Working with Environments","location":"environments/#Returning-to-the-default-environment","category":"section","text":"To return to the default environment after working in a project environment, simply call activate with no arguments:\n\n(MyProject) pkg> activate\n  Activating project at `~/.julia/environments/v1.10`\n\n(@v1.10) pkg>\n\nThis deactivates the current project and returns you to the default shared environment (typically @v#.#).\nThere is no separate \"deactivate\" command—calling activate() with no arguments is how you return to your\nbase package setup. This only affects the current Julia session; the change does not persist when you restart Julia.\n\nnote: Specifying project on startup\nInstead of using activate from within Julia, you can specify the project on startup using\nthe --project=<path> flag. For example, to run a script from the command line using the\nenvironment in the current directory you can run$ julia --project=. myscript.jl"},{"title":"Temporary environments","page":"4. Working with Environments","location":"environments/#Temporary-environments","category":"section","text":"Temporary environments make it easy to start an environment from a blank slate to test a package or set of\npackages, and have Pkg automatically delete the environment when you're done.\nFor instance, when writing a bug report, you may want to test your minimal reproducible\nexample in a 'clean' environment to ensure it's actually reproducible as written. You might\nalso want a scratch space to try out a new package, or a sandbox to resolve version conflicts\nbetween several incompatible packages.\n\n(@v1.10) pkg> activate --temp # requires Julia 1.5 or later\n  Activating new environment at `/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n\n(jl_a31egx) pkg> add Example\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Manifest.toml`\n  [7876af07] + Example v0.5.3"},{"title":"Shared environments","page":"4. Working with Environments","location":"environments/#Shared-environments","category":"section","text":"A \"shared\" environment is simply an environment that exists in ~/.julia/environments. The default v1.10 environment is\ntherefore a shared environment:\n\n(@v1.10) pkg> st\nStatus `~/.julia/environments/v1.10/Project.toml`\n\nShared environments can be activated with the --shared flag to activate:\n\n(@v1.10) pkg> activate --shared mysharedenv\n  Activating project at `~/.julia/environments/mysharedenv`\n\n(@mysharedenv) pkg>\n\nShared environments have a @ before their name in the Pkg REPL prompt."},{"title":"Environment Precompilation","page":"4. Working with Environments","location":"environments/#Environment-Precompilation","category":"section","text":"Before a package can be imported, Julia will \"precompile\" the source code into an intermediate more efficient cache on disc.\nThis precompilation can be triggered via code loading if the un-imported package is new or has changed since the last cache\n\njulia> using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\nor using Pkg's precompile option, which can precompile the entire environment, or a given dependency, and do so in parallel,\nwhich can be significantly faster than the code-load route above.\n\n(@v1.10) pkg> precompile\nPrecompiling environment...\n  23 dependencies successfully precompiled in 36 seconds\n\nHowever, neither of these should be routinely required thanks to Pkg's automatic precompilation."},{"title":"Automatic Precompilation","page":"4. Working with Environments","location":"environments/#Automatic-Precompilation","category":"section","text":"By default, any package that is added to a project or updated in a Pkg action will be automatically precompiled, along\nwith its dependencies.\n\n(@v1.10) pkg> add Images\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [916415d5] + Images v0.25.2\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n    ...\nPrecompiling environment...\n  Progress [===================>                     ]  45/97\n  ✓ NaNMath\n  ✓ IntervalSets\n  ◐ CoordinateTransformations\n  ◑ ArnoldiMethod\n  ◑ IntegralArrays\n  ◒ RegionTrees\n  ◐ ChangesOfVariables\n  ◓ PaddedViews\n\nThe exception is the develop command, which neither builds nor precompiles the package. When\nthat happens is left up to the user to decide.\n\nIf a given package version errors during auto-precompilation, Pkg will remember for the following times it\nautomatically tries and will skip that package with a brief warning. Manual precompilation can be used to\nforce these packages to be retried, as pkg> precompile will always retry all packages.\n\nThe indicators next to the package names displayed during precompilation\nindicate the status of that package's precompilation.\n\n[◐, ◓, ◑, ◒] Animated \"clock\" characters indicate that the package is currently being precompiled.\n✓ A green checkmark indicates that the package has been successfully precompiled (after which that package will disappear from the list). If the checkmark is yellow it means that the package is currently loaded so the session will need to be restarted to access the version that was just precompiled.\n? A question mark character indicates that a PrecompilableError was thrown, indicating that precompilation was disallowed, i.e. __precompile__(false) in that package.\n✗ A cross indicates that the package failed to precompile."},{"title":"Controlling Auto-precompilation","page":"4. Working with Environments","location":"environments/#Controlling-Auto-precompilation","category":"section","text":"Auto-precompilation can be controlled in several ways:\n\nEnvironment variable: Set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 to disable auto-precompilation globally.\nProgrammatically: Use Pkg.autoprecompilation_enabled(false) to disable auto-precompilation for the current session, or Pkg.autoprecompilation_enabled(true) to re-enable it.\nScoped control: Use Pkg.precompile(f, args...; kwargs...) to execute a function f with auto-precompilation temporarily disabled, then automatically trigger precompilation afterward if any packages were modified during the execution.\n\ncompat: Julia 1.13\nThe Pkg.autoprecompilation_enabled() function and Pkg.precompile() do-block syntax require at least Julia 1.13.\n\nFor example, to add multiple packages without triggering precompilation after each one:\n\njulia> Pkg.precompile() do\n           Pkg.add(\"Example\")\n           Pkg.dev(\"JSON\")\n           Pkg.update(\"HTTP\")\n       end\n   Resolving package versions...\n   ...\nPrecompiling environment...\n  14 dependencies successfully precompiled in 25 seconds\n\nOr to temporarily disable auto-precompilation:\n\njulia> Pkg.autoprecompilation_enabled(false)\nfalse\n\njulia> Pkg.add(\"Example\")  # No precompilation happens\n   Resolving package versions...\n   ...\n\njulia> Pkg.autoprecompilation_enabled(true)\ntrue"},{"title":"Precompiling new versions of loaded packages","page":"4. Working with Environments","location":"environments/#Precompiling-new-versions-of-loaded-packages","category":"section","text":"If a package that has been updated is already loaded in the session, the precompilation process will go ahead and precompile\nthe new version, and any packages that depend on it, but will note that the package cannot be used until session restart."}]
}
