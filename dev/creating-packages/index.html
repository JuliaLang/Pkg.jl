<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5. Creating Packages · Pkg.jl</title><meta name="title" content="5. Creating Packages · Pkg.jl"/><meta property="og:title" content="5. Creating Packages · Pkg.jl"/><meta property="twitter:title" content="5. Creating Packages · Pkg.jl"/><meta name="description" content="Documentation for Pkg.jl."/><meta property="og:description" content="Documentation for Pkg.jl."/><meta property="twitter:description" content="Documentation for Pkg.jl."/><meta property="og:url" content="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><meta property="twitter:url" content="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><link rel="canonical" href="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Pkg.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pkg.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../"><strong>1.</strong> Introduction</a></li><li><a class="tocitem" href="../getting-started/"><strong>2.</strong> Getting Started</a></li><li><a class="tocitem" href="../managing-packages/"><strong>3.</strong> Managing Packages</a></li><li><a class="tocitem" href="../environments/"><strong>4.</strong> Working with Environments</a></li><li class="is-active"><a class="tocitem" href><strong>5.</strong> Creating Packages</a><ul class="internal"><li><a class="tocitem" href="#Generating-files-for-a-package"><span>Generating files for a package</span></a></li><li><a class="tocitem" href="#Adding-dependencies-to-the-project"><span>Adding dependencies to the project</span></a></li><li><a class="tocitem" href="#Defining-a-public-API"><span>Defining a public API</span></a></li><li><a class="tocitem" href="#Adding-a-build-step-to-the-package"><span>Adding a build step to the package</span></a></li><li><a class="tocitem" href="#adding-tests-to-packages"><span>Adding tests to the package</span></a></li><li><a class="tocitem" href="#Compatibility-on-dependencies"><span>Compatibility on dependencies</span></a></li><li><a class="tocitem" href="#Weak-dependencies"><span>Weak dependencies</span></a></li><li><a class="tocitem" href="#Conditional-loading-of-code-in-packages-(Extensions)"><span>Conditional loading of code in packages (Extensions)</span></a></li><li><a class="tocitem" href="#Package-naming-guidelines"><span>Package naming guidelines</span></a></li><li><a class="tocitem" href="#Registering-packages"><span>Registering packages</span></a></li><li><a class="tocitem" href="#Creating-new-package-versions"><span>Creating new package versions</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../apps/"><strong>6.</strong> Apps</a></li><li><a class="tocitem" href="../compatibility/"><strong>7.</strong> Compatibility</a></li><li><a class="tocitem" href="../registries/"><strong>8.</strong> Registries</a></li><li><a class="tocitem" href="../artifacts/"><strong>9.</strong> Artifacts</a></li><li><a class="tocitem" href="../glossary/"><strong>10.</strong> Glossary</a></li><li><a class="tocitem" href="../toml-files/"><strong>11.</strong> <code>Project.toml</code> and <code>Manifest.toml</code></a></li><li><a class="tocitem" href="../repl/"><strong>11.</strong> REPL Mode Reference</a></li><li><a class="tocitem" href="../api/"><strong>13.</strong> API Reference</a></li><li><a class="tocitem" href="../protocol/"><strong>14.</strong> Package and Storage Server Protocol Reference</a></li><li><a class="tocitem" href="../depots/"><strong>15.</strong> Depots</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><strong>5.</strong> Creating Packages</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><strong>5.</strong> Creating Packages</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/Pkg.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/creating-packages.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="creating-packages-tutorial"><a class="docs-heading-anchor" href="#creating-packages-tutorial"><strong>5.</strong> Creating Packages</a><a id="creating-packages-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#creating-packages-tutorial" title="Permalink"></a></h1><h2 id="Generating-files-for-a-package"><a class="docs-heading-anchor" href="#Generating-files-for-a-package">Generating files for a package</a><a id="Generating-files-for-a-package-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-files-for-a-package" title="Permalink"></a></h2><div class="admonition is-info" id="Note-c9e018e246a54e14"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c9e018e246a54e14" title="Permalink"></a></header><div class="admonition-body"><p>The <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates</a> package offers an easy, repeatable, and
customizable way to generate the files for a new package. It can also generate files needed for Documentation, CI, etc.
We recommend that you use PkgTemplates for creating
new packages instead of using the minimal <code>pkg&gt; generate</code> functionality described below.</p></div></div><p>To generate the bare minimum files for a new package, use <code>pkg&gt; generate</code>.</p><pre><code class="language-julia-repl hljs">(@v1.10) pkg&gt; generate HelloWorld</code></pre><p>This creates a new project <code>HelloWorld</code> in a subdirectory by the same name, with the following files (visualized with the external <a href="https://linux.die.net/man/1/tree"><code>tree</code> command</a>):</p><pre><code class="language-julia-repl hljs">shell&gt; tree HelloWorld/
HelloWorld/
├── Project.toml
└── src
    └── HelloWorld.jl

2 directories, 2 files</code></pre><p>The <code>Project.toml</code> file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:</p><pre><code class="language-toml hljs">name = &quot;HelloWorld&quot;
uuid = &quot;b4cd1eb8-1e24-11e8-3319-93036a3eb9f3&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Some One &lt;someone@email.com&gt;&quot;]

[deps]</code></pre><p>The content of <code>src/HelloWorld.jl</code> is:</p><pre><code class="language-julia hljs">module HelloWorld

greet() = print(&quot;Hello World!&quot;)

end # module</code></pre><p>We can now activate the project by using the path to the directory where it is installed, and load the package:</p><pre><code class="language-julia-repl hljs">pkg&gt; activate ./HelloWorld

julia&gt; import HelloWorld

julia&gt; HelloWorld.greet()
Hello World!</code></pre><p>For the rest of the tutorial we enter inside the directory of the project, for convenience:</p><pre><code class="language-julia-repl hljs">julia&gt; cd(&quot;HelloWorld&quot;)</code></pre><h2 id="Adding-dependencies-to-the-project"><a class="docs-heading-anchor" href="#Adding-dependencies-to-the-project">Adding dependencies to the project</a><a id="Adding-dependencies-to-the-project-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-dependencies-to-the-project" title="Permalink"></a></h2><p>Let’s say we want to use the standard library package <code>Random</code> and the registered package <code>JSON</code> in our project.
We simply <code>add</code> these packages (note how the prompt now shows the name of the newly generated project,
since we <code>activate</code>d it):</p><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; add Random JSON
   Resolving package versions...
    Updating `~/HelloWorld/Project.toml`
  [682c06a0] + JSON v0.21.3
  [9a3f8284] + Random
    Updating `~/HelloWorld/Manifest.toml`
  [682c06a0] + JSON v0.21.3
  [69de0a69] + Parsers v2.4.0
  [ade2ca70] + Dates
 ...</code></pre><p>Both <code>Random</code> and <code>JSON</code> got added to the project’s <code>Project.toml</code> file, and the resulting dependencies got added to the <code>Manifest.toml</code> file.
The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies.</p><p>We can now use both <code>Random</code> and <code>JSON</code> in our project. Changing <code>src/HelloWorld.jl</code> to</p><pre><code class="language-julia hljs">module HelloWorld

import Random
import JSON

greet() = print(&quot;Hello World!&quot;)
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>and reloading the package, the new <code>greet_alien</code> function that uses <code>Random</code> can be called:</p><pre><code class="language-julia-repl hljs">julia&gt; HelloWorld.greet_alien()
Hello aT157rHV</code></pre><h2 id="Defining-a-public-API"><a class="docs-heading-anchor" href="#Defining-a-public-API">Defining a public API</a><a id="Defining-a-public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-public-API" title="Permalink"></a></h2><p>If you want your package to be useful to other packages and you want folks to be able to
easily update to newer version of your package when they come out, it is important to
document what behavior will stay consistent across updates.</p><p>Unless you note otherwise, the public API of your package is defined as all the behavior you
describe about public symbols. A public symbol is a symbol that is exported from your
package with the <code>export</code> keyword or marked as public with the <code>public</code> keyword. When you
change the behavior of something that was previously public so that the new
version no longer conforms to the specifications provided in the old version, you should
adjust your package version number according to <a href="../compatibility/#Version-specifier-format">Julia&#39;s variant on SemVer</a>.
If you would like to include a symbol in your public API without exporting it into the
global namespace of folks who call <code>using YourPackage</code>, you should mark that symbol as
public with <code>public that_symbol</code>. Symbols marked as public with the <code>public</code> keyword are
just as public as those marked as public with the <code>export</code> keyword, but when folks call
<code>using YourPackage</code>, they will still have to qualify access to those symbols with
<code>YourPackage.that_symbol</code>.</p><p>Let&#39;s say we would like our <code>greet</code> function to be part of the public API, but not the
<code>greet_alien</code> function. We could then write the following and release it as version <code>1.0.0</code>.</p><pre><code class="language-julia hljs">module HelloWorld

export greet

import Random
import JSON

&quot;Writes a friendly message.&quot;
greet() = print(&quot;Hello World!&quot;)

&quot;Greet an alien by a randomly generated name.&quot;
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>Then, if we change <code>greet</code> to</p><pre><code class="language-julia hljs">&quot;Writes a friendly message that is exactly three words long.&quot;
greet() = print(&quot;Hello Lovely World!&quot;)</code></pre><p>We would release the new version as <code>1.1.0</code>. This is not breaking
because the new implementation conforms to the old documentation, but
it does add a new feature, that the message must be three words long.</p><p>Later, we may wish to change <code>greet_alien</code> to</p><pre><code class="language-julia hljs">&quot;Greet an alien by the name of \&quot;Zork\&quot;.&quot;
greet_alien() = print(&quot;Hello Zork&quot;)</code></pre><p>And also export it by changing</p><pre><code class="language-julia hljs">export greet</code></pre><p>to</p><pre><code class="language-julia hljs">export greet, greet_alien</code></pre><p>We should release this new version as <code>1.2.0</code> because it adds a new feature
<code>greet_alien</code> to the public API. Even though <code>greet_alien</code> was documented before
and the new version does not conform to the old documentation, this is not breaking
because the old documentation was not attached to a symbol that was exported
at the time so that documentation does not apply across released versions.</p><p>However, if we now wish to change <code>greet</code> to</p><pre><code class="language-julia hljs">&quot;Writes a friendly message that is exactly four words long.&quot;
greet() = print(&quot;Hello very lovely world&quot;)</code></pre><p>we would need to release the new version as <code>2.0.0</code>. In version <code>1.1.0</code>, we specified that
the greeting would be three words long, and because <code>greet</code> was exported, that description
also applies to all future versions until the next breaking release. Because this new
version does not conform to the old specification, it must be tagged as a breaking change.</p><p>Please note that version numbers are free and unlimited. It is okay to use lots of them
(e.g. version <code>6.62.8</code>).</p><h2 id="Adding-a-build-step-to-the-package"><a class="docs-heading-anchor" href="#Adding-a-build-step-to-the-package">Adding a build step to the package</a><a id="Adding-a-build-step-to-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-build-step-to-the-package" title="Permalink"></a></h2><p>The build step is executed the first time a package is installed or when explicitly invoked with <code>build</code>.
A package is built by executing the file <code>deps/build.jl</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; mkpath(&quot;deps&quot;);

julia&gt; write(&quot;deps/build.jl&quot;,
             &quot;&quot;&quot;
             println(&quot;I am being built...&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

julia&gt; print(readchomp(&quot;deps/build.log&quot;))
I am being built...</code></pre><p>If the build step fails, the output of the build step is printed to the console</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;deps/build.jl&quot;,
             &quot;&quot;&quot;
             error(&quot;Ooops&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; build
    Building HelloWorld → `~/HelloWorld/deps/build.log`
ERROR: Error building `HelloWorld`:
ERROR: LoadError: Ooops
Stacktrace:
 [1] error(s::String)
   @ Base ./error.jl:35
 [2] top-level scope
   @ ~/HelloWorld/deps/build.jl:1
 [3] include(fname::String)
   @ Base.MainInclude ./client.jl:476
 [4] top-level scope
   @ none:5
in expression starting at /home/kc/HelloWorld/deps/build.jl:1</code></pre><div class="admonition is-warning" id="Warning-18f7b6980fc9871b"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-18f7b6980fc9871b" title="Permalink"></a></header><div class="admonition-body"><p>A build step should generally not create or modify any files in the package directory. If you need to store some files
from the build step, use the <a href="https://github.com/JuliaPackaging/Scratch.jl">Scratch.jl</a> package.</p></div></div><h2 id="adding-tests-to-packages"><a class="docs-heading-anchor" href="#adding-tests-to-packages">Adding tests to the package</a><a id="adding-tests-to-packages-1"></a><a class="docs-heading-anchor-permalink" href="#adding-tests-to-packages" title="Permalink"></a></h2><p>When a package is tested the file <code>test/runtests.jl</code> is executed:</p><pre><code class="language-julia-repl hljs">julia&gt; mkpath(&quot;test&quot;);

julia&gt; write(&quot;test/runtests.jl&quot;,
             &quot;&quot;&quot;
             println(&quot;Testing...&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed</code></pre><p>Tests are run in a new Julia process, where the package itself, and any
test-specific dependencies, are available, see below.</p><div class="admonition is-warning" id="Warning-d48ed01c29d330d1"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d48ed01c29d330d1" title="Permalink"></a></header><div class="admonition-body"><p>Tests should generally not create or modify any files in the package directory. If you need to store some files
from the build step, use the <a href="https://github.com/JuliaPackaging/Scratch.jl">Scratch.jl</a> package.</p></div></div><h3 id="Test-specific-dependencies"><a class="docs-heading-anchor" href="#Test-specific-dependencies">Test-specific dependencies</a><a id="Test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Test-specific-dependencies" title="Permalink"></a></h3><p>Test-specific dependencies are dependencies that are not dependencies of the package itself but are available when the package is tested.</p><h4 id="Recommended-approach:-Using-workspaces-with-test/Project.toml"><a class="docs-heading-anchor" href="#Recommended-approach:-Using-workspaces-with-test/Project.toml">Recommended approach: Using workspaces with <code>test/Project.toml</code></a><a id="Recommended-approach:-Using-workspaces-with-test/Project.toml-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-approach:-Using-workspaces-with-test/Project.toml" title="Permalink"></a></h4><div class="admonition is-compat" id="Compat-c1ac8dae7e5c883f"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-c1ac8dae7e5c883f" title="Permalink"></a></header><div class="admonition-body"><p>Workspaces require Julia 1.12+. For older Julia versions, see the legacy approaches below.</p></div></div><p>The recommended way to add test-specific dependencies is to use workspaces. This is done by:</p><ol><li><p>Adding a <code>[workspace]</code> section to your package&#39;s <code>Project.toml</code>:</p></li></ol><pre><code class="language-toml hljs">[workspace]
projects = [&quot;test&quot;]</code></pre><ol><li><p>Creating a <code>test/Project.toml</code> file with your test dependencies:</p></li></ol><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; activate ./test
[ Info: activating environment at `~/HelloWorld/test/Project.toml`.

(HelloWorld/test) pkg&gt; dev .  # add current package to test dependencies using its path
 Resolving package versions...
  Updating `~/HelloWorld/test/Project.toml`
  [8dfed614] + HelloWorld v0.1.0 `..`

(HelloWorld/test) pkg&gt; add Test  # add other test dependencies
 Resolving package versions...
  Updating `~/HelloWorld/test/Project.toml`
  [8dfed614] + Test</code></pre><p>When using workspaces, the package manager resolves dependencies for all projects in the workspace together, and creates a single <code>Manifest.toml</code> next to the base <code>Project.toml</code>. This provides better dependency resolution and makes it easier to manage test-specific dependencies.</p><div class="admonition is-info" id="Info-5b96cee26b93e3d0"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-5b96cee26b93e3d0" title="Permalink"></a></header><div class="admonition-body"><p>Unlike some earlier test dependency workflows, this one explicitly requires adding <code>HelloWorld</code> (the parent package) to your <code>test/Project.toml</code>.</p></div></div><p>You can now use <code>Test</code> in the test script:</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;test/runtests.jl&quot;,
             &quot;&quot;&quot;
             using HelloWorld, Test
             @test 1 == 1
             &quot;&quot;&quot;);

(HelloWorld/test) pkg&gt; activate .

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
   Testing HelloWorld tests passed</code></pre><p>Workspaces can also be used for other purposes, such as documentation or benchmarks, by adding additional projects to the workspace:</p><pre><code class="language-toml hljs">[workspace]
projects = [&quot;test&quot;, &quot;docs&quot;, &quot;benchmarks&quot;]</code></pre><p>See the section on <a href="../toml-files/#Workspaces">Workspaces</a> in the <code>Project.toml</code> documentation for more details.</p><h4 id="Alternative-approach:-Using-[sources]-with-path-based-dependencies"><a class="docs-heading-anchor" href="#Alternative-approach:-Using-[sources]-with-path-based-dependencies">Alternative approach: Using <code>[sources]</code> with path-based dependencies</a><a id="Alternative-approach:-Using-[sources]-with-path-based-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-approach:-Using-[sources]-with-path-based-dependencies" title="Permalink"></a></h4><p>An alternative to workspaces is to use the <code>[sources]</code> section in <code>test/Project.toml</code> to reference the parent package. The <code>[sources]</code> section allows you to specify custom locations (paths or URLs) for dependencies, overriding registry information. This approach creates a <strong>separate manifest</strong> in the <code>test/</code> directory (unlike workspaces which create a single shared manifest).</p><p>To use this approach:</p><ol><li><p>Create a <code>test/Project.toml</code> file and add your test dependencies:</p></li></ol><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; activate ./test
[ Info: activating environment at `~/HelloWorld/test/Project.toml`.

(HelloWorld/test) pkg&gt; add Test
 Resolving package versions...
  Updating `~/HelloWorld/test/Project.toml`
  [8dfed614] + Test</code></pre><ol><li><p>Add the parent package as a dependency using <code>[sources]</code> with a relative path:</p></li></ol><pre><code class="language-toml hljs"># In test/Project.toml
[deps]
HelloWorld = &quot;00000000-0000-0000-0000-000000000000&quot;  # Your package UUID
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[sources]
HelloWorld = {path = &quot;..&quot;}</code></pre><p>The <code>[sources]</code> section tells Pkg to use the local path for <code>HelloWorld</code> instead of looking it up in a registry. This creates a separate <code>test/Manifest.toml</code> that tracks the resolved dependencies for your test environment independently from the main package manifest. You can now run tests directly:</p><pre><code class="language-julia-repl hljs">$ julia --project=test
julia&gt; using HelloWorld, Test

julia&gt; include(&quot;test/runtests.jl&quot;)</code></pre><div class="admonition is-info" id="Difference-from-workspaces-d22753a043eab08c"><header class="admonition-header">Difference from workspaces<a class="admonition-anchor" href="#Difference-from-workspaces-d22753a043eab08c" title="Permalink"></a></header><div class="admonition-body"><p>The key difference from workspaces is that this approach uses a <strong>separate manifest file</strong> (<code>test/Manifest.toml</code>) for the test environment, while workspaces create a <strong>single shared manifest</strong> (<code>Manifest.toml</code>) that resolves all projects together. This means:</p><ul><li><p>With <code>[sources]</code> + path: Dependencies are resolved independently for each environment</p></li><li><p>With workspaces: Dependencies are resolved together, ensuring compatibility across all projects in the workspace</p></li></ul><p>For more details on <code>[sources]</code>, see the <a href="../toml-files/#sources-section"><code>[sources]</code> section</a> in the Project.toml documentation.</p></div></div><h4 id="Legacy-approach:-target-based-test-specific-dependencies"><a class="docs-heading-anchor" href="#Legacy-approach:-target-based-test-specific-dependencies">Legacy approach: <code>target</code> based test specific dependencies</a><a id="Legacy-approach:-target-based-test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-approach:-target-based-test-specific-dependencies" title="Permalink"></a></h4><div class="admonition is-warning" id="Warning-c6fe404edbf575b3"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-c6fe404edbf575b3" title="Permalink"></a></header><div class="admonition-body"><p>This approach is legacy and maintained for compatibility. New packages should use workspaces instead.</p></div></div><p>Using this method, test-specific dependencies are added under an <code>[extras]</code> section and to a test target:</p><pre><code class="language-toml hljs">[extras]
Markdown = &quot;d6f4376e-aef5-505a-96c1-9c027394607a&quot;
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Markdown&quot;, &quot;Test&quot;]</code></pre><p>Note that the only supported targets are <code>test</code> and <code>build</code>, the latter of which (not recommended) can be used for any <code>deps/build.jl</code> scripts.</p><h4 id="Legacy-approach:-test/Project.toml-without-workspace"><a class="docs-heading-anchor" href="#Legacy-approach:-test/Project.toml-without-workspace">Legacy approach: <code>test/Project.toml</code> without workspace</a><a id="Legacy-approach:-test/Project.toml-without-workspace-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-approach:-test/Project.toml-without-workspace" title="Permalink"></a></h4><div class="admonition is-warning" id="Warning-c6fe404edbf575b3"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-c6fe404edbf575b3" title="Permalink"></a></header><div class="admonition-body"><p>This approach is legacy and maintained for compatibility. New packages should use workspaces instead.</p></div></div><p>In Julia 1.2 and later, test dependencies can be declared in <code>test/Project.toml</code> without using a workspace. When running tests, Pkg will automatically merge the package and test projects to create the test environment.</p><div class="admonition is-info" id="Note-51035121e9e23c5b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-51035121e9e23c5b" title="Permalink"></a></header><div class="admonition-body"><p>If no <code>test/Project.toml</code> exists, Pkg will use the <code>target</code> based test specific dependencies.</p></div></div><p>This approach works similarly to the workspace approach, but without the workspace declaration in the main <code>Project.toml</code>.</p><h2 id="Compatibility-on-dependencies"><a class="docs-heading-anchor" href="#Compatibility-on-dependencies">Compatibility on dependencies</a><a id="Compatibility-on-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility-on-dependencies" title="Permalink"></a></h2><p>Every dependency should in general have a compatibility constraint on it.
This is an important topic so there is a separate chapter about it: <a href="../compatibility/#Compatibility">Compatibility</a>.</p><h2 id="Weak-dependencies"><a class="docs-heading-anchor" href="#Weak-dependencies">Weak dependencies</a><a id="Weak-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-dependencies" title="Permalink"></a></h2><div class="admonition is-info" id="Note-2e947d176fe1312a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2e947d176fe1312a" title="Permalink"></a></header><div class="admonition-body"><p>This is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.</p></div></div><div class="admonition is-compat" id="Compat-1766f654c932407"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-1766f654c932407" title="Permalink"></a></header><div class="admonition-body"><p>The described feature requires Julia 1.9+.</p></div></div><p>A weak dependency is a dependency that will not automatically install when the package is installed but
you can still control what versions of that package are allowed to be installed by setting compatibility on it.
These are listed in the project file under the <code>[weakdeps]</code> section:</p><pre><code class="language-toml hljs">[weakdeps]
SomePackage = &quot;b3785f31-9d33-4cdf-bc73-f646780f1739&quot;

[compat]
SomePackage = &quot;1.2&quot;</code></pre><p>The current usage of this is almost solely limited to &quot;extensions&quot; which is described in the next section.</p><h2 id="Conditional-loading-of-code-in-packages-(Extensions)"><a class="docs-heading-anchor" href="#Conditional-loading-of-code-in-packages-(Extensions)">Conditional loading of code in packages (Extensions)</a><a id="Conditional-loading-of-code-in-packages-(Extensions)-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-loading-of-code-in-packages-(Extensions)" title="Permalink"></a></h2><div class="admonition is-info" id="Note-2e947d176fe1312a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2e947d176fe1312a" title="Permalink"></a></header><div class="admonition-body"><p>This is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.</p></div></div><div class="admonition is-compat" id="Compat-1766f654c932407"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-1766f654c932407" title="Permalink"></a></header><div class="admonition-body"><p>The described feature requires Julia 1.9+.</p></div></div><p>Sometimes one wants to make two or more packages work well together, but may be reluctant (perhaps due to increased load times) to make one an unconditional dependency of the other.
A package <em>extension</em> is a module in a file (similar to a package) that is automatically loaded when <em>some other set of packages</em> are
loaded into the Julia session. This is very similar to functionality that the external package
<a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a> provides, but which is now available directly through Julia,
and provides added benefits such as being able to precompile the extension.</p><h3 id="Code-structure"><a class="docs-heading-anchor" href="#Code-structure">Code structure</a><a id="Code-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Code-structure" title="Permalink"></a></h3><p>A useful application of extensions could be for a plotting package that should be able to plot
objects from a wide variety of different Julia packages.
Adding all those different Julia packages as dependencies of the plotting package
could be expensive since they would end up getting loaded even if they were never used.
Instead, the code required to plot objects for specific packages can be put into separate files
(extensions) and these are loaded only when the packages that define the type(s) we want to plot
are loaded.</p><p>Below is an example of how the code can be structured for a use case in which a
<code>Plotting</code> package wants to be able to display objects defined in the external package <code>Contour</code>.
The file and folder structure shown below is found in the <code>Plotting</code> package.</p><p><code>Project.toml</code>:</p><pre><code class="language-toml hljs">name = &quot;Plotting&quot;
version = &quot;0.1.0&quot;
uuid = &quot;...&quot;

[weakdeps]
Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot;

[extensions]
# name of extension to the left
# extension dependencies required to load the extension to the right
# use a list for multiple extension dependencies
ContourExt = &quot;Contour&quot;

[compat]
Contour = &quot;0.6.2&quot;</code></pre><p><code>src/Plotting.jl</code>:</p><pre><code class="language-julia hljs">module Plotting

function plot(x::Vector)
    # Some functionality for plotting a vector here
end

end # module</code></pre><p><code>ext/ContourExt.jl</code> (can also be in <code>ext/ContourExt/ContourExt.jl</code>):</p><pre><code class="language-julia hljs">module ContourExt # Should be same name as the file (just like a normal package)

using Plotting, Contour

function Plotting.plot(c::Contour.ContourCollection)
    # Some functionality for plotting a contour here
end

end # module</code></pre><p>Extensions can have arbitrary names (here <code>ContourExt</code>), following the format of this example is likely a good idea for extensions with a single dependency.
In <code>Pkg</code> output, extension names are always shown together with their parent package name.</p><div class="admonition is-compat" id="Compat-cd35bd7129bb2987"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-cd35bd7129bb2987" title="Permalink"></a></header><div class="admonition-body"><p>Often you will want to load extension dependencies when testing your package. The recommended approach is to use workspaces and add the extension dependencies to your <code>test/Project.toml</code> (see <a href="#adding-tests-to-packages">Test-specific dependencies</a>). For older Julia versions that don&#39;t support workspaces, you can put the extension dependencies into the <code>test</code> target, which requires you to also put the package in the <code>[extras]</code> section. The project verifier on older Julia versions will complain if this is not done.</p></div></div><div class="admonition is-info" id="Note-cc0fa370ac66a325"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cc0fa370ac66a325" title="Permalink"></a></header><div class="admonition-body"><p>If you use a manifest generated by a Julia version that does not know about extensions with a Julia version that does
know about them, the extensions will not load. This is because the manifest lacks some information that tells Julia
when it should load these packages. So make sure you use a manifest generated at least the Julia version you are using.</p></div></div><h3 id="Behavior-of-extensions"><a class="docs-heading-anchor" href="#Behavior-of-extensions">Behavior of extensions</a><a id="Behavior-of-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Behavior-of-extensions" title="Permalink"></a></h3><p>A user that depends only on <code>Plotting</code> will not pay the cost of the &quot;extension&quot; inside the <code>ContourExt</code> module.
It is only when the <code>Contour</code> package actually gets loaded that the <code>ContourExt</code> extension is loaded too
and provides the new functionality.</p><p>In our example, the new functionality is an additional <em>method</em>, which we add to an existing <em>function</em> from the parent package <code>Plotting</code>.
Implementing such methods is among the most standard use cases of package extensions.
Within the parent package, the function to extend can even be defined with zero methods, as follows:</p><pre><code class="language-julia hljs">function plot end</code></pre><div class="admonition is-info" id="Note-56826a57a6f4b838"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-56826a57a6f4b838" title="Permalink"></a></header><div class="admonition-body"><p>If one considers <code>ContourExt</code> as a completely separate package, it could be argued that defining <code>Plotting.plot(c::Contour.ContourCollection)</code> is
<a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">type piracy</a> since <code>ContourExt</code> <em>owns</em> neither the function <code>Plotting.plot</code> nor the type <code>Contour.ContourCollection</code>.
However, for extensions, it is ok to assume that the extension owns the functions in its parent package.</p></div></div><p>In other situations, one may need to define new symbols in the extension (types, structs, functions, etc.) instead of reusing those from the parent package.
Such symbols are created in a separate module corresponding to the extension, namely <code>ContourExt</code>, and thus not in <code>Plotting</code> itself.
If extension symbols are needed in the parent package, one must call <code>Base.get_extension</code> to retrieve them.
Here is an example showing how a custom type defined in <code>ContourExt</code> can be accessed in <code>Plotting</code>:</p><pre><code class="language-julia hljs">ext = Base.get_extension(@__MODULE__, :ContourExt)
if !isnothing(ext)
    ContourPlotType = ext.ContourPlotType
end</code></pre><p>On the other hand, accessing extension symbols from a third-party package (i.e. not the parent) is not a recommended practice at the moment.</p><h3 id="Backwards-compatibility"><a class="docs-heading-anchor" href="#Backwards-compatibility">Backwards compatibility</a><a id="Backwards-compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Backwards-compatibility" title="Permalink"></a></h3><p>This section discusses various methods for using extensions on Julia versions that support them,
while simultaneously providing similar functionality on older Julia versions.</p><h4 id="Requires.jl"><a class="docs-heading-anchor" href="#Requires.jl">Requires.jl</a><a id="Requires.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Requires.jl" title="Permalink"></a></h4><p>This section is relevant if you are currently using Requires.jl but want to transition to using extensions (while still having Requires be used on Julia versions that do not support extensions).
This is done by making the following changes (using the example above):</p><ul><li><p>Add the following to the package file. This makes it so that Requires.jl loads and inserts the
callback only when extensions are not supported</p><pre><code class="language-julia hljs"># This symbol is only defined on Julia versions that support extensions
if !isdefined(Base, :get_extension)
using Requires
end

@static if !isdefined(Base, :get_extension)
function __init__()
    @require Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot; include(&quot;../ext/ContourExt.jl&quot;)
end
end</code></pre><p>or if you have other things in your <code>__init__()</code> function:</p><pre><code class="language-julia hljs">if !isdefined(Base, :get_extension)
using Requires
end

function __init__()
    # Other init functionality here

    @static if !isdefined(Base, :get_extension)
        @require Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot; include(&quot;../ext/ContourExt.jl&quot;)
    end
end</code></pre></li><li><p>Make the following change in the conditionally-loaded code in <code>ContourExt.jl</code>:</p><pre><code class="language-julia hljs">isdefined(Base, :get_extension) ? (using Contour) : (using ..Contour)</code></pre></li><li><p>Add <code>Requires</code> to <code>[weakdeps]</code> in your <code>Project.toml</code> file, so that it is listed in both <code>[deps]</code> and <code>[weakdeps]</code>.
Julia 1.9+ knows to not install it as a regular dependency, whereas earlier versions will consider it a dependency.</p></li></ul><p>The package should now work with Requires.jl on Julia versions before extensions were introduced
and with extensions on more recent Julia versions.</p><h4 id="Transition-from-normal-dependency-to-extension"><a class="docs-heading-anchor" href="#Transition-from-normal-dependency-to-extension">Transition from normal dependency to extension</a><a id="Transition-from-normal-dependency-to-extension-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-from-normal-dependency-to-extension" title="Permalink"></a></h4><p>This section is relevant if you have a normal dependency that you want to transition be an extension (while still having the dependency be a normal dependency on Julia versions that do not support extensions).
This is done by making the following changes (using the example above):</p><ul><li><p>Make sure that the package is <strong>both</strong> in the <code>[deps]</code> and <code>[weakdeps]</code> section. Newer Julia versions will ignore dependencies in <code>[deps]</code> that are also in <code>[weakdeps]</code>.</p></li><li><p>Add the following to your main package file (typically at the bottom):</p><pre><code class="language-julia hljs">if !isdefined(Base, :get_extension)
  include(&quot;../ext/ContourExt.jl&quot;)
end</code></pre></li></ul><h4 id="Using-an-extension-while-supporting-older-Julia-versions"><a class="docs-heading-anchor" href="#Using-an-extension-while-supporting-older-Julia-versions">Using an extension while supporting older Julia versions</a><a id="Using-an-extension-while-supporting-older-Julia-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Using-an-extension-while-supporting-older-Julia-versions" title="Permalink"></a></h4><p>In the case where one wants to use an extension (without worrying about the
feature of the extension being available on older Julia versions) while still
supporting older Julia versions without workspace support, the packages under <code>[weakdeps]</code> should be
duplicated into <code>[extras]</code>. This is an unfortunate duplication, but without
doing this the project verifier under older Julia versions will throw an error
if it finds packages under <code>[compat]</code> that is not listed in <code>[extras]</code>.</p><p>For Julia 1.13+, using workspaces is recommended and this duplication is not necessary.</p><h2 id="Package-naming-guidelines"><a class="docs-heading-anchor" href="#Package-naming-guidelines">Package naming guidelines</a><a id="Package-naming-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Package-naming-guidelines" title="Permalink"></a></h2><p>Package names should be sensible to most Julia users, <em>even to those who are not domain experts</em>.
The following guidelines apply to the <code>General</code> registry but may be useful for other package
registries as well.</p><p>Since the <code>General</code> registry belongs to the entire community, people may have opinions about
your package name when you publish it, especially if it&#39;s ambiguous or can be confused with
something other than what it is. Usually, you will then get suggestions for a new name that
may fit your package better.</p><ol><li><p>Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.</p><ul><li>It&#39;s ok for package names to contain <code>DNA</code> if you&#39;re talking about the DNA, which has a universally agreed upon definition.</li><li>It&#39;s more difficult to justify package names containing the acronym <code>CI</code> for instance, which may mean continuous integration, confidence interval, etc.</li><li>If there is risk of confusion it may be best to disambiguate an acronym with additional words such as a lab group or field.</li><li>If your acronym is unambiguous, easily searchable, and/or unlikely to be confused across domains a good justification is often enough for approval.</li></ul></li><li><p>Avoid using <code>Julia</code> in your package name or prefixing it with <code>Ju</code>.</p><ul><li>It is usually clear from context and to your users that the package is a Julia package.</li><li>Package names already have a <code>.jl</code> extension, which communicates to users that <code>Package.jl</code> is a Julia package.</li><li>Having Julia in the name can imply that the package is connected to, or endorsed by, contributors
to the Julia language itself.</li></ul></li><li><p>Packages that provide most of their functionality in association with a new type should have pluralized
names.</p><ul><li><code>DataFrames</code> provides the <code>DataFrame</code> type.</li><li><code>BloomFilters</code> provides the <code>BloomFilter</code> type.</li><li>In contrast, <code>JuliaParser</code> provides no new type, but instead new functionality in the <code>JuliaParser.parse()</code>
function.</li></ul></li><li><p>Err on the side of clarity, even if clarity seems long-winded to you.</p><ul><li><code>RandomMatrices</code> is a less ambiguous name than <code>RndMat</code> or <code>RMT</code>, even though the latter are shorter.</li><li>Generally package names should be at least 5 characters long not including the <code>.jl</code> extension</li></ul></li><li><p>A less systematic name may suit a package that implements one of several possible approaches to
its domain.</p><ul><li>Julia does not have a single comprehensive plotting package. Instead, <code>Gadfly</code>, <code>PyPlot</code>, <code>Winston</code>
and other packages each implement a unique approach based on a particular design philosophy.</li><li>In contrast, <code>SortingAlgorithms</code> provides a consistent interface to use many well-established
sorting algorithms.</li></ul></li><li><p>Packages that wrap external libraries or programs can be named after those libraries or programs.</p><ul><li><p><code>CPLEX.jl</code> wraps the <code>CPLEX</code> library, which can be identified easily in a web search.</p></li><li><p><code>MATLAB.jl</code> provides an interface to call the MATLAB engine from within Julia.</p></li></ul></li><li><p>Avoid naming a package closely to an existing package</p><ul><li><p><code>Websocket</code> is too close to <code>WebSockets</code> and can be confusing to users. Rather use a new name such as <code>SimpleWebsockets</code>.</p></li></ul></li><li><p>Avoid using a distinctive name that is already in use in a well known, unrelated project.</p><ul><li><p>Don&#39;t use the names <code>Tkinter.jl</code>, <code>TkinterGUI.jl</code>, etc. for a package that is unrelated
to the popular <code>tkinter</code> python package, even if it provides bindings to Tcl/Tk.
A package name of <code>Tkinter.jl</code> would only be appropriate if the package used Python&#39;s
library to accomplish its work or was spearheaded by the same community of developers.</p></li><li><p>It&#39;s okay to name a package <code>HTTP.jl</code> even though it is unrelated to the popular rust
crate <code>http</code> because in most usages the name &quot;http&quot; refers to the hypertext transfer
protocol, not to the <code>http</code> rust crate.</p></li><li><p>It&#39;s okay to name a package <code>OpenSSL.jl</code> if it provides an interface to the OpenSSL
library, even without explicit affiliation with the creators of the OpenSSL (provided
there&#39;s no copyright or trademark infringement etc.)</p></li></ul></li><li><p>Packages should follow the <a href="https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions">Stylistic Conventions</a>.</p><ul><li><p>The package name should begin with a capital letter and word separation is shown with upper camel case</p></li><li><p>Only ASCII characters are allowed in a package name</p></li><li><p>Packages that provide the functionality of a project from another language should use the Julia convention</p></li><li><p>Packages that <a href="https://docs.binarybuilder.org/stable/jll/">provide pre-built libraries and executables</a> can keep their original name, but should get <code>_jll</code>as a suffix. For example <code>pandoc_jll</code> wraps pandoc. However, note that the generation and release of most JLL packages is handled by the <a href="https://github.com/JuliaPackaging/Yggdrasil">Yggdrasil</a> system.</p></li></ul></li><li><p>For the complete list of rules for automatic merging into the General registry, see <a href="https://juliaregistries.github.io/RegistryCI.jl/stable/guidelines/">these guidelines</a>.</p></li></ol><h2 id="Registering-packages"><a class="docs-heading-anchor" href="#Registering-packages">Registering packages</a><a id="Registering-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Registering-packages" title="Permalink"></a></h2><p>Once a package is ready it can be registered with the <a href="https://github.com/JuliaRegistries/General#registering-a-package-in-general">General Registry</a> (see also the <a href="https://github.com/JuliaRegistries/General#faq">FAQ</a>).
Currently, packages are submitted via <a href="https://juliaregistrator.github.io/"><code>Registrator</code></a>.
In addition to <code>Registrator</code>, <a href="https://github.com/marketplace/actions/julia-tagbot"><code>TagBot</code></a> helps manage the process of tagging releases.</p><h2 id="Creating-new-package-versions"><a class="docs-heading-anchor" href="#Creating-new-package-versions">Creating new package versions</a><a id="Creating-new-package-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-new-package-versions" title="Permalink"></a></h2><p>After registering your package, you&#39;ll want to release new versions as you add features and fix bugs. The typical workflow is:</p><ol><li><p><strong>Update the version number</strong> in your <code>Project.toml</code> file according to <a href="../compatibility/#Version-specifier-format">semantic versioning rules</a>. For example:</p><ul><li><p>Increment the patch version (1.2.3 → 1.2.4) for bug fixes</p></li><li><p>Increment the minor version (1.2.3 → 1.3.0) for new features that don&#39;t break existing functionality</p></li><li><p>Increment the major version (1.2.3 → 2.0.0) for breaking changes</p></li></ul></li><li><p><strong>Commit your changes</strong> to your package repository, including the updated version number.</p></li><li><p><strong>Tag the release</strong> using Registrator. Comment <code>@JuliaRegistrator register</code> on a commit or pull request in your GitHub repository</p></li><li><p><strong>Automated tagging</strong>: Once you&#39;ve set up <a href="https://github.com/marketplace/actions/julia-tagbot"><code>TagBot</code></a>, it will automatically create a git tag in your repository when a new version is registered. This keeps your repository tags synchronized with registered versions.</p></li></ol><p>The registration process typically takes a few minutes. Registrator will:</p><ul><li><p>Check that your package meets registry requirements (has tests, proper version bounds, etc.)</p></li><li><p>Submit a pull request to the General registry</p></li><li><p>Automated checks will run, and if everything passes, the PR will be automatically merged</p></li></ul><p>For private registries or more advanced workflows, see the documentation for <a href="https://github.com/GunnarFarneback/LocalRegistry.jl">LocalRegistry.jl</a> and <a href="https://github.com/JuliaRegistries/RegistryCI.jl">RegistryCI.jl</a>.</p><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><p>Packages should avoid mutating their own state (writing to files within their package directory).
Packages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a>).
To support the various use cases in the Julia package ecosystem, the Pkg developers have created a number of auxiliary packages and techniques to help package authors create self-contained, immutable, and relocatable packages:</p><ul><li><p><a href="https://pkgdocs.julialang.org/v1/artifacts/"><code>Artifacts</code></a> can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand.
Prefer artifacts over attempting to open a file via a path such as <code>joinpath(@__DIR__, &quot;data&quot;, &quot;my_dataset.csv&quot;)</code> as this is non-relocatable.
Once your package has been precompiled, the result of <code>@__DIR__</code> will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location.
Artifacts can be bundled and accessed easily using the <code>artifact&quot;name&quot;</code> string macro.</p></li><li><p><a href="https://github.com/JuliaPackaging/Scratch.jl"><code>Scratch.jl</code></a> provides the notion of &quot;scratch spaces&quot;, mutable containers of data for packages.
Scratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled.
For important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg.</p></li><li><p><a href="https://github.com/JuliaPackaging/Preferences.jl"><code>Preferences.jl</code></a> allows packages to read and write preferences to the top-level <code>Project.toml</code>.
These preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior.
Packages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that <code>Preferences</code> is available.</p></li></ul><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../managing-packages/#Managing-Packages">Managing Packages</a> - Learn how to add, update, and manage package dependencies</li><li><a href="../environments/#Working-with-Environments">Working with Environments</a> - Understand environments and reproducible development</li><li><a href="../compatibility/#Compatibility">Compatibility</a> - Specify version constraints for dependencies</li><li><a href="../api/#API-Reference">API Reference</a> - Functional API for non-interactive package management</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environments/">« <strong>4.</strong> Working with Environments</a><a class="docs-footer-nextpage" href="../apps/"><strong>6.</strong> Apps »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 16:49">Tuesday 10 February 2026</span>. Using Julia version 1.14.0-DEV.1703.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
