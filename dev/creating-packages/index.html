<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5. Creating Packages · Pkg.jl</title><meta name="title" content="5. Creating Packages · Pkg.jl"/><meta property="og:title" content="5. Creating Packages · Pkg.jl"/><meta property="twitter:title" content="5. Creating Packages · Pkg.jl"/><meta name="description" content="Documentation for Pkg.jl."/><meta property="og:description" content="Documentation for Pkg.jl."/><meta property="twitter:description" content="Documentation for Pkg.jl."/><meta property="og:url" content="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><meta property="twitter:url" content="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><link rel="canonical" href="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Pkg.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pkg.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../"><strong>1.</strong> Introduction</a></li><li><a class="tocitem" href="../getting-started/"><strong>2.</strong> Getting Started</a></li><li><a class="tocitem" href="../managing-packages/"><strong>3.</strong> Managing Packages</a></li><li><a class="tocitem" href="../environments/"><strong>4.</strong> Working with Environments</a></li><li class="is-active"><a class="tocitem" href><strong>5.</strong> Creating Packages</a><ul class="internal"><li><a class="tocitem" href="#Generating-files-for-a-package"><span>Generating files for a package</span></a></li><li><a class="tocitem" href="#Adding-dependencies-to-the-project"><span>Adding dependencies to the project</span></a></li><li><a class="tocitem" href="#Defining-a-public-API"><span>Defining a public API</span></a></li><li><a class="tocitem" href="#Adding-a-build-step-to-the-package"><span>Adding a build step to the package</span></a></li><li><a class="tocitem" href="#adding-tests-to-packages"><span>Adding tests to the package</span></a></li><li><a class="tocitem" href="#Compatibility-on-dependencies"><span>Compatibility on dependencies</span></a></li><li><a class="tocitem" href="#Weak-dependencies"><span>Weak dependencies</span></a></li><li><a class="tocitem" href="#Conditional-loading-of-code-in-packages-(Extensions)"><span>Conditional loading of code in packages (Extensions)</span></a></li><li><a class="tocitem" href="#Package-naming-rules"><span>Package naming rules</span></a></li><li><a class="tocitem" href="#Registering-packages"><span>Registering packages</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li></ul></li><li><a class="tocitem" href="../compatibility/"><strong>6.</strong> Compatibility</a></li><li><a class="tocitem" href="../registries/"><strong>7.</strong> Registries</a></li><li><a class="tocitem" href="../artifacts/"><strong>8.</strong> Artifacts</a></li><li><a class="tocitem" href="../glossary/"><strong>9.</strong> Glossary</a></li><li><a class="tocitem" href="../toml-files/"><strong>10.</strong> <code>Project.toml</code> and <code>Manifest.toml</code></a></li><li><a class="tocitem" href="../repl/"><strong>11.</strong> REPL Mode Reference</a></li><li><a class="tocitem" href="../api/"><strong>12.</strong> API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><strong>5.</strong> Creating Packages</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><strong>5.</strong> Creating Packages</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/Pkg.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/creating-packages.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="creating-packages-tutorial"><a class="docs-heading-anchor" href="#creating-packages-tutorial"><strong>5.</strong> Creating Packages</a><a id="creating-packages-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#creating-packages-tutorial" title="Permalink"></a></h1><h2 id="Generating-files-for-a-package"><a class="docs-heading-anchor" href="#Generating-files-for-a-package">Generating files for a package</a><a id="Generating-files-for-a-package-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-files-for-a-package" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates</a> package offers an easy, repeatable, and customizable way to generate the files for a new package. It can also generate files needed for Documentation, CI, etc. We recommend that you use PkgTemplates for creating new packages instead of using the minimal <code>pkg&gt; generate</code> functionality described below.</p></div></div><p>To generate the bare minimum files for a new package, use <code>pkg&gt; generate</code>.</p><pre><code class="language-julia-repl hljs">(@v1.8) pkg&gt; generate HelloWorld</code></pre><p>This creates a new project <code>HelloWorld</code> in a subdirectory by the same name, with the following files (visualized with the external <a href="https://linux.die.net/man/1/tree"><code>tree</code> command</a>):</p><pre><code class="language-julia-repl hljs">shell&gt; tree HelloWorld/
HelloWorld/
├── Project.toml
└── src
    └── HelloWorld.jl

2 directories, 2 files</code></pre><p>The <code>Project.toml</code> file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:</p><pre><code class="language-toml hljs">name = &quot;HelloWorld&quot;
uuid = &quot;b4cd1eb8-1e24-11e8-3319-93036a3eb9f3&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Some One &lt;someone@email.com&gt;&quot;]

[deps]</code></pre><p>The content of <code>src/HelloWorld.jl</code> is:</p><pre><code class="language-julia hljs">module HelloWorld

greet() = print(&quot;Hello World!&quot;)

end # module</code></pre><p>We can now activate the project by using the path to the directory where it is installed, and load the package:</p><pre><code class="language-julia-repl hljs">pkg&gt; activate ./HelloWorld

julia&gt; import HelloWorld

julia&gt; HelloWorld.greet()
Hello World!</code></pre><p>For the rest of the tutorial we enter inside the directory of the project, for convenience:</p><pre><code class="language-julia-repl hljs">julia&gt; cd(&quot;HelloWorld&quot;)</code></pre><h2 id="Adding-dependencies-to-the-project"><a class="docs-heading-anchor" href="#Adding-dependencies-to-the-project">Adding dependencies to the project</a><a id="Adding-dependencies-to-the-project-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-dependencies-to-the-project" title="Permalink"></a></h2><p>Let’s say we want to use the standard library package <code>Random</code> and the registered package <code>JSON</code> in our project. We simply <code>add</code> these packages (note how the prompt now shows the name of the newly generated project, since we <code>activate</code>d it):</p><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; add Random JSON
   Resolving package versions...
    Updating `~/HelloWorld/Project.toml`
  [682c06a0] + JSON v0.21.3
  [9a3f8284] + Random
    Updating `~/HelloWorld/Manifest.toml`
  [682c06a0] + JSON v0.21.3
  [69de0a69] + Parsers v2.4.0
  [ade2ca70] + Dates
 ...</code></pre><p>Both <code>Random</code> and <code>JSON</code> got added to the project’s <code>Project.toml</code> file, and the resulting dependencies got added to the <code>Manifest.toml</code> file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies.</p><p>We can now use both <code>Random</code> and <code>JSON</code> in our project. Changing <code>src/HelloWorld.jl</code> to</p><pre><code class="language-julia hljs">module HelloWorld

import Random
import JSON

greet() = print(&quot;Hello World!&quot;)
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>and reloading the package, the new <code>greet_alien</code> function that uses <code>Random</code> can be called:</p><pre><code class="language-julia-repl hljs">julia&gt; HelloWorld.greet_alien()
Hello aT157rHV</code></pre><h2 id="Defining-a-public-API"><a class="docs-heading-anchor" href="#Defining-a-public-API">Defining a public API</a><a id="Defining-a-public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-public-API" title="Permalink"></a></h2><p>If you want your package to be useful to other packages and you want folks to be able to easily update to newer version of your package when they come out, it is important to document what behavior will stay consistent across updates.</p><p>Unless you note otherwise, the public API of your package is defined as all the behavior you describe about public symbols. A public symbol is a symbol that is exported from your package with the <code>export</code> keyword or marked as public with the <code>public</code> keyword. When you change the behavior of something that was previously public so that the new version no longer conforms to the specifications provided in the old version, you should adjust your package version number according to <a href="#Version-specifier-format">Julia&#39;s variant on SemVer</a>. If you would like to include a symbol in your public API without exporting it into the global namespace of folks who call <code>using YourPackage</code>, you should mark that symbol as public with <code>public that_symbol</code>. Symbols marked as public with the <code>public</code> keyword are just as public as those marked as public with the <code>export</code> keyword, but when folks call <code>using YourPackage</code>, they will still have to qualify access to those symbols with <code>YourPackage.that_symbol</code>.</p><p>Let&#39;s say we would like our <code>greet</code> function to be part of the public API, but not the <code>greet_alien</code> function. We could the write the following and release it as version <code>1.0.0</code>.</p><pre><code class="language-julia hljs">module HelloWorld

export greet

import Random
import JSON

&quot;Writes a friendly message.&quot;
greet() = print(&quot;Hello World!&quot;)

&quot;Greet an alien by a randomly generated name.&quot;
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>Then, if we change <code>greet</code> to</p><pre><code class="language-julia hljs">&quot;Writes a friendly message that is exactly three words long.&quot;
greet() = print(&quot;Hello Lovely World!&quot;)</code></pre><p>We would release the new version as <code>1.1.0</code>. This is not breaking because the new implementation conforms to the old documentation, but it does add a new feature, that the message must be three words long.</p><p>Later, we may wish to change <code>greet_alien</code> to</p><pre><code class="language-julia hljs">&quot;Greet an alien by the name of \&quot;Zork\&quot;.&quot;
greet_alien() = print(&quot;Hello Zork&quot;)</code></pre><p>And also export it by changing</p><pre><code class="language-julia hljs">export greet</code></pre><p>to</p><pre><code class="language-julia hljs">export greet, greet_alien</code></pre><p>We should release this new version as <code>1.2.0</code> because it adds a new feature <code>greet_alien</code> to the public API. Even though <code>greet_alien</code> was documented before and the new version does not conform to the old documentation, this is not breaking because the old documentation was not attached to a symbol that was exported at the time so that documentation does not apply across released versions.</p><p>However, if we now wish to change <code>greet</code> to</p><pre><code class="language-julia hljs">&quot;Writes a friendly message that is exactly four words long.&quot;
greet() = print(&quot;Hello very lovely world&quot;)</code></pre><p>we would need to release the new version as <code>2.0.0</code>. In version <code>1.1.0</code>, we specified that the greeting would be three words long, and because <code>greet</code> was exported, that description also applies to all future versions until the next breaking release. Because this new version does not conform to the old specification, it must be tagged as a breaking change.</p><p>Please note that version numbers are free and unlimited. It is okay to use lots of them (e.g. version <code>6.62.8</code>).</p><h2 id="Adding-a-build-step-to-the-package"><a class="docs-heading-anchor" href="#Adding-a-build-step-to-the-package">Adding a build step to the package</a><a id="Adding-a-build-step-to-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-build-step-to-the-package" title="Permalink"></a></h2><p>The build step is executed the first time a package is installed or when explicitly invoked with <code>build</code>. A package is built by executing the file <code>deps/build.jl</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; mkpath(&quot;deps&quot;);

julia&gt; write(&quot;deps/build.jl&quot;,
             &quot;&quot;&quot;
             println(&quot;I am being built...&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

julia&gt; print(readchomp(&quot;deps/build.log&quot;))
I am being built...</code></pre><p>If the build step fails, the output of the build step is printed to the console</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;deps/build.jl&quot;,
             &quot;&quot;&quot;
             error(&quot;Ooops&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; build
    Building HelloWorld → `~/HelloWorld/deps/build.log`
ERROR: Error building `HelloWorld`:
ERROR: LoadError: Ooops
Stacktrace:
 [1] error(s::String)
   @ Base ./error.jl:35
 [2] top-level scope
   @ ~/HelloWorld/deps/build.jl:1
 [3] include(fname::String)
   @ Base.MainInclude ./client.jl:476
 [4] top-level scope
   @ none:5
in expression starting at /home/kc/HelloWorld/deps/build.jl:1</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>A build step should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the <a href="https://github.com/JuliaPackaging/Scratch.jl">Scratch.jl</a> package.</p></div></div><h2 id="adding-tests-to-packages"><a class="docs-heading-anchor" href="#adding-tests-to-packages">Adding tests to the package</a><a id="adding-tests-to-packages-1"></a><a class="docs-heading-anchor-permalink" href="#adding-tests-to-packages" title="Permalink"></a></h2><p>When a package is tested the file <code>test/runtests.jl</code> is executed:</p><pre><code class="language-julia-repl hljs">julia&gt; mkpath(&quot;test&quot;);

julia&gt; write(&quot;test/runtests.jl&quot;,
             &quot;&quot;&quot;
             println(&quot;Testing...&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed</code></pre><p>Tests are run in a new Julia process, where the package itself, and any test-specific dependencies, are available, see below.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Tests should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the <a href="https://github.com/JuliaPackaging/Scratch.jl">Scratch.jl</a> package.</p></div></div><h3 id="Test-specific-dependencies"><a class="docs-heading-anchor" href="#Test-specific-dependencies">Test-specific dependencies</a><a id="Test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Test-specific-dependencies" title="Permalink"></a></h3><p>There are two ways of adding test-specific dependencies (dependencies that are not dependencies of the package but will still be available to load when the package is tested).</p><h4 id="target-based-test-specific-dependencies"><a class="docs-heading-anchor" href="#target-based-test-specific-dependencies"><code>target</code> based test specific dependencies</a><a id="target-based-test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#target-based-test-specific-dependencies" title="Permalink"></a></h4><p>Using this method of adding test-specific dependencies, the packages are added under an <code>[extras]</code> section and to a test target, e.g. to add <code>Markdown</code> and <code>Test</code> as test dependencies, add the following to the <code>Project.toml</code> file:</p><pre><code class="language-toml hljs">[extras]
Markdown = &quot;d6f4376e-aef5-505a-96c1-9c027394607a&quot;
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Markdown&quot;, &quot;Test&quot;]</code></pre><p>Note that the only supported targets are <code>test</code> and <code>build</code>, the latter of which (not recommended) can be used for any <code>deps/build.jl</code> scripts.</p><h4 id="Alternative-approach:-test/Project.toml-file-test-specific-dependencies"><a class="docs-heading-anchor" href="#Alternative-approach:-test/Project.toml-file-test-specific-dependencies">Alternative approach: <code>test/Project.toml</code> file test specific dependencies</a><a id="Alternative-approach:-test/Project.toml-file-test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-approach:-test/Project.toml-file-test-specific-dependencies" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The exact interaction between <code>Project.toml</code>, <code>test/Project.toml</code> and their corresponding <code>Manifest.toml</code>s are not fully worked out and may be subject to change in future versions. The older method of adding test-specific dependencies, described in the previous section, will therefore be supported throughout all Julia 1.X releases.</p></div></div><p>In Julia 1.2 and later test dependencies can be declared in <code>test/Project.toml</code>. When running tests, Pkg will automatically merge this and the package Projects to create the test environment.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If no <code>test/Project.toml</code> exists Pkg will use the <code>target</code> based test specific dependencies.</p></div></div><p>To add a test-specific dependency, i.e. a dependency that is available only when testing, it is thus enough to add this dependency to the <code>test/Project.toml</code> project. This can be done from the Pkg REPL by activating this environment, and then use <code>add</code> as one normally does. Let&#39;s add the <code>Test</code> standard library as a test dependency:</p><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; activate ./test
[ Info: activating environment at `~/HelloWorld/test/Project.toml`.

(test) pkg&gt; add Test
 Resolving package versions...
  Updating `~/HelloWorld/test/Project.toml`
  [8dfed614] + Test
  Updating `~/HelloWorld/test/Manifest.toml`
  [...]</code></pre><p>We can now use <code>Test</code> in the test script and we can see that it gets installed when testing:</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;test/runtests.jl&quot;,
             &quot;&quot;&quot;
             using Test
             @test 1 == 1
             &quot;&quot;&quot;);

(test) pkg&gt; activate .

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```</code></pre><h2 id="Compatibility-on-dependencies"><a class="docs-heading-anchor" href="#Compatibility-on-dependencies">Compatibility on dependencies</a><a id="Compatibility-on-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility-on-dependencies" title="Permalink"></a></h2><p>Every dependency should in general have a compatibility constraint on it. This is an important topic so there is a separate chapter about it: <a href="../compatibility/#Compatibility">Compatibility</a>.</p><h2 id="Weak-dependencies"><a class="docs-heading-anchor" href="#Weak-dependencies">Weak dependencies</a><a id="Weak-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-dependencies" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>The described feature requires Julia 1.9+.</p></div></div><p>A weak dependency is a dependency that will not automatically install when the package is installed but you can still control what versions of that package are allowed to be installed by setting compatibility on it. These are listed in the project file under the <code>[weakdeps]</code> section:</p><pre><code class="language-toml hljs">[weakdeps]
SomePackage = &quot;b3785f31-9d33-4cdf-bc73-f646780f1739&quot;

[compat]
SomePackage = &quot;1.2&quot;</code></pre><p>The current usage of this is almost solely limited to &quot;extensions&quot; which is described in the next section.</p><h2 id="Conditional-loading-of-code-in-packages-(Extensions)"><a class="docs-heading-anchor" href="#Conditional-loading-of-code-in-packages-(Extensions)">Conditional loading of code in packages (Extensions)</a><a id="Conditional-loading-of-code-in-packages-(Extensions)-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-loading-of-code-in-packages-(Extensions)" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>The described feature requires Julia 1.9+.</p></div></div><p>Sometimes one wants to make two or more packages work well together, but may be reluctant (perhaps due to increased load times) to make one an unconditional dependency of the other. A package <em>extension</em> is a module in a file (similar to a package) that is automatically loaded when <em>some other set of packages</em> are loaded into the Julia session. This is very similar to functionality that the external package <a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a> provides, but which is now available directly through Julia, and provides added benefits such as being able to precompile the extension.</p><h3 id="Code-structure"><a class="docs-heading-anchor" href="#Code-structure">Code structure</a><a id="Code-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Code-structure" title="Permalink"></a></h3><p>A useful application of extensions could be for a plotting package that should be able to plot objects from a wide variety of different Julia packages. Adding all those different Julia packages as dependencies of the plotting package could be expensive since they would end up getting loaded even if they were never used. Instead, the code required to plot objects for specific packages can be put into separate files (extensions) and these are loaded only when the packages that define the type(s) we want to plot are loaded.</p><p>Below is an example of how the code can be structured for a use case in which a <code>Plotting</code> package wants to be able to display objects defined in the external package <code>Contour</code>. The file and folder structure shown below is found in the <code>Plotting</code> package.</p><p><code>Project.toml</code>:</p><pre><code class="language-toml hljs">name = &quot;Plotting&quot;
version = &quot;0.1.0&quot;
uuid = &quot;...&quot;

[weakdeps]
Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot;

[extensions]
# name of extension to the left
# extension dependencies required to load the extension to the right
# use a list for multiple extension dependencies
ContourExt = &quot;Contour&quot;

[compat]
Contour = &quot;0.6.2&quot;</code></pre><p><code>src/Plotting.jl</code>:</p><pre><code class="language-julia hljs">module Plotting

function plot(x::Vector)
    # Some functionality for plotting a vector here
end

end # module</code></pre><p><code>ext/ContourExt.jl</code> (can also be in <code>ext/ContourExt/ContourExt.jl</code>):</p><pre><code class="language-julia hljs">module ContourExt # Should be same name as the file (just like a normal package)

using Plotting, Contour

function Plotting.plot(c::Contour.ContourCollection)
    # Some functionality for plotting a contour here
end

end # module</code></pre><p>Extensions can have arbitrary names (here <code>ContourExt</code>), following the format of this example is likely a good idea for extensions with a single dependency. In <code>Pkg</code> output, extension names are always shown together with their parent package name.</p><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>Often you will put the extension dependencies into the <code>test</code> target so they are loaded when running e.g. <code>Pkg.test()</code>. On earlier Julia versions this requires you to also put the package in the <code>[extras]</code> section. This is unfortunate but the project verifier on older Julia versions will complain if this is not done.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you use a manifest generated by a Julia version that does not know about extensions with a Julia version that does know about them, the extensions will not load. This is because the manifest lacks some information that tells Julia when it should load these packages. So make sure you use a manifest generated at least the Julia version you are using.</p></div></div><h3 id="Behavior-of-extensions"><a class="docs-heading-anchor" href="#Behavior-of-extensions">Behavior of extensions</a><a id="Behavior-of-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Behavior-of-extensions" title="Permalink"></a></h3><p>A user that depends only on <code>Plotting</code> will not pay the cost of the &quot;extension&quot; inside the <code>ContourExt</code> module. It is only when the <code>Contour</code> package actually gets loaded that the <code>ContourExt</code> extension is loaded too and provides the new functionality.</p><p>In our example, the new functionality is an additional <em>method</em>, which we add to an existing <em>function</em> from the parent package <code>Plotting</code>. Implementing such methods is among the most standard use cases of package extensions. Within the parent package, the function to extend can even be defined with zero methods, as follows:</p><pre><code class="language-julia hljs">function plot end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If one considers <code>ContourExt</code> as a completely separate package, it could be argued that defining <code>Plotting.plot(c::Contour.ContourCollection)</code> is <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">type piracy</a> since <code>ContourExt</code> <em>owns</em> neither the function <code>Plotting.plot</code> nor the type <code>Contour.ContourCollection</code>. However, for extensions, it is ok to assume that the extension owns the functions in its parent package.</p></div></div><p>In other situations, one may need to define new symbols in the extension (types, structs, functions, etc.) instead of reusing those from the parent package. Such symbols are created in a separate module corresponding to the extension, namely <code>ContourExt</code>, and thus not in <code>Plotting</code> itself. If extension symbols are needed in the parent package, one must call <code>Base.get_extension</code> to retrieve them. Here is an example showing how a custom type defined in <code>ContourExt</code> can be accessed in <code>Plotting</code>:</p><pre><code class="language-julia hljs">ext = Base.get_extension(@__MODULE__, :ContourExt)
if !isnothing(ext)
    ContourPlotType = ext.ContourPlotType
end</code></pre><p>On the other hand, accessing extension symbols from a third-party package (i.e. not the parent) is not a recommended practice at the moment.</p><h3 id="Backwards-compatibility"><a class="docs-heading-anchor" href="#Backwards-compatibility">Backwards compatibility</a><a id="Backwards-compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Backwards-compatibility" title="Permalink"></a></h3><p>This section discusses various methods for using extensions on Julia versions that support them, while simultaneously providing similar functionality on older Julia versions.</p><h4 id="Requires.jl"><a class="docs-heading-anchor" href="#Requires.jl">Requires.jl</a><a id="Requires.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Requires.jl" title="Permalink"></a></h4><p>This section is relevant if you are currently using Requires.jl but want to transition to using extensions (while still having Requires be used on Julia versions that do not support extensions). This is done by making the following changes (using the example above):</p><ul><li><p>Add the following to the package file. This makes it so that Requires.jl loads and inserts the callback only when extensions are not supported</p><pre><code class="language-julia hljs"># This symbol is only defined on Julia versions that support extensions
if !isdefined(Base, :get_extension)
using Requires
end

@static if !isdefined(Base, :get_extension)
function __init__()
    @require Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot; include(&quot;../ext/ContourExt.jl&quot;)
end
end</code></pre><p>or if you have other things in your <code>__init__()</code> function:</p><pre><code class="language-julia hljs">if !isdefined(Base, :get_extension)
using Requires
end

function __init__()
    # Other init functionality here

    @static if !isdefined(Base, :get_extension)
        @require Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot; include(&quot;../ext/ContourExt.jl&quot;)
    end
end</code></pre></li><li><p>Make the following change in the conditionally-loaded code in <code>ContourExt.jl</code>:</p><pre><code class="language-julia hljs">isdefined(Base, :get_extension) ? (using Contour) : (using ..Contour)</code></pre></li><li><p>Add <code>Requires</code> to <code>[weakdeps]</code> in your <code>Project.toml</code> file, so that it is listed in both <code>[deps]</code> and <code>[weakdeps]</code>. Julia 1.9+ knows to not install it as a regular dependency, whereas earlier versions will consider it a dependency.</p></li></ul><p>The package should now work with Requires.jl on Julia versions before extensions were introduced and with extensions on more recent Julia versions.</p><h4 id="Transition-from-normal-dependency-to-extension"><a class="docs-heading-anchor" href="#Transition-from-normal-dependency-to-extension">Transition from normal dependency to extension</a><a id="Transition-from-normal-dependency-to-extension-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-from-normal-dependency-to-extension" title="Permalink"></a></h4><p>This section is relevant if you have a normal dependency that you want to transition be an extension (while still having the dependency be a normal dependency on Julia versions that do not support extensions). This is done by making the following changes (using the example above):</p><ul><li>Make sure that the package is <strong>both</strong> in the <code>[deps]</code> and <code>[weakdeps]</code> section. Newer Julia versions will ignore dependencies in <code>[deps]</code> that are also in <code>[weakdeps]</code>.</li><li>Add the following to your main package file (typically at the bottom):<pre><code class="language-julia hljs">if !isdefined(Base, :get_extension)
  include(&quot;../ext/ContourExt.jl&quot;)
end</code></pre></li></ul><h4 id="Using-an-extension-while-supporting-older-Julia-versions"><a class="docs-heading-anchor" href="#Using-an-extension-while-supporting-older-Julia-versions">Using an extension while supporting older Julia versions</a><a id="Using-an-extension-while-supporting-older-Julia-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Using-an-extension-while-supporting-older-Julia-versions" title="Permalink"></a></h4><p>In the case where one wants to use an extension (without worrying about the feature of the extension being available on older Julia versions) while still supporting older Julia versions the packages under <code>[weakdeps]</code> should be duplicated into <code>[extras]</code>. This is an unfortunate duplication, but without doing this the project verifier under older Julia versions will throw an error if it finds packages under <code>[compat]</code> that is not listed in <code>[extras]</code>.</p><h2 id="Package-naming-rules"><a class="docs-heading-anchor" href="#Package-naming-rules">Package naming rules</a><a id="Package-naming-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Package-naming-rules" title="Permalink"></a></h2><p>Package names should be sensible to most Julia users, <em>even to those who are not domain experts</em>. The following rules apply to the <code>General</code> registry but may be useful for other package registries as well.</p><p>Since the <code>General</code> registry belongs to the entire community, people may have opinions about your package name when you publish it, especially if it&#39;s ambiguous or can be confused with something other than what it is. Usually, you will then get suggestions for a new name that may fit your package better.</p><ol><li><p>Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.</p><ul><li>It&#39;s ok to say <code>USA</code> if you&#39;re talking about the USA.</li><li>It&#39;s not ok to say <code>PMA</code>, even if you&#39;re talking about positive mental attitude.</li></ul></li><li><p>Avoid using <code>Julia</code> in your package name or prefixing it with <code>Ju</code>.</p><ul><li>It is usually clear from context and to your users that the package is a Julia package.</li><li>Package names already have a <code>.jl</code> extension, which communicates to users that <code>Package.jl</code> is a Julia package.</li><li>Having Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.</li></ul></li><li><p>Packages that provide most of their functionality in association with a new type should have pluralized names.</p><ul><li><code>DataFrames</code> provides the <code>DataFrame</code> type.</li><li><code>BloomFilters</code> provides the <code>BloomFilter</code> type.</li><li>In contrast, <code>JuliaParser</code> provides no new type, but instead new functionality in the <code>JuliaParser.parse()</code> function.</li></ul></li><li><p>Err on the side of clarity, even if clarity seems long-winded to you.</p><ul><li><code>RandomMatrices</code> is a less ambiguous name than <code>RndMat</code> or <code>RMT</code>, even though the latter are shorter.</li></ul></li><li><p>A less systematic name may suit a package that implements one of several possible approaches to its domain.</p><ul><li>Julia does not have a single comprehensive plotting package. Instead, <code>Gadfly</code>, <code>PyPlot</code>, <code>Winston</code> and other packages each implement a unique approach based on a particular design philosophy.</li><li>In contrast, <code>SortingAlgorithms</code> provides a consistent interface to use many well-established sorting algorithms.</li></ul></li><li><p>Packages that wrap external libraries or programs can be named after those libraries or programs.</p><ul><li><code>CPLEX.jl</code> wraps the <code>CPLEX</code> library, which can be identified easily in a web search.</li><li><code>MATLAB.jl</code> provides an interface to call the MATLAB engine from within Julia.</li></ul></li><li><p>Avoid naming a package closely to an existing package</p><ul><li><code>Websocket</code> is too close to <code>WebSockets</code> and can be confusing to users. Rather use a new name such as <code>SimpleWebsockets</code>.</li></ul></li><li><p>Avoid using a distinctive name that is already in use in a well known, unrelated project.</p><ul><li>Don&#39;t use the names <code>Tkinter.jl</code>, <code>TkinterGUI.jl</code>, etc. for a package that is unrelated to the popular <code>tkinter</code> python package, even if it provides bindings to Tcl/Tk. A package name of <code>Tkinter.jl</code> would only be appropriate if the package used Python&#39;s library to accomplish its work or was spearheaded by the same community of developers.</li><li>It&#39;s okay to name a package <code>HTTP.jl</code> even though it is unrelated to the popular rust crate <code>http</code> because in most usages the name &quot;http&quot; refers to the hypertext transfer protocol, not to the <code>http</code> rust crate.</li><li>It&#39;s okay to name a package <code>OpenSSL.jl</code> if it provides an interface to the OpenSSL library, even without explicit affiliation with the creators of the OpenSSL (provided there&#39;s no copyright or trademark infringement etc.)</li></ul></li><li><p>Packages should follow the <a href="https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions">Stylistic Conventions</a>.</p><ul><li>The package name begin with a capital letter and word separation is shown with upper camel case</li><li>Packages that provide the functionality of a project from another language should use the Julia convention</li><li>Packages that <a href="https://docs.binarybuilder.org/stable/jll/">provide pre-built libraries and executables</a> can keep orignal name, but should get <code>_jll</code>as a suffix. For example <code>pandoc_jll</code> wraps pandoc. However, note that the generation and release of most JLL packages is handled by the <a href="https://github.com/JuliaPackaging/Yggdrasil">Yggdrasil</a> system. </li></ul></li></ol><h2 id="Registering-packages"><a class="docs-heading-anchor" href="#Registering-packages">Registering packages</a><a id="Registering-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Registering-packages" title="Permalink"></a></h2><p>Once a package is ready it can be registered with the <a href="https://github.com/JuliaRegistries/General#registering-a-package-in-general">General Registry</a> (see also the <a href="https://github.com/JuliaRegistries/General#faq">FAQ</a>). Currently, packages are submitted via <a href="https://juliaregistrator.github.io/"><code>Registrator</code></a>. In addition to <code>Registrator</code>, <a href="https://github.com/marketplace/actions/julia-tagbot"><code>TagBot</code></a> helps manage the process of tagging releases.</p><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><p>Packages should avoid mutating their own state (writing to files within their package directory). Packages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a>). To support the various use cases in the Julia package ecosystem, the Pkg developers have created a number of auxiliary packages and techniques to help package authors create self-contained, immutable, and relocatable packages:</p><ul><li><p><a href="https://pkgdocs.julialang.org/v1/artifacts/"><code>Artifacts</code></a> can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand. Prefer artifacts over attempting to open a file via a path such as <code>joinpath(@__DIR__, &quot;data&quot;, &quot;my_dataset.csv&quot;)</code> as this is non-relocatable. Once your package has been precompiled, the result of <code>@__DIR__</code> will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location. Artifacts can be bundled and accessed easily using the <code>artifact&quot;name&quot;</code> string macro.</p></li><li><p><a href="https://github.com/JuliaPackaging/Scratch.jl"><code>Scratch.jl</code></a> provides the notion of &quot;scratch spaces&quot;, mutable containers of data for packages. Scratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled. For important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg.</p></li><li><p><a href="https://github.com/JuliaPackaging/Preferences.jl"><code>Preferences.jl</code></a> allows packages to read and write preferences to the top-level <code>Project.toml</code>. These preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior. Packages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that <code>Preferences</code> is available.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environments/">« <strong>4.</strong> Working with Environments</a><a class="docs-footer-nextpage" href="../compatibility/"><strong>6.</strong> Compatibility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 23 February 2025 07:07">Sunday 23 February 2025</span>. Using Julia version 1.13.0-DEV.103.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
