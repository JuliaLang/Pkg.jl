number,title,state,author,assignees,labels,milestone,comments_count,created_at,updated_at,age_days,days_since_update,url,api_url,body_full,comments_text,comments_count_actual,locked,reactions_total,reactions_plus_one,reactions_minus_one,reactions_laugh,reactions_hooray,reactions_confused,reactions_heart,reactions_rocket,reactions_eyes
4232,Add PDF export to pkgdocs deployment,open,ickc,,,,1,2025-05-08T09:34:13.0,2025-07-16T10:11:36.0,73,4,https://github.com/JuliaLang/Pkg.jl/issues/4232,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4232,"The Pkg documentation at https://pkgdocs.julialang.org/v1/ currently lacks a PDF download option, unlike the main Julia documentation at https://docs.julialang.org/en/v1/ which provides one.\n\nI noticed there's already a PDF target in the project's build configuration, but it's not being deployed to gh-pages alongside the HTML version. Adding the PDF to the deployment would provide:\n\n- **Offline access** - Read Pkg documentation without internet connectivity\n- **Better study workflow** - Add highlights, annotations, and bookmarks directly in the document\n- **Research integration** - Import into reference managers like Zotero for easier citation and retrieval\n- **Consistency** - Match the main Julia documentation's offering of multiple formats\n\nSince the PDF target already exists, this should just require adding it to the gh-pages deployment process. Would you be open to including the built PDF in the deployment?","[ickc]: Actually, pdf are already built and uploaded in https://github.com/JuliaLang/Pkg.jl/blob/gh-pages-pdf/v1.11.6/Pkg.jl.pdf\nI guess the only remaining issue is that it is not linked from the documentation site?",1,false,0,0,0,0,0,0,0,0,0
4324,Pkg.develop uses backslash instead of forward slash in [sources] on Windows,open,davidanthoff,,,1.13,1,2025-07-15T10:36:09.0,2025-07-15T13:46:29.0,5,5,https://github.com/JuliaLang/Pkg.jl/issues/4324,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4324,"When I call something like\n```julia\njulia +1.12 --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=""""../../TestItemServer""""))'\n```\non Windows, it creates a `Project.toml` like this\n```\n[deps]\nTestItemServer = """"1076c532-7f93-4758-ac65-93afa8eae143""""\n\n[sources]\nTestItemServer = {path = """"..\\..\\TestItemServer""""}\n```\nNote the use of backslash instead of forward slash. The manifest that is created correctly has forward slashes in there.\n\nMy proposal would be to _always_ use forward slash and never backslash. That is how it is handled for the manifest, and it makes the cross platform story way way easier (Julia 1.0 and 1.1 didn't do this for manifests, and we still have a lot of workaround code for that in the extension in a lot of places).\n\nBut I think minimally it should respect what is passed to the `develop` function.\n\nThis should ideally be fixed pre 1.12 release, I think?",[KristofferC]: Adding of sources is a 1.13 thing (that was accidentally in 1.12 so adding to 1.13 milestone).,1,false,0,0,0,0,0,0,0,0,0
2153,client-side pkg server selection,open,StefanKarpinski,,,,13,2020-10-22T15:01:45.0,2025-07-10T16:45:52.0,1732,9,https://github.com/JuliaLang/Pkg.jl/issues/2153,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2153,"There is already a `/siblings` end point on package servers:\n```sh\n$ curl -L https://pkg.julialang.org/meta/siblings\n[""""https://us-west.pkg.julialang.org"""",""""https://us-east.pkg.julialang.org"""",""""https://us-east2.pkg.julialang.org"""",""""https://us-east-ci.pkg.julialang.org"""",""""https://eu-central.pkg.julialang.org"""",""""https://in.pkg.julialang.org"""",""""https://kr.pkg.julialang.org"""",""""https://sg.pkg.julialang.org"""",""""https://cn-southeast.pkg.julialang.org"""",""""https://cn-east.pkg.julialang.org"""",""""https://cn-northeast.pkg.julialang.org"""",""""https://au.pkg.julialang.org""""]\n```\nThe plan, which @staticfloat and I have discussed has been to allow the client to probe the available package server instances to see which one is fastest and pick one based on which is fastest at getting back to them. This will do geographical load balancing more accurately than our current server-side redirection and will also take into account CPU load: if a server is really busy, it will be slower to respond and this will send more clients to other servers, thereby reducing the load on busier servers.\n\nThe flow that was envisioned was this:\n\n1. The client requests `https://pkg.julialang.org/meta/siblings` and gets redirected to `https://us-east.pkg.julialang.org/meta/siblings`, for example.\n\n2. The `us-east` server replies with the list of sibling servers.\n\n3. The client requests `https://pkg.julialang.org/status` or something and chooses the server that replies the fastest and/or reports the lowest workload.\n\nThere is, however, a problem with the current plan: we would want this to work even if the user's primary pkg server is not responding at all. If `us-east.pkg.julialang.org` is completely broken, then anyone who is mapped there will not be able to get a list of siblings at all, so they're just stuck. This design is as flaky as the flakiest server.\n\nInstead, I think we need to arrange for `https://pkg.julialang.org/servers` to reply with a list of servers as static data, not forwarded to any specific package server (like `us-east.pkg.julialang.org`). Then the client can use that list proceed to step 3. Any server that doesn't reply at all will be ignored and the client will pick the server that replies first/reports low workload/good status. This design means that any one pkg server being down will not affect clients except that they might need to go a little further to get packages.","[DilumAluthge]: Cache the list of siblings locally? | [DilumAluthge]: So as long as the user is able to connect to their primary Pkg server one time, they can pull the list of siblings, and then we keep (and update) that list locally. | [DilumAluthge]: We could also hardcode a (not necessarily proper) subset of the siblings in the Pkg client code. And then if the sibling-list cache doesn't exist, we prepopulate it with the hardcoded list. | [StefanKarpinski]: All possible options, but it seems more reliable to serve the list of servers as a static page. It's a bad first experience if the server happens to be down and you can't connect. Hardcoding a server list is possible, but feels kind of icky—you really want to hardcode as little as possible, and if you change from `pkg.julialang.org` to `pkg.company.com` then what? | [DilumAluthge]: Hmmm. What happens when https://pkg.julialang.org/servers goes down? | [DilumAluthge]: Even if we go with https://pkg.julialang.org/servers and we don't hardcode anything, I think that at least caching the results of https://pkg.julialang.org/servers locally would be good. At the very least, we should cache those results for the remainder of the same Julia session - no need to hit https://pkg.julialang.org/servers multiple times during a single Julia session.\n\nAnd if we cache the results of https://pkg.julialang.org/servers on disk locally, then maybe we only need to hit https://pkg.julialang.org/servers one time per week to update the cache.\n\nWould reduce strain on whichever machine serves https://pkg.julialang.org/servers\n\n--- \n\nWe'd tie this cache to the value of the JULIA_PKG_SERVER environment variable. If someone changes the value of JULIA_PKG_SERVER, we'd invalidate the cache. | [DilumAluthge]: There are other special cases that might be nice to do.\n\nFor example, if `get(ENV, """"CI"""", """""""")` is `""""true""""`, I would not bother fetching https://pkg.julialang.org/servers - I would just connect to the geo-selected Pkg server, which if we have done our job should be `us-east-ci`.\n\nJust trying to think of ways to reduce traffic to https://pkg.julialang.org/servers. If every Julia user in the world is hitting https://pkg.julialang.org/servers one time per Julia session, that's a good deal of traffic, even if it is statically serving a file. | [StefanKarpinski]: Synthesizing all of this, it seems like this may be a viable strategy:\n\n- cache a list of alternatives for each pkg server value\n- have a hard-coded pre-populated list for `pkg.julialang.org`\n- if we have a list for a server, try all of them and pick the best one\n- if we don't have a list for a server yet, request `$server/meta/siblings` in order to get such a list\n\nOne thing that's a little bit weird about this is that if you set your package server to `pkg.julialang.org` then you will be redirected, so you should probably do this dance. On the other hand, if you've explicitly set your package server to `au.pkg.julialang.org`, should we be second-guessing that or just using that server? Perhaps the logic here should be:\n\n- if your `pkg_server()` value is in the list, then use it; if it cannot be reached, what then?\n- if your `pkg_server()` value is not in the list, always pick the best server from the list\n\nThat way people can set a specific sibling to use and that will be honored. | [DilumAluthge]: That sounds like a good plan to me!\n\nI agree that the """"you've explicitly set your package server to `au.pkg.julialang.org`"""" case is a weird case. I think the logic you outlined there makes sense. | [johnnychen94]: Could this functionality be implemented as a non-standard package? That way 3rd-party pkg servers can be added to the pre-populated list in a more flexible way.\n\n(Although I'm thinking of those storage mirrors in China, e.g., [BFSU](https://mirrors.bfsu.edu.cn/julia/), as 3rd-party pkg servers.) | [StefanKarpinski]: It seems like a static file on the server would work in that case, no? | [KristofferC]: My guess is that this does not have to be discussed much more. | [StefanKarpinski]: This isn't done yet though...",13,false,2,2,0,0,0,0,0,0,0
4237,Automatic addition to `[sources]` does not play well with workspaces,open,Keno,,bug,,1,2025-05-15T22:30:47.0,2025-07-09T08:46:08.0,65,11,https://github.com/JuliaLang/Pkg.jl/issues/4237,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4237,"Consider a Project like https://github.com/JuliaComputing/DAECompiler.jl/blob/6f771bd21dc7f8e61befca32beb0a6dbab32a6aa/test/Project.toml (which is part of a workspace with its parent directory). On Julia main, I did `add Polynomials`, which resulted in Pkg adding\n\n```\nCompiler = {path = """"/home/keno/julia-clean/Compiler/""""}\nCthulhu = {rev = """"master"""", url = """"https://github.com/JuliaDebug/Cthulhu.jl.git""""}\nDAECompiler = {path = """".""""}\nDiffractor = {rev = """"main"""", url = """"https://github.com/JuliaDiff/Diffractor.jl.git""""}\nSciMLSensitivity = {path = """"/home/keno/.julia/dev/SciMLSensitivity""""}\nStateSelection = {rev = """"main"""", url = """"git@github.com:JuliaComputing/StateSelection.jl.git""""}\n```\n\nto my `[sources]`. These are mostly copied from the main Project.toml, which seems fine, but redundant (I'd prefer to only have to specify these one place). However, I think the new `DAECompiler` entry is just wrong, because it's at the wrong level of the tree.","[KristofferC]: Some notes:\n\n- The `DAECompiler` entry is completely bogus and should not be there. In fact, any package within the workspace should not be added to sources.\n- As to what file the source entry should go into, would it make sense to put it in the project file closest to the root that also has the corresponding package as a dependency? Or should the source info always go into the root project? But then we would need to add an entry about the UUID for that package there, maybe under [extras].",1,false,1,1,0,0,0,0,0,0,0
3269,"Support for ""raw"" artifacts (that are not extracted)",open,maleadt,,bug; artifacts,,14,2022-12-02T09:21:54.0,2025-07-07T15:59:33.0,961,12,https://github.com/JuliaLang/Pkg.jl/issues/3269,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3269,"Certain artifacts rely on specific permissions, or other peculiarities that get lost when tarballs are extracted and files are stored in the artifacts folder. It would be convenient if next to `lazy = (true|false*)` there were something like `raw = (true|false*)` that makes it the user's responsibility to handle these tarballs, i.e., without Pkg.jl messing with them other than downloading and verifying them.\n\nThis would be useful for PkgEval.jl, where we now can't use the high-level APIs of the Artifacts stdlib, and instead have to manually fiddle with the Artifacts.toml file: https://github.com/JuliaCI/PkgEval.jl/pull/189\n\nOriginal issue below:\n\n---\n\n\nI'm having an issue with a rootfs artifact (i.e. containing a Linux OS) being extracted with the wrong permissions. The image in question is used in PkgEval.jl, and the problematic file is a lock whose `u+w` permissions are dropped.\n\nFirst of all, here's the tarball and the permissions the lock file should have:\n\n```\n❯ wget https://github.com/JuliaCI/PkgEval.jl/releases/download/v0.1/debian-bullseye-20220818.tar.xz\n❯ tar -tvf debian-bullseye-20220818.tar.xz | grep var/lib/dpkg/lock-frontend\n-rw-r-----  0 tim    tim         0 Aug 18 16:19 ./var/lib/dpkg/lock-frontend\n```\n\nIf I download this tarball using Pkg's `download_verify_unpack`, all seems well (an `o+r` permission is added, which isn't great, but also not terrible):\n\n```\njulia> Pkg.download_verify_unpack(""""https://github.com/JuliaCI/PkgEval.jl/releases/download/v0.1/debian-bullseye-20220818.tar.xz"""", nothing, mktempdir(); verbose=true, ignore_existence=true)\n[ Info: Unpacking /var/folders/q0/wbdz2dpd0q9gtjk3wkj1fcnh0000gn/T/jl_ti7eJ2RSRC-download.xz into /var/folders/q0/wbdz2dpd0q9gtjk3wkj1fcnh0000gn/T/jl_EajM2J...\ntrue\n\nshell> ls -la /var/folders/q0/wbdz2dpd0q9gtjk3wkj1fcnh0000gn/T/jl_EajM2J/var/lib/dpkg/lock-frontend\n-rw-r--r--  1 tim  staff  0 Dec  2 10:07 /var/folders/q0/wbdz2dpd0q9gtjk3wkj1fcnh0000gn/T/jl_EajM2J/var/lib/dpkg/lock-frontend\n```\n\nHowever, if I pack this up in an `Artifacts.toml`, I get the following:\n\n```\njulia> ArtifactUtils.add_artifact!(""""Artifacts.toml"""", """"debian"""", """"https://github.com/JuliaCI/PkgEval.jl/releases/download/v0.1/debian-bullseye-20220818.tar.xz""""; lazy=true)\n\n❯ cat Artifacts.toml\n[debian]\ngit-tree-sha1 = """"e5d2359bc94f9d9ddc771c2274c83324ca8cbbcc""""\nlazy = true\n    [[debian.download]]\n    sha256 = """"072392d8635847de70665af512551038b04baca99b38e271d0eef1ea36d2833a""""\n    url = """"https://github.com/JuliaCI/PkgEval.jl/releases/download/v0.1/debian-bullseye-20220818.tar.xz""""\n\njulia> using LazyArtifacts\n\njulia> artifact""""debian""""\n""""/Users/tim/.julia/artifacts/e5d2359bc94f9d9ddc771c2274c83324ca8cbbcc""""\n\nshell> ls -la /Users/tim/.julia/artifacts/e5d2359bc94f9d9ddc771c2274c83324ca8cbbcc/var/lib/dpkg/lock-frontend\n-r--r--r--  1 tim  staff  0 Dec  2 10:08 /Users/tim/.julia/artifacts/e5d2359bc94f9d9ddc771c2274c83324ca8cbbcc/var/lib/dpkg/lock-frontend\n```\n\n... and our `u+w` permission is gone. That's bad, here breaking `dpkg` in the containers spawned using this rootfs because it can't take the lock.\n\nTested on 1.8.2, reproduces on macOS and Linux. This artifact also seems to trigger an unrelated git tree hash change between 1.7 (`d41ccdb32c924682293a4fe525b9986b7debb11d`) and 1.8 (`e5d2359bc94f9d9ddc771c2274c83324ca8cbbcc`).","[giordano]: Is that because Tar.jl normalises permissions? | [maleadt]: I don't think so, because in https://github.com/JuliaCI/PkgEval.jl/pull/189 I'm now using Tar.jl directly to unpack this tarball, and permissions are fine. | [staticfloat]: The issue is that Pkg likes to set things to be read-only: https://github.com/JuliaLang/Pkg.jl/blob/6dd0e7c9e99d578aa5477e2c78c91a161ce4c357/src/Artifacts.jl#L79\n\nI think the reason the areas of the ecosystem that I administer don't run into this is that I'm usually running as `root` on the inside of containers, and `dpkg` likely ignores read-only permissions on lock files if its run as `root`:\n\n```\njulia> using Sandbox\n       config = SandboxConfig(\n           Dict(""""/"""" => Sandbox.debian_rootfs());\n           stdin, stdout, stderr,\n       )\n       with_executor() do exe\n           run(exe, config, `/bin/bash -c 'apt update; apt install make'`)\n       end\nGet:1 https://deb.debian.org/debian bullseye InRelease [116 kB]\nGet:2 https://deb.debian.org/debian bullseye/main amd64 Packages [8068 kB]\nGet:3 https://deb.debian.org/debian bullseye/main Translation-en [6236 kB]\nFetched 14.4 MB in 2s (7687 kB/s)                           \nReading package lists... Done\nBuilding dependency tree... Done\n20 packages can be upgraded. Run 'apt list --upgradable' to see them.\nW: No sandbox user '_apt' on the system, can not drop privileges\nReading package lists... Done\nBuilding dependency tree... Done\nSuggested packages:\n  make-doc\nThe following NEW packages will be installed:\n  make\n0 upgraded, 1 newly installed, 0 to remove and 20 not upgraded.\nNeed to get 396 kB of archives.\nAfter this operation, 1630 kB of additional disk space will be used.\nGet:1 https://deb.debian.org/debian bullseye/main amd64 make amd64 4.3-4.1 [396 kB]\nFetched 396 kB in 0s (1996 kB/s)\ndebconf: delaying package configuration, since apt-utils is not installed\nSelecting previously unselected package make.\n(Reading database ... 6972 files and directories currently installed.)\nPreparing to unpack .../make_4.3-4.1_amd64.deb ...\nUnpacking make (4.3-4.1) ...\nSetting up make (4.3-4.1) ...\nW: No sandbox user '_apt' on the system, can not drop privileges\nProcess(`/usr/bin/docker run --privileged -i --label org.julialang.sandbox.jl=7utA1BMVq3 -t -w / --user 0:0 sandbox_rootfs:a507efe7-0-0 /bin/bash -c 'apt update; apt install make'`, ProcessExited(0))\n\njulia> run(`ls -la $(joinpath(Sandbox.debian_rootfs(), """"var"""", """"lib"""", """"dpkg"""", """"lock""""))`)\n-r--r--r-- 1 sabae sabae 0 Aug  8  2023 /home/sabae/.julia/artifacts/16738e2d713323e608ff891cb66de38d9d667d45/var/lib/dpkg/lock\n``` | [maleadt]: > I think the reason the areas of the ecosystem that I administer don't run into this is that I'm usually running as `root` on the inside of containers\n\nMakes sense, but for PkgEval I don't want to run as root in order to spot packages doing questionable things (e.g., using `su` or `sudo`). | [KristofferC]: What could be done here? Stop setting the artifacts to read only? | [maleadt]: > Stop setting the artifacts to read only?\n\nI would argue that's the expected behavior. But root filesystems are a fairly special case, and for most packages it's probably more interesting to have everything be read-only in order to detect accidental writes to the artifact store.\n\nWhat about an additional tag in the `Artifacts.toml`? A default `chmod = true` for the current behavior, and `chmod = false` to support disabling it? | [KristofferC]: Should that choice be made at the `Artifact.toml` level or at the point when things are installed? | [maleadt]: In my case at least, it's mostly a property of the artifact. Maybe phrasing it as `readonly = true` ties it more to the artifact? | [staticfloat]: Because we identify artifacts by content-hash, it's a little risky to allow them to be made non-readonly, as we then break the implicit contract that this artifact can be shared by multiple environments/packages with no fear of them being """"incorrect"""" in some way.\n\nIn practice, I'll just remind Tim that he broke the contract by setting the flag, and he has only himself to blame.  This should be a pretty easy thing to implement, and I agree this should be in `Artifacts.toml` on a per-artifact basis. | [staticfloat]: I think the name of the setting should be something like `set_read_only = false`. | [maleadt]: Yeah, I guess agree that this kinda violates the idea of the artifact store, and maybe we should simply not use it to store (extracted) root filesystems, if anything because there's additional issues like the fact that empty directories (as required by some tools) are not always dealt with correctly. I'd be fine with that as well. | [staticfloat]: I guess it comes down to convenience. If you are okay with using something that just downloads to a scratch space and using that, that’s easiest for the Pkg devs. | [maleadt]: Maybe one convenience feature then would be to support artifacts that are not to be extracted. Currently, I hand-roll the TOML parsing, while something like `extract = false` could allow me to simply look up the tarball. | [staticfloat]: So we’d have artifacts, lazy artifacts, and “utterly devoted to the sin of sloth” artifacts. :)",14,false,0,0,0,0,0,0,0,0,0
4157,Changing a source in `Project.toml` doesn't trigger a full resolution of the environment,open,giordano,,bug,,4,2025-02-15T17:03:38.0,2025-07-07T09:07:35.0,154,13,https://github.com/JuliaLang/Pkg.jl/issues/4157,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4157,"Consider the following `Project.toml`\n```toml\n[deps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\n\n[sources]\nExample = {url = """"https://github.com/JuliaLang/Example.jl.git"""", rev = """"9eafbe382ffe5bf31d674cd3d7bfd7dbaf3f4b29""""}\n```\nResolve the environment and you get the following `Manifest.toml`:\n```toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = """"1.13.0-DEV""""\nmanifest_format = """"2.0""""\nproject_hash = """"2ba095eea143434854ea510082d0697aa2bcd3f3""""\n\n[[deps.Example]]\ngit-tree-sha1 = """"f5f048e73ccd0bdfbddd9bd556d9eca360135609""""\nrepo-rev = """"9eafbe382ffe5bf31d674cd3d7bfd7dbaf3f4b29""""\nrepo-url = """"https://github.com/JuliaLang/Example.jl.git""""\nuuid = """"7876af07-990d-54b4-ab0e-23690620f79a""""\nversion = """"0.5.5""""\n```\nNow change the project to (note the change of the `rev` attribute of the `Example` package)\n```toml\n[deps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\n\n[sources]\nExample = {url = """"https://github.com/JuliaLang/Example.jl.git"""", rev = """"82d1224c32990c0105898fa44009864f5648e98d""""}\n```\nand re-resolving the environment changes the `Manifest.toml` to\n```toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = """"1.13.0-DEV""""\nmanifest_format = """"2.0""""\nproject_hash = """"2ba095eea143434854ea510082d0697aa2bcd3f3""""\n\n[[deps.Example]]\ngit-tree-sha1 = """"f5f048e73ccd0bdfbddd9bd556d9eca360135609""""\nrepo-rev = """"82d1224c32990c0105898fa44009864f5648e98d""""\nrepo-url = """"https://github.com/JuliaLang/Example.jl.git""""\nuuid = """"7876af07-990d-54b4-ab0e-23690620f79a""""\nversion = """"0.5.5""""\n```\nNote that only `deps.Example.repo-rev` changed, but not `deps.Example.git-tree-sha1`, nor `project_hash`.\n\n```julia-repl\njulia> versioninfo()\nJulia Version 1.13.0-DEV.63\nCommit f5f6d4115b* (2025-02-14 21:22 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin23.4.0)\n  CPU: 8 × Apple M1\n  WORD_SIZE: 64\n  LLVM: libLLVM-18.1.7 (ORCJIT, apple-m1)\n  GC: Built with stock GC\nThreads: 1 default, 1 interactive, 1 GC (on 4 virtual cores)\n```",[KristofferC]: Might be related to https://github.com/JuliaLang/Pkg.jl/issues/4086. | [KristofferC]: It wasn't the case that you could change rev / repo / path without a corresponding Pkg command so there are some cases (like in `resolve`) where this causes Pkg to miss that information has been updated directly in the project file. | [KristofferC]: The project hash not updating seems to be due to\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/d2c81dbe7288e9cf6acea2098a2f3de22e24782a/src/Types.jl#L601-L602\n\nwhere it claims that only compact + deps affect resolve (which is no longer true with sources). | [KristofferC]: We do not enter the repo handling here:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/d2c81dbe7288e9cf6acea2098a2f3de22e24782a/src/Operations.jl#L410-L418\n\nbecause we see that we have already downloaded the package with the tree hash recorded in the manifest (failing to see that information is no longer valid due to the updated rev in the project sources).,4,false,1,1,0,0,0,0,0,0,0
3857,`instantiate` always instantiates whole workspace,open,KristofferC,,bug; workspace,,2,2024-03-26T13:10:57.0,2025-07-07T08:40:04.0,481,13,https://github.com/JuliaLang/Pkg.jl/issues/3857,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3857,"https://github.com/JuliaLang/Pkg.jl/blob/162634c5615d12b889e4b64f3cff95d1c377f189/src/API.jl#L1274-L1276\n\nwill download all packages + artfacts from packages in the manifest (which will be the whole workspace), not limited to the currently active project.","[NHDaly]: I've seen something very similar in our monorepo project, where we have a bunch of subprojects that are dev'd and they all share a manifest via the `manifest = """"../../Manifest.toml""""` field in their Project.tomls.\n\nActivating one, and instantiating will build the whole top-level project, not just the currently active one.\n\nI _think_ that's probably the same issue as in this ticket, but if not we can open a new one. | [KristofferC]: I would personally consider the `manifest = ` """"feature"""" deprecated by the workspace functionality. Is there any reason you would keep wanting to use it in presence of workspaces?",2,false,1,1,0,0,0,0,0,0,0
3644,Since v1.10 --warn-overtype will be overwritten to yes in Pkg.test(),open,s-fuerst,,,,2,2023-10-04T15:20:19.0,2025-07-07T08:00:37.0,654,13,https://github.com/JuliaLang/Pkg.jl/issues/3644,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3644,"Since Julia 1.10 (I tested 1.10.0-beta3 and 1.10.alpha1, both installed via juliaup) I get `Method definition ... overwritten` warnings when I test my package. The MWE for this is:\n\n```\n using Test\n\n@testset begin\n    @eval asserting() = true\n    @eval asserting() = false\nend\n```\n\nas `test/runtest.jl` file for a project.\n\nWhen I test this with 1.10, I get:\n```\n> julia +1.10 --project --warn-overwrite=no      \n\njulia> using Pkg; Pkg.test()\n[...]\nWARNING: Method definition asserting() in module Main at [...]/test/runtests.jl:4 overwritten [...]/test/runtests.jl:5.\n[...]\n```\n\nThe documentation of Pkg.test mentions only that `check-bounds` will be set to yes in the new process. \n\nSo, if this change is intended (which IMHO is not a good idea), please update the documentation and add a remark to the 1.10 Release notes.\n\nThank you.\n\n```\njulia> versioninfo()\nJulia Version 1.10.0-beta3\nCommit 404750f8586 (2023-10-03 12:53 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 16 × 12th Gen Intel(R) Core(TM) i5-1240P\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, alderlake)\n  Threads: 1 on 16 virtual cores\nEnvironment:\n  LD_RUN_PATH = /usr/lobal/lib\n  LD_LIBRARY_PATH = /usr/local/lib:/usr/local/lib\n```","[vtjnash]: Xref https://github.com/JuliaLang/Pkg.jl/pull/3350 | [KristofferC]: Right now, there is no way to check if a user has forcefully disabled warn overwrite or if it is just by default so that would need to be updated in Julia for us to be able to check it.",2,false,0,0,0,0,0,0,0,0,0
2701,Cloning repo using Pkg.add(url) results in a non-descriptive error,open,timcop,,,,1,2021-08-14T05:04:08.0,2025-07-04T22:25:59.0,1436,15,https://github.com/JuliaLang/Pkg.jl/issues/2701,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2701,"Encountered a """"failed to fetch from ... error: GitError(Code:ERROR, Class:HTTP, unexpected http status code: 403"""" when adding a private repository that I have access to, and using my GitHUb username and password when prompted:\n![Screenshot from 2021-08-14 16-50-27](https://user-images.githubusercontent.com/70932357/129434517-e8b18739-0d7f-4a61-a89d-97d07d706314.png)\n\nI think this is due to GitHub's new change to requiring a private access token as the password when prompted, which when I created an access token and used it as the password I was able to overcome this error. However I only realised this was the issue when I went to clone the repository using terminal which gave me this error \n![Screenshot from 2021-08-14 17-00-37](https://user-images.githubusercontent.com/70932357/129434684-2d9a4a9e-d7c6-4db7-80c3-927894e962bb.png)\n\nSo a suggested change would be to add the message """"Support for password authentication was removed..."""" for the Pkg error so for those that are unaware of the change know what to do.",[IanButterworth]: I think a generic solution to this is if we start showing the messages that github sends through that git shows.\n\nI've tried to implement that in LibGit2 here but it's not currently capturing them. Needs more investigation.\nhttps://github.com/JuliaLang/julia/compare/master...IanButterworth:julia:ib/libgit2_sideband,1,false,0,0,0,0,0,0,0,0,0
2489,Consider the possibility of git cloning cli doing a shallow clone instead,open,,,,,3,2021-04-06T00:34:49.0,2025-07-04T13:27:59.0,1566,16,https://github.com/JuliaLang/Pkg.jl/issues/2489,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2489,"<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including a minimal reproducible example and the output of `versioninfo()`.\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n\nI've reported issue #[40193 ](https://github.com/JuliaLang/julia/issues/40193) about the speed of cloning. \n\nI understand there's improvements with cloning, it's now possible to use the git cli. \n\nIs it possible for the git cli to do a [shallow clone](https://github.com/JuliaLang/Pkg.jl/commit/623625b843b0e01070e936d45787873370176153#r49137314) with `git shallow clone with git clone --depth 1 --quiet $url $source_path` instead? \nMakes cloning much faster, and decreases the no of objects downloaded. \n","[StefanKarpinski]: I believe that GitHub does not like shallow clones in the sense that they support them but it overloads their servers if too many people do it. If that's still the case, it would be rude of us to default to using a shallow clone. This also wouldn't be in a release prior to 1.7 and for that release, we're going to download tarballs and use them [without unpacking them](https://github.com/JuliaLang/Pkg.jl/pull/2431), which addresses the performance issues on Windows, allowing us to stop defaulting to using git clones at all there (at which point we could use a shallow clone since not that many people would be doing it). | [KristofferC]: Ref https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935 and https://blog.cocoapods.org/Master-Spec-Repo-Rate-Limiting-Post-Mortem/. | [KristofferC]: I think it is fine for us to use a shallow clone since our git usage is so low and support for this has recently been added to libgit2.",3,false,0,0,0,0,0,0,0,0,0
2524,Allow compat specifiers in Pkg.add,open,fonsp,,,,1,2021-04-22T22:57:24.0,2025-07-04T13:13:47.0,1549,16,https://github.com/JuliaLang/Pkg.jl/issues/2524,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2524,"The `^` syntax is allowed in a Project.toml:\n```\n[compat]\nJSON = """"^1.2.3""""\n```\n\nbut not in a `PackageSpec`:\n```julia\njulia> Pkg.PackageSpec(name=""""JSON"""", version=""""^1.2.3"""")\n```\nunless you use an internal function:\n```julia\njulia> Pkg.PackageSpec(name=""""JSON"""", version=Pkg.Types.semver_spec(""""^1.2.3""""))\n```\n\nCan the first PackageSpec syntax be allowed?","[KristofferC]: The current code calls the `VersionSpec` constructor with the string:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/f4b66f7da6ff40cce9781c548324bdd3680d7cb4/src/Versions.jl#L232\n\nOne difference between that and the """"semver"""" version is for example with the current behavior, `version=1.2` gives you a version `[1.2.0 - 1.3.0)` while semver `""""1.2""""` is `[1.2.0 - 2.0.0)`.",1,false,2,2,0,0,0,0,0,0,0
4212,`free --all` fails with confusing message,open,nickrobinson251,,,,1,2025-04-07T14:14:27.0,2025-07-01T19:11:04.0,104,18,https://github.com/JuliaLang/Pkg.jl/issues/4212,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4212,"```\n(Foobar) pkg> free --all\nERROR: packages may only be specified by name or UUID when calling `free`\n```\n\nIsn't the ERROR message in contradiction with there being a `--all` flag? I am confused 😊 \n\nSeen on Julia v1.11 and nightly (1.13.0-DEV)\n\nThe `Project.toml` looks like\n```\nname = """"Foobar""""\nuuid = """"469444d5-79b5-4f80-a9af-0769fa2f9410""""\nauthors = [""""""""]\nversion = """"0.1.0""""\n\n[preferences.Foobar]\nQUX3 = false\n\n[deps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\nLocalPkg = """"fcf55292-0d03-4e8a-9e0b-701580031fc3""""\nPreferences = """"21216c6a-2e73-6563-6e65-726566657250""""\n\n[sources]\nExample = {url = """"https://github.com/JuliaLang/Example.jl""""}\nLocalPkg = {path = """"LocalPkg""""}\n```","[KristofferC]: For posterity, this happens because there is a check in `free` that ensures that one doesn't do something like `free Foo#master` but this has a bad interaction with sources which will assign e.g. a branch to the package.",1,false,0,0,0,0,0,0,0,0,0
4139,App improvement mega issue,open,KristofferC,,apps,,2,2025-01-24T15:22:59.0,2025-07-01T16:04:22.0,176,18,https://github.com/JuliaLang/Pkg.jl/issues/4139,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4139,"Things to fix/improve:\n\n## Functionality\n- [ ] Add `Apps.instantiate`\n- [ ] Add `Apps.update`\n- [ ] Allow specifying a subfolder in package with a project [+ manifest] with an app\n- [x] Allow submodules with `@main` as apps\n\n## Display\n- [ ] Improve output of  `Apps.status()`\n- [ ] Move away from using `@info` and use the same formatting as Pkg does elsewhere\n\n## Questions\n\n- [ ] PATH handling, make juliaup add `.julia/bin` to path?\n- [ ] How to make juliaup not GC versions used by apps","[nilshg]: As discussed on Slack, I would propose changing the info output to\n\n```\nInfo: package Runic installed the following app(s): runic\n```\n\n(maybe print `app` singular if only one is installed and plural otherwise, assuming that's easy to determine) | [ericphanson]: some observations trying out the apps feature:\n\n- I think load path or project influences compat for `app add` when it seems like it should not\n    - I worked around this in my installation instructions for [SearchablePDFs.jl](https://github.com/ericphanson/SearchablePDFs.jl?tab=readme-ov-file#usage) by writing `JULIA_LOAD_PATH=""""@:@stdlib"""" julia +nightly --startup-file=no -e 'using Pkg; Pkg.activate(temp=true); Pkg.Apps.add(url=""""https://github.com/ericphanson/SearchablePDFs.jl"""")'`. Pretty long!\n- updating an app should probably regenerate the project/manifest from scratch (delete them), since otherwise there can be issues with the manifest\n- similarly, I did `app add ...` then `app dev ...` and the generated manifest still was that of `app add` instead of updating to the format used with `dev`\n- `app rm` does not remove the generated environment, I believe it should\n- if an app fails to precompile when installed, the errors are not clear but it seems to retry like 3 times. I think this is because it's the auto-precompile on installation, maybe it should set some flags or something for this case when it's not a regular library dependency",2,false,0,0,0,0,0,0,0,0,0
3963,Add back support for full VersionNumbers to the resolver,open,KristofferC,,,,2,2024-07-23T07:25:58.0,2025-06-16T12:53:21.0,362,34,https://github.com/JuliaLang/Pkg.jl/issues/3963,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3963,"We are getting quite a few requests for various functionalities that cannot really be implemented due to the resolver right now only supporting `major.minor.patch` versions. These are things like:\n\n- Pre-release support\n- Build meta-data\n\nIronically, the resolver used to have support for the full version number spec but this was removed due to the belief that it was not useful in Pkg3 (https://github.com/JuliaLang/Pkg.jl/pull/73/commits/f5eff1215b2de405fcd6c65ba7f90a02b448e729).\n\n@carlobaldassi, just checking, what level of effort do you think it is to put back the prerelease/build stuff to the resolver? If that support was added back I think I could do the rest of the surrounding scaffolding to add e.g. pre-release support.\n\n","[carlobaldassi]: I just had a look at the diff in that commit you linked, in which the functionality was removed. In principle, it should be sufficient to simply revert that. (It may slow down the resolver a bit though, and eat up some extra memory, I'm not sure to what extent.)  I believe there were also some tests, removed in some other commit.\n\nThe code used to support also versions of the form `1.2.3-` and `1.2.3+` which are not valid semver but were used to specify ranges (and indeed are still accepted as `VersionNumber` objects in Julia). Also, since we need to rank all versions somehow, the code ignores the semver prescription that build meta-data should not be used in the ranking; instead, it applies the same logic as for prerelease specs (`1.2.3+beta` > `1.2.3+alpha` > `1.2.3`). | [MilesCranmer]: I would be hugely in support of this. There is some relevant community discussion on this here: https://discourse.julialang.org/t/can-we-have-pre-release-versions-in-the-registry-v2/129887\n\n(h/t @MasonProtter)",2,false,4,4,0,0,0,0,0,0,0
3027,[Feature request] option to automatically install a package when using `using`,open,gitboy16,,,,13,2022-03-12T07:54:52.0,2025-05-29T13:11:31.0,1226,52,https://github.com/JuliaLang/Pkg.jl/issues/3027,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3027,"As suggested by @KristofferC in the following link:\nhttps://discourse.julialang.org/t/using-package-install-automatically/70896/5\nI am opening an issue so that maintainers can discuss whether they deem it useful or not to have an option to automatically install a package when using `using`. That option would bypass the prompt message asking whether the user wants to install the package or not.\n\nJust speaking for myself here (i.e. not for other users), but when I use `using X`, I will probably answer yes  99% of the time to the question """"do you want to install package X"""".\n\nThat option could be implemented via macro or env variable, I don't really have a strong view on it.\n\nI just think it is a nice to have option.\n\nThank you","[IanButterworth]: In 1.8 you get the options y/n/o where `o` lets you choose the environment you want to install into. If you're not in the main environment this can be useful for installing packages like Revise or BenchmarkTools into the main env that you don't want in your current project, but will want available. \n\nThere could be an env var to automatically select `y` but it would side-step that functionality, which seems a shame. But given it would be opt-in, then it sounds reasonable, as long as new users aren't persuaded to add the env var by default. | [KristofferC]: In my original test implementation of installing during `using` I had that pressing `Y` would remember your choice (while `y` would not). But you would still have to make one active choice. Perhaps an env variable so that you can set it even before the first `using` is a better idea. | [IanButterworth]: One thought.. would removing the need to confirm open users up more to typo issues, malicious or not. I guess they'd still see the package installation, so that would give them pause? | [KristofferC]: Well, that's something that is up to the user. Just by installing a package (or doing an update), you are already opening yourself up to some level of possible maliciousness. | [IanButterworth]: Yeah I guess I just meant that if there's no confirm, they might not be aware they're installing a new package. But the messaging probably makes it clear. | [gitboy16]: Would you be ok with a macro like the following?\n\n```julia\n@add_pkg using DataFrames, CSV\n```\nWe can call the macro as you wish and it would need to be available in Julia when the session starts.\n\nThe same macro coukd install from a local directory.\n\n```julia\n@add_pkg """"C:/temp/MyPackage"""" using MyPackage\n```\nSimilarly we can have `@dev_pkg` macro.\n\nI am not fan of environment variable. I always forget about them or to set them up. I prefer to have everything in the code.\n\nAlternatively we could have some like:\n```julia\nusing install=true DataFrames, CSV\n```\n\nIs that something you would consider? | [gitboy16]: Or we can simply have a macro that install packages at the beginning of the script without the need to load Pkg:\n```julia\n@add_pkg DataFrames, CSV\nusing DataFrames\nimport CSV\n```\nThe macro would check if the packages are install or not and if not then install them automatically without prompt message requesting input from the user every time a package needs to be installed. | [GHTaarn]: I tried to think who would actually use a feature like this, and came up with 3 scenarios:\n\n1. An experienced Julia user starts a simulation on a Friday afternoon, leaves for the weekend and comes back Monday morning to a prompt asking him if he wants to Install the `DataFrames` package, instead of having a set of simulation results.\n2. A teacher has a 2 hour hands on class with some students that have little programming experience and know nothing about Julia. In order to simplify their experience she would like to avoid the complication of explaining packages.\n3. An employee in the IT-department is making a program for the sales department. He/she does not want the program to have the complication of answering questions about installing packages. This can of course be done without this new feature, but this feature could greatly reduce the number of lines of code needed to do this, which would hopefully both save time and reduce the probability of bugs.\n\nScenarios 1 and 2 would benefit from something simple that can be done either just before Julia starts or just after. @KristofferC s suggestion of an env variable would be just perfect for this, you can put it in your startup.jl , you can set it in your .bashrc , you can use it with the -i -e commandline options, you can type it manually in the REPL and a lot more. To use it in the example given by @gitboy16 you would write something like:\n\n```julia\nENV[""""JULIA_PKG_USING_AUTOINSTALL""""] = """"yes""""\nusing DataFrames\nimport CSV\n```\n\nLike @IanButterworth , I also get a gut reaction that creating this feature could have some bad consequences. Maybe Julia could get the blame for a bad user experience caused by this. Would it be a good idea to explicitly warn about the dangers of using the feature in the documentation of it?\n\nI also want to say that I am not sure that I would use this feature personally, I like the current behaviour, but I do see situations where others could find it useful. | [gitboy16]: The only reason why I prefer a macro over an environment variable is because it forces the user to add it to the script/code and makes it clear to whoever is reading the code. Anyway feel free to close if you don't care about it. | [Yue-Wang-qvp]: Any new progress on this topic? I also prefer to have the package needed by the activated environment installed automatically. | [NilsWildt]: Something I've been using quite a while is https://github.com/mossr/AddPackage.jl\nHowever, some command to pull just whatever I need from registry to run my script would be convenient. | [GHTaarn]: `AddPackage` seems like exactly what @gitboy16 was requesting. @NilsWildt the extra functionality that you wish for sounds like a perfectly sensible feature request for `AddPackage` and maybe you could even write it yourself and submit it as a PR to the `AddPackage` project. | [vchuravy]: I think it's to early for that discussion, we need to get to a point where we are comfortably putting out patch releases and they get picked up and used in a sensible matter.",13,false,1,1,0,0,0,0,0,0,0
3824,replace 7z with gzip,open,StefanKarpinski,StefanKarpinski,security,,18,2024-03-04T20:35:44.0,2025-05-27T06:13:21.0,502,54,https://github.com/JuliaLang/Pkg.jl/issues/3824,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3824,"It seems from [reports on discourse](https://discourse.julialang.org/t/alternative-to-7zip-when-installing-packages/111141) that 7z is banned for security reasons at many organizations. We used to use a lot of its functionality, but now we only use it in ways that gzip can replace. We should do that. The changes to Pkg are actually trivial, the most annoying part is removing 7z as a Base dependency and adding gzip.","[stevengj]: Or something more modern like [zstd](https://github.com/facebook/zstd)? | [giordano]: But we want to be able to unpack more than gzipped tarballs, no? https://github.com/JuliaLang/Pkg.jl/blob/48eea8dbd7b651cdc932b909c1b718bb9c3f94f4/src/PlatformEngines.jl#L485 | [StefanKarpinski]: > Or something more modern like [zstd](https://github.com/facebook/zstd)?\n\nAdding support for zstd would be fine, but we can't drop support for gzip in the client because there are private package servers in the wild that will continue serving gzip tarballs for the foreseeable future and we also can't drop gzip as a format on servers because they have to keep serving to older Julia versions that expect gzip. So adding zstd would force servers to generate and serve both gzip and zstd. I'm also not convinced that zstd is such a huge win for our use case. I haven't seen massively better compression ratios. The compression time is better, but since we'll have to do gzip *and* zstd on the server, that doesn't actually save us any compute. Decompression time is also better, but I don't think decompression time is a meaningful bottleneck. My inclination is to add support for negotiating the compression format so that at some point in the future we can migrate over.\n\n> But we want to be able to unpack more than gzipped tarballs, no?\n\nI'm not sure how big an issue this is in practice (i.e. how much do we actually use/rely on this), but what we can do is ship gzip with Julia itself and then dynamically install JLLs for the other compression formats as required. That allows us to bootstrap from gzip to install and handle other compression formats as needed. | [mnemnion]: Bundling [libarchive](https://github.com/yuyichao/LibArchive.jl) would cover gzip, and leave plenty of flexibility for switching to another, or decoding existing data in other formats. | [StefanKarpinski]: I'm a bit hesitant to swap out one swiss-army-knife dependency that handles multiple compression formats but isn't _the standard tool_ that's guaranteed to be patched and maintained and allowed by sysadmins for another one with the exact same description. Of course, `libarchive` looks much better maintained than `7z`, but you get my point. It also seems likely that `gzip` is going to be faster and more efficient than anything else. | [stevengj]: > Adding support for zstd would be fine, but we can't drop support for gzip in the client\n\nThe zstd web page says that its library/command-line tool supports `.gz` files?  Or does it do that by linking another library?\n\nLooks like zstd include a [`minigzip.c`](https://github.com/facebook/zstd/blob/8689633fdf5dabfc7f4cd6f79611335c3f8def88/zlibWrapper/examples/minigzip.c#L4) implementation, but maybe it requires zlib?\n\nBut it seems safer/simpler to stick with gzip alone if there's not a compelling reason to support other formats. | [mnemnion]: > Of course, libarchive looks much better maintained than 7z, but you get my point.\n\nWorth noting that libarchive has been integrated into Windows 11, which has implications both for continuity of maintenance and the likelihood that sysadmins will green-light it. I can't speak to gzip's speed and efficiency vs. libarchive, but it's clearly both a more narrowly-tailored tool and some of the most battle-tested code in existence. | [StefanKarpinski]: Ok, seems like we've got a few solid options here—gzip, zstd (with built-in gzip), or libarchive. | [nsajko]: A pure Julia solution would allow decreasing the amount of external dependencies of the Julia install. The memory-safety would also look better security-wise, given no `@inbounds` or other unchecked operations. | [StefanKarpinski]: If it's implemented in Julia we have to build it into the Julia sysimg, which we would rather not do. It's also safer to do decompression in an external transient process. Ideally, we would put the decompression process in a jail where it can't open files and all it can do is read from stdin and write to stdout. Putting it in the main Julia process is the opposite of what we want from a security perspective. | [nhz2]: There is a new version of 7z that supports unpacking zstd https://github.com/ip7z/7zip/releases/tag/24.05 | [giordano]: Note that we use https://github.com/p7zip-project/p7zip, that's a different project. | [nhz2]: From what I can tell we are already using 7zip 23.01 for Windows instead of p7zip. According to https://github.com/ip7z/7zip/blob/24.05/DOC/readme.txt compiling 7zip for Unix is possible now. | [inkydragon]: We want to support unpack: """"tar"""", """"gz"""", """"tgz"""", """"bz2"""", """"xz""""\n\n## gzip\n- size: 909 KB, v1.13, on windows\n- supported suffix: `.gz/.tgz` only\n\n## zstd-cli\n- size: 1.48 MB, v1.5.6, on windows\n- supported suffix: `.gz/.tgz/.zst/.tzst/` (default) and `.xz/.txz/.lz4/.tlz4`\n- un-supported suffix: `.bz2`\n\n## libarchive-cli (bsdtar)\n- size: 4.12 MB, v3.7.7, on windows, `bsdtar.exe` only, I guess it's statically linked to libarchive.\n- supported suffix: `.tar/.gz/.tgz/.bz2/.xz` and more ...\n- deps lib (dynamic link): zlib; bz2lib; lzma\n\n## 7z\n- size: 549 KB, v24.08, on windows\n- supported suffix: `.tar/.gz/.tgz/.bz2/.xz` and more ...\n\nSee also: https://wiki.archlinux.org/title/Archiving_and_compression#Decompress\n\n## Some Choice\n\n1. Continue to use `7z`\n2. Change to `bsdtar` (libarchive)\n3. Change to `zstd` + `bz2`\n4. Use a separate decompression program for each format\n\nFrom a security standpoint, maybe 4. is the best choice? Because each program only does one thing.\nFor comparison: libarchive can even link to openssl to handle """"mtree and xar hashes"""".\n\nWe may create a package to provide the ability to decompress archives and support loading various implementations via `PkgExt` or other ways.\n\n## CVE issues\n\n- [7-zip 7-zip versions and number of CVEs, vulnerabilities](https://www.cvedetails.com/version-list/0/16324/1/)\n- [Libarchive Libarchive versions and number of CVEs, vulnerabilities](https://www.cvedetails.com/version-list/0/26168/1/)\n- [GNU Gzip versions and number of CVEs, vulnerabilities](https://www.cvedetails.com/version-list/0/1670/1/)\n- [zstd - OSV](https://osv.dev/list?q=zstd&ecosystem=)\n | [KristofferC]: I think the reason we only support tar.gz is to be able to use Tar.jl to unpack it. | [kjeel-dev]: Hi!\nAny chance of 7-zip being replaced in the near future? My company is now going to ban it, and I am afraid to loose Julia! | [nhz2]: What does your company recommend for reading """".xz"""" files? Would any of the workarounds in https://discourse.julialang.org/t/alternative-to-7zip-when-installing-packages/111141 work for you? | [kjeel-dev]: Hmm, seems that my company do not agree about what to use. It turned out that the Linux team had no current plans to ban 7-zip. The Windows team will ban it and recommended WinZip. Haven't got a reply about Macs yet, but I only use Windows and LInux so I am less concerned.\nMy preferred workaround on Windows would be to put Julia in a Docker container. My experience is that it works well, except for some challenges with GLMakie, so I ended up doing plotting via python and matplotlib. \n",18,false,4,2,1,0,0,1,0,0,0
4249,Indicate which project(s) are active when emitting Pkg errors,open,LilithHafner,,feature request; error handling,,0,2025-05-26T22:41:31.0,2025-05-26T22:41:45.0,54,54,https://github.com/JuliaLang/Pkg.jl/issues/4249,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4249,"When working with AirspeedVelocity.jl, I got this error:\n```\nshell> benchpkg\nERROR: LoadError: ArgumentError: Package AirspeedVelocity [1c8270ee-6884-45cc-9545-60fa71ec23e4] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\nStacktrace:\n  [1] _require(pkg::Base.PkgId, env::String)\n    @ Base ./loading.jl:2515\n  [2] __require_prelocked(uuidkey::Base.PkgId, env::String)\n    @ Base ./loading.jl:2388\n  [3] #invoke_in_world#3\n    @ ./essentials.jl:1089 [inlined]\n  [4] invoke_in_world\n    @ ./essentials.jl:1086 [inlined]\n  [5] _require_prelocked(uuidkey::Base.PkgId, env::String)\n    @ Base ./loading.jl:2375\n  [6] macro expansion\n    @ ./loading.jl:2314 [inlined]\n  [7] macro expansion\n    @ ./lock.jl:273 [inlined]\n  [8] __require(into::Module, mod::Symbol)\n    @ Base ./loading.jl:2271\n  [9] #invoke_in_world#3\n    @ ./essentials.jl:1089 [inlined]\n [10] invoke_in_world\n    @ ./essentials.jl:1086 [inlined]\n [11] require(into::Module, mod::Symbol)\n    @ Base ./loading.jl:2260\nin expression starting at /home/x/.julia/bin/benchpkg:13\n```\nThe Pkg level issue here is that there is no indication of what project I must activate before running `Pkg.instantiate()`, nor is there any apparent way to get that information.",,0,false,1,1,0,0,0,0,0,0,0
4247,Support authentication when downloading files (e.g. artifacts),open,giordano,,enhancement; help wanted; used by downstream tooling,,2,2025-05-25T16:12:18.0,2025-05-25T16:21:21.0,55,55,https://github.com/JuliaLang/Pkg.jl/issues/4247,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4247,"It has been requested several times to make it possible to have artifacts in private GitHub repositories, or other services such as S3 which would require authentication.  For GitHub and GitLab (I don't know if this is the same for all other services) the solution is simple: add the entry `""""Authorization"""" => """"Bearer ${TOKEN}""""` to the headers.  But some of the problems to implement such a solution are:\n\n* how to let the user provide the token?\n* how to determine when the tokens are required?\n* related to the point above, the authentication method may not be a single one for a `Pkg.add`: an environment may have artifacts hosted on different private services, we should have a (user-defined?) mechanism to identify which token to use for each service.\n\nTo further complicate things, authentication could be optional: GitHub in general allows unauthenticated downloads from public repositories (also, there's no way to programmatically tell whether a repo is public or private based on the URL only without querying the server), but it recently [started aggressively throttling such requests](https://github.blog/changelog/2025-05-08-updated-rate-limits-for-unauthenticated-requests/), so that even downloading public artifacts could need a token.\n\nI have the feeling that the `Artifacts.toml` should optionally have at least some hints for """"how to authenticate"""" for each artifact: for example the name of the environment variable to use as token if it exists?  I'm not a fan of this solution, but this to give an idea of the type of approach we may want.\n\nI'm opening the ticket to start the discussion about this, since the new rate limiting also affects Julia's own CI and of many downstream packages.","[vchuravy]: I was hoping artifacts were immune to that, but that would require them to be proxied through the package servers? \n\nFor reference in Trixi.jl we did https://github.com/trixi-framework/Trixi.jl/pull/2415 | [giordano]: > I was hoping artifacts were immune to that, but that would require them to be proxied through the package servers?\n\nYes, but for example https://github.com/JuliaLang/Pkg.jl/blob/88629b552621cf8b0d5dbf3bbd5b00ecaa10d0e0/test/test_packages/ArtifactInstallation/Artifacts.toml#L145-L162 isn't on the PkgServer and that's used in CI here and in Julia.  And we still need a way to allow users host private artifacts.",2,false,1,1,0,0,0,0,0,0,0
4244,Registry update failures should throw or return status,open,omus,,,,2,2025-05-22T20:37:44.0,2025-05-22T20:50:38.0,58,58,https://github.com/JuliaLang/Pkg.jl/issues/4244,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4244,"When using `Pkg.Registry.update()` if a registry fails to be updated an error is logged but there is no exception or return value to indicate this. This can make it difficult to work with this function call in automated scripts such as `Dockerfile`s where you may want to abort immediately if registries fail to update:\n\n```\n...\n#14 1.239     Updating registry at `/usr/local/share/julia-depot/registries/Private`\n#14 1.275     Updating git-repo `https://github.com/.../PrivateRegistry.git`\n#14 1.621 Username for 'https://github.com' [git]:     Updating registry at `/usr/local/share/julia-depot/registries/General.toml`\n#14 1.816 ┌ Error: Some registries failed to update:\n#14 1.816 │     — /usr/local/share/julia-depot/registries/Private — failed to fetch from repo: failed to fetch from https://github.com/../PrivateRegistry.git, error: GitError(Code:EUSER, Class:Callback, Aborting, user cancelled credential request.)\n#14 1.816 └ @ Pkg.Registry /usr/local/julia/share/julia/stdlib/v1.10/Pkg/src/Registry/Registry.jl:528\n#14 2.026 ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.11.5). Unexpected behavior may occur.\n#14 2.026 └ @ /project/Manifest.toml:0\n...\n```","[DilumAluthge]: It looks like the manual doesn't currently say what the behavior of the function will be if the update fails.\n\nSo I wonder if we could make it throw, and call that a non-breaking change. | [DilumAluthge]: Technically, we'd be introducing an exception where there wasn't one before, but given that we didn't promise (in the manual) that the function wouldn't throw, maybe it's okay?",2,false,1,1,0,0,0,0,0,0,0
2311,add some way to show git commit hash when tracking branch,open,Crghilardi,,,,2,2021-01-01T19:51:35.0,2025-05-13T06:46:20.0,1660,68,https://github.com/JuliaLang/Pkg.jl/issues/2311,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2311,"I ran into a situation recently where I was tracking a `#master` version of a package and was trying to figure out which commit it was on. This same idea came up in this [discourse thread](https://discourse.julialang.org/t/how-to-get-commit-hash-in-pkg3/11927) while searching. It seemed like a good idea, but wasn't sure if it went anywhere.\n\nI searched both open and closed issues and pull requests and did not see anything similar. Feel free to close if duplicated elsewhere.","[rashidrafeek]: Currently this can be done with: `git log --pretty=raw | grep -B 2 <tree-hash>`, where `<tree-hash>` is the value of git-tree-sha1 in the Manifest.toml (From the discourse thread linked in the issue).\n | [xgdgsc]: Yes. This is so confusing.",2,false,5,5,0,0,0,0,0,0,0
4235,Default `test` to `allow_reresolve=false` when a manifest is checked in,open,IanButterworth,,,,3,2025-05-12T16:47:05.0,2025-05-12T19:16:16.0,68,68,https://github.com/JuliaLang/Pkg.jl/issues/4235,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4235,"Repos with checked in manifests are intentionally fixing their deps, and therefore `Pkg.test` defaulting to `allow_reresolve=false` would be more in-line with expectations. Otherwise `Pkg.test` is allowed to deviate, and although it does warn when re-resolving, it's easy to miss such logs, especially when CI ends up green.\n\nTo do this requires figuring out if a manifest is checked-in to git. @DilumAluthge pointed out LibGit2 can do that per file\nhttps://libgit2.org/docs/reference/main/ignore/git_ignore_path_is_ignored.html","[DilumAluthge]: I actually think we probably want this instead: https://libgit2.org/docs/reference/main/status/git_status_file.html | [IanButterworth]: And if `JULIA_PKG_USE_CLI_GIT=true` ether `git ls-files` or `git rev-parse` (pointed out by @GunnarFarneback) | [DilumAluthge]: FWIW, IIUC, the current approach in Pkg.jl is to use LibGit2 for all local (non-cloning operations), regardless of the value of `JULIA_PKG_USE_CLI_GIT`.\n\nAnd then the value of `JULIA_PKG_USE_CLI_GIT` is only consulted for operations such as cloning, which are the cases in which CLI Git and LibGit2 have different behavior.\n\nFor local behavior, such as checking the status of a file, I think it's easiest to just always use LibGit2.",3,false,1,1,0,0,0,0,0,0,0
4221,[Workspaces] resolve does not report anything,open,vchuravy,,workspace,,2,2025-04-22T09:37:19.0,2025-05-05T10:25:51.0,89,76,https://github.com/JuliaLang/Pkg.jl/issues/4221,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4221,"Two issues:\n\n1. A workspace Manifest is reported as """"empty manifest"""" if the top-level has no dependencies on it's own.\n2. `resolve` shows no indication that a workspace manifest is being resolved.\n\nProject.toml:\n```\n[workspace]\nprojects = [""""docs""""]\n```\n\ndocs/Project.toml:\n```\n[deps]\nDocumenter = """"e30172f5-a6a5-5a46-863b-614d45cd2de4""""\n```\n\n```\njulia --project=.\n\n(workspace) pkg> st -m\nStatus `~/src/experiments/workspace/Manifest.toml` (empty manifest)\n\n(workspace) pkg> resolve\nNo packages added to or removed from `~/src/experiments/workspace/Project.toml`\nNo packages added to or removed from `~/src/experiments/workspace/Manifest.toml`\n\n(workspace) pkg> st -m\nStatus `~/src/experiments/workspace/Manifest.toml` (empty manifest)\n\n(workspace) pkg> status --workspace\nStatus `~/src/experiments/workspace/Project.toml`\nStatus docs/Project.toml\n  [e30172f5] Documenter v1.10.1\n```\n\n```\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = """"1.12.0-beta1""""\nmanifest_format = """"2.0""""\nproject_hash = """"1e9ffa7d4739f7d125a5e2c66af8747a8effd889""""\n\n[[deps.ANSIColoredPrinters]]\ngit-tree-sha1 = """"574baf8110975760d391c710b6341da1afa48d8c""""\nuuid = """"a4c015fc-c6ff-483c-b24f-f7ea428134e9""""\nversion = """"0.0.1""""\n```\n\n\n","[KristofferC]: Any suggestions of what these should say? | [vchuravy]: Hm.\n\nFor\n\n```\n(workspace) pkg> st -m\nStatus `~/src/experiments/workspace/Manifest.toml` (empty manifest)\n```\n\nthere is:\n\n```\n(workspace) pkg> st -m --workspace\nStatus `~/src/experiments/workspace/Manifest.toml`\n  [a4c015fc] ANSIColoredPrinters v0.0.1\n...\n```\n\nAnd I think my UX issue is more that I can't tell if I am in a workspace or not if I only look at the top-level directory. \n\nSo we could have `-m` imply `--workspace`, but then we would need some way of filtering, or maybe we could have a line of status/prompt:\n\n> Manifest is for a workspace, for the full version use `st -m --workspace`\n\nSimilarly for \n\n```\n(workspace) pkg> st\nStatus `~/src/experiments/workspace/Project.toml` (empty project)\n```\n\nI would like to at least know that the `Project.toml` is part of a workspace.\n\n\nFor resolve, I think it should have printed as if it was `resolve --workspace` (which doesn't exist) and tell me all the changes it did.\n\nE.g:\n\n```\n    Updating `~/src/experiments/workspace/docs/Project.toml`\n  [e30172f5] + Documenter v1.10.2\n    Updating `~/src/experiments/workspace/libs/SubLib/Project.toml`\n  [6e4b80f9] + BenchmarkTools v1.6.0\n    Updating `~/src/experiments/workspace/Manifest.toml`\n[...]\n```\n\nOr similarly how `status --workspace` prints it:\n\n```\nStatus `~/src/experiments/workspace/Project.toml`\nStatus libs/SubLib/Project.toml\nStatus docs/Project.toml\nStatus libs/Project.toml\n  [6e4b80f9] + BenchmarkTools v1.6.0\n  [e30172f5] + Documenter v1.10.2\n```",2,false,0,0,0,0,0,0,0,0,0
3185,`stdin` closed / unavailable during testing,open,t-bltg,,,,14,2022-08-30T20:05:25.0,2025-04-29T15:46:01.0,1054,81,https://github.com/JuliaLang/Pkg.jl/issues/3185,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3185,"https://github.com/JuliaLang/Pkg.jl/pull/3065 broke [`Sixel.jl`](https://github.com/JuliaIO/Sixel.jl) testing (this used to work on `1.6`, `1.7`, so I consider this a regession).\n\nIn our case, we need `stdin` opened in order to query / analyze terminal properties via control sequences.\n\nCould we set an option to keep `stdin` opened if we cannot revert the PR ?\n\ncc @johnnychen94, @IanButterworth \n\n<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including a minimal reproducible example and the output of `versioninfo()`.\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n","[oxinabox]: This also broke DataDeps.jl oxinabox/DataDeps.jl#104\nwhere it is a feature that the user is prompted to confirm that they do infact want to download data during the test.\n(which they can bypass by setting an enviroment variable).\nI feature I am no longer sure the wisdom of, but given it has been working this way for 5 years, I am not inclined to change. | [oxinabox]: also https://github.com/JuliaCI/PkgTemplates.jl/issues/370 | [IanButterworth]: I don't understand what happened here.\n\nhttps://github.com/JuliaLang/Pkg.jl/pull/3065 removed stdin forwarding that was added in https://github.com/JuliaLang/Pkg.jl/pull/2933 (because of https://github.com/JuliaLang/Pkg.jl/issues/3062). Both of which were during development of 1.8.0\n\nIf this used to work before 1.8, the change & revert above isn't the reason for the breakage | [IanButterworth]: 1.7.3\nhttps://github.com/JuliaLang/Pkg.jl/blob/0fae7809dbaa400d99cbe3a5b39c82332a1381d1/src/Operations.jl#L1630\n\n1.8.0\nhttps://github.com/JuliaLang/Pkg.jl/blob/63f4405d17e11decd2e5eb786cc491322b68c58c/src/Operations.jl#L1754 | [IanButterworth]: Ok. \n\nFrom the [Base.run](https://docs.julialang.org/en/v1/base/base/#Base.run) docs\n> When wait is true (default), I/O streams are shared with the parent process. Use [pipeline](https://docs.julialang.org/en/v1/base/base/#Base.pipeline-Tuple{Any,%20Any,%20Any,%20Vararg{Any}}) to control I/O redirection.\n\n@vtjnash in https://github.com/JuliaLang/Pkg.jl/issues/3062 you said that one shouldn't forward stdin, but isn't that what `run` was doing by default before 1.8? | [vtjnash]: You should not forward and set wait=false. It is application dependent though if you need stdin | [IanButterworth]: Ok. So would this be better?\n```\np = run(ignorestatus(cmd), stdin, sandbox_ctx.io, stderr_f())\n``` | [vtjnash]: The Pkg tests are run on a worker which does not have access to `stdin` | [vtjnash]: Tests that need a TTY, should be BYO | [IanButterworth]: So is this a way forward?\n- revert https://github.com/JuliaLang/Pkg.jl/pull/3065 (re-enable stdin forwarding)\n- When Pkg tests actually test `Pkg.test` we should provide stdin | [IanButterworth]: So is this a way forward?\n- revert https://github.com/JuliaLang/Pkg.jl/pull/3065 (re-enable stdin forwarding)\n- When Pkg tests actually test `Pkg.test` we should provide stdin | [IanButterworth]: bump @vtjnash | [vtjnash]: Sure, we could move `julia/test/testhelpers/FakePTYs.jl` into the test harness itself. You would not want to revert https://github.com/JuliaLang/Pkg.jl/pull/3065 though, since that brings back all sorts of other problems. | [IanButterworth]: I was just bitten by the original Sixel issue. \n\nWhat I want is for sixel to be automatically used by ReferenceTests (https://github.com/JuliaTesting/ReferenceTests.jl/pull/133) to show high res images in the terminal. IIUC it cannot detect whether sixel is supported because stdin is closed within the `Pkg.test` process. \n\nThere are ways to opt-in here but the real need is for it to automatically work where possible. \n\nI don't think your suggestions above @vtjnash are compatible with full automation?",14,false,1,1,0,0,0,0,0,0,0
3641,Dependencies of an Extension,open,Tortar,,feature request,,8,2023-10-03T22:11:25.0,2025-04-17T13:14:35.0,655,94,https://github.com/JuliaLang/Pkg.jl/issues/3641,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3641,"Inspired also by [this discourse thread](https://discourse.julialang.org/t/how-to-use-package-extensions/104553/8) I would like to propose the possibility to add dependencies for an extension. Imagine a situation where I create a visualization extension for `MyPackage` which requires `Makie`, but that extension depends also on `GraphMakie`, it would be very useful not to make `GraphMakie` a dependency since it's heavy to precompile, but install that alongside `Makie` when the user does `using MyPackage, Makie`. Maybe adding a `Project.toml` for extensions could be good? Not sure if this is already possible somehow but haven't found anything on the topic.\n\nRelated: https://github.com/JuliaLang/Pkg.jl/issues/3532","[mofeing]: I'm looking forward this too. Some of my package use `GraphMakie` and have an extension for it, but I want them to load the extension when `Makie` loads. The current solution is to mark `Makie` as a weak dependency and `GraphMakie` as a strong dependency, such that the extension is loaded when `Makie` loads but it still has access to the `GraphMakie` package.\n\nThe downside is that the extension is **always** precompiled, triggering `Makie` and `GraphMakie` dependencies to download and precompile, which is costly. | [Tortar]: Hi @mofeing, there is another (better) workaround we were able to use not to precompile any plotting package, see the `ext` folder in the Agents.jl package: https://github.com/JuliaDynamics/Agents.jl/tree/main/ext, which I also tried to explain here: https://discourse.julialang.org/t/how-to-use-package-extensions. \n\nBut this is harder to reason about and **not always applicable**, so you need to see if it possible to be used in your case | [mofeing]: Thanks @Tortar, but I think it doesn't apply to my case. Maybe I'm wrong but I understood that the case of `Agents.jl` is different. What I want is that the user doesn't need to do `using GraphMakie`, but that by just `using Makie` the extension that uses `GraphMakie` is loaded. I'm looking for this because I'm specializing the `Makie.plot!` method for my types.\n\nThe only available solution currently is to add `GraphMakie` as strong dependency, add `Makie` as weak dependency but only use `Makie` as the trigger for the extension (which I'm doing now)\n\nThis solution has the inconvenience that because `GraphMakie` is a strong dependency (and thus, `Makie`), the extension is always precompiled. This would effectively be solved with strong dependencies of extensions. | [LilithHafner]: I recently ran into a situation where this would be useful. I think it is a worthwhile feature to implement. | [kapple19]: I have a custom type that needs to be translated using `Point2f` in the `MakieCore.convert_arguments` method for my custom type.\n\nBut `Point2f` isn't available via `MakieCore.jl` - it's from `GeometryBasics.jl`.\n\nSo, if my `MakieCoreExt.jl` loads, it will need `GeometryBasics: Point2f`.\n\nHope this helps as another use case for extensions to have their own dependencies.\n\nUpdate: I learned that you can use `Tuple`s instead of `Point2f` so I'm not blocked by this issue. Though I do imagine similar scenarios arise in general. | [jlbosse]: Another use case that I can't be the only one to have: \n\nI want to add optional GPU support to my package in a `MyPackageCUDAExt` that gets automatically loaded when `CUDA` gets added to the project. But in `MyPackageCUDAExt` I also depend on `KernelAbstractions.jl` and `ExponentialUtilities.jl`. | [drizk1]: I have a use case as well, where I would be able keep `Dates.jl` and `CSV.jl` as Ext dependencies only | [aquaresima]: I have a use case as well, I want to load ColorSchemes and LaTeXStrings when loading PlotsExt. \n\nIf extensions don't support further dependencies, it means they are there just for method extension. Is that correct?",8,false,16,16,0,0,0,0,0,0,0
3460,TestEnv.jl functionality/support,open,oxinabox,,,,6,2023-05-08T05:33:20.0,2025-04-14T14:40:20.0,804,97,https://github.com/JuliaLang/Pkg.jl/issues/3460,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3460,"The code in TestEnv.jl is made from hacking up the internal code from Pkg.\nThis means it often breaks, due to changes in Pkg that are not mirrored in TestEnv yet.\nThough for the last few releases the Pkg internals seem to be back in a period of stability.\n\nI think at this point, TestEnv.jl has proven the utility of being able to activate the test enviroment. \nAnd that it would be reasonable to add `] activate --test` or similar.\nIf we did that and stdlib-ized the the TestEnv functionality then it wouldn't need \nCould keep TestEnv.jl around for compat reasons, but it could just delegate to Pkg if version is beyond 1.10\n\nAn alternative would be to expose just enough functionality to do this.\nThis probably means a public API of:\n - extract UUID from `[extras]` \n -  easily get lists of packages from `target.test` \n - and easily subset `[compat]`\n - Merge  Projects/Manifests","[fredrikekre]: Duplicate of https://github.com/JuliaLang/Pkg.jl/issues/1233 ? | [oxinabox]: no, it is related but distinct.\nIn that the TestEnv thing *also* needs to keep support for the way tests are specified Julia 1.0 style. with `[extras]`. Which is not going to be removed any time soon. As well as the 1.2 approximation to sub-proects with `test/Project.toml`.\n | [IanButterworth]: FWIW I took a look at implementing `pkg> activate --test` (and `pkg> activate --build` given its a supported target) but it's relatively involved.\n\nIt would be nice to get those in though, I agree that TestEnv has shown how helpful it would be. | [ufechner7]: Any update on this? Is there a consensus that this would be useful? | [IanButterworth]: WIP here https://github.com/JuliaLang/Pkg.jl/pull/4218 | [KristofferC]: At least to me, the workspace feature is kind of supposed to subsume the implicit test env creation and those projects you can just activate as a normal julia project (`--project`).",6,false,6,6,0,0,0,0,0,0,0
4217,Testing docs are very confusing,open,ZedThree,,,,0,2025-04-11T09:53:13.0,2025-04-11T09:53:13.0,100,100,https://github.com/JuliaLang/Pkg.jl/issues/4217,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4217,"The docs for [`target` based test specific dependencies](https://pkgdocs.julialang.org/v1/creating-packages/#target-based-test-specific-dependencies) don't mention that this only works when running `]test` from the REPL, and doesn't work on the command line. It's not clear if this is a bug in the implementation or just the docs.\n\nThe alternative way, using `test/Project.toml`, is implied to still be unstable, which is very off-putting for a Julia novice. #3953 even claims there are two further ways to do this!\n\nHere's a minimal example, doing my best to follow the docs:\n\n`Project.toml` can be auto-generated, but the `[extras]` and `[targets]` sections have to be manually added:\n```toml\nname = """"mvce""""\nuuid = """"5c5c69df-07ce-4eec-9db9-de18ccd496a9""""\nauthors = [""""Peter Hill <peter.hill@york.ac.uk>""""]\nversion = """"0.1.0""""\n\n[extras]\nTestItemRunner = """"f8b46487-2199-4994-9208-9a1283c18c0a""""\nTestItems = """"1c621080-faea-4a02-84b6-bbd5e436b8fe""""\n\n[targets]\ntest = [""""TestItems"""", """"TestItemRunner""""]\n```\n`test/runtests.jl`:\n```jl\nusing TestItemRunner\n```\nand running from the command line fails:\n\n```console\n$ julia --project=. test/runtests.jl\nERROR: LoadError: ArgumentError: Package TestItemRunner not found in current path.\n- Run `import Pkg; Pkg.add(""""TestItemRunner"""")` to install the TestItemRunner package.\n```\n\nIf I instead use the alternative, possibly unstable test/Project.toml method:\n\n`Project.toml`:\n```toml\nname = """"mvce""""\nuuid = """"5c5c69df-07ce-4eec-9db9-de18ccd496a9""""\nauthors = [""""Peter Hill <peter.hill@york.ac.uk>""""]\nversion = """"0.1.0""""\n```\n`test/Project.toml`:\n```toml\n[dep]\nTestItemRunner = """"f8b46487-2199-4994-9208-9a1283c18c0a""""\nTestItems = """"1c621080-faea-4a02-84b6-bbd5e436b8fe""""\n```\n(do I need the top-level items? It's unclear from the docs)\n\nThen after activating the project and test environments and instantiating inside the REPL, I can run:\n```console\n$ julia --project=test test/runtests.jl\n```\n\n---\n\nThere generally seems to be bigger meta-issue around the docs for testing. Coming from Rust and Python, I've found it very confusing getting tests set up in Julia! \nSee also: \n- #3688\n- #3694\n- #3953\n- #3297\n- #3673",,0,false,0,0,0,0,0,0,0,0,0
4216,Feature request: allow a more general use of `[sources]` for dependencies,open,giannipetrella,,,,0,2025-04-09T21:51:34.0,2025-04-09T21:51:34.0,101,101,https://github.com/JuliaLang/Pkg.jl/issues/4216,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4216,"Hello,\n\n[The documentation](https://pkgdocs.julialang.org/v1/toml-files/#The-%5Bsources%5D-section) of the `[sources]` section of `Project.toml` files currently states the following:\n\n> [Dependencies listed via `[sources]` are] not used if [the current] project is a package that is being used as a dependency.\n\nI would like to do precisely that, i.e., to use an unregistered package `A` as a dependency for another unregistered package `B`, which I plan to share with third parties who would only use `B`.\n\nThe `Project.toml` file for Package B would ideally look like\n\n```toml\nname = """"B""""\nuuid = """"BBBBBBBBBBBBBBBBB""""\nauthors = [""""me""""]\nversion = """"1.0.0""""\n\n[deps]\nA = """"AAAAAAAAAAAAAAAAA""""\n\n[sources]\nA = {url = """"https://github.com/the-repository-hosting-A"""", rev = """"some-version""""} \n```\n\nConsequently, I would ideally just instruct folks wishing to use `B` to install it via the one-liner\n\n```julia\njulia> using Pkg; Pkg.add(url = """"https://github.com/the-repository-hosting-B"""", rev = """"some-version"""")\n```\n\nTo handle versioning (i.e., to know what version of `A` is being installed when `B` is added) a choice of `rev` could for instance be required, or a warning could be thrown if there isn't one.\n\nThis would greatly simplify the workflow of people who develop niche packages with niche dependencies (e.g. for research purposes), do not want to go through the hassle of setting up a dedicated registry and do not want their users to have to add said registry.\n\n\n",,0,false,1,1,0,0,0,0,0,0,0
3667,The CompatHelper functionality (`force_latest_compatible_version`) should probably also be applied to weakdeps/weakcompat,open,DilumAluthge,,feature,,1,2023-10-16T22:26:54.0,2025-03-29T20:50:04.0,642,112,https://github.com/JuliaLang/Pkg.jl/issues/3667,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3667,"<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including:\n\n1. The output of `versioninfo()`\n2. How you installed Julia\n3. A minimal working example (MWE), also known as a minimum reproducible example\n\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n",[miguelbiron]: Hi! Any updates on this feature being implemented? I just posted [this issue](https://github.com/julia-actions/julia-runtest/issues/144) on the julia-runtest action but now I realize it's probably related to this.,1,false,1,1,0,0,0,0,0,0,0
4175,Extension dependencies as weak dependencies,open,Zetison,,,,1,2025-02-27T19:13:39.0,2025-03-26T12:50:57.0,142,116,https://github.com/JuliaLang/Pkg.jl/issues/4175,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4175,"If extensions have dependencies not present in the main project they must either be listed in `[deps]` or can be included in the extension i.e. (with `EMGExt` being an extension with `EnergyModelsGeography`)\n```toml\n[extensions]\nEMGExt = [""""GeoJSON"""", """"GeoMakie"""", """"HTTP"""", """"EnergyModelsGeography""""]\n```\nThe former would require redundant dependencies (if EMGExt is not used) while the latter would in order to use the extension require not only `EnergyModelsGeography` to be loaded, but `GeoJSON`, `GeoMakie`, and `HTTP` as well. It would be convenient if these three packages would be loaded only when EnergyModelsGeography is loaded. Could this be implemented?",[KristofferC]: >  It would be convenient if these three packages would be loaded only when EnergyModelsGeography is loaded. Could this be implemented?\n\nYou can chose to only load them in the extension. They would still be unconditionally installed though. There isn't really a way to get around that right now.,1,false,1,1,0,0,0,0,0,0,0
3080,Merge Pkg docs fully into julia docs,open,IanButterworth,,documentation,,6,2022-05-05T18:12:15.0,2025-03-18T19:08:24.0,1171,123,https://github.com/JuliaLang/Pkg.jl/issues/3080,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3080,"`docs/getting-started.md` is the only page currently served within julia docs. https://docs.julialang.org/en/v1/stdlib/Pkg/\n\nThere is a clear link to the full separately hosted docs, but them being hosted separately prevents users from discovering a lot of the Pkg docs via the julia docs search.\n\nIt seems beneficial to fully merge the Pkg docs into julia docs.\n\nOr is there a particular benefit to the current setup?","[IanButterworth]: @fredrikekre it'd be helpful to understand your disagreement here. I might be missing something | [fredrikekre]: I just don't think it is necessary. Pkg.jl docs are already quite big and self-contained and I prefer concentrated docs. If you are looking for documentation for the package manager you know where to go, you don't have to sort through unrelated search result etc. There are already links here from the main docs, right? | [IanButterworth]: > If you are looking for documentation for the package manager you know where to go\n\nI'm not sure that's robustly true for new users who are using the base docs search feature. That's the issue I was thinking it would overcome. \n\nAnd in terms of size, I'm not sure  size is a factor when it comes to the web interface? The pdf docs would grow in filesize though | [IanButterworth]: A couple of reasons why we might want to do this:\n- Often Pkg doesn't get release tags until a lot later than julia does because it requires someone to remember, so docs are often outdated (The latest Pkg tag is currently v1.9.2).\n- Once stdlibs become upgradable the latest version on the repo may not be the version that ships with julia | [DilumAluthge]: > * Often Pkg doesn't get release tags until a lot later than julia does because it requires someone to remember, so docs are often outdated (The latest Pkg tag is currently v1.9.2).\n\nOrthogonal to the docs discussion, we should fix this. Maybe some kind of CI cron job that runs once a week and detects whether external stdlibs have made the newest tags? | [IanButterworth]: We need to do something about this.. We keep forgetting to tag Pkg releases.. currently the latest are 1.11.0 and 1.10.4\n\nOptions that come to mind, ordered from least developer work to most:\n1) Merge pkg docs into Base docs\n2) Automate tagging Pkg (and other stdlibs?) versions when new julia tags are made\n3) Add a checklist item for release managers to make Pkg (and other stdlib) tags \n4) Someone remember more frequently to make tags",6,false,5,4,1,0,0,0,0,0,0
4189,`activate` in the wrong current working directory,open,PatrickHaecker,,,,1,2025-03-17T17:57:45.0,2025-03-18T04:14:15.0,124,124,https://github.com/JuliaLang/Pkg.jl/issues/4189,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4189,"I regularly waste a bit of time because when I want to activate an environment, I need to give the path. As the absolute path is often long, I need to provide the relative one which means I need to check which is the current working directory. This is not a show-stopper, but a flow-stopper :-).\n\nSometimes, I manage to get it wrong and therefore activate a non-existing directory, happily add a package to the environment and spend the next minutes with debugging errors which do not fit my mental model.\n\nCan't we just check all packages which are already `add`ed or `develop`ed when only a package name without any path information is provided for `activate` and activate that existing environment even if it is not in the current working directory?\n\nI think this is probably what we want in more than 99% of the cases. In the remaining cases where you already have a package `Package` and want to create a new environment in the current directory with the same name, you could still `activate ./Package` in the package REPL.","[PatrickHaecker]: This would mirror the `$PATH` behavior in most operating systems (`.` not in the `$PATH`) on the shell, so should feel familiar to most users:\n- If you want to start a process, just enter the binary and `$PATH` is being searched for it.\n- When you really want to start something in the current directory, you use an explicit path like `./julia`.",1,false,0,0,0,0,0,0,0,0,0
1415,Make `activate` instantiate by default,open,davidanthoff,,speculative,,20,2019-09-23T18:25:12.0,2025-03-18T03:44:40.0,2126,124,https://github.com/JuliaLang/Pkg.jl/issues/1415,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1415,"Would it make sense that activating an env automatically instantiates that env, unless one explicitly opts out?\n\nWe are starting to prep a fair number of replication repositories for stuff we publish. All of them have a `Project.toml`/`Manifest.toml` in their root, but now we need a fair bit of explanation in our `README`s to walk folks through activating and instantiating of these environments. That is a lot of concepts that our average users won't have heard before...\n\nI guess my other question is: isn't it way, way more common that I activate an env and then actually want it to be instantiated, rather than the other way around? In fact, what is the scenario where I want an env activated but not instantiated? Those seem really corner cases?\n\nIf it wasn't fully automatic, maybe there could be at least a prompt that offers this? Something like """"You activated an env that still needs to download stuff. Do you want to download these things now? y/n"""".","[StefanKarpinski]: We could add an opt out option like `activate --instantiate=no` and have it default to `yes`. | [davidanthoff]: Yes, I think that would be great. Probably needs a command line flag as well? So that one can also opt out of `julia --project foo.jl` instantiating? | [StefanKarpinski]: Yeah, that's the complication. It seems a bit much to automatically instantiate just because you started Julia in a directory with the `--project` flag. Maybe we can prompt for instantiation the first time you try to load something that isn't installed. | [KristofferC]: > but now we need a fair bit of explanation in our READMEs to walk folks through activating and instantiating of these environments.\n\nDo you have an example? Since it is literally just running `Pkg.instantiate()` after activating the project for the first time, I wonder how much explanation is needed. The error message you get when you try to load a package before it also tells you to run this exact command.\n\nI really like that activate is instant and doesn't try to download and build a bunch of stuff. You can get a nice view of what the project contains with `st`, you might want to remove some packages before instantiating etc. \n\n\n | [davidanthoff]: Maybe the default should be a prompt with an option to save your answer? Say:\n```\nSome of the packages in the active environment are not installed.\nDo you want to install them now? yes / no / always / never\n```\nThat would require some way to save the answer as a config setting, but I think that might the option that accommodates the widest range of users?\n\n> Do you have an example?\n\nIt literally is just an academic paper repository that has replication code (not public yet). But the audience we have their typically has never heard of julia before, and I'd much prefer instructions a la """"Install Julia, then run `julia --project src/main.jl`"""". Yes, it is only a few commands more today, but it introduces a lot of concepts that these users won't be familiar with, which I think is not great. They might literally not know what a package in the julia sense is, what activating means, what instantiating means etc.\n\n> I really like that activate is instant and doesn't try to download and build a bunch of stuff. You can get a nice view of what the project contains with st, you might want to remove some packages before instantiating etc.\n\nYeah, I completely see that this is the preferred option for some folks that are familiar with julia, but I think there is another user group out there for which this is entirely irrelevant and where this becomes a distraction. | [KristofferC]: They figured out how to download and install Julia, clone the paper repository, cd to it etc, but saying\n\n> The first thing to do is to run `julia --project -e 'import Pkg; Pkg.instantiate()' which installs everything that is needed for the code to run\n\nis where the limit is? Has this really been a problem in practice? | [Datseris]: Hi, I would just like to chime in and say that this would be a big and bad hit to DrWatson. As @KristofferC said, activating should be instant, and there are a lot of benefits to it being instant, as for example knowing for where to load packages, but most importantly using DrWatson instantly.\n\nAs a scientist, I switch several Julia projects during my work day, each corresponding to a different scientific project. If every time I switch I would have to wait for the registry to update, I would be a sad man. \n\nIf you add this, please consider *not* making it the default behavior, although I fully agree with Kristoffer, I see no reason that this should happen. | [davidanthoff]: I don't think this would require hitting the registry every time you switch, presumably it would only hit the registry if you switch _and_ there is a package in your new env that isn't instantiated. I completely agree, this feature would have to be implemented in such a way that switching between env that are fully instantiated is still instantaneous. | [davidanthoff]: > Has this really been a problem in practice?\n\nIn general, very much yes. My lab is about 10 folks that use julia pretty much daily for their scientific work, but are not package contributors (roughly). My not super systematic sense is that maybe half of them are still not using environments in any systematic sense, and when I chat with them about it, it is pretty clear that they find the concepts confusing and don't fully understand the story. The other half is using environments, but it took me quite a while to convince them, and explain things.\n\nBut our work is actually targeting folks that use julia _much_ less than daily. We want our replication code to be easily usable by folks that might not have used Julia ever. I'm worried that a) if the folks that use this daily (but have no interest in CS topics, i.e. they are really users that don't show up on github, the forum etc.) already have quite a jump to make to grasp these concepts, then I think for even less involved users this will be even more tricky, and b) I'm worried that if the first experience of Julia these folks see is a complicated packaging story to even just run a quick replication, we are losing an opportunity to impress new users how easy things are. | [StefanKarpinski]: The alternative is to prompt for install when someone runs code and the required package isn't installed. That seems just as effective since the user just needs to hit `y` to agree but safer since they still have to approve to installing the packages that they're about to run. | [davidanthoff]: I guess that would also work, but on the other hand it would be nice to not have multiple prompts in a row, i.e. one prompt for package A, then a few seconds a prompt for package B etc. Would be nicer if there was just one prompt a la """"your env is not instantiated, do you want to instantiate it?"""". But I guess the trigger for that could be the first `using` statement that fails. | [StefanKarpinski]: It could list all the packages that aren't installed in one prompt. | [xgdgsc]: Would also auto activate like https://bkamins.github.io/julialang/2020/05/10/julia-project-environments.html make sense? | [aplavin]: If wonder if there were any updates or new considerations on this topic?\nWhen I share a Julia script with colleagures, I provide script.jl + Project + Manifest, and the script has\n```julia\nusing Pkg\nPkg.activate(@__DIR__)\nPkg.instantiate()\n```\nat the top. This works ok generally, with two issues that would be nice to fix to streamline the experience:\n- These lines is a clear piece of boilerplate\n- `instantiate()` has a noticeable delay even on later runs when everything is installed\n\nMaybe, a flag like `julia --script myscript.jl` would be useful? It would be equivalent to these three lines, with potential to future extension of what is officially meant by """"run a julia script"""". | [tecosaur]: We now have `--project=@script`, which is a nice way of specifying how the project for a file should be interpreted, but requiring instantiation to be separately handled whenever a script+project is shared is an annoying bit of boilerplate/overhead.\n\nI would find it convenient to be able to say """"Julia: just run this file, and install packages as needed"""" without `julia --project=@script -E 'using Pkg; Pkg.instantiate()' myfile.jl` and then paying the full instantiate (e.g. registry update) cost every time.\n\nFor infrequent Julia users I want to share code with, and to respond to the comment """"is where the limit is? Has this really been a problem in practice?"""" I think there is a substantial difference in perceived complexity between:\n\n- Just call `julia --script myscript.jl`\n\nand\n\n- Call `julia --project=@script -e 'using Pkg; Pkg.instantiate()'`, but only the first time, or any time I give you a new version and you see package-y error\n- Call `julia --project=@script myscript.jl` every time thereafter\n\nI'll expect most people to be able to memorise a single command like the first example, but not once you add in bits like `-e 'using Pkg; Pkg.instantiate()'.\n\nI think it's notable that the latest python packaging tools like `uv` seem to do automatic instantiation + activation, which makes running scripts with them a breeze.\n\nI'd love to see Julia reach a similar point, including gaining support for embedded project/manifest information, so we eventually get easy to run self-contained files 🙂 | [StefanKarpinski]: Agree, I'm increasingly finding having to explicitly instantiate to be a drag. You know what I want, why should I care whether you have it installed already or not? OTOH, I get that people might be a little touchy about automatically downloading and installing stuff. Maybe we could have a `JULIA_PKG_AUTO_INSTANTIATE` environment flag? | [PatrickHaecker]: If it's really about activating and instantiating in one go, wouldn't an additional verb do it? Something like `initialize`? I think that would not solve all use cases discussed in this issue, but it could solve some.\nIf you are the person who wants to cautiously peek, you train yourself to `activate`. If you are more the """"get stuff done"""" person, you automate `initialize`. | [StefanKarpinski]: The name """"initialize"""" seems to be the opposite of what we want: initialization is something you do the very first time you want to use something; this is something we want to do every time you use something. | [IanButterworth]: We already have this if you're loading a package.\n```\npkg> activate Foo\njulia> using Foo\n# Pkg.precompile calls `instantiate` before running\n```\n\nBut not if you do \n```\npkg> activate Foo\njulia> include(""""foo.jl"""")\n``` | [PatrickHaecker]: > The name """"initialize"""" seems to be the opposite of what we want: initialization is something you do the very first time you want to use something; this is something we want to do every time you use something.\n\nI was thinking about the Unix tradition of an `init` process which """"initializes"""" at ever boot., but I see that this can be misleading. `systemd` would also offer """"start"""", """"enable"""" and """"preset"""". Or what about """"setup""""?\n\nAlternatively, we could reuse """"activate"""" for the new behavior and have a new verb for the old behavior (might be more controversial due to muscle memory), but then we could use something like """"peek"""".",20,false,7,2,5,0,0,0,0,0,0
4184,Registries are decompressed and unpacked twice when they are updated,open,KristofferC,,,,0,2025-03-04T16:42:35.0,2025-03-04T19:23:28.0,137,137,https://github.com/JuliaLang/Pkg.jl/issues/4184,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4184,Once to compute the hash: https://github.com/JuliaLang/Pkg.jl/blob/60e3185e38b1d49425fb3396b0fc9fe2ab1a3ab8/src/Registry/Registry.jl#L200\n\n(which calls)\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/60e3185e38b1d49425fb3396b0fc9fe2ab1a3ab8/src/PlatformEngines.jl#L694\n\nOnce to actually create the Pkg data structure: https://github.com/JuliaLang/Pkg.jl/blob/60e3185e38b1d49425fb3396b0fc9fe2ab1a3ab8/src/Registry/registry_instance.jl#L263\n\nFeels wasteful.,,0,false,0,0,0,0,0,0,0,0,0
4179,Add `julia` compat entry automatically,open,eschnett,,feature request,,0,2025-03-01T17:17:02.0,2025-03-01T17:17:02.0,140,140,https://github.com/JuliaLang/Pkg.jl/issues/4179,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4179,"Pkg adds compat entries for packages automatically when a new package is added. It should also add a compat entry for julia when a new `Project.toml` is generated. Same as when adding packages, it should use the current Julia version as minimum requirement.\n",,0,false,1,1,0,0,0,0,0,0,0
2219,Adding packages is thread-unsafe?,open,giordano,,,,7,2020-11-19T18:38:39.0,2025-02-28T22:54:13.0,1703,141,https://github.com/JuliaLang/Pkg.jl/issues/2219,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2219,"In Yggdrasil, where we happen to install the same packages in parallel, we have often issues with files that disappear.  [Last example](https://dev.azure.com/JuliaPackaging/Yggdrasil/_build/results?buildId=7399&view=logs&j=572c5e49-83d5-5271-390a-e6dc77f89c6b&t=25aa3cdb-e20d-599e-657c-8776cc8a525f&s=d654deb9-056d-50a2-1717-90c08683d50a):\n```\nERROR: LoadError: Error when installing package SuiteSparse32_jll:\nIOError: unlink: no such file or directory (ENOENT)\nStacktrace:\n [1] uv_error\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:802 [inlined]\n [9] (::Pkg.Operations.var""""#62#65""""{Bool, Pkg.Types.Context, Dict{Base.UUID, Vector{String}}, Channel{Any}, Channel{Tuple{Pkg.Types.PackageSpec, String}}})()\n   @ Pkg.Operations ./task.jl:395\nStacktrace:\n  [1] pkgerror(::String, ::Vararg{String, N} where N)\n    @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:52\n  [2] macro expansion\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:819 [inlined]\n  [3] macro expansion\n    @ ./task.jl:371 [inlined]\n  [4] download_source(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, urls::Dict{Base.UUID, Vector{String}}; readonly::Bool)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:775\n  [5] #download_source#58\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:750 [inlined]\n  [6] download_source\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:748 [inlined]\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Vector{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Platform)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1225\n  [8] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Platform, kwargs::Base.Iterators.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:194\n  [9] (::BinaryBuilderBase.var""""#58#64""""{Bool, Prefix, Vector{Pkg.Types.PackageSpec}, Platform, Vector{String}})()\n    @ BinaryBuilderBase /depot/packages/BinaryBuilderBase/66EAL/src/Prefix.jl:436\n [10] activate(f::BinaryBuilderBase.var""""#58#64""""{Bool, Prefix, Vector{Pkg.Types.PackageSpec}, Platform, Vector{String}}, new_project::String)\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1351\n [11] setup_dependencies(prefix::Prefix, dependencies::Vector{Pkg.Types.PackageSpec}, platform::Platform; verbose::Bool)\n    @ BinaryBuilderBase /depot/packages/BinaryBuilderBase/66EAL/src/Prefix.jl:429\n [12] autobuild(dir::AbstractString, src_name::AbstractString, src_version::VersionNumber, sources::Vector{var""""#s1129""""} where var""""#s1129""""<:BinaryBuilderBase.AbstractSource, script::AbstractString, platforms::Vector{T} where T, products::Vector{var""""#s1128""""} where var""""#s1128""""<:Product, dependencies::Vector{var""""#s824""""} where var""""#s824""""<:BinaryBuilderBase.AbstractDependency; verbose::Bool, debug::Bool, skip_audit::Bool, ignore_audit_errors::Bool, autofix::Bool, code_dir::Union{Nothing, String}, require_license::Bool, kwargs::Any)\n    @ BinaryBuilder /depot/packages/BinaryBuilder/LCVcc/src/AutoBuild.jl:651\n [13] build_tarballs(ARGS::Any, src_name::Any, src_version::Any, sources::Any, script::Any, platforms::Any, products::Any, dependencies::Any; kwargs::Any)\n    @ BinaryBuilder /depot/packages/BinaryBuilder/LCVcc/src/AutoBuild.jl:264\n [14] top-level scope\n    @ /agent/_work/1/s/S/Sundials/Sundials32@5/build_tarballs.jl:116\nin expression starting at /agent/_work/1/s/S/Sundials/Sundials32@5/build_tarballs.jl:116\n```\nSo `Pkg.add` deletes files?","[StefanKarpinski]: I don't think any effort has gone into making package operations threadsafe. Would probably make sense to just have a """"global package lock"""" that prevents more than one package operation from being in progress at a time. | [fonsp]: This is an issue for Pluto users, since starting two notebooks at the same time is fairly common. This also means that we can't run notebooks in parallel inside github actions.\n\nI can implement this lock in the future built-in Pkg stuff, but users who manage their environment manually (by calling `Pkg.activate`) will still be affected. | [StefanKarpinski]: Are the notebooks run in the same process? | [fonsp]: Thanks for pointing that out -- no, it's on separate processes, so my guess is that this issue is present in any form of parallelism on the same file system. Maybe the registry update process? | [StefanKarpinski]: There's two levels of potential synchronization needed: same process and inter-process. In the one process, we can just put a global lock at the entrance to Pkg APIs. Locking between processes is much harder; we could use a mechanism like `flock` but that doesn't work on all file systems (notoriously not on NFS, iirc). We also don't need to lock between processes all the time. Since many of the things that Pkg installs are immutable, it's often fine if two processes are doing it concurrently as long as we use the pattern of creating a temp version in the same file system and then only move it into place at the last moment. That way one of the two processes """"wins"""" by going last, but it doesn't matter since they both install identical content. | [fonsp]: This package (solves and) references more discussions about this issue: https://github.com/simonbyrne/PkgLock.jl | [IanButterworth]: https://github.com/JuliaLang/Pkg.jl/pull/4168 makes a fair bit of progress here, and not just thread safety but mutliprocess concurrency safety. \n\nOne remaining issue that comes to mind would be changes to the same Project/Manifest\n\nShould we also pidlock that?",7,false,0,0,0,0,0,0,0,0,0
3112,`Pkg.add` with a `ctx` operates in-place on the arguments without notice,open,giordano,,binarybuilder,,4,2022-06-16T21:12:09.0,2025-02-24T03:04:01.0,1129,146,https://github.com/JuliaLang/Pkg.jl/issues/3112,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3112,"```julia\njulia> using Pkg\n\njulia> Pkg.activate(; temp=true, io=devnull)\n\njulia> spec = Pkg.PackageSpec(; name = """"Example"""", version = Pkg.Types.VersionSpec(""""0.5.3""""));\n\njulia> Pkg.add(Pkg.Types.Context(), [spec]; io=devnull)\n\njulia> spec\nPackageSpec(\n  name = Example\n  uuid = 7876af07-990d-54b4-ab0e-23690620f79a\n  tree_hash = 46e44e869b4d90b96bd8ed1fdcf32244fddfb6cc\n  version = v""""0.5.3""""\n)\n```\n`spec` changed after the call to `Pkg.add`, it acquired the tree hash and the UUID.  One could claim this method is internal, but this still violates the convention of appending `!` to a function name when arguments are modified in-place.","[KristofferC]: https://github.com/JuliaLang/Pkg.jl/blob/423343402943074825392faa8b04a6d353204689/src/API.jl#L154\n\n | [giordano]: That's not the same method I used above. | [IanButterworth]: The rub again is that the first arg `Context()` methods aren't part of the public API. And adding them was rejected https://github.com/JuliaLang/Pkg.jl/pull/2952\n\nSo seems like you need to `deepcopy` before passing the arg in to use this internal method | [giordano]: > The rub again is that the first arg Context() methods aren't part of the public API.\n\nIn fact I said\n\n> One could claim this method is internal, but this still violates the convention of appending `!` to a function name when arguments are modified in-place.\n\n> So seems like you need to `deepcopy` before passing the arg in to use this internal method\n\nWhich is what I had done before opening the issue: https://github.com/JuliaPackaging/BinaryBuilderBase.jl/pull/250. But discovering that a method not following the naming convention was modifying my specs, just to make me run into another Pkg bug #3113, wasn't exactly fun",4,false,0,0,0,0,0,0,0,0,0
4164,Are `dependencies` and `project` experimental?,open,Sbozzolo,,,,0,2025-02-19T16:17:02.0,2025-02-19T16:17:02.0,150,150,https://github.com/JuliaLang/Pkg.jl/issues/4164,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4164,I found myself using `Pkg.project()` and `Pkg.dependencies()` often when inspecting the dependency tree of a package. The docstring says that the functions are experimental. The functions were introduced for julia 1.4 in [in 2019](https://github.com/JuliaLang/Pkg.jl/commit/996c6b9b69ef0c058e0105427983622b7cc8cb1d) and haven't changed much since. \n\nIs there a plan to stabilize them? Should they still be considered experimental?,,0,false,0,0,0,0,0,0,0,0,0
4163,`dev` doesn't try as hard as `add` to maintain existing versions,open,IanButterworth,,bug,,0,2025-02-18T21:08:52.0,2025-02-18T21:09:02.0,151,151,https://github.com/JuliaLang/Pkg.jl/issues/4163,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4163,I just had a situation where `dev`-ing a local dir caused a massive amount of upgrade in my project.\nBut `add`-ing the dir only resulted in that dep being updated.,,0,false,0,0,0,0,0,0,0,0,0
4152,How does gc work for Scratch spaces?,open,fonsp,,,,0,2025-02-10T14:36:05.0,2025-02-10T14:36:05.0,160,160,https://github.com/JuliaLang/Pkg.jl/issues/4152,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4152,"Hi!\n\nI am wondering how `gc` works for Scratch objects, exactly when will they get deleted? I have two specific questions:\n\n# 1. Per object?\nMy package uses two objects, with:\n\n\n```julia\nmodule MyPackage\npublic f1, f2\n\nfunction f1()\n    Scratch.@get_scratch!(""""one"""")\nend\n\nfunction f2()\n    Scratch.@get_scratch!(""""two"""")\nend\nend\n```\n\nA user called `MyPackage.f1` recently, `MyPackage.f2` two weeks ago, and never since. Will `""""two""""` get deleted when the user does `gc`? Or is it an all-or-nothing situation, where the objects only get deleted if the entire package `MyPackage` is not used in the past week?\n\n\n\n# 2. `collect_delay=Second(1)` leaves some scratch spaces\nI called `Pkg.gc(collect_delay=Second(1))` in a terminal and I was surprised that some scratch spaces were still there. The `.julia/scratchspaces` folder still has three subfolders (from Pluto, Makie and Pkg I believe). Is this expected? I assumed that `collect_delay=Second(1)` would cause all scratch spaces to get deleted, since nothing was used in the past second.\n\nThanks! Let me know if my questions are unclear :) ☀\n\n",,0,false,0,0,0,0,0,0,0,0,0
4149,Treat julia compatibility as a normal package,open,KristofferC,,,,0,2025-02-04T17:22:33.0,2025-02-04T17:22:33.0,165,165,https://github.com/JuliaLang/Pkg.jl/issues/4149,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4149,"Right now there is some special code in the resolver for julia compatibility, for example https://github.com/JuliaLang/Pkg.jl/blame/7aeec766cf637e2bc2af161eba8abd3a4b68d025/src/Resolve/graphtype.jl#L247-L254 but it would be better if the julia compatibility was all dealt with outside the resolver and it could in there be treated as a normal package.",,0,false,0,0,0,0,0,0,0,0,0
4129,Automatic `[compat]` bounds added on `add` breaks some workflows,open,jonniediegelman,,,,10,2025-01-07T18:50:19.0,2025-01-16T15:17:15.0,193,184,https://github.com/JuliaLang/Pkg.jl/issues/4129,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4129,"The new functionality that automatically adds `[compat]` bounds whenever a dependency is added makes it more difficult to work with a monorepo workflow. By """"monorepo workflow"""" here, I mean specifically workflows that:\n- don't use a private registry for internal packages in the repo; internal packages are all `dev`ed by path\n- check in Manifest.toml files so exact dependencies are pinned for every git commit SHA\n\nIn these workflows, compat bounds are only useful in cases where certain dependency versions need to be explicitly restricted from updating due to known issues. It's unnecessary to add them for every dependency, as things will already be pinned by the Manifest files. Beyond that, it makes it difficult to tell which compat bounds were actually added for good reason when all dependencies have compat bounds.\n\nMaking everything automatically add compat bounds also forces the use of `CompatHelper`. This is more difficult for monorepos, since you need to explicitly pass in the package subdirectory paths in order for them to be included. Any time someone creates a new package, they need to know to add to this list (for large organizations, this isn't easy to enforce). Writing a wrapper around `CompatHelper.main` that automatically crawls the repo and searches for Julia packages isn't a good solution either, since it will regularly change multiple different teams’ projects and require sign-off from each of them each time its run. There’s a lot of extra infrastructure you need to manually build around `Pkg` if you want it to work with a monorepo workflow (in the very least, you need to write something that resolves the package Manifest files in order whenever a dependency is added to one of them), so little things like this–while they aren’t that hard to implement–just end up making things a lot more complex/brittle with no added benefit.\n\nI'd also argue there is limited benefit to standard registry workflows, as this only adds compat bounds the first time you add a package, it doesn't set up `CompatHelper` for the repo. Anyone creating a new package that doesn't know about `CompatHelper` won't receive any messages telling them they need to set it up, they'll just run into unresolvable dependency issues a few weeks/months down the road.","[giordano]: > check in Manifest.toml files so exact dependencies are pinned for every git commit SHA\n\nI don't think that's a good reason for not adding compat bounds. I often want to update my environment, whether it has a checked in manifest or not, in a """"compatible way"""", and having compat bounds would enable that. If you don't, you start getting upgrades to breaking releases of packages and good luck dealing with that | [visr]: Here are the config settings pixi offers for pinning: https://pixi.sh/latest/reference/pixi_configuration/#pinning-strategy. For the same reason I use no-pin there, also since there is no dependabot support yet. The default is similar to Julia. So I just run a monthly update action that conveniently highlights breaking changes so they can be reviewed: https://github.com/Deltares/Ribasim/pull/1992. | [jonniediegelman]: > If you don't, you start getting upgrades to breaking releases of packages and good luck dealing with that\n\nIt's pretty easy actually. Every so often, you try to update everything in your environment. If things break, they fail CI and you either add a compat bound to restrict the version or fix what broke. It's the exact same thing you'd do with CompatHelper. | [giordano]: I was speaking from the experience of helping newbies who don't really do any of that and expect that updating an environment after a while everything will magically work. If you have an advanced CI system to deal with breakage, probably you can also deal with compat bounds. People who don't know that compat bounds can save them frustration are left hopeless. | [jonniediegelman]: >People who don't know that compat bounds can save them frustration are left hopeless.\n\nI would imagine those people would be equally frustrated when they start getting upstream unsatisfiable requirements errors because they didn't know they needed to add CompatHelper to their package repo to keep the compat bounds up-to-date.\n\n>If you have an advanced CI system to deal with breakage\n\nThat's just the regular function of any CI system?\n\n>probably you can also deal with compat bounds\n\nProbably. But there is already a lot of friction to using Julia in a monorepo organization (which is a fairly popular setup these days) and little things like this really do add up. | [lassepe]: How about a slight UI change to `]dev path/to/Foo` that offers to remove the compat bound for Foo if there is one. Then offer to add it back on `]free` and `]add` | [Cvikli]: I want to emphasize that this issue is very dangerous. Actually I think lot of us who already working in julia for ages run into problems due to these automatical package version locks. And as it was pointed out by @giordano  every newbie will face problems. And lot of them will end up losing their hair to understand the extreme situation that can come out with these package locks. \n\nI think this should be an optional feature (anybody who is knowledgeabel can turn this on if he needs). Till 1.10 everything was magically working. It was totally developer friendly. \nWe need it back! :D \n | [StefanKarpinski]: FWIW, these are not package *locks*. `Foo = """"1.2.3""""` means """"any version that is compatible with `1.2.3` according to SemVer,"""" which roughly means ≥ 1.2.3 and < 2.0.0 (ignoring prereleases and such). This is can more explicitly be written as `Foo = """"^1.2.3""""` which I think would be better. Yes, these mean the same thing, but it's confusing and based on various comments about """"locking"""", people seem to think that the latter syntax locks to a single version. | [StefanKarpinski]: To be clear, I think that at the very least, we should explicitly put `Foo = """"^1.2.3""""` in the autogenerated compat entries to avoid this confusion. | [StefanKarpinski]: > It's pretty easy actually. Every so often, you try to update everything in your environment. If things break, they fail CI and you either add a compat bound to restrict the version or fix what broke. It's the exact same thing you'd do with CompatHelper.\n\nThis sounds great in theory. However, lack of lower bounds ends up being a significant problem for resolving package versions when there are conflicts between the latest versions of packages that someone needs to use at the same time. Why? Because when there aren't any lower compat bounds the resolver thinks """"great, I can use this ancient version because it's compatible with everything!"""". Of course, that ancient version probably doesn't actually work with everything, it's just that no one bothered to put a lower bound on what versions of that package they actually work with so it looks like it should work to the resolver.",10,false,0,0,0,0,0,0,0,0,0
4131,JLLs in the sysimage confuse Pkg.update when their Project.toml version build doesn't match the registry build number,open,IanButterworth,,,,0,2025-01-10T15:48:30.0,2025-01-10T15:48:30.0,190,190,https://github.com/JuliaLang/Pkg.jl/issues/4131,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4131,"Usually JLL build numbers in their Project.toml match the registered build number, but https://github.com/JuliaRegistries/General/pull/122129 was done with the intention of being the least breaking way to undo an awkward compat issue.\n\nThis seems to be fine, except if the JLLs are in a sysimage.\n\nHere, it seems Pkg.update thinks the loaded version is +1 (I assume based on pkgorigins) where it's actually +3 in manifest terms (based off the registry).\n\n```\n(@v1.12) pkg> activate jll_test\n  Activating new project at `~/Documents/GitHub/julia/jll_test`\n\n(jll_test) pkg> add Xorg_libXau_jll@1.0.11\n   Resolving package versions...\n    Updating `~/Documents/GitHub/julia/jll_test/Project.toml`\n  [0c0b7dd1] + Xorg_libXau_jll v1.0.11+3\n    Updating `~/Documents/GitHub/julia/jll_test/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.7.0\n  [21216c6a] + Preferences v1.4.3\n  [0c0b7dd1] + Xorg_libXau_jll v1.0.11+3\n  [56f22d72] + Artifacts v1.11.0\n  [ade2ca70] + Dates v1.11.0\n  [8f399da3] + Libdl v1.11.0\n  [de0858da] + Printf v1.11.0\n  [fa267f1f] + TOML v1.0.3\n  [4ec0a83e] + Unicode v1.11.0\n\njulia> create_sysimage([""""Xorg_libXau_jll""""]; sysimage_path=""""JLLTestSysimage.so"""")\nPrecompiling packages finished.\n  4 dependencies successfully precompiled in 2 seconds. 3 already precompiled.\n✔ [01m:12s] PackageCompiler: compiling incremental system image\nld: warning: reexported library with install name '@rpath/libunwind.1.dylib' found at '/Users/ian/Documents/GitHub/julia/usr/lib/libunwind.1.0.dylib' couldn't be matched with any parent library and will be linked directly\n\njulia>\nian@Ians-MacBook-Pro julia % ./julia --sysimage=JLLTestSysimage.so\nPrecompiling InteractiveUtils finished.\n  5 dependencies successfully precompiled in 11 seconds\nPrecompiling REPL finished.\n  1 dependency successfully precompiled in 22 seconds. 5 already precompiled.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.12.0-DEV.1869 (2025-01-10)\n _/ |\__'_|_|_|\__'_|  |  Commit d3964b600a (0 days old master)\n|__/                   |\n\njulia> import Pkg\nPrecompiling Pkg finished.\n  17 dependencies successfully precompiled in 40 seconds. 4 already precompiled.\nPrecompiling REPLExt finished.\n  1 dependency successfully precompiled in 3 seconds. 23 already precompiled.\n\n(@v1.12) pkg> activate jll_test\n  Activating project at `~/Documents/GitHub/julia/jll_test`\n\n(jll_test) pkg> update\n    Updating registry at `~/.julia/registries/HolyLabRegistry`\n    Updating git-repo `git@github.com:HolyLab/HolyLabRegistry`\n    Updating registry at `~/.julia/registries/LeukoRegistry`\n    Updating git-repo `git@github.com:LeukoMaster/LeukoRegistry`\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/Documents/GitHub/julia/jll_test/Project.toml`\n⌅ [0c0b7dd1] ↓ Xorg_libXau_jll v1.0.11+3 ⇒ v1.0.11+1\n    Updating `~/Documents/GitHub/julia/jll_test/Manifest.toml`\n⌅ [0c0b7dd1] ↓ Xorg_libXau_jll v1.0.11+3 ⇒ v1.0.11+1\n        Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`\n\n(jll_test) pkg> add Xorg_libXau_jll@1.0.11\n   Resolving package versions...\nNo packages added to or removed from `~/Documents/GitHub/julia/jll_test/Project.toml`\nNo packages added to or removed from `~/Documents/GitHub/julia/jll_test/Manifest.toml`\n\n(jll_test) pkg>\n```\n\nThis is somehow related to the error https://github.com/JuliaLang/Pkg.jl/pull/4130 tries to fix, but I haven't found a reproducer yet.\n\ncc. @giordano",,0,false,0,0,0,0,0,0,0,0,0
2688,A way to list environments,open,layne-sadler,,,,15,2021-08-09T20:31:44.0,2025-01-06T05:49:41.0,1440,195,https://github.com/JuliaLang/Pkg.jl/issues/2688,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2688,"The first thing I wanted to do when using Julia in VS Code was list my environments.\n\nSo I wound up on this [discourse page](https://discourse.julialang.org/t/julia-environments-list/37774/3)\n```julia\njulia> using Pkg\n\njulia> Pkg.envdir()\n""""/home/jrun/data/.julia/environments""""\n\nshell> cd """"/home/jrun/data/.julia""""\n/mnt/data/.julia\n\nshell> ls -la\ntotal 36\ndrwxr-xr-x  8 jrun jrun 6144 Aug  9 19:52 .\ndrwxr-xr-x  6 jrun jrun 6144 Aug  9 18:29 ..\ndrwxr-xr-x  5 jrun jrun 6144 Aug  9 19:51 artifacts\ndrwxr-xr-x  3 jrun jrun 6144 Aug  9 19:48 compiled\ndrwxr-xr-x  2 jrun jrun 6144 Aug  9 19:51 logs\ndrwxr-xr-x 16 jrun jrun 6144 Aug  9 19:51 packages\nlrwxrwxrwx  1 jrun jrun   15 Aug  9 18:29 registries -> /tmp/registries\ndrwxr-xr-x  3 jrun jrun 6144 Aug  9 19:52 scratchspaces\ndrwxr-xr-x  3 jrun jrun 6144 Aug  9 18:29 servers\n```\nLooks like there are no environments by default\n\nHere is how I do this in python\n```python\n$ pyenv versions\n  system #<--- default\n  3.7.6\n  3.7.6/envs/GAN\n  3.7.6/envs/aiqc_test\n  3.8.7\n  3.8.7/envs/jupyterlab3\n```","[KristofferC]: So you want to see the equivalent of what `gc --verbose` outputs?\n\n```\n(Pkg) pkg> gc --verbose\n      Active manifest files: 6 found\n        `~/JuliaPkgs/PackageCompiler.jl/Manifest.toml`\n        `~/.julia/environments/v1.6/Manifest.toml`\n        `~/.julia/environments/v1.8/Manifest.toml`\n        `~/JuliaPkgs/Pkg.jl/Manifest.toml`\n        `~/.julia/environments/v1.7/Manifest.toml`\n        `~/JuliaPkgs/MKL.jl/Manifest.toml`\n...\n```\n\nRedaing what `pyenv` does:\n\n>     Let you change the global Python version on a per-user basis.\n>     Provide support for per-project Python versions.\n>     Allow you to override the Python version with an environment variable.\n>     Search commands from multiple versions of Python at a time. This may be helpful to test across Python versions with tox.\n\nit seems to be quite different from what we call a Julia environment.\n | [StefanKarpinski]: I think it may be more like listing all the shared named environments? By comparison, what `gc --verbose` shows every environment that Pkg knows about, even local project ones. Interestingly, in Julia it turns out that people mostly use project-specific environments and not named, shared environments, whereas it seems like people use named shared environments in pyenv more? Perhaps because Julia environments are so lightweight — they're just a manifest file. By comparison, Python environments are fairly heavyweight since they are entire separate installs of Python and its libraries. | [KristofferC]: Yes, I think the shared environments are indeed pretty uncommon and that people almost always associate an environment with a piece of code that they then have next to the environment. That's why I'm a bit unsure of what should be shown here. | [fredrikekre]: https://github.com/JuliaLang/Pkg.jl/issues/621 | [mkitti]: What I would like to see is a list of shared environments in the depot stack.\n\nFor most installations this would likely just show the default shared environments for each Julia version.\n\nWhere I find this particularly useful is in situations where there is a system level configuration of one of the depots at either `/usr/local/share/julia` or `/usr/share/julia`. In this case a system administrator or a package manager may be managing one of the these depots. These depots may include standard environments shared by many users of the system or pre-installed by a package manager.\n\nOne application I have is in packaging the Python library PySR for conda-forge [1]. This is a Python wrapper for SymbolicRegression.jl. To deliver the Julia components fully installed, the build script packages a Julia depot with all the Julia dependencies as well as a shared environment. This is done by invoking `pysr.install()`. Upon activation of the conda environment, the depot is inserted into stack by manipulating `JULIA_DEPOT_STACK`.\n\nThe prepared shared environment is `@pysr-0.10.3`. The Python package activates this Julia environment by default. Because all the packages are available in the depot stack the user does not need to invoke `pysr.install()` or otherwise use Pkg.jl directly. Discovering that `@pysr-0.10.3` exists somewhere on the `DEPOT_PATH` is difficult. Adding a command to list the shared environments in a depot stack would help make the existence of `@pysr-0.10.3` easier to discover.\n\nI can imagine that providing pre-configured shared environments could be useful for high performance computing clusters for particular common tasks or for teaching workshops.\n\n[1] https://github.com/conda-forge/pysr-feedstock/pull/43 | [KristofferC]: > What I would like to see is a list of shared environments in the depot stack.\n\nYou mean see the `pkg> status` output for all environments in the stack? | [mkitti]: I mean something like\n\n```julia\njulia> function list_shared_environments()\n           println(""""Shared Environments"""")\n           println(""""-------------------"""")\n           for depot in DEPOT_PATH\n               envdir = joinpath(depot, """"environments"""")\n               if isdir(envdir)\n                   for env in readdir(envdir)\n                       println(""""$envdir: @$env"""")\n                   end\n               end\n           end\n       end\nlist_shared_environments (generic function with 1 method)\n\njulia> list_shared_environments()\nShared Environments\n-------------------\n~/.julia/environments: @__pluto_boot_v2_1.7.1\n~/.julia/environments: @v1.7\n\n```\n\nI did not know that `@__pluto_boot_v2_1.7.1` existed until now. | [digital-carver]: The code for `Pkg.REPLMode._shared_envs` is quite close to what you've written:\n\n```julia\nfunction _shared_envs()\n    possible = String[]\n    for depot in Base.DEPOT_PATH\n        envdir = joinpath(depot, """"environments"""")\n        isdir(envdir) || continue\n        append!(possible, readdir(envdir))\n    end\n    return possible\nend\n```\n\nIt seems to be explicitly marked as private with the initial underscore though - perhaps you're asking for this to be made part of the public API? | [mkitti]: The current interface to this is via autocomplete via the following keystrokes.\n\n```\n] activate @[tab]\n```\n\nThat results in\n\n```\n(@v1.7) pkg> activate @\n@__pluto_boot_v2_1.7.1 @v1.7\n```\n\n | [mkitti]: Proposed actions:\n1. Expose a `Pkg.shared_envs()` public API\n2. Implement `env` command as in #621\n3. Implement `env list` subcommand using `Pkg.shared_envs()`\n\nTo perhaps make this more useful, perhaps there should be a way to register environments that may exist outside of the depot such that they effectively become """"shared"""". If all operating systems had symlinks, one could just make a symbolic link into `~/.julia/environments/` but alas this is not the case. | [StefanKarpinski]: We could also list non-shared environments that we keep track of in `~/.julia/logs/manifest_usage.toml`. | [zsz00]: Is there any progress so far ? | [alex180500]: **bump.** I felt this lack of environment routines a lot coming from python with conda | [LUK4S-B]: Would also appreciate a command to list shared environments. Now also using `] activate @[tab]` as suggested above as only alternative. | [liuyxpp]: Now that I use ShareAdd.jl, I separate many useful common packages to their corresponding envs to avoid cluttering, such as @plot, @tool, @test, etc. However, sometimes I will forget whether a package has been added to one of those shared envs. Having a way to list all these share envs is really helpful.",15,false,3,3,0,0,0,0,0,0,0
3905,Make `PRESERVE_TIERED_INSTALLED` the default,open,IanButterworth,,enhancement,,6,2024-05-22T18:18:19.0,2025-01-03T20:46:12.0,423,197,https://github.com/JuliaLang/Pkg.jl/issues/3905,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3905,"Since `PRESERVE_TIERED_INSTALLED` was added to [Pkg.add](https://pkgdocs.julialang.org/v1/api/#Pkg.add) in 1.9 I've had it enabled as the default via the env var\n```\nJULIA_PKG_PRESERVE_TIERED_INSTALLED = true\n```\nand I've not seen any issues with getting stuck on older package versions, as was feared.\n\nIn short it tries harder to avoid updating packages that are already installed, to minimize installation and re-precompilation.\n\nGiven precompilation times have been increasing as precompilation workload coverage increases I think it would be good to make that the default behavior.\n\nIt'd be good to hear from others that have used that setting to see if there are any negatives identified.\n","[fredrikekre]: Xref https://github.com/JuliaLang/Pkg.jl/issues/3890#issuecomment-2100594526 | [jakobnissen]: I have also set `ENV[""""JULIA_PKG_PRESERVE_TIERED_INSTALLED""""] = true` in my startup.jl for ages - at least a year. and I haven't had any issues. Though to be fair, I do fairly frequently disable startup.jl when I'm developing packages. I agree this is a better default for most people. | [IanButterworth]: I just had my first case of being bitten by this behavior, where I didn't get the latest version in a fresh env https://github.com/JuliaIO/JLD2.jl/issues/608#issuecomment-2419536272\n\nMight be reason not to make it the default.. I'm not sure | [fonsp]: I think this feature is amazing and it's a good default! It's already set as default for all Pluto users. We don't get much feedback about it, which is probably a good sign :)\n\n | [IanButterworth]: > It's already set as default for all Pluto users\n\n😬 | [MasonProtter]: I think the problem with `PRESERVE_TIERED_INSTALLED` is that you're unlikely to experience serious problems with it for the first N months you use it, but the longer you have it enabled the more likely you are to end up with a supremely weird, broken combination of packages.\n\nI'd be pretty cautious about making this the default behaviour, especially because we still don't have a satisfactory story around testing the lower limits of a package's compat bounds.",6,false,10,6,0,0,0,0,4,0,0
4125,"`add` should prefer versions of any already-loaded deps, if compatible",open,IanButterworth,,,,0,2024-12-31T15:02:48.0,2024-12-31T15:02:48.0,201,201,https://github.com/JuliaLang/Pkg.jl/issues/4125,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4125,,,0,false,1,1,0,0,0,0,0,0,0
4121,Tab-complete error with `pkg` mode,open,jakobjpeters,,REPL,,0,2024-12-20T00:18:42.0,2024-12-20T09:54:34.0,212,212,https://github.com/JuliaLang/Pkg.jl/issues/4121,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4121,"To reproduce, enter package mode and type `a;[TAB]`. Uncertain if it's related, but sometimes you can type `;` in package mode and it will stay in package mode, rather than switch to shell mode. In this case, entering `[TAB]` throws the same error as with `a;[TAB]`.\n\n```julia-repl\n~> julia --startup-file=no --banner=no\njulia> versioninfo()\nJulia Version 1.11.2\nCommit 5e9a32e7af2 (2024-12-01 20:02 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, tigerlake)\nThreads: 8 default, 0 interactive, 4 GC (on 8 virtual cores)\nEnvironment:\n  JULIA_NUM_THREADS = auto\n\n(@v1.11) pkg> a;┌ Error: Error in the keymap\n│   exception =\n│    MethodError: no method matching startswith(::String, ::Nothing)\n│    The function `startswith` exists, but no method is defined for this combination of argument types.\n│\n│    Closest candidates are:\n│      startswith(::AbstractString, ::Regex)\n│       @ Base regex.jl:324\n│      startswith(::Union{SubString{String}, String}, ::Union{SubString{String}, String})\n│       @ Base strings/util.jl:69\n│      startswith(::AbstractString, ::AbstractString)\n│       @ Base strings/util.jl:31\n│      ...\n│\n│    Stacktrace:\n│      [1] (::REPLExt.var""""#39#41"""")(possible::String)\n│        @ REPLExt ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:253\n│      [2] filter(f::REPLExt.var""""#39#41"""", a::Vector{String})\n│        @ Base ./array.jl:2876\n│      [3] #_completions#38\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:253\n│      [4] _completions\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:216 [inlined]\n│      [5] #completions#42\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:270\n│      [6] completions\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:258 [inlined]\n│      [7] #complete_line#46\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/REPLExt.jl:29\n│      [8] complete_line\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:188\n│      [9] #complete_line#14\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:428\n│     [10] complete_line\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:427\n│     [11] complete_line\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:369\n│     [12] edit_tab (repeats 2 times)\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:2419\n│     [13] JuliaLang/julia#118\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:2465\n│     [14] #invokelatest#2\n│        @ ./essentials.jl:1055 [inlined]\n│     [15] invokelatest\n│        @ ./essentials.jl:1052 [inlined]\n│     [16] JuliaLang/julia#30\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:1711\n│     [17] macro expansion\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:2861 [inlined]\n│     [18] macro expansion\n│        @ ./lock.jl:273 [inlined]\n│     [19] JuliaLang/julia#282\n│        @ ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:2851\n└ @ REPL.LineEdit ~/.julia/juliaup/julia-1.11.2+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/LineEdit.jl:2863\njulia>\njulia>\n```",,0,false,0,0,0,0,0,0,0,0,0
4120,Bundled compile cache modified if writeable,open,maleadt,,,,2,2024-12-20T08:38:02.0,2024-12-20T09:53:35.0,212,212,https://github.com/JuliaLang/Pkg.jl/issues/4120,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4120,"Working on a Docker container image, I noticed that layers were getting modified when they shouldn't (i.e., when doing simple read-only operations). I reduced it down to the following:\n\n```\n❯ docker run --rm -it julia:1.11 -e 'using Pkg; run(`ls -la /usr/local/julia/share/julia/compiled/v1.11/Pkg`)'\ntotal 184384\ndrwxr-xr-x 1 1000 1000      112 Dec  1 20:19 .\ndrwxr-xr-x 1 1000 1000     1002 Dec  1 20:19 ..\n-rw-r--r-- 1 1000 1000   577081 Dec 20 08:29 tUTdb_4x0TT.ji\n-rwxr-xr-x 1 1000 1000 90088808 Dec  1 20:19 tUTdb_4x0TT.so\n-rw-r--r-- 1 1000 1000   577081 Dec  1 20:19 tUTdb_OhzNv.ji\n-rwxr-xr-x 1 1000 1000 97561296 Dec  1 20:19 tUTdb_OhzNv.so\n```\n\nNotice how I'm simply importing Pkg here, which touches a `ji` file part of the *bundled* depot at `/usr/local/julia` (which is where Julia is installed, and is not the user depot which sits at `/root/.julia`). That seems very unexpected to me. Simply switching to another user that cannot write to these files prevents this from happening, without any error from Julia:\n\n```\n❯ docker run --rm -it --user 999 julia:1.11 -e 'using Pkg; run(`ls -la /usr/local/julia/share/julia/compiled/v1.11/Pkg`)'\ntotal 184384\ndrwxr-xr-x 1 1000 1000      112 Dec  1 20:19 .\ndrwxr-xr-x 1 1000 1000     1002 Dec  1 20:19 ..\n-rw-r--r-- 1 1000 1000   577081 Dec  1 20:19 tUTdb_4x0TT.ji\n-rwxr-xr-x 1 1000 1000 90088808 Dec  1 20:19 tUTdb_4x0TT.so\n-rw-r--r-- 1 1000 1000   577081 Dec  1 20:19 tUTdb_OhzNv.ji\n-rwxr-xr-x 1 1000 1000 97561296 Dec  1 20:19 tUTdb_OhzNv.so\n```\n\nRunning with `JULIA_DEBUG=loading` doesn't reveal anything:\n\n```patch\n❯ diff -u5 /tmp/good.log /tmp/bad.log\n--- /tmp/good.log\t2024-12-20 09:33:10.251674895 +0100\n+++ /tmp/bad.log\t2024-12-20 09:33:18.141641672 +0100\n@@ -41,9 +41,9 @@\n ┌ Debug: Loading object cache file /usr/local/julia/share/julia/compiled/v1.11/Pkg/tUTdb_4x0TT.so for Pkg [44cfe95a-1eb2-52ea-b672-e2afdf69b78f]\n └ @ Base loading.jl:1244\n total 184384\n drwxr-xr-x 1 1000 1000      112 Dec  1 20:19 .\n drwxr-xr-x 1 1000 1000     1002 Dec  1 20:19 ..\n--rw-r--r-- 1 1000 1000   577081 Dec  1 20:19 tUTdb_4x0TT.ji\n+-rw-r--r-- 1 1000 1000   577081 Dec 20 08:33 tUTdb_4x0TT.ji\n -rwxr-xr-x 1 1000 1000 90088808 Dec  1 20:19 tUTdb_4x0TT.so\n -rw-r--r-- 1 1000 1000   577081 Dec  1 20:19 tUTdb_OhzNv.ji\n -rwxr-xr-x 1 1000 1000 97561296 Dec  1 20:19 tUTdb_OhzNv.so\n```\n\nIt also happens with other stdlibs, e.g., `Test`:\n\n```\n❯ docker run --rm -it julia:1.11 -e 'using Test; run(`ls -la /usr/local/julia/share/julia/compiled/v1.11/Test`)'\ntotal 10432\ndrwxr-xr-x 1 1000 1000     112 Dec  1 20:19 .\ndrwxr-xr-x 1 1000 1000    1002 Dec  1 20:19 ..\n-rw-r--r-- 1 1000 1000   98538 Dec 20 08:36 JfdTE_4x0TT.ji\n-rwxr-xr-x 1 1000 1000 5141568 Dec  1 20:19 JfdTE_4x0TT.so\n-rw-r--r-- 1 1000 1000   98538 Dec  1 20:19 JfdTE_OhzNv.ji\n-rwxr-xr-x 1 1000 1000 5332784 Dec  1 20:19 JfdTE_OhzNv.so\n\n❯ docker run --rm -it julia:1.10 -e 'using Test; run(`ls -la /usr/local/julia/share/julia/compiled/v1.10/Test`)'\ntotal 8572\ndrwxr-xr-x 1 1000 1000     140 Nov 26 16:10 .\ndrwxr-xr-x 1 1000 1000     382 Nov 26 16:10 ..\n-rw-r--r-- 1 1000 1000 2607001 Nov 26 16:10 JfdTE_3ZKsT.ji\n-rw-r--r-- 1 1000 1000   94509 Nov 26 16:10 JfdTE_WHJbb.ji\n-rwxr-xr-x 1 1000 1000 2990040 Nov 26 16:10 JfdTE_WHJbb.so\n-rw-r--r-- 1 1000 1000   94509 Dec 20 08:36 JfdTE_WUnMZ.ji\n-rwxr-xr-x 1 1000 1000 2979544 Nov 26 16:10 JfdTE_WUnMZ.so\n```\n\nNote how the above also shows that this doesn't happen on 1.10.\n\nFinally, it's (at least for my use case) possible to work around this by forcing Julia to not have access to the bundled depot, by setting `JULIA_DEPOT_PATH` to something that doesn't include a trailing `:` (i.e., building on https://github.com/JuliaLang/julia/pull/51448)","[IanButterworth]: We `touch` .ji files when loading them, so that they are first when the next load takes place, so speed up loading. | [KristofferC]: Should exclude the stdlib folder for that.",2,false,0,0,0,0,0,0,0,0,0
4116,Significant GC collection time in Pkg.add (and other performance related things),open,KristofferC,,performance,,4,2024-12-17T11:01:20.0,2024-12-17T11:53:04.0,215,215,https://github.com/JuliaLang/Pkg.jl/issues/4116,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4116,"```\njulia> @time Pkg.add(""""Plots"""")\n   Resolving package versions...\n  No Changes to `~/.julia/environments/v1.11/Project.toml`\n  No Changes to `~/.julia/environments/v1.11/Manifest.toml`\n  0.785516 seconds (4.85 M allocations: 359.270 MiB, 24.80% gc time)\n\njulia> @time Pkg.add(""""Plots"""")\n   Resolving package versions...\n  No Changes to `~/.julia/environments/v1.11/Project.toml`\n  No Changes to `~/.julia/environments/v1.11/Manifest.toml`\n  0.767055 seconds (4.85 M allocations: 359.259 MiB, 23.82% gc time)\n```\n\n20%+ GC time. Should not be needed...\n\nTangentially, the no-op precompile check in the end of `Pkg.add` is a quite significant contributor to the timing above:\n\n```\njulia> ENV[""""JULIA_PKG_PRECOMPILE_AUTO""""] = 0\n0\n\njulia> @time Pkg.add(""""Plots"""")\n   Resolving package versions...\n  No Changes to `/tmp/jl_lIIjwR/Project.toml`\n  No Changes to `/tmp/jl_lIIjwR/Manifest.toml`\n  0.538715 seconds (4.05 M allocations: 271.299 MiB, 33.17% gc time)\n```\n\n","[vchuravy]: >  Should not be needed...\n\nTough to say, on the other hand the code allocates ~360MiB to do """"nothing""""  and someone needs to pay the cost of cleaning that up. I don't find it surprising that the code hits at least one GC pause. | [KristofferC]: > Tough to say, on the other hand the code allocates ~360MiB to do """"nothing""""\n\nYeah, the point is not to blame the GC but to say we shouldn't need to allocate so much temp stuff (5M allocations...). | [KristofferC]: I added a branch here https://github.com/JuliaLang/Pkg.jl/tree/kc/timeroutput to do some TimerOutputting:\n\n```\njulia> @time Pkg.add(""""Plots"""")\n   Resolving package versions...\nNo packages added to or removed from `/tmp/jl_2HO1zH/Project.toml`\nNo packages added to or removed from `/tmp/jl_2HO1zH/Manifest.toml`\n───────────────────────────────────────────────────────────────────────────────────────────────\n                                                      Time                    Allocations      \n                                             ───────────────────────   ────────────────────────\n              Tot / % measured:                   676ms /  99.5%            291MiB /  99.2%    \n\nSection                              ncalls     time    %tot     avg     alloc    %tot      avg\n───────────────────────────────────────────────────────────────────────────────────────────────\nadd                                       1    673ms  100.0%   673ms    289MiB  100.0%   289MiB\n  add                                     1    673ms  100.0%   673ms    289MiB  100.0%   289MiB\n    download_artifacts                    1    353ms   52.5%   353ms   75.8MiB   26.3%  75.8MiB\n    _resolve                              1    312ms   46.4%   312ms    206MiB   71.3%   206MiB\n      tiered_resolve                      1    312ms   46.4%   312ms    206MiB   71.3%   206MiB\n        targeted_resolve                  1    312ms   46.4%   312ms    206MiB   71.3%   206MiB\n          resolve_versions!               1    312ms   46.4%   312ms    206MiB   71.3%   206MiB\n            deps_graph                    1    160ms   23.8%   160ms    169MiB   58.7%   169MiB\n              Resolve.Graph               1    140ms   20.9%   140ms    136MiB   47.2%   136MiB\n            Resolve.simplify_graph        1    152ms   22.5%   152ms   36.0MiB   12.5%  36.0MiB\n            collect_fixed!                1   33.2μs    0.0%  33.2μs   13.6KiB    0.0%  13.6KiB\n            Resolve.resolve               1   18.7μs    0.0%  18.7μs   66.3KiB    0.0%  66.3KiB\n            collect_developed             1    546ns    0.0%   546ns   1.66KiB    0.0%  1.66KiB\n    download_source                       1    377μs    0.1%   377μs    222KiB    0.1%   222KiB\n    update_manifest!                      1    148μs    0.0%   148μs    250KiB    0.1%   250KiB\n    _auto_precompile                      1   1.64μs    0.0%  1.64μs     32.0B    0.0%    32.0B\n───────────────────────────────────────────────────────────────────────────────────────────────\n  0.676781 seconds (4.29 M allocations: 291.008 MiB, 32.78% gc time)\n```\n\n`download_artifacts` taking 353ms and 75MB to do nothing feels excessive.\n\nAlso the `Resolve.Graph` allocates 136 MB. | [KristofferC]: The `download_artifacts` is taken care of by https://github.com/JuliaLang/Pkg.jl/pull/4117.",4,false,0,0,0,0,0,0,0,0,0
4108,`package` shown in autocompletion list of pkg mode but not a recognized command,open,felixcremer,,,,3,2024-12-06T14:56:17.0,2024-12-06T15:42:39.0,226,225,https://github.com/JuliaLang/Pkg.jl/issues/4108,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4108,When I hit tab in the pkg mode of the REPL I thought that I would get a list of all available commands. \nThis list includes `package` but when I try to run it  I get this error:\n\n```julia\n(@v1.10) pkg> package\nERROR: `package` is not a recognized command. Type ? for help with available commands\n```\nand if I try to get the help for `package` I get the expanded help for all available commands.\n\nI find this confusing and would have expected that this entry is not in the autocompletion list. \n\n,"[fredrikekre]: The command just isn't complete, you have to keep tabbing to reach for example `package add`. | [IanButterworth]: I'd not heard of `package` before. It's not listed in `pkg>?` | [fredrikekre]: It is just an optional prefix to all the normal commands (similar to `registry`, but for `registry` it isn't optional of course).",3,false,0,0,0,0,0,0,0,0,0
4105,Pkg docs: `Pkg.resolve` differs from `pkg> resolve`,open,fonsp,,,,0,2024-12-04T12:08:23.0,2024-12-04T12:08:55.0,228,228,https://github.com/JuliaLang/Pkg.jl/issues/4105,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4105,"According to the [Pkg docs](https://pkgdocs.julialang.org/v1/api/#Pkg.resolve), `Pkg.resolve` will:\n\n> Update the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n\nAnd the [REPL-mode `resolve`](https://pkgdocs.julialang.org/v1/repl/#repl-resolve) will:\n\n> Resolve the project i.e. run package resolution and update the Manifest. This is useful in case the dependencies of developed packages have changed causing the current Manifest to be out of sync.\n\n---\n\nI believe that the `Pkg.resolve` docs are insufficient: they should also mention that this will run """"package resolution and update the Manifest"""", it's not just about path-tracking dependencies.\n\nPerhaps the two docs can be the same? I like the REPL-mode docs.",,0,false,0,0,0,0,0,0,0,0,0
4103,is_manifest_current doesn't detect changes to deved packages,open,amilsted,,,,0,2024-12-02T17:30:54.0,2024-12-02T17:30:54.0,229,229,https://github.com/JuliaLang/Pkg.jl/issues/4103,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4103,"I am looking for a way to detect if the Manifest for a project containing deved packages is up to date.\n\nIn particular, if someone adds a dependency or compat contraint to a deved packages, I would like to detect this without using `Pkg.resolve` to update the Manifest.\n\n`is_manifest_current` detects changes to the current project that might affect the Manifest, but does not detect changes to deved packages in the current project.\n\n```julia\nusing Pkg\nPkg.activate(""""./my_project"""")\n\nPkg.generate(""""my_deved_dep"""")\nPkg.develop(path=""""./my_deved_dep"""")\n\nPkg.activate(""""./my_deved_dep"""")\nPkg.add(""""Cowsay"""")\n\nPkg.activate(""""./my_project"""")\nPkg.is_manifest_current()  # returns true, but the Manifest is now incorrect\n```",,0,false,1,1,0,0,0,0,0,0,0
4069,Add automatically compat entry when adding a dependency to non-package projects,open,giordano,,enhancement; compat bounds,,3,2024-11-01T11:55:06.0,2024-11-29T12:43:33.0,261,233,https://github.com/JuliaLang/Pkg.jl/issues/4069,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4069,"#3732 enabled automatic addition of compat entries when adding a new dependency to a package project, but I believe we should do that for all environments, or at least the non shared ones.  Manifests are certainly useful when you have a fixed pipeline which is always running with a fixed version of Julia, but in other cases they're more annoying to carry around, as they are julia version-specific. Now we have versioned manifests which help in certain situations, but do absolutely nothing for instantiating a compatible project in one or two year time with a version of julia which didn't exist when one first created the environment.\n\nCertainly the risk of this proposal is for compat bounds to go stale over a long time, but I think that ensuring that instantiating an environment with (presumably) compatible packages at a later time outweighs the benefit of always having the super latest version of all packages which comes with the risk of breaking the workflow anyway.  Automatically adding compat bounds on all non-shared environments would help promote this practice.","[IanButterworth]: Seems reasonable to me. | [giordano]: How to distinguish a """"shared"""" environment from other non-named non-UUID'ed environments?  I was looking at implementing this, but I don't know how to do it. | [giordano]: Searching for [""""shared"""" in this repo](https://github.com/search?q=repo%3AJuliaLang%2FPkg.jl+shared+language%3AJulia+path%3A%2F%5Esrc%5C%2F%2F&type=code) I got the feeling that a """"shared"""" environment isn't a property of an environment, but merely a convenience concept?  Looking at https://github.com/JuliaLang/Pkg.jl/blob/83e13631e712384340ca5dff8c390f4dc6ad2479/ext/REPLExt/completions.jl#L4-L12 a shared depot should be identified by whether it lives in the `environments` subdirectory of a depot?",3,false,2,2,0,0,0,0,0,0,0
4087,No feedback when upgrading a package fails,open,GHTaarn,,,,3,2024-11-17T05:12:11.0,2024-11-28T15:54:12.0,245,233,https://github.com/JuliaLang/Pkg.jl/issues/4087,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4087,"Upgrading the `Revise` package from 3.5.15 to the newest version with `pkg""""up Revise""""` does not have the desired effect, the package stays at version 3.5.15:\n\n```julia-repl\nInstalling Julia 1.11.1+0.x64.linux.gnu\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.1 (2024-10-16)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(@v1.11) pkg> add Revise@3.5.15\n  Installing known registries into `~/.julia`\n       Added `General` registry to ~/.julia/registries\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n   Installed OrderedCollections ─ v1.6.3\n   Installed CodeTracking ─────── v1.3.6\n   Installed JuliaInterpreter ─── v0.9.37\n   Installed Requires ─────────── v1.3.0\n   Installed LoweredCodeUtils ─── v2.4.8\n   Installed Revise ───────────── v3.5.15\n    Updating `~/.julia/environments/v1.11/Project.toml`\n⌃ [295af30f] + Revise v3.5.15\n    Updating `~/.julia/environments/v1.11/Manifest.toml`\n  [da1fd8a2] + CodeTracking v1.3.6\n  [aa1ae85d] + JuliaInterpreter v0.9.37\n⌅ [6f1432cf] + LoweredCodeUtils v2.4.8\n  [bac558e1] + OrderedCollections v1.6.3\n  [ae029012] + Requires v1.3.0\n⌃ [295af30f] + Revise v3.5.15\n  [0dad84c5] + ArgTools v1.1.2\n  [56f22d72] + Artifacts v1.11.0\n  [2a0f44e3] + Base64 v1.11.0\n  [ade2ca70] + Dates v1.11.0\n  [8ba89e20] + Distributed v1.11.0\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching v1.11.0\n  [b77e0a4c] + InteractiveUtils v1.11.0\n  [b27032c2] + LibCURL v0.6.4\n  [76f85450] + LibGit2 v1.11.0\n  [8f399da3] + Libdl v1.11.0\n  [56ddb016] + Logging v1.11.0\n  [d6f4376e] + Markdown v1.11.0\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.11.0\n  [de0858da] + Printf v1.11.0\n  [3fa0cd96] + REPL v1.11.0\n  [9a3f8284] + Random v1.11.0\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization v1.11.0\n  [6462fe0b] + Sockets v1.11.0\n  [f489334b] + StyledStrings v1.11.0\n  [fa267f1f] + TOML v1.0.3\n  [a4e569a6] + Tar v1.10.0\n  [cf7118a7] + UUIDs v1.11.0\n  [4ec0a83e] + Unicode v1.11.0\n  [deac9b47] + LibCURL_jll v8.6.0+0\n  [e37daf67] + LibGit2_jll v1.7.2+0\n  [29816b5a] + LibSSH2_jll v1.11.0+1\n  [c8ffd9c3] + MbedTLS_jll v2.28.6+0\n  [14a3606d] + MozillaCACerts_jll v2023.12.12\n  [83775a58] + Zlib_jll v1.2.13+1\n  [8e850ede] + nghttp2_jll v1.59.0+0\n  [3f19e933] + p7zip_jll v17.4.0+2\n        Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`\nPrecompiling project...\n  6 dependencies successfully precompiled in 15 seconds. 29 already precompiled.\n  1 dependency had output during precompilation:\n┌ LoweredCodeUtils\n│  ┌ Warning: skipping callee #f#38 (called by f) due to UndefVarError(:f, LoweredCodeUtils)\n│  └ @ LoweredCodeUtils ~/.julia/packages/LoweredCodeUtils/608oq/src/signatures.jl:316\n└  \n\n(@v1.11) pkg> st\nStatus `~/.julia/environments/v1.11/Project.toml`\n⌃ [295af30f] Revise v3.5.15\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.11) pkg> up Revise\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `~/.julia/environments/v1.11/Project.toml`\n  No Changes to `~/.julia/environments/v1.11/Manifest.toml`\n        Info We haven't cleaned this depot up for a bit, running Pkg.gc()...\n      Active manifest files: 1 found\n      Active artifact files: 0 found\n      Active scratchspaces: 0 found\n     Deleted no artifacts, repos, packages or scratchspaces\n\n(@v1.11) pkg> st\nStatus `~/.julia/environments/v1.11/Project.toml`\n⌃ [295af30f] Revise v3.5.15\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.11) pkg> \n\n```\n\nFortunately in my case, I can just use `pkg""""upgrade""""` which does upgrade `Revise` to the latest version.\n","[serenity4]: I can reproduce, the following successfully updates Revise:\n```\npkg> up --preserve=none Revise\npkg> up --preserve=direct Revise\n```\nbut the following fails to do so:\n```\npkg> up --preserve=all Revise\npkg> up Revise\n```\n\nI believe `preserve=all` is the default when a package is specified (so it updates only the selected package). And, to update Revise to the next version we also need to update LoweredCodeUtils, which I am guessing Pkg does not attempt due to the preserve mode. | [serenity4]: The behavior of preserve modes is described in https://pkgdocs.julialang.org/v1/managing-packages/#updating and illustrated in https://github.com/JuliaLang/Pkg.jl/pull/3001. I wonder why `--preserve=direct` was not made the default though 🤔\n\nOr at least, when upgrading a package specifically (via `up SomePkg`), IMO it should try to update to the required version (latest if unspecified) without upgrading anything else. If it fails (e.g. due to compat bounds on indirect packages), it should try a slightly stricter version of `--preserve=direct` to only allow upgrades for dependencies that otherwise prevent `SomePkg` from upgrading due to compatibility requirements.\n\nEDIT: the same issue/solution was briefly mentioned in #4009 | [GHTaarn]: Thank you for your comment, now I know what to do in future. I agree with you that I was expecting a behaviour similar to your suggestion or to `--preserve=direct`. An alternative could also be to just write a message similar to """"`Revise` was not upgraded because this would require upgrading some packages that you did not specify. Please consider using the `--preserve` flag or resolving the dependencies explicitly""""",3,false,0,0,0,0,0,0,0,0,0
4098,Package completions should deduplicate suggestions,open,IanButterworth,,feature request,,0,2024-11-27T17:08:31.0,2024-11-27T17:08:31.0,234,234,https://github.com/JuliaLang/Pkg.jl/issues/4098,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4098,i.e. this should suggest SnoopCompileCore here\n![Image](https://github.com/user-attachments/assets/807c0ab0-0a77-4dba-bafa-df8438ac6bc0)\n,,0,false,0,0,0,0,0,0,0,0,0
4009,Preserve option for `up`,open,jariji,,,,1,2024-08-29T20:29:25.0,2024-11-26T12:12:30.0,324,236,https://github.com/JuliaLang/Pkg.jl/issues/4009,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4009,When I do `up Foo@1.2.3` it sometimes doesn't do anything because it's preserving something else. I would like instead if it preserved as much as possible while still doing the upgrade I asked for. Would that be possible?,"[serenity4]: You can do `up --preserve=direct Foo@1.2.3` manually, but that means you may also change versions of dependencies that didn't need to be changed, and the update is no longer minimal.\n\nPreserving everything else by default causes some confusion, as e.g. reported in #4087.",1,false,0,0,0,0,0,0,0,0,0
4097,compat errors should clearly state where each constraint comes from,open,aplavin,,,,0,2024-11-25T21:18:49.0,2024-11-25T21:18:49.0,236,236,https://github.com/JuliaLang/Pkg.jl/issues/4097,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4097,"Whenever one gets a message like this\n\n> empty intersection between SomePackage@1.2.3 and project compatibility 2.3.4-2\n\nit's clear where the latter constraint comes from (""""project compatibility"""", presumably `[compat]` in Project.toml). But what about the first one? One can only guess with experience that it refers to Manifest.toml, but would be much clearer to explicitly state that.\n\nThere are other compat errors that could use this improvement as well, I'll try to keep this thread updated whenever I encounter one.",,0,false,0,0,0,0,0,0,0,0,0
4095,(1.10) `] precompile` does not understand extension triggers in `[deps]`,open,topolarity,,,1.10,0,2024-11-24T21:37:49.0,2024-11-24T21:38:10.0,237,237,https://github.com/JuliaLang/Pkg.jl/issues/4095,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4095,"> You also hit that error if you only add a symmetric extension `Parent → DepWithParentExtExt`:\n> ```diff\n> diff --git a/test/project/Extensions/Parent.jl/Project.toml b/test/project/Extensions/Parent.jl/Project.toml\n> index a79ec8859b..9119864a47 100644\n> --- a/test/project/Extensions/Parent.jl/Project.toml\n> +++ b/test/project/Extensions/Parent.jl/Project.toml\n> @@ -4,3 +4,6 @@ version = """"0.1.0""""\n> \n>  [deps]\n>  DepWithParentExt = """"8a35c396-5ffc-40d2-b7ec-e8ed2248da32""""\n> +\n> +[extensions]\n> +DepWithParentExtExt = """"DepWithParentExt""""\n> diff --git a/test/project/Extensions/Parent.jl/ext/DepWithParentExtExt.jl b/test/project/Extensions/Parent.jl/ext/DepWithParentExtExt.jl\n> new file mode 100644\n> index 0000000000..c9232efcbd\n> --- /dev/null\n> +++ b/test/project/Extensions/Parent.jl/ext/DepWithParentExtExt.jl\n> @@ -0,0 +1,6 @@\n> +module DepWithParentExtExt\n> +\n> +using DepWithParentExt\n> +using Parent\n> +\n> +end\n> ```\n> \n> That diff introduces an extension """"cycle"""" of the kind that doesn't exist on 1.11, but is a cycle on 1.10.\n> \n> We don't even get to print our warning though:\n> ```julia\n> ./julia --project=test/project/Extensions/tempenv -q\n> (tempenv) pkg> dev ./test/project/Extensions/DepWithParentExt.jl/ ./test/project/Extensions/Parent.jl/\n>    Resolving package versions...\n>     Updating `~/repos/julia/test/project/Extensions/tempenv/Project.toml`\n>   [8a35c396] + DepWithParentExt v0.1.0 `../DepWithParentExt.jl`\n>   [58cecb9c] + Parent v0.1.0 `../Parent.jl`\n>     Updating `~/repos/julia/test/project/Extensions/tempenv/Manifest.toml`\n>   [8a35c396] + DepWithParentExt v0.1.0 `../DepWithParentExt.jl`\n>   [58cecb9c] + Parent v0.1.0 `../Parent.jl`\n> \n> (tempenv) pkg> precompile\n> ERROR: KeyError: key """"DepWithParentExt"""" not found\n> Stacktrace:\n>   [1] getindex\n>     @ ./dict.jl:498 [inlined]\n>   [2] precompile(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; internal_call::Bool, strict::Bool, warn_loaded::Bool, already_instantiated::Bool, timing::Bool, _from_loading::Bool, kwargs::@Kwargs{io::Base.TTY})\n>     @ Pkg.API ~/repos/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1168\n>   [3] precompile(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::@Kwargs{})\n>     @ Pkg.API ~/repos/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:159\n>   [4] precompile(pkgs::Vector{Pkg.Types.PackageSpec})\n>     @ Pkg.API ~/repos/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:148\n>   [5] precompile(pkgs::Vector{String})\n>     @ Pkg.API ~/repos/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:147\n> ``` \n\n _Originally posted by @topolarity in [#56675](https://github.com/JuliaLang/julia/issues/56675#issuecomment-2496238280)_\n\nPkg is trying to look-up extension triggers in just `[weakdeps]` instead of both `[deps]` and `[weakdeps]`. This is not an issue on 1.11+, since the new `ExplicitEnv` code properly does the look-up properly\n\nThis is an important fix to get into 1.10, since our fix for https://github.com/JuliaLang/julia/issues/56204 can sometimes force you to add triggers on `[deps]` instead of just `[weakdeps]`",,0,false,0,0,0,0,0,0,0,0,0
4073,Can't `dev` package with url in [sources],open,fredrikekre,,,,1,2024-11-04T14:33:18.0,2024-11-21T21:23:38.0,258,240,https://github.com/JuliaLang/Pkg.jl/issues/4073,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4073,"Here `Foo` is a package with a url set under `[sources]`:\n\n```\njulia> Pkg.develop(path = """"../Foo/"""")\nERROR: `path` and `url` are conflicting specifications\nStacktrace:\n [1] pkgerror(msg::String)\n   @ Pkg.Types ~/.julia/juliaup/julia-1.11.1+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/src/Types.jl:68\n [2] get_path_repo\n   @ ~/.julia/juliaup/julia-1.11.1+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/src/project.jl:17 [inlined]\n [3] update_source_if_set(project::Pkg.Types.Project, pkg::Pkg.Types.PackageSpec)\n   @ Pkg.API ~/.julia/juliaup/julia-1.11.1+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/src/API.jl:198\n```","[clarkevans]: This is important to me as well. Currently, we use `Pkg.develop(url=""""git@github.com:TuftsCTSI/TRDW.jl.git"""")` for our development setup, where we also added `TRDW = {url = """"https://github.com/TuftsCTSI/TRDW.jl"""", rev = """"main""""}` to Project.toml -- is this correct? \n\nPerhaps what would be ideal is `Pkg.develop(""""TRDW"""")` and it'd use the Project.toml sources section to know where to find it.\n\nIs there a workaround for this?",1,false,2,2,0,0,0,0,0,0,0
4089,Allow simultaneous `path` and `url` under `[sources]` with `path`-priority,open,thchr,,,,0,2024-11-18T13:30:17.0,2024-11-18T13:31:10.0,244,244,https://github.com/JuliaLang/Pkg.jl/issues/4089,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4089,"I have a situation where I'd like to use the `[sources]` entry of Project.toml, to indicate that a package, X, should first be looked for at some `path` - and, if not present there, be looked for at some `url`. I had hoped this might be possible to do by something like\n```toml\n[sources]\nX = {path="""".."""", url=""""https://github.com/user/X.jl""""}\n```\nbut that's not possible currently, by design, cf. https://github.com/JuliaLang/Pkg.jl/blob/69c6de01909d53b0a4514b11715f829fe0569d98/src/project.jl#L104-L106\n\nI think it would be nice to be able to do this though: it would allow one to develop multiple interdependent private packages locally, preferring local versions specified in `path` if the exist, and then distribute them to collaborators, who might not have a local versions (then pulling from `url`).\n\nBasically, I think it would be natural to let `path` take precedence if both `path` and `url` are present and a directory with a project exists at `path`.",,0,false,1,0,0,0,0,0,1,0,0
4085,`add` vs `dev` for local path,open,fonsp,,,,2,2024-11-15T14:35:19.0,2024-11-15T15:03:01.0,247,247,https://github.com/JuliaLang/Pkg.jl/issues/4085,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4085,"Hello!\n\nWhen adding a package from a local path, you can either `add` or `dev` the package. They seem to have similar effect, but `dev` is able to pick up changes to the package made later. Would it not make more sense to always `dev` when the source is a local path? i.e. that the command `add ~/Hello.jl` would act like `dev ~/Hello.jl`.\n\n\n\nRelated: I was looking into `[sources]`. When instantiating a Project.toml with a path specified in `[sources]`, the package will currently get `dev`ed, not `add`ed. Is this intentional? (I like it!)\n\nThanks!","[KristofferC]: `add URL` works the same as `add path` in that it will give you a reproducible state (a git-tree-sha1 entry in the manifest). \n\nMy idea with keeping this separate is that if you only use `add` you always have a reproducible manifest (as long as you have access to the repos) while with `dev` you are tracking something mutable. But I have thought about if `add path` should have worked like `dev` as well many times...\n\n\n> When instantiating a Project.toml with a path specified in [sources], the package will currently get deved, not added. Is this intentional? (I like it!)\n\nYes, do get the `add path` behavior you would (slightly awkwardly) use a `url = ` entry to the local path. | [fonsp]: Aha, thanks for clarifying!\n\n> if you only use `add` you you always have a reproducible manifest\n\nReproducible as in, you could reconstruct it by hand, right? By cloning the repos and searching for the right commit?",2,false,0,0,0,0,0,0,0,0,0
4060,set compat version for specific package for whole environment,open,SimeonEhrig,,,,1,2024-10-28T15:42:42.0,2024-11-13T12:48:40.0,264,249,https://github.com/JuliaLang/Pkg.jl/issues/4060,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4060,"I have the following problem. I develop package A, which changes it's version from `1.0.0` to `2.0.0` because a breaking changes. Now I want to test package A with package B. Package B has as dependency to package A and the compat requires package `A==1.0.0`. If I add package B, I get the following error:\n\n`ERROR: Unsatisfiable requirements detected for package B [...]`\n\nA the moment, the solution is to clone the repository of package B, modify the compat section int the `Project.toml` and add package B as development package. Is there a easy or common solution of my problem?\n\nAlso this is only the minimum use case of my problem. For example, we have also a package C, which has package B as dependency and therefore package A is a implicit dependency. Or we have week circular dependencies, because Package A uses Package B in test extra section.\n\nTherefore it would pretty helpful to tell the dependency resolver, that it should use version 2.0.0 of package A, if it finds as dependency of any package, which should be added to the environment.",[aplavin]: Very useful indeed! There even were attempts to add this functionality to Pkg before:\nhttps://github.com/JuliaLang/Pkg.jl/pull/2285\nhttps://github.com/JuliaLang/Pkg.jl/pull/1607,1,false,3,2,0,0,0,0,0,0,1
4082,`Pkg.dependencies()` triggers `write_env_usage`,open,fonsp,,,,0,2024-11-13T11:21:20.0,2024-11-13T11:21:20.0,249,249,https://github.com/JuliaLang/Pkg.jl/issues/4082,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4082,"While debugging performance issues in https://github.com/JuliaPluto/PlutoSliderServer.jl we found that the `Pkg.dependencies()` call is quite heavy and was causing IO performance issues. Some profiling showed that `write_env_usage` was the cause.\n\nI understand that more information on the `write_env_usage` performance problem would be really useful, but in the meantime I just wanted to ask:\n\nIs it intentional that the call `Pkg.dependencies()` gets recorded in `manifest_usage.toml`? I feel like `Pkg.dependencies()` should not have any side effects. I also don't think it is necessary to record this as """"manifest usage"""", since `Pkg.dependencies()` is mainly used by scripts and doesn't necessarily signal """"usage"""" by a person.\n\nThanks!",,0,false,0,0,0,0,0,0,0,0,0
2640,API to activate first parent dir with Project.toml,open,fonsp,,,,14,2021-06-22T13:00:15.0,2024-11-13T09:32:00.0,1489,249,https://github.com/JuliaLang/Pkg.jl/issues/2640,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2640,"When launching `julia` with argument `--project`, then it will _""""search through parent directories until a Project.toml or JuliaProject.toml file is found.""""_ ([docs](https://docs.julialang.org/en/v1/manual/command-line-options/)). This is really useful for projects with scripts and notebooks in nested folders. (e.g. `<project-root>/notebooks/analysis/hello.jl`)\n\nIt would be great if this automatic Project search was available as a **function** in Pkg, to be called at the top of a script/notebook. This would be useful in environments where setting the `project` flag is impractical (Pluto.jl, Jupyter, VS Code). It also helps to simplify the reproducibility steps: you can just run the script.\n\nCurrently, you need to manually count towards the root directory of your project:\n\n```julia\nimport Pkg\nPkg.activate(joinpath(@__DIR__, """".."""", """"..""""))\n\n# but I wish I could do:\nPkg.activate(; search_parents=true)\n```\n\nI would be happy to make this PR myself if there is interest?","[Datseris]: To give some more context, the proposed functionality is already implemented in DrWatson, as a function `quickactivate` and a macro `@quickactivate`. https://juliadynamics.github.io/DrWatson.jl/dev/project/#Activating-a-Project-1  \n\nYou start a script with the lines:\n```julia\nusing DrWatson\n@quickactivate """"ProjectName"""" \n```\nand Julia starts scanning the folder that contains your script until it finds a project, and activates that project. The argument `""""ProjectName""""` only checks that the activated project matches the given name, and gives an error if not.\n\nThe Macro is the most useful version, and our users are extremely happy with it. It allows for reproducible scientific projects, allows finding your """"correct"""" project automatically by running your script (no manual labor!), and it allows for easily switching projects within the same Julia session.\n\nThe only problem it has is that it requires `DrWatson` to be loaded. This means that `DrWatson` needs to be available on the global environment to use `@quickactivate`. That's a problem because even if the Project.toml of your scientific project contains `DrWatson`, this doesn't really guarantee that the global environment of the person you've sent it to will also have it. \n\nThis as a result also leads to some difficulties in Pluto.jl notebooks, cf https://github.com/JuliaDynamics/DrWatson.jl/issues/261 . Given that this functionality seems generally useful, we think it is a good idea to have it in Pkg.jl directly. | [fredrikekre]: You can use `Pkg.activate(Base.current_project())` | [Datseris]: Yes (and actually the source of this function was the starting point for `quickactivate`). But if we really care about reproducibility, then `Base.current_project()` would have to be documented (currently it has no docstring) and be formally made part of the public API. If not, it could """"potentially"""" change or be removed at any point between even patch releases (according to SemVer stuff). \n\nDoes this sound like something possible for you? If yes, then this issue practically resolves to a documentation PR. | [aplavin]: > This would be useful in environments where setting the project flag is impractical (Pluto.jl, Jupyter, VS Code).\n\nHow is it relevant to Jupyter and VS Code? Jupyter (IJulia) already activates the closest parent env:\n\n> The default Jupyter kernel that is installed by IJulia starts with the Julia command line flag --project=@.. A Project.toml (or JuliaProject.toml) in the folder of a notebook (or in a parent folder of this notebook) will therefore automatically become the active project for that notebook.\n\nVS Code suggests to choose which of the parent envs to activate when opening a project for the first time, and activates it automatically afterwards. | [fonsp]: Hello! Maybe we could decide whether to add this API or close this issue? The suggested API is:\n\n```julia\nPkg.activate(search_parents=true)\n```\n\nTo have behaviour identical to `julia --project`: *""""search through parent directories until a Project.toml file is found.""""*\n\nThere is currently no public API to do this (`Pkg.activate(Base.current_project())` is private), and using a package for this is tricky for reproducibility because you need it before `Pkg.activate`. | [Datseris]: +1. Unfortunately, making this the default would be a breaking change :( | [Datseris]: Actually, it may be breaking no matter what, because currently if one calls `Pkg.activate` without input arguments then it says:\n\n> If no argument is given to activate, then use the first project found in LOAD_PATH | [Datseris]: Additionally, `Pkg.activate(search_parents=true)` would somehow need to know that it should search the parents of the directory it was called in.\n\nDoesn't just porting `@quickactivate` to Pkg satisfy all our needs? Would this be an option for the Pkg developers? | [fredrikekre]: Perhaps `Pkg.activate(""""@."""")` since that is already used for this in `JULIA_PROJECT`? | [Datseris]: Seems to me like a simple enough solution! EDIT: Sorry, I don't understand how this command would understand _where_ it is called from if it is not a macro. The main point is that if the command is in a script it would search the folder the script is in. Hence the usage of `@__DIR__` in the original post. | [KristofferC]: I don't really like magical strings like that in normal julia functions. Fine for the REPL mode. | [fonsp]: @Datseris I think searching relative to `pwd()` makes sense, just like `Pkg.activate("""".."""")` is relative to `pwd()`, not to its call location. | [Datseris]: > [@Datseris](https://github.com/Datseris) I think searching relative to `pwd()` makes sense, just like `Pkg.activate("""".."""")` is relative to `pwd()`, not to its call location.\n\nI disagree; I would argue what makes most sense is the lines that contains the statement, i.e., `@__DIR__`. In most scenarios where you care about managing dedicated Project.toml per project (such as in a scientific context), your scripts are in a folder that also contains your project in a parent directory. Whether this folder coincides with `pwd()` is secondary. I think it's fair to say that it is much more common that your script is in your project directory than it is that your `pwd()` matches the project you want to activate. \n\nAs an example, I have 8 projects in my VSCode """"workspace"""" and when VSCode opens it sets my `pwd()` to the first project. 7/8 times that's not the directory I would like to have for searching where my project file is. | [Datseris]: I've suggested porting `@quickactivate` here before and faced decline in other issues/discussions. Can someone **clearly, and objectively**, tell me why porting the `@quickactivate` macro here isn't the solution to the issues raised so far? """"I don't like it"""" is not an objective argument.",14,false,4,4,0,0,0,0,0,0,0
4079,Improve Pkg's own precompilation to make `Pkg.instantiate()` in a script faster.,open,NHDaly,,,,3,2024-11-07T21:28:01.0,2024-11-12T09:34:24.0,254,250,https://github.com/JuliaLang/Pkg.jl/issues/4079,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4079,"We want to run a script locally, and we want to include an `instantiate()` step to make sure that the user has everything installed. The instantiate should be a noop most of the time, once things are installed. However, it takes almost 1 second the first time, vs a quarter of a second after that.\n\nCan we better precompile Pkg.instantiate so this doesn't have any compile time?:\n```julia\njulia> @time @eval import Pkg\n  0.000365 seconds (356 allocations: 35.180 KiB)\n\njulia> @time @eval Pkg.instantiate()\n  0.914451 seconds (3.33 M allocations: 267.919 MiB, 9.12% gc time, 41.20% compilation time)\n\njulia> @time @eval Pkg.instantiate()\n  0.265228 seconds (551.15 k allocations: 50.819 MiB, 1.63% gc time)\n\njulia> @time @eval Pkg.instantiate()\n  0.244608 seconds (551.15 k allocations: 50.817 MiB, 1.28% gc time)\n```","[KristofferC]: This is the trace output from running Pkg.instantiate (sorted by time):\n\n```\n❯ sort -g trace.jl        \n#=    2.0 ms =# precompile(Tuple{Base.BottomRF{typeof(Base.:(+))}, Base._InitialValue, Int64}) # recompile\n#=    2.0 ms =# precompile(Tuple{Type{Memory{String}}, UndefInitializer, Int64}) # recompile\n#=    2.0 ms =# precompile(Tuple{Type{Pair{A, B} where B where A}, String, Dates.DateTime})\n#=    2.0 ms =# precompile(Tuple{typeof(Base.Iterators.enumerate), Array{String, 1}}) # recompile\n#=    2.0 ms =# precompile(Tuple{typeof(Base.string), Module}) # recompile\n#=    2.1 ms =# precompile(Tuple{typeof(Base.write), Base.TTY, Array{UInt8, 1}}) # recompile\n#=    2.1 ms =# precompile(Tuple{typeof(TOML.Internals.Printer.is_array_of_tables), Array{Base.Dict{String, Dates.DateTime}, 1}})\n#=    2.2 ms =# precompile(Tuple{typeof(Base.get), Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, Symbol, Nothing}) # recompile\n#=    2.3 ms =# precompile(Tuple{typeof(Base.isopen), Base.GenericIOBuffer{Memory{UInt8}}})\n#=    2.4 ms =# precompile(Tuple{typeof(Base.join), Base.GenericIOBuffer{Memory{UInt8}}, Tuple{UInt32}, Char})\n#=    2.5 ms =# precompile(Tuple{typeof(Base.deepcopy_internal), Tuple{String}, Base.IdDict{Any, Any}})\n#=    2.6 ms =# precompile(Tuple{typeof(Base.map), Function, Array{Base.Dict{String, Dates.DateTime}, 1}})\n#=    2.6 ms =# precompile(Tuple{typeof(Base.setindex!), Array{String, 1}, String, Int64}) # recompile\n#=    2.7 ms =# precompile(Tuple{typeof(Base.Filesystem.contractuser), String}) # recompile\n#=    2.8 ms =# precompile(Tuple{Base.var""""##invokelatest#1"""", Base.Pairs{Symbol, Any, NTuple{4, Symbol}, NamedTuple{(:indent, :sorted, :by, :inline_tables), Tuple{Int64, Bool, typeof(Base.identity), Base.IdSet{Base.Dict{String, V} where V}}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}}) # recompile\n#=    2.8 ms =# precompile(Tuple{typeof(Base._prechecked_iterate), Base.OneTo{Int64}, Int64}) # recompile\n#=    2.8 ms =# precompile(Tuple{typeof(Base.similar), Array{Any, 1}}) # recompile\n#=    2.9 ms =# precompile(Tuple{typeof(Base.map), Function, Array{Any, 1}})\n#=    3.1 ms =# precompile(Tuple{typeof(Base.similar), Array{String, 1}}) # recompile\n#=    3.2 ms =# precompile(Tuple{Type{Array{Dates.DateTime, 1}}, UndefInitializer, Tuple{Int64}})\n#=    3.3 ms =# precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:indent, :sorted, :by, :inline_tables), Tuple{Int64, Bool, typeof(Base.identity), Base.IdSet{Base.Dict{String, V} where V}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})\n#=    3.3 ms =# precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:indent, :sorted, :by, :inline_tables), Tuple{Int64, Bool, typeof(Base.identity), Base.IdSet{Base.Dict{String, V} where V}}}, typeof(TOML.Internals.Printer.print_table), Nothing, Base.IOStream, Base.Dict{String, Dates.DateTime}, Array{String, 1}})\n#=    3.4 ms =# precompile(Tuple{typeof(Base.empty), Base.Dict{Any, Any}, Type{String}, Type{Base.UUID}})\n#=    3.6 ms =# precompile(Tuple{Base.var""""#691#692""""{Base.Process}})\n#=    3.6 ms =# precompile(Tuple{typeof(Base.uv_shutdowncb_task), Ptr{Nothing}, Int32}) # recompile\n#=    4.9 ms =# precompile(Tuple{Type{Base.IOContext{IO_t} where IO_t<:IO}, Base.GenericIOBuffer{Memory{UInt8}}, Base.TTY}) # recompile\n#=    9.7 ms =# precompile(Tuple{typeof(Base.CoreLogging.shouldlog), Base.CoreLogging.ConsoleLogger, Base.CoreLogging.LogLevel, Module, Symbol, Symbol})\n#=   13.3 ms =# precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:internal_call, :strict, :warn_loaded, :timing, :_from_loading, :configs, :manifest, :io), Tuple{Bool, Bool, Bool, Bool, Bool, Pair{Base.Cmd, Base.CacheFlags}, Bool, Base.TTY}}, typeof(Base.Precompilation.precompilepkgs), Array{String, 1}})\n#=   13.8 ms =# precompile(Tuple{typeof(Base.deepcopy_internal), Array{String, 1}, Base.IdDict{Any, Any}})\n#=   15.3 ms =# precompile(Tuple{typeof(Base.maximum), Array{Dates.DateTime, 1}})\n#=   15.9 ms =# precompile(Tuple{typeof(Base.convert), Type{Base.Dict{String, Union{Array{String, 1}, String}}}, Base.Dict{String, Any}})\n#=   15.9 ms =# precompile(Tuple{typeof(Base.deepcopy_internal), Base.Dict{String, Base.UUID}, Base.IdDict{Any, Any}})\n#=   16.2 ms =# precompile(Tuple{typeof(Base.deepcopy_internal), Base.Dict{String, Array{String, 1}}, Base.IdDict{Any, Any}})\n#=   19.0 ms =# precompile(Tuple{typeof(Base.readbytes!), Base.PipeEndpoint, Array{UInt8, 1}, Int64})\n#=   22.0 ms =# precompile(Tuple{typeof(Base.CoreLogging.default_metafmt), Base.CoreLogging.LogLevel, Vararg{Any, 5}})\n#=   22.1 ms =# precompile(Tuple{typeof(Base.deepcopy_internal), Base.Dict{String, Union{Array{String, 1}, String}}, Base.IdDict{Any, Any}})\n#=   25.5 ms =# precompile(Tuple{typeof(Base.closewrite), Base.PipeEndpoint})\n#=   32.5 ms =# precompile(Tuple{typeof(Base.deepcopy_internal), Base.Dict{String, Base.Dict{String, String}}, Base.IdDict{Any, Any}})\n#=   33.8 ms =# precompile(Tuple{typeof(Base.unsafe_read), Base.PipeEndpoint, Ptr{UInt8}, UInt64})\n#=   46.8 ms =# precompile(Tuple{Base.Compiler.var""""#get_infer_result#typeinf_edge##0""""{Method, Bool, Bool, Base.Compiler.InferenceResult, Base.Compiler.Future{Base.Compiler.MethodCallResult}}, Base.Compiler.NativeInterpreter, Base.Compiler.IRInterpretationState})\n#=   59.8 ms =# precompile(Tuple{Base.Precompilation.var""""#_precompilepkgs##31#_precompilepkgs##32""""{Bool, Array{Pair{Base.Cmd, Base.CacheFlags}, 1}, Bool, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, String}, Base.Set{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}}, String, String, String, String, Base.Precompilation.var""""#ansi_moveup#_precompilepkgs##19"""", Base.Event, Base.Event, Base.ReentrantLock, Array{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, 1}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, String}, Array{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, 1}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, Bool}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, Bool}, Array{Base.PkgId, 1}, Base.Precompilation.var""""#describe_pkg#_precompilepkgs##1""""{Base.Dict{Base.PkgId, String}, Base.Precompilation.var""""#color_string#_precompilepkgs##0""""{Bool}, Int64}, Base.Dict{Base.PkgId, Array{Base.PkgId, 1}}, Base.Precompilation.var""""#color_string#_precompilepkgs##0""""{Bool}}}) # recompile\n#=  128.3 ms =# precompile(Tuple{Base.Precompilation.var""""#_precompilepkgs##45#_precompilepkgs##46""""{Bool, Bool, Array{Task, 1}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, String}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, Base.GenericIOBuffer{Memory{UInt8}}}, Base.Event, Base.Event, Base.ReentrantLock, Array{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, 1}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, String}, Array{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, 1}, Array{Base.PkgId, 1}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, Bool}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, Base.Event}, Base.Dict{Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}, Bool}, Array{Base.PkgId, 1}, Base.Precompilation.var""""#describe_pkg#_precompilepkgs##1""""{Base.Dict{Base.PkgId, String}, Base.Precompilation.var""""#color_string#_precompilepkgs##0""""{Bool}, Int64}, Base.Dict{Base.PkgId, Array{Base.PkgId, 1}}, Base.Dict{Base.PkgId, String}, Base.Dict{Base.PkgId, Array{String, 1}}, Base.Dict{Tuple{Base.PkgId, UInt128, String, String}, Bool}, Base.Precompilation.var""""#color_string#_precompilepkgs##0""""{Bool}, Bool, Base.Semaphore, Bool, String, Array{String, 1}, Array{Base.PkgId, 1}, Base.PkgId, Base.CacheFlags, Base.Cmd, Pair{Base.Cmd, Base.CacheFlags}, Tuple{Base.PkgId, Pair{Base.Cmd, Base.CacheFlags}}}}) # recompile\n#=  301.6 ms =# precompile(Tuple{typeof(Base.CoreLogging.handle_message), Base.CoreLogging.ConsoleLogger, Base.CoreLogging.LogLevel, Vararg{Any, 6}})\n```\n\nSo it seems most time is spent in:\n\n- Precompiling `Base.Precompilation.precompilepkgs` which is invalidated for some reason (60m + 128ms).\n- Compiling some logging code for `Vararg{Any, 6}` (300 ms).\n\nSo we need to figure out why the precompile code is invalidated and why the `handle_message` gets specialized on the number of arguments... | [martinholters]: > So we need to figure out [...] why the `handle_message` gets specialized on the number of arguments...\n\nBecause it has a fixed number of arguments:\nhttps://github.com/JuliaLang/julia/blob/001c666086de77101b6937c3d31f0888a35325db/base/logging/ConsoleLogger.jl#L106-L108\nIt appears that the compilation is logged as \n```\nprecompile(Tuple{typeof(Base.CoreLogging.handle_message), Base.CoreLogging.ConsoleLogger, Base.CoreLogging.LogLevel, Vararg{Any, 6}})\n```\nbut the generated specialization is indeed\n```\nMethodInstance for Base.CoreLogging.handle_message(::Base.CoreLogging.ConsoleLogger, ::Base.CoreLogging.LogLevel, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\n``` | [KristofferC]: Something related to that it is nospecialize combined with being a kwarg function?",3,false,1,0,0,0,0,0,1,0,0
3161,Artifact sandbox broken in Test environment,open,vchuravy,staticfloat,bug; artifacts,1.8,1,2022-08-06T16:21:25.0,2024-11-11T12:39:43.0,1078,251,https://github.com/JuliaLang/Pkg.jl/issues/3161,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3161,"On 1.8-rc1/1.9.0-DEV.1065, but fine on 1.7\n\n```\n@v1.8) pkg> generate SomePkg\n  Generating  project SomePkg:\n    SomePkg/Project.toml\n    SomePkg/src/SomePkg.jl\n\nshell> mkdir SomePkg/test\n\nshell> touch SomePkg/test/runtests.jl\n\n(@v1.8) pkg> activate SomePkg/test\n  Activating new project at `~/SomePkg/test`\n\n(test) pkg> add LLVM_jll\n    Updating registry at `~/.julia/registries/CESMIX`\n    Updating git-repo `https://github.com/Cesmix-mit/CESMIX`\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n    Updating registry at `~/.julia/registries/MolSim`\n    Updating git-repo `https://github.com/JuliaMolSim/MolSim`\n   Resolving package versions...\n    Updating `~/SomePkg/test/Project.toml`\n⌅ [86de99a1] + LLVM_jll v13.0.1+3\n    Updating `~/SomePkg/test/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.4.1\n  [21216c6a] + Preferences v1.3.0\n⌅ [86de99a1] + LLVM_jll v13.0.1+3\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL v0.6.3\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.8.0\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML v1.0.0\n  [a4e569a6] + Tar v1.10.0\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll v7.83.1+1\n  [29816b5a] + LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] + MbedTLS_jll v2.28.0+0\n  [14a3606d] + MozillaCACerts_jll v2022.2.1\n  [83775a58] + Zlib_jll v1.2.12+3\n  [8f36deef] + libLLVM_jll v13.0.1+2\n  [8e850ede] + nghttp2_jll v1.47.0+0\n  [3f19e933] + p7zip_jll v17.4.0+0\n        Info Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated -m`\n\n(test) pkg> activate SomePkg\n  Activating project at `~/SomePkg`\n\n(SomePkg) pkg> test\n  No Changes to `~/SomePkg/Project.toml`\n  No Changes to `~/SomePkg/Manifest.toml`\n     Testing SomePkg\n      Status `/tmp/jl_FcgnTz/Project.toml`\nERROR: LoadError: ArgumentError: Package TOML not found in current path.\n- Run `import Pkg; Pkg.add(""""TOML"""")` to install the TOML package.\nStacktrace:\n [1] macro expansion\n   @ ./loading.jl:1163 [inlined]\n [2] macro expansion\n   @ ./lock.jl:223 [inlined]\n [3] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1144\n [4] include(fname::String)\n   @ Base.MainInclude ./client.jl:476\n [5] top-level scope\n   @ none:5\nin expression starting at /home/vchuravy/.julia/packages/LLVM_jll/44Mtf/.pkg/select_artifacts.jl:3\nERROR: failed process: Process(`/usr/bin/julia -Cnative -J/usr/lib/julia/sys.so -g1 -O0 --color=no --history-file=no --startup-file=no --compiled-modules=yes --project=/tmp/jl_FcgnTz/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""""/home/vchuravy/.julia"""", """"/usr/local/share/julia"""", """"/usr/share/julia""""])\nappend!(empty!(Base.DL_LOAD_PATH), String[])\n\ncd(""""/home/vchuravy/.julia/packages/LLVM_jll/44Mtf/.pkg"""")\ninclude(""""/home/vchuravy/.julia/packages/LLVM_jll/44Mtf/.pkg/select_artifacts.jl"""")\n' x86_64-linux-gnu-libgfortran5-cxx11-libstdcxx29-julia_version+1.8.0`, ProcessExited(1)) [1]\n```\n","[staticfloat]: So it turns out that this may not be a Pkg bug but rather a Julia problem.  Pointing `julia-1.7` at a `release-1.7` checkout of Pkg, the issue does not appear, but pointing `julia-1.8` at a `release-1.7` checkout of Pkg, the issue does appear.\n\nBisecting `julia` yields the following:\n\n```\n$ git bisect bad\na4e2cfb722dc3a4e8cf95179f03b425568b0df21 is the first bad commit\ncommit a4e2cfb722dc3a4e8cf95179f03b425568b0df21\nAuthor: Valentin Churavy <v.churavy@gmail.com>\nDate:   Fri Feb 11 18:59:56 2022 -0500\n\n    Upgrade LLVM to 13.0.1\n\n deps/Versions.make              |  10 +-\n deps/checksums/clang            | 116 +++++-----\n deps/checksums/llvm             | 468 ++++++++++++++++++++--------------------\n deps/llvm.mk                    |   6 +-\n deps/llvm.version               |   4 +-\n stdlib/libLLVM_jll/Project.toml |   2 +-\n 6 files changed, 301 insertions(+), 305 deletions(-)\n```\n\nEqual parts irony and tragedy, it appears that once again, our beloved Valentin has partaken in the debugging murder mystery, where he is simultaneously the victim and the perpetrator.  Looking at [the diff for a4e2cfb](https://github.com/JuliaLang/julia/commit/a4e2cfb722dc3a4e8cf95179f03b425568b0df21), it hardly seems possible that this could be the root issue.  It's so innocuous!  So perhaps there is some problem in the added JLL?  Looking at [the diff of the two `libLLVM_jll` versions](https://github.com/JuliaBinaryWrappers/libLLVM_jll.jl/compare/a223c1c0027f5bb2b1c48d99f4fbdd06ef50e081...d1c0098a91012dafec1ad5164bad104a3e6e74a1) is similarly unenlightening.  And then, a bolt of inspiration strikes; it's not that `libLLVM_jll` has new code, it's that changing the version of `libLLVM_jll` allows new code.  Indeed, the issue is that by upgrading the version of `libLLVM_jll`, we allow a new `LLVM_jll`, which has the new `.pkg/select_artifacts.jl` hook.\n\nThe whole idea that it's somehow Julia version dependent is a red herring; the version constraints on `LLVM_jll` simply restrict us to an older version of that package on Julia 1.7-, and that older version does not contain the `select_artifacts.jl` hook.  Digging into the actual problem, it becomes evident that this is due to the [`gen_build_code()` function clearing the entire `LOAD_PATH`](https://github.com/JuliaLang/Pkg.jl/blob/17f257a0916f4c7bd6fa6489868ba042919c4947/src/Operations.jl#L927), and the fact that during testing, we have no access to the standard library.  Fix here: https://github.com/JuliaLang/Pkg.jl/pull/3167",1,false,0,0,0,0,0,0,0,0,0
3389,[Preferences] Test ignores preferences that are not explicitly listed as test dependencies.,open,carstenbauer,,,,8,2023-02-23T10:01:51.0,2024-11-09T04:57:04.0,878,253,https://github.com/JuliaLang/Pkg.jl/issues/3389,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3389,"Came up over at MPI.jl [here](https://github.com/JuliaParallel/MPI.jl/issues/715).\n\nCurrently, `] test` ignores `JULIA_LOAD_PATH`. On our cluster, we use the latter to expand the default load path to an extra directory (via `JULIA_LOAD_PATH=:/some/global/path`) that contains a `Project.toml` that sets some global preferences (e.g. for MPI.jl). Consequently, the global preferences aren't respected within `] test`.\n\nI see two possible ways forward:\n\n1) Make `] test` respect `JULIA_LOAD_PATH`. (Why doesn't it?)\n2) Propagate **all** preferences that are set along the load path to the test environment. (This is along the lines of https://github.com/JuliaLang/Pkg.jl/issues/2500 and https://github.com/JuliaLang/Pkg.jl/pull/2920 which didn't cover the case of global preferences, IIUC.)\n\n(Tested with Julia 1.8.5)","[carstenbauer]: Maybe I'm wrong with my point 2) above. MWE:\n\nMinimal package with the following `Project.toml` and `test/runtest.jl`:\n```\nname = """"mwe""""\nuuid = """"4187ee2f-2d69-45e0-8479-75d21fecdd8d""""\nauthors = [""""Carsten Bauer <crstnbr@gmail.com>""""]\nversion = """"0.1.0""""\n\n[deps]\nLinearAlgebra = """"37e2e46d-f89d-539d-b4ee-838fcccc9c8e""""\nPreferences = """"21216c6a-2e73-6563-6e65-726566657250""""\n\n[extras]\nLinearAlgebra = """"37e2e46d-f89d-539d-b4ee-838fcccc9c8e""""\nPreferences = """"21216c6a-2e73-6563-6e65-726566657250""""\nTest = """"8dfed614-e22c-5e08-85e1-65c5234f0b40""""\n\n[targets]\ntest = [""""Test"""", """"LinearAlgebra"""", """"Preferences""""]\n```\n\n```\n@show LOAD_PATH\nusing Preferences, LinearAlgebra\n@show Preferences.load_preference(LinearAlgebra, """"testpref"""")\n```\n\nNow, an extra `Project.toml` in some global path (say `/some/global/path`) with the following content:\n```\n[extras]\nLinearAlgebra = """"37e2e46d-f89d-539d-b4ee-838fcccc9c8e""""\n\n[preferences.LinearAlgebra]\ntestpref = 1\n```\n\nRunning `JULIA_LOAD_PATH=:/some/global/path julia --project` and then `] test` I get\n\n```\nLOAD_PATH = [""""@"""", """"/var/folders/qk/nm34_hqn7_7g8fvxgpg24gm40000gn/T/jl_CemQ7p""""]\nPreferences.load_preference(LinearAlgebra, """"testpref"""") = 1\n```\n\nSo, despite the fact that `/some/global/path` isn't in `LOAD_PATH`,  the preference seems to propagate fine!\n\n(Why didn't it for MPIPreferences than?) | [vchuravy]: breadcrumbs #3061 and https://github.com/JuliaParallel/MPI.jl/issues/561\n\ncc: @staticfloat | [vchuravy]: What happens if you add `MPIPreferences` to the test dependencies? | [carstenbauer]: > What happens if you add `MPIPreferences` to the test dependencies?\n\nThat works!\n\nSo I take it that only preferences of direct test dependencies are forwarded? | [vchuravy]: Hm still smells like a bug, we use `Base.get_preferences` to collect the Preferences to propagate, and while #3061 added load path, `get_preferences` might only collect preferences of direct dependencies.\n\nBut looking at https://github.com/JuliaLang/julia/blob/b5482c82d486aaa68939871eb1d1bc71bb421096/base/loading.jl#L2608 I don't see how or why that would happen/ | [vchuravy]: @staticfloat https://github.com/JuliaLang/Pkg.jl/blob/63e9558b9786556dc92b606d1e3f22ffd0af00af/src/Operations.jl#L1911 returns a dictonary of `Name=>Prefs` but no associated `Name=>UUID` mapping. We then copy over the preferences https://github.com/JuliaLang/Pkg.jl/blob/63e9558b9786556dc92b606d1e3f22ffd0af00af/src/Operations.jl#L1742 to the test environment, but preference loading will ignore them since the `tmp_project` does not contain an appropriate `Name=>UUID` mapping. \n\n | [JBlaschke]: In case people find this, to make CUDA pick up local configurations, you need to add:\n```\nCUDA_Runtime_jll = """"76a88914-d11a-5bdc-97e0-2f5a05c973a2""""\n```\n\nThat shouldn't be necessary if the JULIA_LOAD_PATH was respected -- what causes this behavior in `Pkg.test`? | [carstenbauer]: > That shouldn't be necessary if the JULIA_LOAD_PATH was respected -- what causes this behavior in Pkg.test?\n\nRelated: https://github.com/JuliaPackaging/Preferences.jl/issues/33",8,false,0,0,0,0,0,0,0,0,0
4074,dev gives confusing error on stdlibs,open,IanButterworth,,,,0,2024-11-04T15:00:12.0,2024-11-04T15:01:33.0,258,258,https://github.com/JuliaLang/Pkg.jl/issues/4074,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4074,"```\n(@v1.11) pkg> dev Test\n    Updating registry at `~/.julia/registries/General.toml`\nERROR: The following package names could not be resolved:\n * Test (not found in project, manifest or registry)\n   Suggestions: ReTest P4est Pesto RNGTest TestEnv JETTest Term Ket TensND CUTEst Trusty Jets Hestia TidyTest\n```\n\nPerhaps should be something like\n```\n(@v1.11) pkg> dev Test\n    Updating registry at `~/.julia/registries/General.toml`\nERROR: The following package names could not be resolved:\n * Test (Test is in the standard library, so cannot be `develop`-ed by name. Use a path/url)\n```",,0,false,0,0,0,0,0,0,0,0,0
4068,When dev'ing a cloned repository Pkg.build is not triggered,open,mohamed-barakat,,,,1,2024-10-30T16:02:42.0,2024-10-30T16:19:15.0,262,262,https://github.com/JuliaLang/Pkg.jl/issues/4068,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4068,"When Pkg.develop downloads the package\n\n```\n$ julia -e 'using Pkg; Pkg.develop(""""CapAndHomalg"""");';\n```\n\nPkg.build is successfully invoked, while when dev'ing the cloned repository Pkg.build is not triggered\n\n```\n$ git clone https://github.com/homalg-project/CapAndHomalg.jl .julia/dev/CapAndHomalg\n$ julia -e 'using Pkg; Pkg.develop(""""CapAndHomalg"""");';\n```\n",[mohamed-barakat]: Maybe the reason is here: https://github.com/JuliaLang/Pkg.jl/issues/862.\n\nSee also\n* https://github.com/JuliaLang/Pkg.jl/issues/710#issuecomment-460167206\n* https://discourse.julialang.org/t/what-is-build-jl-for/64583/2\n,1,false,0,0,0,0,0,0,0,0,0
4063,"ArgumentError when adding packages with ""+"" in version",open,arlowhite,,,,2,2024-10-29T06:03:51.0,2024-10-29T22:41:58.0,264,263,https://github.com/JuliaLang/Pkg.jl/issues/4063,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4063,"Julia 1.11.1\n\nPackages can have a version that causes an `ArgumentError` when added.\n\nIn a new project:\n```\n(julia_tmp) pkg> add MKL_jll@2024.2.0+0\nERROR: ArgumentError: invalid base 10 digit '+' in """"0+0""""\n```\n\nSame error with Pkg API: `Pkg.add(name=""""MKL_jll"""", version=""""2024.2.0+0"""")`\n\n---\n\n`add MKL_jll@2024.2.0` works\n\n```\n(julia_tmp) pkg> status MKL_jll\n  [856f044c] MKL_jll v2024.2.0+0\n```\n","[KristofferC]: I think this works `Pkg.add(; name=""""MKL_jll"""", version=v""""2024.2.0+0"""")` | [arlowhite]: That does work, but you can't do that in the `]` REPL.\n\n`(jl_981J6x) pkg> add MKL_jll@v""""2024.2.0+0""""`\n> ERROR: Unable to parse `2024.2.0+0` as a package.\n\nIn any case, I would expect version values printed by status or the string conversion of a `VersionNumber` to be valid values when using `Pkg.add` or `] add <name>@<version>`",2,false,0,0,0,0,0,0,0,0,0
4018,1.10: `KeyError` when dev'ing a package with strong-dep extension triggers,open,topolarity,,bug; extensions,1.10,0,2024-09-10T02:52:59.0,2024-10-29T08:05:43.0,313,264,https://github.com/JuliaLang/Pkg.jl/issues/4018,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4018,"```toml\n# Project.toml\nname = """"Foo""""\nuuid = """"0a21ebe4-285f-4d3c-b082-40545a858146""""\nauthors = [""""Cody Tapscott <topolarity@tapscott.me>""""]\nversion = """"0.1.0""""\n\n[deps]\nModelingToolkit = """"961ee093-0014-501f-94e3-6117800e7a78""""\n\n[weakdeps]\nSymbolicIndexingInterface = """"2efcf032-c050-4f8e-a9bb-153293bab1f5""""\n\n[extensions]\nModelingToolkitFooExt = [""""ModelingToolkit"""", """"SymbolicIndexingInterface""""]\n```\n\nWhen trying to `dev` this package it gives a `KeyError`:\n```julia\njulia +1.10 --project=tmp -q\n(tmp) pkg> dev Foo\nERROR: KeyError: key """"ModelingToolkit"""" not found\nStacktrace:\n  [1] getindex\n    @ ./dict.jl:498 [inlined]\n  [2] status_ext_info(pkg::Pkg.Types.PackageSpec, env::Pkg.Types.EnvCache)\n    @ Pkg.Operations ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2213\n  [3] print_status(env::Pkg.Types.EnvCache, old_env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, header::Symbol, uuids::Vector{Base.UUID}, names::Vector{String}; manifest::Bool, diff::Bool, ignore_indent::Bool, outdated::Bool, extensions::Bool, io::Base.TTY, mode::Pkg.Types.PackageMode, hidden_upgrades_info::Bool, show_usagetips::Bool)\n    @ Pkg.Operations ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2298\n  [4] print_status\n    @ ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2240 [inlined]\n  [5] status(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}; header::Symbol, mode::Pkg.Types.PackageMode, git_diff::Bool, env_diff::Pkg.Types.EnvCache, ignore_indent::Bool, io::Base.TTY, outdated::Bool, extensions::Bool, hidden_upgrades_info::Bool, show_usagetips::Bool)\n    @ Pkg.Operations ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2471\n  [6] status (repeats 2 times)\n    @ ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2442 [inlined]\n  [7] #show_update#167\n    @ ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2438 [inlined]\n  [8] develop(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Set{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1416\n  [9] develop\n    @ ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1402 [inlined]\n [10] develop(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; shared::Bool, preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::@Kwargs{io::Base.TTY})\n    @ Pkg.API ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/API.jl:225\n [11] develop(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::@Kwargs{})\n    @ Pkg.API ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/API.jl:159\n [12] develop(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/API.jl:148\n [13] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:412\n [14] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:390\n [15] do_cmd\n    @ ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:380 [inlined]\n [16] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:557\n [17] #invokelatest#2\n    @ ./essentials.jl:892 [inlined]\n [18] invokelatest\n    @ ./essentials.jl:889 [inlined]\n [19] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/REPL/src/LineEdit.jl:2656\n [20] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/REPL/src/REPL.jl:1312\n [21] (::REPL.var""""#62#68""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ~/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/share/julia/stdlib/v1.10/REPL/src/REPL.jl:386\n```\n\nOn 1.10:\n```julia\njulia> versioninfo()\nJulia Version 1.10.5\nCommit 6f3fdf7b362 (2024-08-27 14:19 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 12 × 12th Gen Intel(R) Core(TM) i7-1255U\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, alderlake)\nThreads: 1 default, 0 interactive, 1 GC (on 12 virtual cores)\n```\n\nRelated: https://github.com/JuliaLang/Pkg.jl/issues/3797",,0,false,0,0,0,0,0,0,0,0,0
4059,Show manifest julia version in `status`,open,IanButterworth,,,,0,2024-10-28T13:47:31.0,2024-10-28T13:47:31.0,265,265,https://github.com/JuliaLang/Pkg.jl/issues/4059,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4059,"`instantiate` will warn if the julia version of the manifest is from a different minor release etc.\n\nI think it would be helpful to also present the information in `status` and I'm thinking a field of `status` with a warn, rather than a full warning that only shows if it's different.\n\nAlso show even in non manifest status mode. \n\nSomething like:\n```\n(Foo) pkg> st\nStatus `~/Foo/Project.toml`\n  [295af30f] Revise v3.6.2\n  Manifest julia version v1.11.1 (potentially incompatible with this version)\n```\n\nBut it's not quite right.",,0,false,0,0,0,0,0,0,0,0,0
819,Better resolver failure messages,open,fredrikekre,,enhancement; resolver,,3,2018-10-11T23:38:44.0,2024-10-22T12:28:14.0,2473,271,https://github.com/JuliaLang/Pkg.jl/issues/819,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/819,"For example from https://stackoverflow.com/questions/52770092/julia-package-dependencies-in-travis-ci/52770252#52770252\n```\nERROR: Unsatisfiable requirements detected for package SchumakerSpline [65e68595]:\n     SchumakerSpline [65e68595] log:\n     ├─possible versions are: 0.0.1 or uninstalled\n     ├─restricted to versions 0.0.1-* by UnivariateFunctions [117ba14f], leaving only versions 0.0.1\n     │ └─UnivariateFunctions [117ba14f] log:\n     │   ├─possible versions are: 0.0.0 or uninstalled\n     │   └─UnivariateFunctions [117ba14f] is fixed to version 0.0.0\n     └─restricted by julia compatibility requirements to versions: uninstalled — no versions left\n```\n\nis not very clear IMO. It would  be nice to at least print which julia versions the package support etc.","[goerz]: Even though we now show which versions particular packages support, this kind of """"tree-view"""" should be considered internal state, and not shown as part of a user-facing error message. I would recommend keeping it as a `@debug` log only.\n\nAs for a user-facing error message, I think this could boil down to a simple message\n\n```Could not resolve the dependency for `PackageName`, available in versions <versions>```\n\nfollowed by two lines in one of the following formats:\n\n* Project `<path>` has a direct dependency on `PackagName` `<version>`\n* Package `PackageA` has a direct dependency on `PackageName` `<version>`\n* Package `PackageB` has an indirect dependency on `PackageName` `<version>` via `<chain of packages>`\n\nThe `<path>` would be the path of the project that is being instantiated, and `PackageA`/`PackageB` would be a direct dependency in that project.\n\nThere might be _more_ conflicts than given by those two lines (which the current tree-view exposes, if you know how to read it), but I think as a user, I only care about the _first_ incompatibility.\n\nThis is just an idea (possibly half-baked) that I want to throw out here from the [black whole that is Slack](https://julialang.slack.com/archives/C67910KEH/p1729597619063269?thread_ts=1729590862.044159&cid=C67910KEH) | [araujoms]: While @goerz's solution is the ideal one, simply changing the current """"restricted to versions `<version>` by an explicit requirement"""" to """"Project `<path>` has a direct dependency on `PackagName` `<version>`"""" would already be a massive improvement, and is trivial to implement. | [KristofferC]: Great with some ideas here and I would be happy to see some PRs with example error messages before and after this suggestion.",3,false,6,6,0,0,0,0,0,0,0
3718,Allow optional commit and tag metadata in Manifests and registries,open,simonbyrne,,,,27,2023-12-06T18:10:40.0,2024-10-19T09:40:48.0,591,274,https://github.com/JuliaLang/Pkg.jl/issues/3718,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3718,"Currently we only identify versions by their `git-tree-sha1`. However this is sub-optimal when looking up git histories: GitHub doesn't provide a convenient way to find commits of a given tree, which means that e.g. TagBot has to jump through all sorts of funny hoops to try to link the tag back to a given commit.\n\nI propose the following:\n- Registry `Versions.toml` and `Manifest.toml` allow optional `git-commit-sha1`, `git-tag-sha1` (for Annotated Tags only) and `git-tag-name` (for the tag reference) that link to the corresponding objects\n- In the case of subpackages, we can have an optional `git-tree-path` giving the path in the commit/tag to the corresponding tree.\n- Unlike `git-tree-sha1`, these should be considered mutable (i.e. registries may add/update/remove these as required)\n\ncc: @IanButterworth \n\nCurrent PRs:\n- https://github.com/JuliaRegistries/RegistryTools.jl/pull/97\n- https://github.com/JuliaRegistries/Registrator.jl/pull/429 (requires above PR)\n- https://github.com/JuliaRegistries/RegistryCI.jl/pull/537 (independent, but need to agree on names)","[simonbyrne]: Another use case would be rewriting file paths in CI stacktraces so that we can provide a HTML link to the GitHub URL | [DilumAluthge]: Can we split this into two separate issues, one for the General registry (`Versions.toml`), and a separate one for local `Manifest.toml` files? It seems to me that those two can be implemented independently of each other. | [simonbyrne]: I think you would need the registry one first, no? | [simonbyrne]: What would actually need to be done for the registry changes?\n\nFrom what I can tell, it seems that:\nhttps://github.com/JuliaRegistries/RegistryTools.jl/blob/77e2a02e62185ce865653bdae95203a3a40510f0/src/register.jl#L326\nwould need to be updated, along with Registrator.jl? | [DilumAluthge]: > I think you would need the registry one first, no?\n\nOh, I was thinking that the manifest would be getting its info from a local Git clone. But yeah, if the plan is for the manifest to get the info from the registry, then we first need to implement this in the registry. | [KristofferC]: Makes sense to me to have optional metadata tied to versions that can be used to improve various tooling. You would have to verify that the commit metadata resolves to the correct tree, right?\n | [simonbyrne]: The commit info we can probably get from registrator. But I was thinking we could have a cron job that periodically queries the repos and updates the registry as required. | [ericphanson]: > In the case of subpackages, we can have an optional git-tree-path giving the path in the commit/tag to the corresponding tree.\n\nWe do have `subdir` that is similar but that's one subdir per package, rather than per version | [simonbyrne]: > We do have `subdir` that is similar but that's one subdir per package, rather than per version\n\nPerhaps I should rename it for consistency? Should I just call it `subdir` as well? | [ericphanson]: Yeah, maybe `subdir` should just move to be per version? Or have both for awhile until all supported Pkg’s know the new location | [simonbyrne]: > Yeah, maybe `subdir` should just move to be per version? Or have both for awhile until all supported Pkg’s know the new location\n\nWe probably need to keep a global one for non-released versions (e.g. a specific git commit) | [GunnarFarneback]: I'd like to better understand the use cases for the different pieces of information.\n\n* `git-commit-sha1`: Ok, I understand this one. This is readily available at the time of registration and not uniquely determined by the tree hash. Moreover it can only change if the repository history is rewritten.\n* `git-tree-path`: Presumably needed to create source code links and taking height for the possibility that packages are moved around in the repository so the global `subdir` is insufficient?\n* `git-tag-sha1`: Not needed according to https://github.com/JuliaRegistries/RegistryTools.jl/pull/97#issuecomment-1874317203.\n* `git-tag-name`: For what purpose is it useful to have this information in the registry? | [GunnarFarneback]: Trick question: What is the tooling supposed to do if the same package is found in multiple registries, with diverging values for the optional fields?\n | [simonbyrne]: > * `git-tree-path`: Presumably needed to create source code links and taking height for the possibility that packages are moved around in the repository so the global `subdir` is insufficient?\n\nYes, exactly.\n\n> * `git-tag-name`: For what purpose is it useful to have this information in the registry?\n\nTwo reasons\n- tags can have information that the commit does not (e.g. annotated tags can contain release notes or signatures)\n- GitHub lets you link to revisions via tags, which gives """"nicer"""" URLs, e.g. https://github.com/JuliaParallel/MPI.jl/tree/v0.20.19 vs https://github.com/JuliaParallel/MPI.jl/tree/c7f0fc3dae044db04eed09bd00ea93e7bbfedfd4\n\n\n> Trick question: What is the tooling supposed to do if the same package is found in multiple registries, with diverging values for the optional fields?\n\nPick the first one? In general, it shouldn't matter, only the tree hashes should, the optional fields are just there to help find the trees. | [GunnarFarneback]: > tags can have information that the commit does not (e.g. annotated tags can contain release notes or signatures)\n\n* How would the tooling make use of signatures?\n* If we want to have tooling around release notes, digging them out from annotated tags seems like the wrong way. Much better would be to have them in a file in the repository, in some standardized format.\n\nWhat is the intended workflow to get the tag names into the General registry? I can see two possibilities:\n1. Registrator directly writes a tag name, which may or may not materialize in the package repository depending on whether TagBot is activated and runs successfully.\n2. Registrator doesn't write the tag name, instead TagBot makes a new PR to General to add this information, once it has made the tag in the package repository.\n\nNeither of those options seems great, so I hope I've missed some better approach.\n\n> GitHub lets you link to revisions via tags, which gives """"nicer"""" URLs\n\nA shorter URL is certainly nicer than a longer one, but it seems like a marginal win compared to the increased size of the registry, the logistics around syncing registry tag information and package repository tags, and the possibility that the nicer link suddenly breaks if someone mistakenly deletes a non-annotated tag.\n\n> the optional fields are just there to help find the trees.\n\nThis sounds contrary to the use case of investigating annotated tags. | [simonbyrne]: > * How would the tooling make use of signatures?\n>\n>  * If we want to have tooling around release notes, digging them out from annotated tags seems like the wrong way. Much better would be to have them in a file in the repository, in some standardized format.\n\nI don't have too many thoughts on what sort of tooling this could be useful for, but some other reasons it is useful to have tags:\n- if the repository does have its history re-written, this would provide an easy mechanism for the registry to update the commit hashes.\n- it provides a way for registry maintainers to ensure that tags exist: having tags for commits ensures they don't get GCed by git: e.g. say I make a release off a non-main branch, then accidentally delete that branch: if there is no tag, there is no reference to that commit, and so it may get cleaned up eventually. Requiring/encouraging tags seems like a good practice.\n- [Git only allows fetching named refs, not commits](https://stackoverflow.com/questions/26905446/fetch-specific-commit-from-remote-git-repo). We currently work around this by cloning the entire repository (when using git instead of Pkg tarballs), but if we tag information is available, we could use that to only fetch the appropriate data.\n\n> What is the intended workflow to get the tag names into the General registry? I can see two possibilities:\n> \n>   1. Registrator directly writes a tag name, which may or may not materialize in the package repository depending on whether TagBot is activated and runs successfully.\n> \n>   2. Registrator doesn't write the tag name, instead TagBot makes a new PR to General to add this information, once it has made the tag in the package repository.\n> \n> \n> Neither of those options seems great, so I hope I've missed some better approach.\n\nThis I don't have a good answer to yet. One other option would be to have a semi-regular job (say weekly), which goes through and verifies:\n1. the commit hashes exist and point to the appropriate tree\n2. the tags exist and point to the appropriate commits\n\nand if any updates are required, open a PR against the registry.\n\n> A shorter URL is certainly nicer than a longer one, but it seems like a marginal win compared to the increased size of the registry, the logistics around syncing registry tag information and package repository tags, and the possibility that the nicer link suddenly breaks if someone mistakenly deletes a non-annotated tag.\n\nI don't think the size will increase too much: it's 1 extra field per version, this is dwarfed by the compat information per version.\n\nAs for breaking things: my suspicion tags are likely to be more stable than commit hashes (e.g. if you rewrite history to remove an intermediate commit, you can still keep the same tag names, but commit hashes will change). It is up to users what they want to use it for, but they shouldn't expect either commit or tags to be completely immutable over time. | [GunnarFarneback]: > but some other reasons it is useful to have tags:\n\nFair enough, those sound like decent arguments.\n\n> I don't think the size will increase too much: it's 1 extra field per version, this is dwarfed by the compat information per version.\n\nThat depends on the amount of dependencies and changes in dependencies, but a stronger argument is that the tag name info can be expected to compress *really* well. Luckily this is a testable hypothesis.\n\nStarting from General registry tree hash 793278ad7a09a821cfac38e86fc150f6c9a00f7f (current about an hour ago), this has a size of 7063293 bytes from the package servers. Packing it up and repacking it with `Tar.create` produces a tar file of the same size as the uncompressed package server tarball. Compressing it with `gzip -9` gives a size of 7093553. This is slightly worse than on the package servers, but I won't bother trying to find exactly how those are computed. For this purpose `gzip -9` should be good enough to estimate the relative size increase.\n\nNow adding random commit hashes to all Versions.toml files increases the compressed tarball size to 9798614 bytes. Additionally adding tag names (constructed as `v0.5.6` etc.) increases the size to 10069487.\n\nIn summary adding commit hashes to all packages increases the registry size by 38% and also adding tag names by another 3%.\n | [simonbyrne]: > Starting from General registry tree hash 793278ad7a09a821cfac38e86fc150f6c9a00f7f (current about an hour ago), this has a size of 7063293 bytes from the package servers. Packing it up and repacking it with `Tar.create` produces a tar file of the same size as the uncompressed package server tarball. Compressing it with `gzip -9` gives a size of 7093553.\n\nWait, the gzip is larger? I know that hashes should not be compressible, but we store them in hex digits which should leave plenty of redundancy,\n\n> In summary adding commit hashes to all packages increases the registry size by 38% and also adding tag names by another 3%.\n\nThanks for trying this out: I guess ~40% increase in size is a reason to be hesitant. Personally, I feel it's worth it, but would understand if others feel otherwise.\n | [simonbyrne]: > Wait, the gzip is larger? I know that hashes should not be compressible, but we store them in hex digits which should leave plenty of redundancy,\n\nActually that doesn't seem right:\n```\n➜  reg ls -l -h\ntotal 127512\n-rw-r--r--@ 1 simon  staff    55M Jan  5 09:51 793278ad7a09a821cfac38e86fc150f6c9a00f7f.tar\n-rw-r--r--@ 1 simon  staff   7.0M Jan  5 09:51 793278ad7a09a821cfac38e86fc150f6c9a00f7f.tar.gz\ndrwxr-xr-x@ 3 simon  staff    96B Jan  5 09:51 General\n➜  reg du -sh General\n166M\tGeneral\n➜  reg du -sh -B 1 -A General\n 18M\tGeneral\n```\n | [simonbyrne]: Honestly, we may want to consider some sort of lightweight database to store this information: the disk usage of all these small files is getting pretty big. | [simonbyrne]: Or switch to xzip: it gives a 4.5MB file. | [GunnarFarneback]: > > Starting from General registry tree hash 793278ad7a09a821cfac38e86fc150f6c9a00f7f (current about an hour ago), this has a size of 7063293 bytes from the package servers. Packing it up and repacking it with Tar.create produces a tar file of the same size as the uncompressed package server tarball. Compressing it with gzip -9 gives a size of 7093553.\n\n> Wait, the gzip is larger? I know that hashes should not be compressible, but we store them in hex digits which should leave plenty of redundancy,\n\nNo, what I'm saying is that `gzip -9` gives a (slightly) worse compression result than whatever is used to compress the tarballs on the package server. The uncompressed original tar file is 58 MB. | [GunnarFarneback]: I don't have a strong opinion whether this information is worth the size increase. Or rather, I do have concerns about the size, and I have in the past had timeout issues with the General registry on a company internal package server. But I also see a value in the added information.\n | [KristofferC]: > Honestly, we may want to consider some sort of lightweight database to store this information: the disk usage of all these small files is getting pretty big.\n\nBut we only **de**compress it in memory so? | [GunnarFarneback]: You probably mean decompress.\n\nThe compressed tarball size is what matters for disk storage per installation, registry download size, and the registry part of the package server load. The decompressed tar file size matters for the in memory handling of the registry. The unpacked disk size only matters for those of us who like to look manually at the registry files or grep through them, or do other non-standard operations.\n | [simonbyrne]: Bump? | [GunnarFarneback]: An observation is that the commit hash is useful for registry maintenance and possibly specialized tooling but doesn't add any value to the primary Pkg functionality. I.e. it's hard to justify why it should add to the download size etc. when most of the time and for most of the users the information just isn't considered at all.\n\nThis could possibly be solved by not distributing the full head of the registry repository or placing the commit hashes in a separate branch or in a separate repository. The latter options seem far from ideal and the first option requires some redesign and new tooling for the registry distribution.",27,false,0,0,0,0,0,0,0,0,0
3341,is there a way to Pkg.add that doesn’t precompile the added Pkgs?,open,anandijain,,precompile,,4,2023-01-26T23:15:25.0,2024-10-14T12:11:09.0,905,279,https://github.com/JuliaLang/Pkg.jl/issues/3341,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3341,"I asked on helpdesk and @sjkelly told be about the `allow_autoprecomp` kwarg to instantiate. it doesn't seem like it works on Pkg.add though.\n\n```julia\njulia> Pkg.add(""""CSV"""";allow_autoprecomp=false)\nERROR: type Context has no field allow_autoprecomp\n```\nMy issue is that I'm generating the environments on the fly and I'd prefer to do it with Pkg.add than manually editing TOML.\n\nif anyone knows how to do this, i'd be very grateful. thanks","[anandijain]: it looks like maybe the only way to do it is with `JULIA_PKG_PRECOMPILE_AUTO` env var | [fonsp]: It works now! But maybe we should add a test for this?\n\nIn Julia 1.10 it is broken.\n\n```\n➜  ~ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.0 (2024-10-07)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> import Pkg\n\n(@v1.11) pkg> activate --temp\n  Activating new project at `/var/folders/v_/fhpj9jn151d4p9c2fdw2gv780000gn/T/jl_z09Nt6`\n\njulia> Pkg.add(""""CSV""""; allow_autoprecomp=false)\n   Resolving package versions...\n    Updating `/private/var/folders/v_/fhpj9jn151d4p9c2fdw2gv780000gn/T/jl_z09Nt6/Project.toml`\n  [336ed68f] + CSV v0.10.14\n    Updating `/private/var/folders/v_/fhpj9jn151d4p9c2fdw2gv780000gn/T/jl_z09Nt6/Manifest.toml`\n  [336ed68f] + CSV v0.10.14\n  [944b1d66] + CodecZlib v0.7.6\n  [34da2185] + Compat v4.16.0\n  [9a962f9c] + DataAPI v1.16.0\n  [e2d170a0] + DataValueInterfaces v1.0.0\n  [48062228] + FilePathsBase v0.9.22\n  [842dd82b] + InlineStrings v1.4.2\n  [82899510] + IteratorInterfaceExtensions v1.0.0\n  [bac558e1] + OrderedCollections v1.6.3\n  [69de0a69] + Parsers v2.8.1\n  [2dfb63ee] + PooledArrays v1.4.3\n  [aea7be01] + PrecompileTools v1.2.1\n  [21216c6a] + Preferences v1.4.3\n  [91c51154] + SentinelArrays v1.4.5\n  [3783bdb8] + TableTraits v1.0.1\n  [bd369af6] + Tables v1.12.0\n  [3bb67fe8] + TranscodingStreams v0.11.3\n  [ea10d353] + WeakRefStrings v1.4.2\n  [76eceee3] + WorkerUtilities v1.6.1\n  [ade2ca70] + Dates v1.11.0\n  [9fa8497b] + Future v1.11.0\n  [8f399da3] + Libdl v1.11.0\n  [a63ad114] + Mmap v1.11.0\n  [de0858da] + Printf v1.11.0\n  [9a3f8284] + Random v1.11.0\n  [ea8e919c] + SHA v0.7.0\n  [fa267f1f] + TOML v1.0.3\n  [cf7118a7] + UUIDs v1.11.0\n  [4ec0a83e] + Unicode v1.11.0\n  [83775a58] + Zlib_jll v1.2.13+1\n\njulia> Pkg.precompile()\nPrecompiling project...\n  11 dependencies successfully precompiled in 12 seconds. 19 already precompiled.\n``` | [KristofferC]: Is this documented? I thought the env var was the """"official way"""" (although the kwarg is better). | [fonsp]: It's not documented: https://pkgdocs.julialang.org/v1/api/#Pkg.add",4,false,2,2,0,0,0,0,0,0,0
4043,Prioritize higher versions of direct dependencies over indirect dependencies,open,KristofferC,,resolver,,1,2024-10-11T13:24:24.0,2024-10-11T15:31:38.0,282,281,https://github.com/JuliaLang/Pkg.jl/issues/4043,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4043,"Right now, you can end up in a situation where you have, say Plots, installed at some version but you can force it to be at an even higher version at the cost of downgrading some transitive dependencies:\n\n```\n(@v1.10) pkg> add Plots@1.40.8\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [91a5bcdd] ↑ Plots v1.40.1 ⇒ v1.40.8\n    Updating `~/.julia/environments/v1.10/Manifest.toml`\n  [b99e7846] - BinaryProvider v0.5.10\n  [c87230d0] ↑ FFMPEG v0.2.4 ⇒ v0.4.2\n  [91a5bcdd] ↑ Plots v1.40.1 ⇒ v1.40.8\n⌅ [b22a6f82] ↓ FFMPEG_jll v6.1.2+0 ⇒ v4.4.4+1\n⌅ [1270edf5] ↓ x264_jll v10164.0.0+0 ⇒ v2021.5.5+0\n⌅ [dfaa095f] ↓ x265_jll v3.6.0+0 ⇒ v3.5.0+0\n```\n\nIn some sense, direct dependencies are more important and it is likely that you want to prioritize those having a higher version over e.g. FFMPEG here.\n\nWould it be possible to incorporate something like that into the resolver, @carlobaldassi",[IanButterworth]: I think this is a better more general approach of what https://github.com/JuliaLang/Pkg.jl/issues/3898 is proposing,1,false,2,2,0,0,0,0,0,0,0
3798,Feature Request: Option to Exclude Non-Essential Directories on Package Installation,open,singularitti,,,,8,2024-02-15T06:57:24.0,2024-10-11T02:39:27.0,521,282,https://github.com/JuliaLang/Pkg.jl/issues/3798,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3798,"I am reaching out to propose an enhancement aimed at optimizing the Julia package installation process, potentially benefiting both users and package authors by addressing disk space efficiency.\n\n### Background\n\nIn my experience with several Julia packages, I've noticed that directories such as `test`, `docs`, `examples`, and `notebooks` often contain large files that are not directly utilized in most projects, such as images and binary data. These files, while crucial for development, testing, and documentation, significantly increase the disk space requirement for package installations.\n\n### Proposal\n\nI suggest introducing a mechanism within `Pkg.jl` that allows package authors to define which directories are essential for their package's core functionality. This feature would adjust the installation process to include only these specified directories by default, thereby reducing unnecessary disk space usage.\n\nFor instance, the `src` directory could be considered essential by default, with authors having the option to include additional directories (e.g., `deps`, `datadeps`) as necessary for their package's operation. Non-essential directories like `docs`, `examples`, and `test` would not be included in the default installation, but could still be made available for users who wish to `dev` the package or explicitly opt-in to download them.\n\n### Examples\n\nPackages such as `GR.jl` and `ColorSchemes.jl` include substantial non-source files within their `docs`, `examples`, or `test` directories. While important for development purposes, these files may not be needed by all users, particularly those focused on using the packages' functionalities rather than modifying or extending them.\n\n![grw35h35u](https://github.com/JuliaLang/Pkg.jl/assets/25192197/99b9517c-2097-46fa-a7b6-26bc68df3641)\n\n### Benefits\n\n- **Reduced Disk Space Usage:** This approach allows for more efficient use of disk space, catering to users with limited storage or those who prefer a minimal installation footprint.\n- **Enhanced Installation Efficiency:** Streamlining the number of files to download can lead to quicker installation times and a more user-friendly experience.","[KristofferC]: One issue with this is that we allow downloading the package both from the PkgServer but also from GitHub. The GitHub download is just getting the repo as is so this would then get a different content hash than we would get from downloading from the PkgServer.  In theory we could ignore the content hash when downloading from GitHub but that leaves us at the mercy if GitHub is sending us bad files we will blindly accept that. | [singularitti]: Is it possible to add something like a [`.vscodeignore` for VSCode extensions](https://code.visualstudio.com/api/working-with-extensions/publishing-extension#using-.vscodeignore) when publishing a release of a package? I mean, the release does not include some folders intentionally? | [KristofferC]: I think in theory it would be possible. `add url#version` would give you a different content hash than `add pkg@version` then but maybe that is not the end of the world. @staticfloat and @fredrikekre might have some opinions. | [fredrikekre]: My .julia is right now:\n\n - compiled: 12 GB\n - artifacts: 8.7 GB\n - packages: 3.3 GB\n - conda: 2.3 GB\n\nSo even if you _completely_ eliminated packages it would only be 13% of the storage. We are already doing a """"good job"""" since we don't need the full repos but just the latest tree. In addition, committing large files to git is generally not recommended since it slow things down anyway? The biggest offenders in the screenshot above looks like binary data and/or docs which could be generated on demand or stored elsewhere.\n\nI don't think it is worth implementing something like a .pkgignore file while the situation looks like above. | [tecosaur]: I've recently done a test across the entire registry and my locally installed packages, and in both cases with just the `src/` directory the packages folder is ~10% the size.\n\nThe idea I proposed on slack was adding a `files` key or similar to the `Project.toml`, and having the registry use this to filter the package and create a reduced tarball, along with a separate hash for verification. Adding an extra hash to every version in the registry increased it from 8 to 11 MiB locally, which seems worth it to me for the `package/` savings. | [KristofferC]: > and in both cases with just the src/ directory the packages folder is ~10% the size.\n\nThis requires some distribution info. One package with some huge files will heavily skew this. | [tecosaur]: I've gone ahead and looked at the tarballs of the registry:\n\n![Image](https://github.com/user-attachments/assets/e67dc196-efdc-4420-94e4-0d61154c84d4)\n\n![Image](https://github.com/user-attachments/assets/753393b6-b573-45cb-9d42-754226d9dcbe)\n\nFrom these plots:\n- The most common package size is ~8 KiB\n- The largest 5% of the registry is responsible for ~85% of the total registry size\n\nLooking at my locally installed packages, the 5% / 80% rule seems to hold too.\n\n![Image](https://github.com/user-attachments/assets/2bb0355f-1350-4cc3-995a-762814d0261b)\n\nIf you want to check this for yourself, this is what I did (not pretty but it works):\n```julia-repl\njulia> using CairoMakie\n\njuila> mypkgs = readdir.(readdir(""""/home/tec/.julia/packages"""", join=true), join=true) |> Iterators.flatten |> collect\n\njulia> mysizes = parse.(Int, first.(split.([read(`du -d0 $dir`, String) for dir in mypkgs], '\t')))\n\njulia> lines(range(100, 0, length=length(mysizes)), 100 .* (1 .- cumsum(sort(mysizes)) ./ sum(mysizes)), axis=(; xticks=[0, 1, 2, 5, 10, 20, 50, 100], yticks=[0, 20, 40, 60, 80, 90, 95, 100], xscale=Makie.pseudolog10, xtickformat = v -> string.(round.(Int, v), '%'), xlabel=""""Proportion of packages"""", ylabel=""""Proportion of registry size"""", title=""""The contribution of packages to install size"""", subtitle=""""Cumulatively counting packages, from largest to smallest""""))\n``` | [tecosaur]: So I'm thinking for a few hundred packages, the ability to filter what's packaged to only relevant parts of the repository (whether by explicit inclusion or exclusion) could be rather beneficial.\n\nThe main downside of such a thing seems to be a larger registry, but only insofar as the effect that has on registry download time: I think this could be majorly sped up/slimmed down regardless by implementing deltas (maybe RFC3284) on the uncompressed tarball (with a heuristic for the versions that deltas are created for).",8,false,0,0,0,0,0,0,0,0,0
4041,Request: Introduce Option to Freeze/Lock Environments,open,alex-fu27,,,,0,2024-10-09T07:18:27.0,2024-10-09T07:18:27.0,284,284,https://github.com/JuliaLang/Pkg.jl/issues/4041,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4041,"Whenever I create a new project, I will forget to activate the new project's directory as an environment for installing packages. So I always install the packages into the default `@#.#` and later realize that no `Project.toml` was created. Then I uninstall the packages from the default environment and create the new `Project.toml`.\n\nThus, I would like to request a feature which can `lock` an environment, for example the default one, so that I get an error message if I try to install packages.\n\nThe hack I am currently using already implies a possible implementation: I did `chmod a-w ~/.julia/environments/v1.10`, which leads to an error when I try to add a package:\n```\n(@v1.10) pkg> add Plots\n   Resolving package versions...\nERROR: SystemError: opening file """"/home/alex/.julia/environments/v1.10/Project.toml"""": Permission denied\nStacktrace:\n  [1] systemerror(p::String, errno::Int32; extrainfo::Nothing)\n    @ Base ./error.jl:176\n  [2] systemerror\n    @ ./error.jl:175 [inlined]\n  [3] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Bool, append::Nothing)\n    @ Base ./iostream.jl:293\n.... huge stack trace truncated...\n```\nBroken down into individual tasks, the implementation would be:\n* Recognize that the current environment's `Project.toml` is read-only, show a concise error message explaining that the environment is 'locked'.\n* Add commands `] lock` and `] unlock` to set the permissions of `Project.toml` and `Manifest.toml` to read-only and rw accordingly.",,0,false,0,0,0,0,0,0,0,0,0
3969,Pkg CI does a lot of re-precompiling stdlibs,open,IanButterworth,,,,3,2024-07-25T13:15:06.0,2024-09-26T21:57:30.0,360,296,https://github.com/JuliaLang/Pkg.jl/issues/3969,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3969,![Screenshot 2024-07-25 at 9 14 13 AM](https://github.com/user-attachments/assets/ec9e6737-51dc-49be-9d4e-887332e03c2b)\n\n\nMaybe we're overloading JULIA_DEPOT_PATH and wiping out `@stdlib`?,"[KristofferC]: Maybe https://github.com/JuliaLang/Pkg.jl/pull/3807 was related to this. Not sure. | [IanButterworth]: Ah yeah. This is precompilation being hit from package load, so I do think we need that | [IanButterworth]: It's back\n![Screenshot 2024-09-26 at 5 08 53 PM](https://github.com/user-attachments/assets/16af513b-c77c-4c0c-906c-04e66e3fc2be)\n\n",3,false,0,0,0,0,0,0,0,0,0
4028,Combining regular and weak dependencies for testing purposes,open,maleadt,,,,4,2024-09-25T18:53:24.0,2024-09-26T10:32:03.0,297,297,https://github.com/JuliaLang/Pkg.jl/issues/4028,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4028,"I want to test NNlib.jl, which has a weak dep on CUDA.jl and cuDNN.jl, using my development version of CUDA.jl/cuDNN.jl. This does not seem to work, presumably because of the weakdep.\n\n```\n$ git clone git@github.com:FluxML/NNlib.jl.git NNlib\n\n$ cat NNlib/Project.toml\n[deps]\n# no CUDA or cuDNN\n[weakdeps]\nCUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\ncuDNN = """"02a925ec-e4fe-4b08-9a7e-0d78e3d38ccd""""\n\n$ jl --project=NNlib\n(NNlib) pkg> dev CUDA cuDNN\nPath `/home/tim/Julia/pkg/CUDA` exists and looks like the correct repo. Using existing path.\n    Updating `~/Julia/pkg/NNlib/Project.toml`\n  [052768ef] + CUDA v5.5.1 `~/Julia/pkg/CUDA`\n  [02a925ec] + cuDNN v1.4.0 `~/Julia/pkg/CUDA/lib/cudnn`\n    Updating `~/Julia/pkg/NNlib/Manifest.toml`\n  [052768ef] + CUDA v5.5.1 `~/Julia/pkg/CUDA`\n  [02a925ec] + cuDNN v1.4.0 `~/Julia/pkg/CUDA/lib/cudnn`\n\n$ cat NNlib/Project.toml\n[deps]\nCUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\ncuDNN = """"02a925ec-e4fe-4b08-9a7e-0d78e3d38ccd""""\n[weakdeps]\nCUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\ncuDNN = """"02a925ec-e4fe-4b08-9a7e-0d78e3d38ccd""""\n```\n\nSo far so good. The `]st` output looks confusing though, with no trace of CUDA or cuDNN:\n\n```\n$ jl --project=NNlib\n(NNlib) pkg> st\nProject NNlib v0.9.24\nStatus `~/Julia/pkg/NNlib/Project.toml`\n  [79e6a3ab] Adapt v4.0.4\n  [a9b6321e] Atomix v0.1.0\n  [d360d2e6] ChainRulesCore v1.25.0\n  [46192b85] GPUArraysCore v0.1.6\n  [63c18a36] KernelAbstractions v0.9.27\n  [37e2e46d] LinearAlgebra\n  [9a3f8284] Random\n  [10745b16] Statistics v1.10.0\n```\n\nI guess that may be because it's both a dep and a weakdep, which is weird. The bigger problem however is that testing discards my development versions of CUDA.jl and cuDNN.jl:\n\n```\n$ jl --project=NNlib\n(NNlib) pkg> test\n     Testing NNlib\n      Status `/tmp/jl_p6O4zu/Project.toml`\n# no mention of CUDA or cuDNN\n```\n\nAdding CUDA or cuDNN to the `test` Project.toml doesn't help either; it just picks up the released versions.\n\nI realize that this is a peculiar combination of dependencies, but it does seem impossible right now to test an unreleased version of CUDA.jl with NNlib.jl.\n\nTested on 1.10.","[vchuravy]: I discussed the same situation recently with @KristofferC on Slack, he mentioned that this should be fixed on 1.11, but in my testing it was only fixed in 1.12\n\nBut even though in 1.12 it works by adding CUDA to the deps and removing it from the weakdeps. This kinda breaks `free` for me and I would need to manually move the dependency back to weakdeps.\n\nCrucially this works because on 1.11/1.12 deps will also trigger extensions | [maleadt]: > Crucially this works because on 1.11/1.12 deps will also trigger extensions\n\nCombining `deps` and `extensions` (instead of `weakdeps`) results in an error on 1.11:\n\n```\n❯ cat /tmp/dev/NNlib/Project.toml\n[deps]\nCUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\ncuDNN = """"02a925ec-e4fe-4b08-9a7e-0d78e3d38ccd""""\n\n[weakdeps]\n# no CUDA or cuDNN\n\n[extensions]\nNNlibCUDACUDNNExt = [""""CUDA"""", """"cuDNN""""]\nNNlibCUDAExt = """"CUDA""""\n```\n\n```\nERROR: NNlib has a malformed Project.toml, the extension package CUDA is not listed in [weakdeps]\n```\n\nWorks on 1.12. If this is the blessed way (which still seems a bit hacky), could it be backportable to 1.11.x? | [KristofferC]: > If this is the blessed way (which still seems a bit hacky), could it be backportable to 1.11.x?\n\nYes, we should do that. | [KristofferC]: https://github.com/JuliaLang/julia/pull/54009 and https://github.com/JuliaLang/Pkg.jl/pull/3865 should be backported.",4,false,0,0,0,0,0,0,0,0,0
659,Support for bare git repositories,open,cstjean,,,,6,2018-08-15T15:36:47.0,2024-09-24T09:55:54.0,2530,299,https://github.com/JuliaLang/Pkg.jl/issues/659,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/659,"I'm updating my company's package to 0.7. So far, we've shared our changes in a [bare git repository](http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/), which is accessible in a shared folder over the network. In 0.7, I thought that I could `add /shared/MyPackage.git`, and indeed that works. Unfortunately, `using MyPackage` tells me that it """"does not seem to be installed"""" and recommends `Pkg.instantiate()`. `instantiate` does not seem to do anything, and `st` still shows a red arrow next to my package.\n\nMy understanding is that `add` did not clone the repo. It's assuming incorrectly that `/shared/MyPackage.git` has a working tree, so of course it cannot find `/shared/MyPackage.git/src/MyPackage.jl`.\n\nPerhaps `Pkg` should automatically clone bare git repositories? Or, if that's a bad setup altogether, it should detect it and give a more helpful error message.","[KristofferC]: > Or, if that's a bad setup altogether, it should detect it and give a more helpful error message.\n\nYes, it should verify the tree structure. I think it does that when there is a Project file...? | [cstjean]: If I have a registry with a package `repo` pointing to a (local) bare git repo, that should be fine, right? I get `ERROR: MyPackage: git object a9a6dbcbb364b9309eeb0a977969d4876de6345a should be a tree,not LibGit2.GitCommit` | [KristofferC]: Sounds like you put a git commit instead of the tree sha in the registry? | [cstjean]: That was it, thank you. | [cossio]: Bump. I have the same situation: a package in a bare git repo in a remote server (where a couple of other people push / pull and share the code). On the same remote server I try to `add /path/to/MyPkg.jl.git` and it doesn't work\n\n```\n(@v1.6) pkg> add ~/git/MyPkg.jl.git\nERROR: Did not find a git repository at `/home/cossio/git/MyPkg.jl.git`\n```\n\nIs there a way around this?\n\nAs pointed out by @KristofferC, https://github.com/JuliaLang/Pkg.jl/blob/9f7eaa36cf91dd92762a394c8c1cc6a7faa6986d/src/Types.jl#L692-L693 should be changed. | [filchristou]: I still get the error as described from @cossio.\nAre there any workarounds or guidelines to get it to work?",6,false,0,0,0,0,0,0,0,0,0
2303,Unsatisfiable requirements when changing compat versions of dependencies,open,mohamed82008,,,,5,2020-12-27T05:25:44.0,2024-09-19T08:42:09.0,1666,304,https://github.com/JuliaLang/Pkg.jl/issues/2303,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2303,"I found that I get a seemingly buggy and confusing unsatisfiable requirements error when the following happens. Say I have a package AlgebraicMultigrid.jl (AMG) whose latest version supports IterativeSolvers.jl versions [0.8.3, 0.9). I dev it to update the compat to 0.9 but it is now incompatible with 0.8.3. Note I didn't explicitly install IterativeSolvers, it was pulled as a dependency when installing AMG. So after I update the compat entry for IterativeSolvers in the AMG Project.toml file, I type `] resolve` and I get the following error:\n\n```julia\nERROR: Unsatisfiable requirements detected for package IterativeSolvers [42fd0dbc]:\n IterativeSolvers [42fd0dbc] log:\n ├─possible versions are: [0.7.0-0.7.1, 0.8.0-0.8.5, 0.9.0] or uninstalled\n ├─restricted to versions 0.9 by AlgebraicMultigrid [2169fc97], leaving only versions 0.9.0\n │ └─AlgebraicMultigrid [2169fc97] log:\n │   ├─possible versions are: 0.4.0 or uninstalled\n │   └─AlgebraicMultigrid [2169fc97] is fixed to version 0.4.0\n └─restricted to versions 0.8.4 by an explicit requirement — no versions left\n```\n\nIn particular, the buggy and confusing part is the line `restricted to versions 0.8.4 by an explicit requirement — no versions left` since I never told Pkg to """"restrict"""" IterativeSolvers to 0.8.4. Simply typing `]add IterativeSolvers` installs the correct version, 0.9, and the above error doesn't show again when I resolve. I came across different forms of this error before many times but I could never come up with a minimal example to reproduce and report it. I hope this is helpful.","[KristofferC]: Bug reports about resolver issues pretty much need to also provide `Project.toml`, `Manifest.toml` and the exact Julia version to be actionable. Or at least steps to reproduce those. | [mohamed82008]: Steps to reproduce it in Julia 1.5.3:\n1. `] dev AlgebraicMultigrid`\n2. Change the compat entry for `IterativeSolvers` in AMG's Project.toml file from `IterativeSolvers = """"0.8.3""""` to `IterativeSolvers = """"0.9""""`\n3. Run `] resolve` | [KristofferC]: Right now, `resolve` tries to keep the current versions fixed.\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/b2bc8627c2835e2b78cf7213e034f17130d534ce/src/API.jl#L331\n\nYou could use `update` instead. | [mohamed82008]: Hmm but I don't want to update any of the direct dependencies (the packages in the Project.toml). Does it make sense to only update the indirect deps, or prompt the user to do so instead of throwing the above error? The above error correctly shows up in a different context when I pin the version of a package for example but in this case it's confusing because I didn't pin anything. | [dpinol]: I agree this is an issue. resolve should be able to upgrade dependencies when needed.\nMaybe it only happens with dev dependencies? (which is also my case)\n```\n\nPkg.resolve(; io::IO=stderr)\n\n  Update the current manifest with potential changes to the dependency graph from packages that are tracking a path\n```",5,false,0,0,0,0,0,0,0,0,0
4023,Replacement of relative path in `[sources]` section,open,hexaeder,,,,0,2024-09-18T12:20:21.0,2024-09-18T12:20:21.0,305,305,https://github.com/JuliaLang/Pkg.jl/issues/4023,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4023,"Hello,\n\nI really like the new `[sources]` blocks. However, I noticed that some PKG operations transform relative paths into absolute paths.\n\nFor example, for my doc environment I'd like to put\n```\n[sources]\nMyPkg = {path = """"..""""}\n```\ninto `MyPkg/docs/Project.toml`.\nHowever, after some local doc build/tests, this sometimes gets transformed into\n```\n[sources]\nMyPkg = {path = """"/home/hw/.juila/dev/MyPkg""""}\n```\nwhich is far less portable. I think its only a matter of time until people will commit and push that...",,0,false,0,0,0,0,0,0,0,0,0
3649,Can we automatically run `registry update` if resolve errors with `Unsatisfiable requirements`?,open,NHDaly,,,,7,2023-10-11T19:53:21.0,2024-09-16T19:47:17.0,647,306,https://github.com/JuliaLang/Pkg.jl/issues/3649,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3649,"We probably get around 1-2 of these questions per week within our company, asking something like this:\n> Latest `master` commit is broken for me:\n> ```\n> (RAICode) pkg> build RAICode\n>     Building HTML_Entities → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/c4144ed3bc5f67f595622ad03c0e39fa6c70ccc7/build.log`\n>     Building TimeZones ────→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/5b347464bdac31eccfdbe1504d9484c31645cafc/build.log`\n>     Building RAICode ──────→ `~/deps/build.log`\n> ┌ Warning: Could not use exact versions of packages in manifest, re-resolving\n> └ @ Pkg.Operations /nix/store/9zwcnqc1n40srcmhj3jb311pm7yz52jd-julia-1.9.2/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1809\n> ERROR: Unsatisfiable requirements detected for package ReTestItems [817f1d60]:\n>  ReTestItems [817f1d60] log:\n>  ├─possible versions are: 1.0.0-1.16.0 or uninstalled\n>  └─restricted to versions 1.17.0-1 by RAICode [8f9924a8] — no versions left\n>    └─RAICode [8f9924a8] log:\n>      ├─possible versions are: 0.0.0 or uninstalled\n>      └─RAICode [8f9924a8] is fixed to version 0.0.0\n> ```\n\nThe answer is almost always:\n> you should `]registry up` when you see this kind of error.\n\nand that fixes things.\n\nMy question is:\nWhy can't we automatically run `registry update` when resolving encounters an ERROR with\n`Unsatisfiable requirements detected`?\n\nI know that there's been some work lately to *stop* running registry update so often, but\ndoing so only in the case of an error (and maybe only once per session?) seems like a happy\nmedium?\n","[IanButterworth]: When that happens to the build step for me it's usually because a version in my manifest has been yanked in the registry. \n\nBecause the build step makes a new env like the test env, it does a resolve so it assesses versions that can actually be resolved. \n\nVery few packages (1 in General I think when I last looked) actually use build-only deps in their project, so it has been proposed to just get rid of that feature, which would mean the build can happen in the actual manifest, whether or not things have been yanked. | [IanButterworth]: I guess if there are no build-only deps, we could do a manifest copy without resolve. | [DilumAluthge]: > Very few packages (1 in General I think when I last looked) actually use build-only deps in their project\n\nDo you happen to recall which package (in General)? | [IanButterworth]: Oh there's a few more now https://juliahub.com/ui/Search?type=code&q=Build%20%3D%20%5B&r=true&i=true (turn regex off if it's on) | [NHDaly]: Ah, I should have clarified, I don't think this only happens on `build`. I've also seen people report it when running `test`, and maybe even just when running `resolve`. I'll have to go back through slack and confirm those, but i'm pretty sure it's not specific to build.\n\nAnd registry update really does always resolve it for people - it's just that their local Pkg doesn't know about the upstream versions that we have committed in our project's Manifest.\n\nSo they pull down the latest commit of our application repository, try to build/instantiate/test, and it complains that it can't install the version of the package listed in the manifest, since it doesn't exist! But if only it would go double check with an updated registry, it would find it right there. | [musoke]: I just ran into this again.  The error was\n```\n(Phase) pkg> resolve\nERROR: Unsatisfiable requirements detected for package StatsFuns [4c63d2b9]:\n StatsFuns [4c63d2b9] log:\n ├─possible versions are: 0.7.0-1.3.1 or uninstalled\n └─restricted to versions 1.3.2 by an explicit requirement — no versions left\n```\nThis happened after running `]update` on one machine and then running the code on another.  \n@NHDaly's suggestion of updating the registry before giving up on resolving the versions would have worked. | [NHDaly]: We got a few requests like this in our helpdesk channel just this week as well. We see these every month or so when someone updates a package dependency to a newly released version 👍",7,false,2,2,0,0,0,0,0,0,0
4021,Intermittent failure in Julia's CI `Being precompiled by another process`,open,giordano,,CI,,0,2024-09-14T14:20:33.0,2024-09-14T14:20:33.0,309,309,https://github.com/JuliaLang/Pkg.jl/issues/4021,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4021,"https://buildkite.com/julialang/julia-master/builds/39356#01916fc7-72e1-4fa0-a4ec-777dbc9f53e8/849-967\n\n```\nThe global RNG seed was 0xe2984d951447ff96680f0c93f624a03c.\nError in testset Pkg:\nTest Failed at /cache/build/tester-amdci4-8/julialang/julia-master/julia-bc64d4fe81/share/julia/stdlib/v1.12/Pkg/test/api.jl:213\n  Expression: any(contains(""""Being precompiled by another process (pid: """"), (s1, s2))\n```",,0,false,0,0,0,0,0,0,0,0,0
4019,Restrict the resolver to only consider the latest patch version per major-minor version tuple.,open,lassepe,,,,0,2024-09-10T15:30:06.0,2024-09-10T15:31:12.0,312,312,https://github.com/JuliaLang/Pkg.jl/issues/4019,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4019,"**Motivation**\nConsider package `Foo` at version `0.1.0` which has declared compatibility with `Bar = ^1`. If now `Bar` makes a change in `1.4` that is breaking `Foo` (e.g. because Foo was using """"internals"""" of Bar; maybe because there was a misunderstanding of what the API promises), `Foo` would have to restrict its compat to `Bar = 1-1.3`.\n\n**Current approach**\nThe current way we handle this setting is by making PR's to the registry: https://github.com/JuliaRegistries/General/pulls?q=is%3Apr+label%3A%22compat+fix%22+is%3Aclosed\n\n**Downsides of the current approach**\nWhile the current approach does the job, in my view it is problematic that a package's `Project.toml` does not reflect its true compatibility. I find that very confusing from a user's perspective. This concern is amplified by the fact that a package can be registered in multiple registries and thus suddenly the compatibility depends on the registry the package was installed from. In an ideal world, the package's `Project.toml` should be the single source of truth (wherever possible).\n\n**Desired Behavior**\nRather than relying on edited compat bounds in the registry, it would be nice if a Package author can just release a new patch version with updated compat bounds. In the example above, the author of `Foo` would release `0.1.1` with new compat `Bar = 1-1.3`.\n\n**Proposed Approach**\nIf one currently would attempt to release such a patch version, it would not reliably have the desired effect since Pkg may resolve to `Foo=0.1.0` and `Bar = 1.4` since the old patch release of Foo did not have the constraint on `Bar`.\n\nTo address this issue without relying on manual edits of the registry, we could consider adjusting the `]resolve` logic to only consider the *latest patch version per major-minor version tuple*. That is, the set of versions during `]resolve` should be restricted to `x.y.$(maxpatch(x.y)`. In the example above, this would mean that `Foo=0.1.0` is never considered when `Foo=0.1.1` is released. If the user then tried to install `Bar` without explicit compat constraints, they would automatically get `Bar=1.3`. If the user tried to install `Bar=1.4`, then the resolver would (correctly) throw a compat error.",,0,false,0,0,0,0,0,0,0,0,0
3549,Make `add --weak` automatically create extension entries,open,oscardssmith,,,,6,2023-07-14T15:26:57.0,2024-09-09T02:06:28.0,736,314,https://github.com/JuliaLang/Pkg.jl/issues/3549,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3549,It would be great if there were an easy way to add weakdeps from the repl rather than editing the Project.toml file.,"[aplavin]: Yeah, especially if `add --weak SomePackage` would not only add `SomePackage = ...` to weakdeps, but also `SomePackageExt = SomePackage` to `[extensions]` and `SomePackageExt.jl` to `ext/` with the empty module skeleton. | [liuyxpp]: So if I am not missed anything, currently I still have to edit Project.toml directly to add weak deps? | [oscardssmith]: correct | [IanButterworth]: Technically you can already add weak deps via `--weak`. That's [new in 1.11](https://github.com/JuliaLang/Pkg.jl/pull/3708). What cannot be done is automatically create an extension that depends on them, or add that weak dep to an existing extension. | [IanButterworth]: Proposal here https://github.com/JuliaLang/Pkg.jl/pull/4016 | [liuyxpp]: > Technically you can already add weak deps via `--weak`. That's [new in 1.11](https://github.com/JuliaLang/Pkg.jl/pull/3708). What cannot be done is automatically create an extension that depends on them, or add that weak dep to an existing extension.\n\nThat's great! I just don't want to deal those UUID manually.",6,false,8,8,0,0,0,0,0,0,0
4012,"Strange output with Pkg add on 1.11.0-rc3, after ""failed Task notice; giving up""",open,PallHaraldsson,,,,12,2024-09-03T14:46:13.0,2024-09-05T20:51:07.0,320,317,https://github.com/JuliaLang/Pkg.jl/issues/4012,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4012,"Full log after starting Julia:\n\n```\n(@v1.11) pkg> st\nStatus `~/.julia/environments/v1.11/Project.toml`\n⌃ [992eb4ea] CondaPkg v0.2.20\n  [f878e3a2] OpenCV v4.5.3\n  [69de0a69] Parsers v2.8.1\n  [91a5bcdd] Plots v1.40.8\n  [438e738f] PyCall v1.96.4\n⌃ [6099a3de] PythonCall v0.9.14\n  [33b9d88c] OpenCV_jll v4.6.0+2\n⌅ [3eaa8342] libcxxwrap_julia_jll v0.9.7+3\n  [0dad84c5] ArgTools v1.1.2\nInfo Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`\n\n(@v1.11) pkg> add CondaPkg@v0.2.23\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.11/Project.toml`\n  [992eb4ea] ↑ CondaPkg v0.2.20 ⇒ v0.2.23\n    Updating `~/.julia/environments/v1.11/Manifest.toml`\n  [992eb4ea] ↑ CondaPkg v0.2.20 ⇒ v0.2.23\nPrecompiling project...\n  ✗ CxxWrap\n  ✗ OpenCV_jll\n  ✗ OpenCV\n  1 dependency successfully precompiled in 20 seconds. 197 already precompiled.\n  3 dependencies errored.\n  For a report of the errors see `julia> err`. To retry use `pkg> precompile`\n\njulia> @time using PythonCall\nERROR: InitError: MethodError: no method matching \nStacktrace:\n  [1] __init__()\n    @ REPLExt ~/.julia/juliaup/julia-1.11.0-rc3+0.x64.linux.gnu/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/REPLExt.jl:305\n  [2] \nSYSTEM (REPL): showing an error caused an error\nERROR: TypeError: \nStacktrace:\n  [1] active_module()\n    @ REPL ~/.julia/juliaup/julia-1.11.0-rc3+0.x64.linux.gnu/share/julia/stdlib/v1.11/REPL/src/REPL.jl:593\n  [2] #invokelatest#2\n    @ ./essentials.jl:1054 [inlined]\n  [3] invokelatest\n    @ ./essentials.jl:1051 [inlined]\n  [4] active_module\n    @ ./show.jl:519 [inlined]\n  [5] \nSYSTEM (REPL): caught exception of type TypeError while trying to handle a nested exception; giving up\n\n(@v1.11) pkg> add PythonCall\nERROR: MethodError: no method matching \nSYSTEM: caught exception of type :TypeError while trying to print a failed Task notice; giving up\nERROR: TaskFailedException\nStacktrace:\n  [1] fatal: error thrown and no exception handler available.\nTypeError(func=:typeassert, context="""""""", expected=REPL.AbstractREPL, got=REPL.LineEditREPL(t=REPL.Terminals.TTYTerminal(term_type=""""xterm-256color"""", in_stream=Base.TTY(handle=0x0000000000789c90, status=8, buffer=Base.GenericIOBuffer{GenericMemory{:not_atomic, UInt8, Core.AddrSpace{Core}(0x00)}}(data=Memory{UInt8}(65536, 0xe07dc8)[0x0d, 0x5b, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n...\n\n  #<null>]), file_path=""""/home/pharaldsson/.julia/logs/repl_history.jl"""", history_file=Base.IOStream(handle=0x00007f97df0b2e70, ios=Array{UInt8, 1}(dims=(184,), mem=Memory{UInt8}(184, 0x7f97df0b2e70)[0x90, 0x22, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), name=""""<file /home/pharaldsson/.julia/logs/repl_history.jl>"""", mark=-1, lock=Base.ReentrantLock(locked_by=nothing, reentrancy_cnt=0x00000000, havelock=0x00, cond_wait=Base.GenericCondition{Base.Threads.SpinLock}(waitq=Base.IntrusiveLinkedList{Task}(head=nothing, tail=nothing), lock=Base.Threads.SpinLock(owned=0)), _=(0, 0, 0)), _dolock=true), start_idx=18808, cur_idx=18809, last_idx=-1, last_buffer=Base.GenericIOBuffer{GenericMemory{:not_atomic, UInt8, Core.AddrSpace{Core}(0x00)}}(data=Memory{UInt8}(32, 0x7f97844e7ea8)[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], reinit=false, readable=true, writable=true, seekable=true, append=false, size=0, maxsize=9223372036854775807, ptr=1, offset=0, mark=-1), last_mode=<circular reference @-6>, mode_mapping=Base.Dict{Symbol, REPL.LineEdit.Prompt}(slots=Memory{UInt8}(16, 0x7f97de5df920)[0x00, 0x00, 0x00, 0x96, 0xaf, 0xd0, 0x00, 0x00, 0x00, 0x00, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00], keys=Memory{Symbol}(16, 0x7f97dec03400)[\n  #<null>,\n  #<null>,\n  #<null>,\n  :julia,\n  :help,\n  :pkg,\n  #<null>,\n  #<null>,\n  #<null>,\n  #<null>,\n  :shell,\n  #<null>,\n  #<null>,\n  #<null>,\n  #<null>,\n  #<null>], vals=Memory{REPL.LineEdit.Prompt}(16, 0x7f97dec034a0)[\n  #<null>,\n  #<null>,\n  #<null>,\n  <circular reference @-8>,\n  REPL.LineEdit.Prompt(prompt=REPL.var""""#103#104""""{REPL.LineEditREPL, String}(repl=<circular reference @-14>, prompt=""""help?> """")\n```\n","[favba]: I'm also seeing a very strange error, with a similar error.\nHere is a recording of what happened.\nI hit ctrl+C to stop the error messages. I seems to print it forever if I don't kill it.\n![julia_error](https://github.com/user-attachments/assets/c6792a0c-3099-4d2b-97be-9d668b585d51)\n\n\n | [favba]: Here are the last few errors lines:\n\n```\n...\n  REPL.var""""#97#100""""{REPL.LineEdit.Prompt}(julia_prompt=<circular reference @-9>),\n  #<null>,\n  #<null>,\n  REPL.LineEdit.KeyAlias(seq=""""\b""""),\n  #<null>,\n  #<null>,\n  #<null>,\n  nothing,\n  REPL.LineEdit.var""""#154#210""""(),\n  REPL.LineEdit.KeyAlias(seq=""""\r""""),\n  REPL.LineEdit.var""""#127#183""""(),\n  REPL.LineEdit.var""""#151#207""""(),\n  #<null>,\n  #<null>,\n  REPL.LineEdit.var""""#125#181""""(),\n  #<null>,\n  #<null>,\n  #<null>,\n  nothing,\n  REPL.LineEdit.var""""#158#214""""(),\n  nothing,\n  nothing,\n  REPL.LineEdit.var""""#145#201""""(),\n  nothing,\n  #<null>,\n  #<null>,\n  #<null>,\n  #<null>,\n  REPL.LineEdit.var""""#150#206""""(),\n  #<null>,\n  Base.Dict{Char, Any}(slots=Memory{UInt8}(64, 0x7fa797c8a240)[0xfe, 0x00, 0xca, 0xcd, 0x00, 0x00, 0x00, 0xb9, 0x00, 0xc0, 0xec, 0x00, 0x00, 0x99, 0x00, 0xd9, 0xab, 0x8a, 0x00, 0x00, 0x00, 0xe4, 0x00, 0xb6, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0x00, 0x00, 0xac, 0xb3, 0xba, 0x99, 0x00, 0x00, 0x00, 0xbc, 0xda, 0xff, 0x00, 0x00, 0x00, 0x00, 0xb5, 0xd2, 0x00, 0x00, 0x00, 0x00, 0xe3, 0x00], keys=Memory{Char}(64, 0x7fa797c91a00)[Char(0x6e000000), Char(0x00000000), Char(0x66000000), Char(0x77000000), Char(0x00000001), Char(0x00000000), Char(0x97c91a20), Char(0x64000000), Char(0x97c95e10), Char(0x65000000), Char(0x5b000000), Char(0x00007fa7), Char(0x97c91a20), Char(0x08000000), Char(0x97c91a10), Char(0x3e000000), Char(0x7f000000), Char(0x3c000000), Char(0x8fdbf2f0), Char(0x00007fa7), Char(0x00000001), Char(0x0a000000), Char(0x97c91a60), Char(0x79000000), Char(0x97c95e40), Char(0x74000000), Char(0x8fdc0260), Char(0x00007fa7), Char(0x97c91a60), Char(0x00007fa7), Char(0x4f000000), Char(0x00007fa7), Char(0x00000001), Char(0x00000000), Char(0x8fdbf2f0), Char(0x00007fa7), Char(0x00000001), Char(0x00000000), Char(0x97c91aa0), Char(0x63000000), Char(0x97c95e70), Char(0x00007fa7), Char(0x70000000), Char(0xf48f9fbf), Char(0x57000000), Char(0x6d000000), Char(0x97c91a90), Char(0x00007fa7), Char(0x00000001), Char(0x0d000000), Char(0x2e000000), Char(0x5f000000), Char(0x9907e5e8), Char(0x00007fa7), Char(0x9384dff0), Char(0x00007fa7), Char(0x6c000000), Char(0x75000000), Char(0x00000090), Char(0x00000000), Char(0x00000002), Char(0x00000000), Char(0x62000000), Char(0x00007fa7)], vals=Memory{Any}(64, 0x7fa796ecc680)[\n  REPL.LineEdit.var""""#233#243""""(),\n  #<null>,\n  REPL.LineEdit.var""""#138#194""""(),\n  REPL.LineEdit.var""""#148#204""""(),\n  #<null>,\n  #<null>,\n  #<null>,\n  REPL.LineEdit.var""""#156#212""""(),\n  #<null>,\n  REPL.LineEdit.var""""#172#228""""(),\n  Base.Dict{Char, Any}(slots=Memory{UInt8}(64, 0x7fa797c8a180)[0x00, 0x00, 0x00, 0x00, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x93, 0xdc, 0xc9, 0x00, 0x00, 0xa2, 0xef, 0x9f, 0xc0, 0xf2, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0x00, 0xb3, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], keys=Memory{Char}(64, 0x7fa797c918e0)[Char(0x97c95d20), Char(0x00007fa7), Char(0x8fdc0260), Char(0x00007fa7), Char(0x31000000), Char(0x00007fa7), Char(0x97c918d0), Char(0x00007fa7), Char(0x00000001), Char(0x00000000), Char(0x37000000), Char(0x36000000), Char(0x5a000000), Char(0x00000000), Char(0x97c91920), Char(0x35000000), Char(0x42000000), Char(0x43000000), Char(0x44000000), Char(0x41000000), Char(0x97c91920), Char(0x00007fa7), Char(0x97c91910), Char(0x00007fa7), Char(0x34000000), Char(0x00000000), Char(0x8fdbf2f0), Char(0x00007fa7), Char(0x00000001), Char(0x38000000), Char(0x46000000), Char(0x00007fa7), Char(0x97c95d80), Char(0x00007fa7), Char(0x8fdc0260), Char(0x00007fa7), Char(0x97c91960), Char(0x00007fa7), Char(0x48000000), Char(0x00007fa7), Char(0x00000001), Char(0x00000000), Char(0x8fdbf2f0), Char(0xf48f9fbf), Char(0x39000000), Char(0x00000000), Char(0x97c919a0), Char(0x00007fa7), Char(0x97c95db0)^C, Char(0x00007fa7), Char(0x8fdc0260), Char(0x00007fa7), Char(0x97c919a0), Char(0x00007fa7), Char(0x32000000), Char(0x33000000), Char(0x00000001), Char(0x00000000), Char(0x8fdbf2f0), Char(0x00007fa7), Char(0x00000001), Char(0x00000000), Char(0x97c919e0), Char(0x00007fa7)], fatal: error thrown and no exception handler available.\nInterruptException()\njl_ast_ctx_leave at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/ast.c:319 [inlined]\nijl_is_operator at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/ast.c:998\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1269\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1184\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1184\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1184\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1286\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1184\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1113\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1286\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\njl_static_show_x_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1278\njl_static_show_next_ at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/rtutils.c:1367\nijl_no_exc_handler at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/task.c:693\ntrue_main at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/jlapi.c:907\njl_repl_entrypoint at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/src/jlapi.c:1059\nmain at /cache/build/tester-amdci5-12/julialang/julia-release-1-dot-11/cli/loader_exe.c:58\nunknown function (ip: 0x7fa7a1c56e07)\n__libc_start_main at /usr/lib/libc.so.6 (unknown line)\nunknown function (ip: 0x4010b8)\n``` | [IanButterworth]: Are you loading any packages in your startup.jl? If so disable it? | [favba]: > Are you loading any packages in your startup.jl? If so disable it?\n\nIndeed. I had VimBindings.jl in my `startup.jl` :\n```julia\nif isinteractive()\n    @eval using VimBindings\nend\n```\nDisabling it fixes the issue. | [IanButterworth]: I tried to investigate but VimBindings doesn't work on master\n```\n% ./julia -ie """"using VimBindings""""\nInfo Given VimBindings was explicitly requested, output will be shown live\nWARNING: Method definition (::Type{Base.Dict{K, V} where V where K})(Base.RegexMatch{S} where S<:AbstractString) in module Base at regex.jl:304 overwritten in module Parse at /Users/ian/.julia/packages/VimBindings/7dPgl/src/parse.jl:183.\nERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n  ? VimBindings\n[ Info: Precompiling VimBindings [51b3953f-5e5d-4a6b-bd62-c64b6fa1518a]\nWARNING: Method definition (::Type{Base.Dict{K, V} where V where K})(Base.RegexMatch{S} where S<:AbstractString) in module Base at regex.jl:304 overwritten in module Parse at /Users/ian/.julia/packages/VimBindings/7dPgl/src/parse.jl:183.\nERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n┌ Info: Skipping precompilation due to precompilable error. Importing VimBindings [51b3953f-5e5d-4a6b-bd62-c64b6fa1518a].\n└   exception = Error when precompiling module, potentially caused by a __precompile__(false) declaration in the module.\nERROR: LoadError: InitError: LoadError: UndefVarError: `TextInterface` not defined in `REPL`\nSuggestion: check for spelling errors or missing imports.\nStacktrace:\n  [1] getproperty(x::Module, f::Symbol)\n    @ Base ./Base.jl:42\n  [2] top-level scope\n    @ ~/.julia/packages/VimBindings/7dPgl/src/lineeditalt.jl:163\n  [3] include(mod::Module, _path::String)\n    @ Base ./Base.jl:582\n  [4] include\n    @ ~/.julia/packages/VimBindings/7dPgl/src/VimBindings.jl:9 [inlined]\n  [5] __init__()\n    @ VimBindings ~/.julia/packages/VimBindings/7dPgl/src/VimBindings.jl:46\n```\n\nWhich is known https://github.com/caleb-allen/VimBindings.jl/issues/98 | [favba]: > I tried to investigate but VimBindings doesn't work on master\n> \n> ```\n> % ./julia -ie """"using VimBindings""""\n> Info Given VimBindings was explicitly requested, output will be shown live\n> WARNING: Method definition (::Type{Base.Dict{K, V} where V where K})(Base.RegexMatch{S} where S<:AbstractString) in module Base at regex.jl:304 overwritten in module Parse at /Users/ian/.julia/packages/VimBindings/7dPgl/src/parse.jl:183.\n> ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n>   ? VimBindings\n> [ Info: Precompiling VimBindings [51b3953f-5e5d-4a6b-bd62-c64b6fa1518a]\n> WARNING: Method definition (::Type{Base.Dict{K, V} where V where K})(Base.RegexMatch{S} where S<:AbstractString) in module Base at regex.jl:304 overwritten in module Parse at /Users/ian/.julia/packages/VimBindings/7dPgl/src/parse.jl:183.\n> ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n> ┌ Info: Skipping precompilation due to precompilable error. Importing VimBindings [51b3953f-5e5d-4a6b-bd62-c64b6fa1518a].\n> └   exception = Error when precompiling module, potentially caused by a __precompile__(false) declaration in the module.\n> ERROR: LoadError: InitError: LoadError: UndefVarError: `TextInterface` not defined in `REPL`\n> Suggestion: check for spelling errors or missing imports.\n> Stacktrace:\n>   [1] getproperty(x::Module, f::Symbol)\n>     @ Base ./Base.jl:42\n>   [2] top-level scope\n>     @ ~/.julia/packages/VimBindings/7dPgl/src/lineeditalt.jl:163\n>   [3] include(mod::Module, _path::String)\n>     @ Base ./Base.jl:582\n>   [4] include\n>     @ ~/.julia/packages/VimBindings/7dPgl/src/VimBindings.jl:9 [inlined]\n>   [5] __init__()\n>     @ VimBindings ~/.julia/packages/VimBindings/7dPgl/src/VimBindings.jl:46\n> ```\n\nYes. I see there is an open issue on [that](https://github.com/caleb-allen/VimBindings.jl/issues/98)\n\n@PallHaraldsson , were you also using VimBindings.jl ?\nIf not, then my issue was different than yours... | [caleb-allen]: > I'm also seeing a very strange error, with a similar error.\n> Here is a recording of what happened.\n\n@favba is there a particular sequence of keys which resulted in this error loop? Also, what terminal and OS are you using? I haven't dug into 1.12, but it'd be particularly concerning if VimBindings is causing this on the 1.11 RC. | [IanButterworth]: I think there are at least two issues here:\n1) Something to do with VimBindings interacting with REPL internals that may have changed\n2) The way we load Pkg via a task now when requesting the pkg repl should have better error state handling if it fails | [favba]: > > I'm also seeing a very strange error, with a similar error.\n> > Here is a recording of what happened.\n> \n> @favba is there a particular sequence of keys which resulted in this error loop? Also, what terminal and OS are you using? I haven't dug into 1.12, but it'd be particularly concerning if VimBindings is causing this on the 1.11 RC.\n\nIn order to trigger the error I have to first start the Pkg REPL with `]`. It then throws the `SYSTEM: caught exception of type :TypeError while trying to print a failed Task notice; giving up` error.\n\nAfter that, I exit the Pkg REPL mode and type any function, the infinite error msg happens after I type the opening bracket `(` for the function.\n\nI'm using the foot terminal v1.18.1 on Arch linux with zen kernel v6.10.8 | [PallHaraldsson]: >@PallHaraldsson , were you also using VimBindings.jl ?\n>If not, then my issue was different than yours...\n\nNo I wasn't. I've never had a problem with my startup.jl, if that's even the cause here, first on 1.11. And there's basically nothing in it, first line some old test I forgot in there...\n\n```\n1+2\nENV[""""JULIA_PKG_PRESERVE_TIERED_INSTALLED""""] = true\n```\n\nThis seems to have been the problem (I may have been deving the package, but then only to try to disable some stuff, to reduce startup time:\n\n```\njulia> @time using PythonCall\nERROR: InitError: MethodError: no method matching \n..\nSYSTEM (REPL): caught exception of type TypeError while trying to handle a nested exception; giving up\n```\n\nWhile I didn't until:\n```\n(@v1.11) pkg> add PythonCall\nERROR: MethodError: no method matching\n```\n\nI probably should have made the issue at julialang, since I'm not/no longer sure, kg> add triggered it. Can somebody move it over there? | [IanButterworth]: Seems like a PythonCall issue with something async that it starts during `__init__()` then?\n\nAt least, if this should go to the julia repo it needs a clearer name / diagnosis. | [PallHaraldsson]: >Seems like a PythonCall issue with something async that it starts during __init__() then?\n\nNo, I don't see any async used (unless if a dependency of it and I also ruled out in CondaPkg), except for `@async write` in code I wouldn't have used:\n\nhttps://github.com/JuliaPy/PythonCall.jl/blob/a61c0223a60b803016e51a0dde39371222abf773/pysrc/juliacall/ipython.py#L86\n\nso I'm back to thinking this is Pkg related, completely unrelated to PythonCall.",12,false,0,0,0,0,0,0,0,0,0
4006,"`ResolverError` coloring should be decided in `showerror`, not on construction",open,danielwe,,,,1,2024-08-27T20:37:05.0,2024-08-29T05:08:06.0,326,325,https://github.com/JuliaLang/Pkg.jl/issues/4006,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/4006,"A `ResolverError` has color hardcoded in the message if `stderr` supports color, as the message is formatted on construction using the following function:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/8b2c0f32939042e5d77da05d2825de6ec56487e9/src/Resolve/graphtype.jl#L571-L576\n\nThis is unfortunate when the error message isn't actually printed to `stderr`, for example in Pluto:\n\n![image](https://github.com/user-attachments/assets/ba132ea4-7072-4a45-a84e-22bd047e4b02)\n\nPerhaps it would be better to store data rather than a preformatted message in the `ResolverError` object, and only format the message in the `showerror(io, ::ResolverError)` method, with or without color depending on `io`.",[danielwe]: The most straightforward solution here is perhaps to use 1.11's new StyledStrings stdlib,1,false,0,0,0,0,0,0,0,0,0
3557,Extension module is missing from the cache,open,jishnub,,,,6,2023-07-27T08:00:40.0,2024-08-19T17:55:12.0,724,334,https://github.com/JuliaLang/Pkg.jl/issues/3557,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3557,"In https://github.com/JuliaApproximation/ApproxFunBase.jl/pull/506, I am trying to move `Statistics` and `SparseArrays` to weak deps loaded through extensions, and I test downstream packages against this PR. However, I [obtained the following warning](https://github.com/JuliaApproximation/ApproxFunBase.jl/actions/runs/5677433632/job/15385743586?pr=506) during precompilation of the downstream package `ApproxFunOrthogonalPolynomials`:\n```julia\n┌ ApproxFunBaseSparseArraysExt [2448fcf3-777e-5e57-899e-a100cfbe46a1]\n│  ┌ Warning: Module ApproxFunBaseSparseArraysExt with build ID ffffffff-ffff-ffff-0000-0056a0f5e447 is missing from the cache.\n│  │ This may mean ApproxFunBaseSparseArraysExt [2448fcf3-777e-5e57-899e-a100cfbe46a1] does not support precompilation but is imported by a module that does.\n│  └ @ Base loading.jl:1793\n│  ┌ Error: Error during loading of extension ApproxFunBaseSparseArraysExt of ApproxFunBase, use `Base.retry_load_extensions()` to retry.\n│  │   exception =\n│  │    1-element ExceptionStack:\n│  │    Declaring __precompile__(false) is not allowed in files that are being precompiled.\n│  │    Stacktrace:\n│  │      [1] _require(pkg::Base.PkgId, env::Nothing)\n│  │        @ Base ./loading.jl:1797\n│  │      [2] _require_prelocked(uuidkey::Base.PkgId, env::Nothing)\n│  │        @ Base ./loading.jl:1660\n│  │      [3] _require_prelocked(uuidkey::Base.PkgId)\n│  │        @ Base ./loading.jl:1658\n│  │      [4] run_extension_callbacks(extid::Base.ExtensionId)\n│  │        @ Base ./loading.jl:1255\n│  │      [5] run_extension_callbacks(pkgid::Base.PkgId)\n│  │        @ Base ./loading.jl:1290\n│  │      [6] run_package_callbacks(modkey::Base.PkgId)\n│  │        @ Base ./loading.jl:1124\n│  │      [7] _require_prelocked(uuidkey::Base.PkgId, env::String)\n│  │        @ Base ./loading.jl:1667\n│  │      [8] macro expansion\n│  │        @ ./loading.jl:1648 [inlined]\n│  │      [9] macro expansion\n│  │        @ ./lock.jl:267 [inlined]\n│  │     [10] require(into::Module, mod::Symbol)\n│  │        @ Base ./loading.jl:1611\n│  │     [11] include\n│  │        @ ./Base.jl:457 [inlined]\n│  │     [12] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String)\n│  │        @ Base ./loading.jl:2049\n│  │     [13] top-level scope\n│  │        @ stdin:3\n│  │     [14] eval\n│  │        @ ./boot.jl:370 [inlined]\n│  │     [15] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n│  │        @ Base ./loading.jl:1903\n│  │     [16] include_string\n│  │        @ ./loading.jl:1913 [inlined]\n│  │     [17] exec_options(opts::Base.JLOptions)\n│  │        @ Base ./client.jl:305\n│  │     [18] _start()\n│  │        @ Base ./client.jl:522\n│  └ @ Base loading.jl:1261\n└ \n```\nand a couple of other similar warnings (one for `Statistics` and one for `ApproxFunOrthogonalPolynomials`). I am unsure about what leads to this warning, although it might be related to the fact that the package is `dev`ed while testing.\n\nIn case it matters, [this is the CI script](https://github.com/JuliaApproximation/ApproxFunBase.jl/blob/master/.github/workflows/downstream.yml) that is used to initiate the test","[IanButterworth]: Seems like https://github.com/JuliaLang/Pkg.jl/issues/3571 which is fixed on master and should be fixed in 1.9.4 (it's in the Pkg bump in https://github.com/JuliaLang/julia/pull/50977) | [jishnub]: This is not fixed on v1.9.4 or v1.10.0, but will possibly be resolved by https://github.com/JuliaLang/julia/pull/52841. Reopening until that is merged. | [IanButterworth]: That is a different issue to the one above, which doesn't appear have multiple exts that each depend on packages in the sysimage.\n\nIf the issue is only happening once you add the above packages to the sysimage, then the other issue is also enough to track this | [jishnub]: Can confirm that this is fixed by https://github.com/JuliaLang/julia/pull/52841 | [jishnub]: Oddly, this doesn't seem to be resolved yet, and I am being able to replicate the issue on v1.10.2. The message is\n```julia\n┌ ApproxFunBase → ApproxFunBaseSparseArraysExt\n│  ┌ Warning: Module ApproxFunBaseSparseArraysExt with build ID ffffffff-ffff-ffff-0000-003639e1cc73 is missing from the cache.\n│  │ This may mean ApproxFunBaseSparseArraysExt [2448fcf3-777e-5e57-899e-a100cfbe46a1] does not support precompilation but is imported by a module that does.\n│  └ @ Base loading.jl:1948\n│  ┌ Error: Error during loading of extension ApproxFunBaseSparseArraysExt of ApproxFunBase, use `Base.retry_load_extensions()` to retry.\n│  │   exception =\n│  │    1-element ExceptionStack:\n│  │    Declaring __precompile__(false) is not allowed in files that are being precompiled.\n│  │    Stacktrace:\n│  │      [1] _require(pkg::Base.PkgId, env::Nothing)\n│  │        @ Base ./loading.jl:1952\n│  │      [2] __require_prelocked(uuidkey::Base.PkgId, env::Nothing)\n│  │        @ Base ./loading.jl:1812\n│  │      [3] #invoke_in_world#3\n│  │        @ ./essentials.jl:926 [inlined]\n│  │      [4] invoke_in_world\n│  │        @ ./essentials.jl:923 [inlined]\n│  │      [5] _require_prelocked\n│  │        @ ./loading.jl:1803 [inlined]\n│  │      [6] _require_prelocked\n│  │        @ ./loading.jl:1802 [inlined]\n│  │      [7] run_extension_callbacks(extid::Base.ExtensionId)\n│  │        @ Base ./loading.jl:1295\n│  │      [8] run_extension_callbacks(pkgid::Base.PkgId)\n│  │        @ Base ./loading.jl:1330\n│  │      [9] run_package_callbacks(modkey::Base.PkgId)\n│  │        @ Base ./loading.jl:1164\n│  │     [10] __require_prelocked(uuidkey::Base.PkgId, env::String)\n│  │        @ Base ./loading.jl:1819\n│  │     [11] #invoke_in_world#3\n│  │        @ ./essentials.jl:926 [inlined]\n│  │     [12] invoke_in_world\n│  │        @ ./essentials.jl:923 [inlined]\n│  │     [13] _require_prelocked(uuidkey::Base.PkgId, env::String)\n│  │        @ Base ./loading.jl:1803\n│  │     [14] macro expansion\n│  │        @ ./loading.jl:1790 [inlined]\n│  │     [15] macro expansion\n│  │        @ ./lock.jl:267 [inlined]\n│  │     [16] __require(into::Module, mod::Symbol)\n│  │        @ Base ./loading.jl:1753\n│  │     [17] #invoke_in_world#3\n│  │        @ ./essentials.jl:926 [inlined]\n│  │     [18] invoke_in_world\n│  │        @ ./essentials.jl:923 [inlined]\n│  │     [19] require(into::Module, mod::Symbol)\n│  │        @ Base ./loading.jl:1746\n│  │     [20] include\n│  │        @ ./Base.jl:495 [inlined]\n│  │     [21] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String)\n│  │        @ Base ./loading.jl:2222\n│  │     [22] top-level scope\n│  │        @ stdin:3\n│  │     [23] eval\n│  │        @ ./boot.jl:385 [inlined]\n│  │     [24] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n│  │        @ Base ./loading.jl:2076\n│  │     [25] include_string\n│  │        @ ./loading.jl:2086 [inlined]\n│  │     [26] exec_options(opts::Base.JLOptions)\n│  │        @ Base ./client.jl:316\n│  │     [27] _start()\n│  │        @ Base ./client.jl:552\n│  └ @ Base loading.jl:1301\n└  \n┌ ApproxFunBase → ApproxFunBaseStatisticsExt\n│  ┌ Warning: Module ApproxFunBaseStatisticsExt with build ID ffffffff-ffff-ffff-0000-00377536ceb1 is missing from the cache.\n│  │ This may mean ApproxFunBaseStatisticsExt [06f40816-ae97-5315-8130-9e560ff8d968] does not support precompilation but is imported by a module that does.\n│  └ @ Base loading.jl:1948\n│  ┌ Error: Error during loading of extension ApproxFunBaseStatisticsExt of ApproxFunBase, use `Base.retry_load_extensions()` to retry.\n│  │   exception =\n│  │    1-element ExceptionStack:\n│  │    Declaring __precompile__(false) is not allowed in files that are being precompiled.\n│  │    Stacktrace:\n│  │      [1] _require(pkg::Base.PkgId, env::Nothing)\n│  │        @ Base ./loading.jl:1952\n│  │      [2] __require_prelocked(uuidkey::Base.PkgId, env::Nothing)\n│  │        @ Base ./loading.jl:1812\n│  │      [3] #invoke_in_world#3\n│  │        @ ./essentials.jl:926 [inlined]\n│  │      [4] invoke_in_world\n│  │        @ ./essentials.jl:923 [inlined]\n│  │      [5] _require_prelocked\n│  │        @ ./loading.jl:1803 [inlined]\n│  │      [6] _require_prelocked\n│  │        @ ./loading.jl:1802 [inlined]\n│  │      [7] run_extension_callbacks(extid::Base.ExtensionId)\n│  │        @ Base ./loading.jl:1295\n│  │      [8] run_extension_callbacks(pkgid::Base.PkgId)\n│  │        @ Base ./loading.jl:1330\n│  │      [9] run_package_callbacks(modkey::Base.PkgId)\n│  │        @ Base ./loading.jl:1164\n│  │     [10] __require_prelocked(uuidkey::Base.PkgId, env::String)\n│  │        @ Base ./loading.jl:1819\n│  │     [11] #invoke_in_world#3\n│  │        @ ./essentials.jl:926 [inlined]\n│  │     [12] invoke_in_world\n│  │        @ ./essentials.jl:923 [inlined]\n│  │     [13] _require_prelocked(uuidkey::Base.PkgId, env::String)\n│  │        @ Base ./loading.jl:1803\n│  │     [14] macro expansion\n│  │        @ ./loading.jl:1790 [inlined]\n│  │     [15] macro expansion\n│  │        @ ./lock.jl:267 [inlined]\n│  │     [16] __require(into::Module, mod::Symbol)\n│  │        @ Base ./loading.jl:1753\n│  │     [17] #invoke_in_world#3\n│  │        @ ./essentials.jl:926 [inlined]\n│  │     [18] invoke_in_world\n│  │        @ ./essentials.jl:923 [inlined]\n│  │     [19] require(into::Module, mod::Symbol)\n│  │        @ Base ./loading.jl:1746\n│  │     [20] include\n│  │        @ ./Base.jl:495 [inlined]\n│  │     [21] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String)\n│  │        @ Base ./loading.jl:2222\n│  │     [22] top-level scope\n│  │        @ stdin:3\n│  │     [23] eval\n│  │        @ ./boot.jl:385 [inlined]\n│  │     [24] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n│  │        @ Base ./loading.jl:2076\n│  │     [25] include_string\n│  │        @ ./loading.jl:2086 [inlined]\n│  │     [26] exec_options(opts::Base.JLOptions)\n│  │        @ Base ./client.jl:316\n│  │     [27] _start()\n│  │        @ Base ./client.jl:552\n│  └ @ Base loading.jl:1301\n└  \n``` \nI obtain a similar warning on v1.11.0-beta1. \n\nI have uploaded the project and manifest files at https://github.com/jishnub/ApproxFunBase.jl/tree/extensionserror, so it should hopefully be easy to reproduce. | [jishnub]: Update: using julia v1.11.0-rc2, I find\n```julia\n┌ Warning: Circular dependency detected. Precompilation will be skipped for:\n│   Base.PkgId(Base.UUID(""""2448fcf3-777e-5e57-899e-a100cfbe46a1""""), """"ApproxFunBaseSparseArraysExt"""")\n│   Base.PkgId(Base.UUID(""""06f40816-ae97-5315-8130-9e560ff8d968""""), """"ApproxFunBaseStatisticsExt"""")\n└ @ Base.Precompilation precompilation.jl:552\nPrecompiling project...\n  56 dependencies successfully precompiled in 52 seconds. 37 already precompiled. 2 skipped due to circular dependency.\n```\nI wonder if this is because some of the dependencies have `SparseArrays` and `Statistics` as hard dependencies? So the chain might go `ApproxFunBase -> DSP -> Statistics -> ApproxFunBaseStatisticsExt -> ApproxFunBase`, therefore creating a cycle?",6,false,0,0,0,0,0,0,0,0,0
3998,"Julia Pkg docs specify that base packages should not have version numbering, but Julia development does not do this",open,AhmedSalih3d,,,,0,2024-08-17T05:49:15.0,2024-08-17T05:49:15.0,337,337,https://github.com/JuliaLang/Pkg.jl/issues/3998,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3998,"Sorry for the bad title, best I could come up with. \n\nThe Julia language manual specifies that base packages should not have version numbers, but the new approach to version numbering cancels that. See thread here for full information:\n\nhttps://github.com/JuliaTesting/Aqua.jl/issues/294#issuecomment-2293874675\n\nRelevant links:\n\nhttps://discourse.julialang.org/t/psa-compat-requirements-in-the-general-registry-are-changing/104958\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/managing-packages.md\n\n![image](https://github.com/user-attachments/assets/1c3dab13-00b6-4cbd-af01-042a93800d93)\n\nShould one consider mentioning with a warning box or something, that version number system is being updated in the official manual as well i.e. the discourse post content put it in, in some way?\n\nKind regards",,0,false,0,0,0,0,0,0,0,0,0
3996,Progress bar thinks displaysize width is always 80,open,KristofferC,,,,0,2024-08-15T13:52:44.0,2024-08-15T13:52:44.0,339,339,https://github.com/JuliaLang/Pkg.jl/issues/3996,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3996,Ref https://github.com/JuliaLang/julia/issues/34721,,0,false,0,0,0,0,0,0,0,0,0
3991,Fix devved packages actually being used when testing them,open,KristofferC,,,1.11,0,2024-08-13T08:43:32.0,2024-08-13T08:43:32.0,341,341,https://github.com/JuliaLang/Pkg.jl/issues/3991,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3991,https://github.com/JuliaLang/Pkg.jl/pull/3990#issuecomment-2285693587,,0,false,0,0,0,0,0,0,0,0,0
3989,Incorrect resolution of local path dependencies included with `[source]` in a root project setup,open,JanisErdmanis,,,,1,2024-08-12T15:30:32.0,2024-08-12T18:17:01.0,341,341,https://github.com/JuliaLang/Pkg.jl/issues/3989,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3989,"There seems to be an oversight in the implementation of `[sources]` for the local path and its interaction with a workflow that uses a root project. In particular, I have a temporary dependency put within the existing package `ShuffleProofs`, and I have the following `[sources]` section:\n```\n[sources]\nSigmaProofs = {path = """"SigmaProofs""""}        \n```\nWhen activating the project at `ShuffleProofs,` the dependency is correctly located, indicating that the setup is done accurately. \n\nI use the root project setup extensively and have the following directory structure:\n```\n├── AppBundler\n├── CryptoGroups\n├── CryptoPRG\n├── CryptoSignatures\n├── HistoryTrees\n├── Manifest.toml\n├── PeaceFounder\n├── PeaceFounderAdmin\n├── PeaceFounderClient\n├── PeaceFounderCompiled\n├── PeaceFounderDemo\n├── Project.toml\n├── ShuffleProofs\n├── TallyProofs\n└── [peacefounder.org](http://peacefounder.org/)\n```\nwhere every dependency is added with `dev` in the project. When I activate this root project and load `ShuffleProofs`, it tries to find `SigmaProofs` in the wrong location:\n```\n(Github) pkg> test ShuffleProofs\n     Testing ShuffleProofs\nERROR: expected package `SigmaProofs [f8559b4c]` to exist at path `/Users/jerdmanis/BtSync/PeaceFounder/Github/SigmaProofs\n```\nwhere instead, it should be located at `/Users/jerdmanis/BtSync/PeaceFounder/Github/ShuffleProofs/SigmaProofs`.  For now, I have resolved the situation by making a soft link in the root project.",[KristofferC]: Maybe dup of https://github.com/JuliaLang/Pkg.jl/issues/3842,1,false,0,0,0,0,0,0,0,0,0
3842,Bug in relative paths in `[sources]`,open,KristofferC,,,,0,2024-03-13T16:04:58.0,2024-08-12T18:16:54.0,493,341,https://github.com/JuliaLang/Pkg.jl/issues/3842,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3842,"IIUC, currently, all relative paths for packages (`pkg.path`) are considered relative to the manifest file. But in cases they are provided by a `[sources]` entry they should in fact be treated relative to the project file. This only matters if the project and manifest file are in different directories. That situation can occur when using the `manifest = ` entry in the project file or when using the subproject functionality in #3841.\n\nThis is a bit annoying because I think it means we need to remember from where the path entry was retrieved.",,0,false,0,0,0,0,0,0,0,0,0
2194,"Add ability for packages to be ""unlisted"" in registry",open,oxinabox,,,,16,2020-11-07T15:22:51.0,2024-07-20T05:54:51.0,1715,365,https://github.com/JuliaLang/Pkg.jl/issues/2194,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2194,"Idea: \nWe should add a field in the registry for to mark packages as """"unlisted"""".\nThis can be applied to abandoned packages, or to packages that gave been deprecated  or renamed.\n\nThe effect of this woud be to make it so that `pkg> add ...` REPL does not tab-complete to that name.\nPossibly some other things might like to use it, e.g. JuliaObserver, or JuliaHub might do something with it.\n\nTo go beyond this, perhaps we could have a free text field that the unlisting reason could be given.\nWhich would be displayed when people directly call `pkg> add`.\nAnd that could give a warning message explaing e.g. that it was renamed and that other one should be installed instead,\nor that it has been discontinued and a good alternative might be...\nSuch a message would not be displayed when it is added indirectly.\n\nNaming things is hard, so perhaps this should be `listed = false` or `visiblity = supressed`,\nor even `unlisted-message = """"Reason this is unlisted""""` and if not present then it is listed.\n or something.\n","[StefanKarpinski]: I like `listed = false` but we could also have something like `status = """"deprecated""""`. | [KristofferC]: Maybe `deprecated = true`. | [oxinabox]: Another use of this is that registry CI should ignoring unlisted entries for purposes of checking for too similar names.\n\nMaybe even if two packages are registered with the same name but one is unlisted it should not present the menu to chose them | [StefanKarpinski]: I think all of that falls under the concept of """"deprecated"""". Although at that point, it feels like we may want to just split deprecated packages into a `Deprecated` registry. I believe that any client using the pkg protocol will install all the registries that the pkg server advertises, so we could introduce more registries pretty smoothly. | [oxinabox]: Is it ok that packages in a Deprecated registry would depend on packages in the General registry *and* packages in the General registry would depend on packages in the Deprecated registry?\nI think that works fine?\n\n---\nOne problem i have with the word deprecated is to me it implies there is a replacement.\n""""X is deprecated in favour of Y"""".\nBut for some things they might be unlisted without replacement.\nLike if everyone decided it was a terrible idea.\nOr if something is super-buggy and the author admits that, but has no time or interest in fixing it.\n | [KristofferC]: I don't think a deprecation necessarily implies an existing replacement (although that is common).\n\n> Although at that point, it feels like we may want to just split deprecated packages into a Deprecated registry. \n\nThen it would have to be installed by default? Or otherwise you can't instantiate a manfiest with a deprecated package.\n | [Nosferican]: PyPI uses:\n- Inactive\n\nCRAN uses:\n- archived\n- orphan (unmaintained) | [MasonProtter]: I think this would be really good to have. We can allow people to install these packages, but print a big warning whenever they do, and repeat the warning every time they attempt to update their packages. Something like e.g.\n```\n┌ Warning: DataFitting.jl is a deprecated package, it is unmaintained \n| and installing it will cause version conflicts which prevent you from\n| installing modern versions of other packages.\n└ @ Main REPL[7]:1\n``` | [MasonProtter]: An idea raised by @giordano in https://github.com/JuliaRegistries/General/pull/38626#issuecomment-864627898 was to just cap the julia compat version for packages like this so that the offending package becomes invisible on newer versions of julia.\n\nThat seems like a pretty elegant solution that also doesn't need new functionality to be added. | [StefanKarpinski]: That's not great though because you might be trying to run a manifest with a new Julia version and it would work but doesn't only because of fake compat caps. More abstractly, introducing misinformation into the registry doesn't seem ideal: deprecated/unlisted packages might still work, so claiming they don't is just a lie. | [KeithWM]: For me this is a becoming an ever more urgent requirement to keep the Julia language spreading. As time passes, the number of abandonned packages is growing. It is a real pain for newcomers to have to figure out which of the `n` packages that claim to do `x` is the relevant one.\n\nBut with whom does the decision lie to deprecate an entire package? I think leaving it up to the package owners is a poor choice, as they have often abandonned the project. \n\nFor me, a warning would suffice, preferrably pointing to the new package, of course. I think we get into dangerous territory if we start allowing name clashes. | [oxinabox]: Process is not needed to be decided here.  This is the Pkg issue for the feature\nBut implictly because the information is stored in the registry it is a registry maintainer.\nWho would likely merge such a PR if it is from the packages maintainer, or if it is well justified from anyone in the community.\n(after all we can always undo that change) | [ronisbr]: One thing that might help here (at least for newcomers) is to improve the experience when searching for packages. I am not sure how hard it will be to populate the data, but there should be a way to search for packages within REPL. AFAIK, we can only perform this kind of searching online. In REPL, we only have the autocompletion which uses only the package name.\n\nHence, when the user searches for something, they can receive a nice table with the package name, package version, description, and state. The latter would be used for the maintainer to mark the package """"abandoned"""" or something else. Something like this:\n\n```julia\n(@v1.10) pkg> search SatelliteToolboxT*\n Package                             Version              Description                                             Status\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n SatelliteToolboxTle.jl              v1.0.6 (2024-05-22)  Creating, fetching, and parsing TLEs.                   Active\n SatelliteToolboxTransformations.jl  v0.1.8 (2024-05-24)  Transformations for the SatelliteToolbox.jl ecosystem.  Active\n```\n\nOf course, the search should also work on the description field, leading to a better discoverability of the packages.\n\nEDIT: I thought the `desc` field on `Project.toml` is copied to the general registry, but it is not. Hence, this feature would require some modifications. | [KeithWM]: I've never used Pkg's search functionality, nor have I heard other mention it, so I'm not sure how relevant it is.\n\nI often find myself pointed to packages via Google or to solutions on Discourse that later appear to have been superceded by a newer package. And it's not like these are really old posts either.\n\n@oxinabox Indeed the process doesn't have to be defined here, but the solution should be something that also works if the package maintainers are no longer available, willing or able to cooperate. | [ronisbr]: > I've never used Pkg's search functionality, nor have I heard other mention it, so I'm not sure how relevant it is.\n\nThere isn't :) My proposal is to implement one so that we can see the current state of the package, including the last version release date and the state. | [mitiemann]: Would it be possible to get and display update and download statistics for interested users? I would assume that this would often give a good enough indication whether a package is maintained or not. It would also solve the problem of finding the de facto standard package in certain domains. E.g., which AD package is the most common.",16,false,15,15,0,0,0,0,0,0,0
1249,yanked packages cause resolver problems when testing,open,simonbyrne,,,,4,2019-07-10T16:05:24.0,2024-07-17T17:22:08.0,2201,367,https://github.com/JuliaLang/Pkg.jl/issues/1249,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1249,"If a yanked version is used in the Manifest.toml, then Pkg.test will fail when it attempts to resolve test dependencies:\n```\n+ ./julia-1.1/bin/julia --project=@. -e 'using Pkg; Pkg.test()'\n   Testing CLIMA\n Resolving package versions...\nERROR: Unsatisfiable requirements detected for package BinaryProvider [b99e7846]:\n BinaryProvider [b99e7846] log:\n ├─possible versions are: [0.1.0-0.1.5, 0.2.2-0.2.3, 0.2.5-0.2.8, 0.3.0, 0.3.2-0.3.3, 0.4.0-0.4.2, 0.5.0-0.5.4, 0.5.6] or uninstalled\n └─restricted to versions 0.5.5 by an explicit requirement — no versions left\nStacktrace:\n [1] check_constraints(::Pkg.GraphType.Graph) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/GraphType.jl:937\n [2] Pkg.GraphType.Graph(::Dict{Base.UUID,Set{VersionNumber}}, ::Dict{Base.UUID,Dict{Pkg.Types.VersionRange,Dict{String,Base.UUID}}}, ::Dict{Base.UUID,Dict{Pkg.Types.VersionRange,Dict{String,Pkg.Types.VersionSpec}}}, ::Dict{Base.UUID,String}, ::Dict{Base.UUID,Pkg.Types.VersionSpec}, ::Dict{Base.UUID,Pkg.Types.Fixed}, ::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/GraphType.jl:364\n [3] deps_graph(::Pkg.Types.Context, ::Dict{Base.UUID,String}, ::Dict{Base.UUID,Pkg.Types.VersionSpec}, ::Dict{Base.UUID,Pkg.Types.Fixed}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:306\n [4] resolve_versions!(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}, ::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:369\n [5] resolve_versions! at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:315 [inlined]\n [6] #add_or_develop#63(::Array{Base.UUID,1}, ::Symbol, ::Function, ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1172\n [7] add_or_develop at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1156 [inlined]\n [8] (::getfield(Pkg.Operations, Symbol(""""##40#44"""")){Bool,getfield(Pkg.Operations, Symbol(""""##68#70"""")){Pkg.Types.Context,getfield(Pkg.Operations, Symbol(""""##67#69"""")){Pkg.Types.Context,Cmd}},Pkg.Types.Context,Pkg.Types.PackageSpec,Pkg.Types.Context})(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:874\n [9] mktempdir(::getfield(Pkg.Operations, Symbol(""""##40#44"""")){Bool,getfield(Pkg.Operations, Symbol(""""##68#70"""")){Pkg.Types.Context,getfield(Pkg.Operations, Symbol(""""##67#69"""")){Pkg.Types.Context,Cmd}},Pkg.Types.Context,Pkg.Types.PackageSpec,Pkg.Types.Context}, ::String) at ./file.jl:581\n [10] mktempdir at ./file.jl:579 [inlined]\n [11] #with_dependencies_loadable_at_toplevel#38(::Bool, ::Function, ::getfield(Pkg.Operations, Symbol(""""##68#70"""")){Pkg.Types.Context,getfield(Pkg.Operations, Symbol(""""##67#69"""")){Pkg.Types.Context,Cmd}}, ::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:853\n [12] #with_dependencies_loadable_at_toplevel at ./none:0 [inlined]\n [13] #test#66(::Bool, ::Function, ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1319\n [14] #test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:0 [inlined]\n [15] #test#46(::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:198\n [16] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:183 [inlined]\n [17] #test#45 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:180 [inlined]\n [18] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:180 [inlined]\n [19] #test#42 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:177 [inlined]\n [20] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:177\n [21] top-level scope at none:0\n```\n(from https://dev.azure.com/spjbyrne/CLIMA/_build/results?buildId=150)\n\nIf yanking is to be used sparingly, I would be okay with failure here (though would prefer a more informative error message).","[IanButterworth]: Given the frequency in which I've seen CI on a checked-in manifest break during `Pkg.test` like this when a package is yanked, I think we might want to instead of error in the resolver put Pkg into a mode where it is allowed to resolve yanked versions but with a very loud warning.\n\nIf yanking was only done for security reasons then I think erroring like above is reasonable, but arguably `Pkg.instantiate` should also error, which it doesn't.\n\nHowever from what I've seen yanking is most commonly used for tricky compat issues (that I believe there is usually a way around, but that's another discussion).\n\nSo above might look like\n```\n% julia --project=@. -e 'using Pkg; Pkg.test()'\n   Testing Foo\n Resolving package versions...\n-------\nWARNING\n\nThe package manifest has a dependency that has been yanked.\nPkg.test will use this version and respect the manifest, but it is recommended to investigate the yanking and fix the dependency version in manifest {manifest_path}\n\nYanked: Bar v1.2.3\n\n-----\n{The rest of Pkg.status output etc.}\n\n```\n | [DilumAluthge]: Hmmmm, we'd only want to do this in a situation where the user checked their manifest into source control, right? Which is not most cases.\n\nShould we instead have an `allow_yanked_packages` kwarg to `Pkg.test`, defaulting to `false`? Then, on repos where the user checks the manifest into source control, the user could also just specify `allow_yanked_packages=true`? | [IanButterworth]: That sounds good. \n\nI do think we should also add a warning in that case if a yanked package is installed. \n\nAnd the same warning for instantiate, which already installs yanked packages. | [Octogonapus]: I would be fine with an `allow_yanks_packages` kwarg for `Pkg.test` (which defaults to `false`), though I think users should avoid that as much as possible. Yanks can be security issues and I would not want that running in my CI. I also think `Pkg.instantiate` should be made consistent and not install yanked packages (it could also get this kwarg).\n\nIndeed this frustration with yanks comes from too many yanks, and I would support working on those root causes rather than just ignoring yanks and losing that utility. As far as I understand, those root causes are all outside this repository (downgrade CI, yank culture, etc.) and should be tackled separately.",4,false,0,0,0,0,0,0,0,0,0
3953,Document two new ways of specifying test-specific dependencies,open,mgkuhn,,,,0,2024-07-16T17:17:17.0,2024-07-16T17:17:17.0,368,368,https://github.com/JuliaLang/Pkg.jl/issues/3953,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3953,"The [**Test-specific dependencies**](https://pkgdocs.julialang.org/dev/creating-packages/#Test-specific-dependencies) section of the documentation currently only lists two older methods for specifying test-specific dependencies:\n* `[targets]` + `[extras]` in main `Project.toml`\n* `test/Project.toml`: add *only additional* dependencies there\n\nBoth of these older methods have been somewhat unsatisfactory: they only work via special magic applied by `Pkg.test()`, and they do not work if one simply tries to activate a local test environment with `julia --project=test/ runtests.jl`.\n\nFortunately there are now two new, alternative, better ways of solving this problem, which do not rely on special magic applied by `Pkg.test()`, and these finally allow the test folder to be just a normal project:\n\n* [`[source]`](https://pkgdocs.julialang.org/dev/toml-files/#The-[sources]-section) in `test/Project.toml`: under `[deps]` add `ProjectName=UUID` as a dependency and under `[source]` also add `ProjectName={path='..'}` such that the `cd test/ && julia --project` environment finds the project to test in its own parent folder\n* [`[workspace]`](https://pkgdocs.julialang.org/dev/toml-files/#The-[workspace]-section) in `Project.toml`: add `projects = [""""test""""]` such that the test environment finds the project to test in its own parent folder\n\nAt the moment, these new features are still hidden in the [`Project.toml` format description](https://pkgdocs.julialang.org/dev/toml-files/#Project.toml)\n\nIt would be great to have these documented as well under https://pkgdocs.julialang.org/dev/creating-packages/#Test-specific-dependencies \n",,0,false,2,2,0,0,0,0,0,0,0
3553,"Weak dep is required, but not installed message",open,jishnub,,,,3,2023-07-23T08:16:14.0,2024-07-14T14:48:43.0,728,371,https://github.com/JuliaLang/Pkg.jl/issues/3553,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3553,"`LazyArrays` uses `StaticArrays` as a weak dependency, and defines an extension module for it. With this, I obtain\n\n```julia\njulia> using LazyArrays\n\njulia> using StaticArrays\nERROR: ArgumentError: Package StaticArrays [90137ffa-7385-5640-81b9-e52037218182] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\nStacktrace:\n [1] _require(pkg::Base.PkgId, env::String)\n   @ Base ./loading.jl:1774\n [2] _require_prelocked(uuidkey::Base.PkgId, env::String)\n   @ Base ./loading.jl:1660\n [3] macro expansion\n   @ ./loading.jl:1648 [inlined]\n [4] macro expansion\n   @ ./lock.jl:267 [inlined]\n [5] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1611\n\n(LazyArrays) pkg> instantiate\n\njulia> using StaticArrays\nERROR: ArgumentError: Package StaticArrays [90137ffa-7385-5640-81b9-e52037218182] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n[...]\n\n(LazyArrays) pkg> st\nProject LazyArrays v1.4.1\nStatus `~/Dropbox/JuliaPackages/LazyArrays.jl/Project.toml`\n  [4c555306] ArrayLayouts v1.0.13\n  [1a297f60] FillArrays v1.4.2\n  [1914dd2f] MacroTools v0.5.10\n  [a3b82374] MatrixFactorizations v2.0.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays\n\njulia> VERSION\nv""""1.9.2""""\n```\nThis is strange, as for non-weakdeps, this would prompt me to add the package as a dependency.  The suggestion of `instantiate` also makes no difference, as it's not a dependency.\n\n[Project.toml](https://github.com/JuliaArrays/LazyArrays.jl/blob/master/Project.toml)","[timholy]: There's a possible reproducer at https://github.com/aviatesk/JET.jl/pull/648 (unless I'm just being an idiot and not seeing a typo or something). | [KristofferC]: You did have a typo but that does not make you an idiot :) | [timholy]: I had even copy/pasted the name but clearly I didn't get them all.\n\nIt seems like it would be useful to check for small errors. But I note the stacktrace is entirely in Base, and `fuzzyscore` is in `Pkg.Types.FuzzySorting`. Is there any obvious way to implement it?",3,false,0,0,0,0,0,0,0,0,0
3947,`status` can error when the RHS in `[extensions]` does not map to a weak dep,open,KristofferC,,,,1,2024-07-12T09:23:51.0,2024-07-12T09:25:25.0,373,373,https://github.com/JuliaLang/Pkg.jl/issues/3947,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3947,"```\n\n(InlineStrings) pkg> test\n     Testing InlineStrings\n      Status `/private/var/folders/tp/2p4x9ygx48sgsdl1ccg1mp_40000gn/T/jl_XqfzsA/Project.toml`\nERROR: KeyError: key """"ParsersExt"""" not found\nStacktrace:\n  [1] getindex\n    @ ./dict.jl:498 [inlined]\n  [2] status_ext_info(pkg::Pkg.Types.PackageSpec, env::Pkg.Types.EnvCache)\n    @ Pkg.Operations ~/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:2214\n```","[KristofferC]: I had a type where I had\n\n```\n[extensions]\nArrowTypesExt = """"ArrowTypes""""\nParsersExt = """"ParsersExt""""\n```\n\ninstead of `""""Parsers""""`.",1,false,0,0,0,0,0,0,0,0,0
3942,Dont overload `zero` for `VersionWeight`,open,KristofferC,,,,0,2024-07-08T10:51:02.0,2024-07-08T10:51:02.0,377,377,https://github.com/JuliaLang/Pkg.jl/issues/3942,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3942,"Seeing\n\n```\nClosest candidates are:\n  zero(::Type{Union{}}, Any...)\n   @ Base number.jl:310\n  zero(::Type{Missing})\n   @ Base missing.jl:104\n  zero(::Type{Pkg.Resolve.VersionWeight})\n   @ Pkg ~/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Pkg/src/Resolve/versionweights.jl:15\n  ...\n```\n\nis kind of dumb.",,0,false,0,0,0,0,0,0,0,0,0
3939,Improvements to registry status outputs,open,KristofferC,,,,1,2024-07-04T18:16:39.0,2024-07-05T06:04:00.0,380,380,https://github.com/JuliaLang/Pkg.jl/issues/3939,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3939,Say you have an outdated General registry that is not in `DEPOT_PATH[1]`. The following then happens:\n\n- You will install outdated packages\n- `registry status` will show the general registry like everything is ok\n- `registry up` will not update any registries (because not first in depot path).\n\nImprovements would be:\n\n- `registry status` shows the the registry is outdated (can be seen with `Pkg.Registry.pkg_server_registry_info()`)\n- `registry up` does a warning if a registry is outdated and not first in depot path,[fredrikekre]: Could perhaps also group by depot path to make it clear that lower depots are read only?,1,false,0,0,0,0,0,0,0,0,0
3453,Simultaneous writing to manifest_usage on NFS crashes Julia,open,lhupe,,,,5,2023-04-28T14:52:05.0,2024-07-04T08:18:20.0,814,381,https://github.com/JuliaLang/Pkg.jl/issues/3453,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3453,"We are having issues with Julia processes randomly crashing when simultaneously activating environments from different machines that share a NFS file system, due to IO issues when writing to the manifest usage log.\n\nThe error messages  generally look something like this (this particular example is on julia 1.9.0-rc2, but we've been seeing similar issues on different versions):\n```\n  Activating project at `/path/to/project`\n┌ Warning: attempting to remove probably stale pidfile\n│   path = """"/path/to/.julia/logs/manifest_usage.toml.pid""""\n└ @ FileWatching.Pidfile /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/FileWatching/src/pidfile.jl:244\nERROR: LoadError: IOError: stat(RawFD(16)): Unknown system error -116 (Unknown system error -116)\nStacktrace:\n  [1] uv_error\n    @ ./libuv.jl:100 [inlined]\n  [2] stat(fd::RawFD)\n    @ Base.Filesystem ./stat.jl:152\n  [3] stat\n    @ ./filesystem.jl:280 [inlined]\n  [4] close(lock::FileWatching.Pidfile.LockMonitor)\n    @ FileWatching.Pidfile /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/FileWatching/src/pidfile.jl:307\n  [5] mkpidlock(f::Pkg.Types.var""""#51#54""""{String, Dates.DateTime, String}, at::String, pid::Int32; kwopts::Base.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:stale_age,), Tuple{Int64}}})\n    @ FileWatching.Pidfile /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/FileWatching/src/pidfile.jl:84\n  [6] mkpidlock\n    @ /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/FileWatching/src/pidfile.jl:79 [inlined]\n  [7] #mkpidlock#6\n    @ /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/FileWatching/src/pidfile.jl:77 [inlined]\n  [8] mkpidlock\n    @ /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/FileWatching/src/pidfile.jl:77 [inlined]\n  [9] write_env_usage(source_file::String, usage_filepath::String)\n    @ Pkg.Types /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Types.jl:511\n [10] Pkg.Types.EnvCache(env::Nothing)\n    @ Pkg.Types /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Types.jl:366\n [11] EnvCache\n    @ /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Types.jl:345 [inlined]\n [12] add_snapshot_to_undo(env::Nothing)\n    @ Pkg.API /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:2045\n [13] add_snapshot_to_undo\n    @ /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:2041 [inlined]\n [14] activate(path::String; shared::Bool, temp::Bool, io::IOStream)\n    @ Pkg.API /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:1828\n [15] activate(path::String)\n    @ Pkg.API /path/to/.julia/juliaup/julia-1.9.0-rc2+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:1787\n [16] top-level scope\n    @ /path/to/script.jl:2\nin expression starting at /path/to/script.jl:2\n```\nWith the rare exception e.g. when this error occurs while loading a `@require`d package, it's caught by a try-catch block, this error is fatal.\n\n This is espcially annoying on our HPC cluster, as a significant number of jobs don't make it past the first `Pkg.activate`.  \nWe are currently dealing with this by overwriting `Pkg.Types.write_env_usage` at the top of our scripts, but it would be nice to have """"proper"""" way of disabling usage logging in situations where we know it will cause trouble, similar to the options for the REPL history file.","[IanButterworth]: I can't speak to whether this is a Pidfile limitation or a bug (@vtjnash ?), but as a mitigation we may want to just make `write_env_usage` and `Pkg.gc()` not throw but give helpful warnings. | [vtjnash]: This seems rather odd, since `-0x74` isn't a value that function should be capable of returning. All of the codepaths should be returning some value from a list of constants, so that shouldn't be a possible value to see. Perhaps someone could go hook up `uv_fs_get_system_error`, so that we get more complete error information for this case | [JonasIsensee]: According to my quick research `-116` refers to *ESTALE* - stale file handle not so uncommon on NFS filesystems.\nGiven the warning at the beginning of the stacktrace,\nI would assume that closing / deleting the lockfile fails because a different julia process on another machine has already done so an instance before, hence invalidating the cache. | [rojizo]: there is no workaround for this? | [JonasIsensee]: > there is no workaround for this?\n\nThere are different options:\n - Manifest usage is written to the """"first"""" depot in the list of depots. In principle, one can start all cluster jobs with an additional first depot in a `tmp` folder unique to each job. This is probably the cleanest solution. (Not sure about file system usage etc., though)\n \n- Our *solution* is to override the relevant section of code in Pkg by adding\n```\nusing Pkg\nPkg.Types.write_env_usage(source_file::AbstractString, usage_filepath::AbstractString) = nothing\n```\nat the top of every cluster job. This currently solves the problem as well, but should probably not be generally recommended.\n",5,false,4,2,0,0,0,0,0,0,2
911,"SSH auth keys, just very painful outside of ssh-agent.",open,oxinabox,,enhancement,,31,2018-11-16T17:05:12.0,2024-07-03T20:08:57.0,2437,381,https://github.com/JuliaLang/Pkg.jl/issues/911,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/911,"This is a meta-issue for just how problematic it is to try and do anything with SSH auth outside of ssh-agent.\nssh-agent really shouldn't be the only way to do this, or even the standard way.\nThis is kinda an expansion upon https://github.com/JuliaLang/julia/issues/29851\n\n\nIn Pkg3 it shows up in 2 places\n1. If you have a personal registry in `~/.julia/registries` that uses ssh auth\n2. if you dev a package passing in its URL as a `git@url.eg`\n\nI used to be able to produce all these same issues in julia 0.6  if I had a package git repo that was using ssh auth/transport. It is generally less bad in Pkg3, since seperate eviroments and `dev --local` and also `update` not doing `git pull` cuts down on it a lot.\n\nI am just going  to list problems,\nand this can be broken up into sub-issues \n(I feel like some of these already have issues, and those can be cross-refed).\n\nTo be clear I have not managed to successfully use SSH auth since at least julia 0.5.\nBut I did largely stop trying at that point and only started again today.\nFor now, excluding ssh-agent, because for other reasons I don't use that.\neverything works fine for my keys when using the git commandline client\nI have both public key and private key in same folder.\nall are `chmod +400`\n\n## 1. Here are a list of ways of providing the key that it does not work\nand just cause the query message `""""Private key location for 'git@url.eg' : """"` to be asked again\n\nI believe this is probably related to https://github.com/libgit2/pygit2/issues/836\n(but see point 4, no error messages so IDK)\n\n\n- [ ] 1a. Providing any answer to the query message the query for private key location including all combinations of\n    -  relative path, absolute path, or path including ~\n    -  path to `id_rsa` or a path to a key with a less standard name (eg. `id_github_rsa`)\n - Basically, that input never seems to do anythign useful\n\n- [ ] 1b. having your key in `~/.ssh/id_rsa`. This is the SSH default, so it should just work. \n   - Having that key does seem like it sets the default for the query (in that the message changes) but that  doesn't help since any input the the query for location never works\n\n- [ ]  1c. Setting `SSH_PUB_KEY_PATH` and `SSH_KEY_PATH` doesn't work.\n\n- [ ]  1d. specifying the key for the URL `.ssh/config` \n\n\n-----\n\n## Other issues\n\n - [ ] 2. `SSH_PUB_KEY_PATH` and `SSH_KEY_PATH` are not documented.\n  - they are mentioned occationally on Discourse etc.\n  - given they don't work AFAICT, documenting them seems low priority. \n  - This is tracked in https://github.com/JuliaLang/julia/issues/29851\n\n - [ ]  3. the private key location query line does not support `readline` functionality. It is a raw text input and so pressing up inserts control characters. \n     - I assume this is becasue it is inside LibSSH, rather than being a julia input.\n - [ ]  4. No error messages are displayed ever. \n   - I don't really have any good handle on where to start debugging this.\n   - odds are there is something like LibSSH hates something about the format of my key files or some such. Or maybe I make typos in the path. or ... but I can't know\n - [ ] 5. `.ssh/config` is not respected \n     - more breadly that 1d. there are a lot more things you can do in your `.ssh/config` than specify the keys. Like aliasing hostnames and such\n    - This was tracked in  https://github.com/libgit2/libgit2/issues/4338  which has been closed.\n    - SSH config should be the canonical source for how to communicate on SSH. \n    - commandline `git` respects it.\n\n-----\n\nI would appreciate it if people could point me at corresponding sub-issues already open in Pkg3/Julia/LibSSH/LibGit2 etc.\n","[omus]: Thanks for reporting these. Most of these are LibGit2.jl problems or possibly libgit2 problems. | [ExpandingMan]: More of a Julia issue than a Pkg issue, but I just wanted to point out that in light of the above and how quickly `libgit2` moves, it seems pretty important to upgrade `libgit2` as much as possible on each Julia release. | [omus]: I've been wanting to work on this but I haven't had the time lately | [codykrieger]: Per https://github.com/libgit2/pygit2/issues/836#issuecomment-501620594, generating a new SSH key passing `-m PEM` to `ssh-keygen` fixed the `Private key location for 'git@github.com'` issue for me on macOS. | [oxinabox]: > Per libgit2/pygit2#836 (comment), generating a new SSH key passing -m PEM to ssh-keygen fixed the Private key location for 'git@github.com' issue for me on macOS.\n\nWe should detect if a key doesn't have that right and if so give a better message | [bliang26]: It is quite inconvenient when working with registries and repos sitting in an Enterprise GitHub which always requires SSH keys. For now I need to launch julia with `SSH_PUB_KEY_PATH` and `SSH_KEY_PATH` but this can't be a long term solution. Would this be fixed any time soon? | [GunnarFarneback]: For the record, repeated queries for """"Private key location"""" does not necessarily indicate a failure of providing the key as such, only that something, anything, went wrong during authentication. Debugging is tricky but see https://github.com/JuliaLang/Pkg.jl/issues/1516#issuecomment-560794389 for a way of forcing `libssh2` to emit debug messages. Those are not necessarily easy to understand either but at least they may give some hints. | [GunnarFarneback]: I have found `-m PEM` to be necessary also on Windows recently.\n\nEdit:\nNaturally this is a question of version. Specifically `ssh-keygen` is provided by OpenSSH, which in their [release notes](https://www.openssh.com/releasenotes.html) for version 7.8 (2018-08-24) write\n>  * ssh-keygen(1): write OpenSSH format private keys by default\n>   instead of using OpenSSL's PEM format. The OpenSSH format,\n>   supported in OpenSSH releases since 2014 and described in the\n>   PROTOCOL.key file in the source distribution, offers substantially\n>   better protection against offline password guessing and supports\n>   key comments in private keys. If necessary, it is possible to write\n>   old PEM-style keys by adding """"-m PEM"""" to ssh-keygen's arguments\n>   when generating or updating a key.\n\nA key stored in OpenSSL PEM format, which libssh2 understands, can be recognized by starting with\n```\n-----BEGIN RSA PRIVATE KEY-----\n```\nwhereas a key stored in OpenSSH format begins with\n```\n-----BEGIN OPENSSH PRIVATE KEY-----\n```\n | [ExpandingMan]: Perhaps not directly relevant, but I have found that [keychain](https://www.funtoo.org/Keychain) (available on most distros) makes dealing with SSH agents *drastically* simpler.  So much so, in fact,  that this has no longer seemed like much of an issue to me.\n\nStill, it would be great if Pkg could use command-line git which just respects the `~/.ssh/config`, in which case most users should have to do literally nothing. | [tbenst]: I'm just a regular old user with my ssh key sitting in `~/.ssh/id_rsa`. I have no need for `ssh-agent` and no interest in using it. All other programs on my computer have no issues using this (git, ssh, rsync, VScode, etc.).\n\nI'm sure it's nice for `ssh-agent` users to have support out-of-the-box but if anything that should be the opt-in behavior. At least, would be nice to fall back to `~/.ssh/id_rsa`.\n\nJust a small gripe on an otherwise best-in-class package manager! | [ExpandingMan]: There are plenty of """"regular old users"""" who will either have multiple keys in `~/.ssh` or a key there under a different name.  I don't see this as an edge case but an extremely common one for private keys.  Of course, if `libgit2` somehow respected the `.ssh/config`, your `.ssh/id_rsa` would still work (assuming you did not go in and set something wrong in the config).\n\nIt's been quite a long time and I still don't see any solution to this that's any better than using an agent manager like `keychain`.  Certainly it seems totally crazy to expect Pkg to parse `.ssh/config`.  In all likelihood we are just going to be waiting on someone to do something about it in `libgit2`, which would probably involve changing how they call the `ssh` back-end.  The fact that command line `git` works as expected in these cases suggests there must be something that can be done there. | [StefanKarpinski]: Folks, if you have complaints, please open issues on libgit2. If libgit2 does whacky stuff when talking over SSH or doesn't respect your SSH key setups, there's nothing we can do about it. Venting here has zero effect since we are not about to start adding major features to the libgit2 project. These hands are already quite full. | [tbenst]: For what it’s worth, Rust’s package manager can use system git to avoid this issue: https://github.com/rust-lang/cargo/issues/2078#issuecomment-434388584. Cargo has a thread tracking this issue here: https://github.com/rust-lang/cargo/issues/2078\n\nFalling back to system git would seem the most user friendly. It does seem better to have this fixed in libgit2 rather than have everyone write a workaround. | [StefanKarpinski]: I'm working on adding a system git fallback for 1.6, so that might address this. | [ExpandingMan]: Yeah, I don't understand what's going on over in `libgit2` that they don't seem to have the will to do something about this.  It was discussed [in this issue](https://github.com/libgit2/libgit2/issues/4338) but they seem to have closed it despite not coming to any kind of resolution.  Out of curiosity, does anyone know how `git` itself handles this?  I guess from what they're saying in `libgit2` they use `libssh` instead of `libssh2`.  So maybe the can is kicked further down the road and this is actually a `libssh2` issue... | [StefanKarpinski]: My interpretation is that libgit2 is essentially developed by GitHub for GitHub and they don't care about anything that doesn't affect their use cases. In particular, anything regarding end-users using libgit2 on their personal systems is a non-priority for the project. Which is in stark contrast with the git project, where that is the only priority. Perhaps an uncharitable view, but in the years that we've used the library, that seems to be the way things pan out. | [ExpandingMan]: If that's a correct interpretation it sounds like a good reason to abandon it entirely in favor of command line git, if that's practical. | [StefanKarpinski]: I've made the case for that on pkg-dev calls, but there are very legitimate concerns in the other direction:\n\n1. There are many users who many not have any `git` command installed and they should still be able to use the package manager, even for unregistered packages. Shipping Julia with `git` on Windows would be a very heavy-weight, awkward dependency since it requires shipping `bash` and other stuff that `git` uses.\n\n2. Faulty though it is, `libgit2` is what we've been using for a while now and there are lots of people that it *is* working for. If we drop it entirely, then we may break their workflows for the sake of fixing that of others.\n\nSo I think the best approach is probably to use both:\n\n* Try using `libgit2` first and if that works, great.\n* If `libgit2` fails, look for a `git` command and try that instead.\n* Allow people to choose whether to use one or both and in what order.\n\nI'm working on this, but I'm stuck in incredibly tedious stdlibs plumbing work that's necessary just to be able to replace the current ramshackle download functionality with something sane: https://github.com/JuliaLang/julia/pull/37686, https://github.com/JuliaLang/julia/pull/37340, https://github.com/JuliaLang/julia/pull/37611, https://github.com/JuliaLang/julia/pull/37763. All that noise is just to be able to add Downloads and Tar as stdlibs so that we can download and extract things consistently everywhere. Every time someone proposes that they want to add a new stdlib, I just laugh a world-wearied jaded little laugh and think """"if only they had any idea how awful adding stdlibs actually is, they would not think this was a good idea"""". | [KristofferC]: Having the system git as a fallback (or as an option via some kind of configuration) for fetching things from the internet is perfectly fine. However, we use LibGit2 for much more than just that. In those cases, having a proper Julian API with types having nice `show` methods etc makes things much much easier than having to go via system git and using string output from a process to communicate. Constantly launching git executables is also bad for performance (especially on Windows) and IIRC was one of the major reasons for starting using LibGit2 in the package manager at all (back in Pkg2 time).\n\n | [StefanKarpinski]: > However, we use LibGit2 for much more than just that.\n\nGoing forward there are only three things we will be using git for in Pkg as far as I can tell:\n\n1. Acquiring package tarballs from git repos.\n2. Checking out a dev copy of a package.\n3. Updating registries that are git repos.\n\nThe first requires only two very high-level git operations: `git clone --bare` and `git archive`. The second only requires `git clone` and seems fine to just use CLI `git` for since the user needs `git` to interact with the dev'd package anyway; in fact it seems far more likely to cause problems to use `libgit2` for this since it will potentially set up the clone differently than `git` would, causing confusing as soon as the user tries to interact with it via `git`. The third case we could frankly get rid of as soon as I've implemented loading registries directly from tarballs. Having multiple different ways to acquire and install registries doesn't seem ideal. | [StefanKarpinski]: In particular, there are no more situations where we would have to do git operations that don't hit the network (which, slow as exec is on Windows, it's still faster than a network RTT). Yes, we _used_ to do lots of little local git operations, but Pkg3 got rid of all of that. Where do you see us doing that sort of thing anymore? | [KristofferC]: > In particular, there are no more situations where we would have to do git operations that don't hit the network\n\nSome examples: we use it to check if a certain tree hash is in a cached git repo when we add by a branch or commit. We use it for diff support in status output. We use it to checkout a subdir of a repo (https://github.com/JuliaLang/Pkg.jl/blob/f1430b5dbbdeb09236a77faf755275a611690a93/src/Types.jl#L623-L626)\n\nThose lines above are something that I think would be quite a lot harder using the git command line.\n\n> Updating registries that are git repos.\n\n> The third case we could frankly get rid of as soon as I've implemented loading registries directly from tarballs. Having multiple different ways to acquire and install registries doesn't seem ideal.\n\nPeople host their own registries on GitHub or other git host services and I don't think that is a feature we can just break. Having to implement your own Pkg server is a significant step up in complexity over just setting up LocalRegistry.jl, especially since you then have to serve all packages. | [StefanKarpinski]: > People host their own registries on GitHub or other git host services and I don't think that is a feature we can just break. Having to implement your own Pkg server is a significant step up in complexity over just setting up LocalRegistry.jl, especially since you then have to serve all packages.\n\nThat's fine and the tarball can still be acquired from a git repo. The thing I don't want to support is having the registry be a git clone or a tarball locally. I'd prefer to only support it being a tarball. | [GunnarFarneback]: > Those lines above are something that I think would be quite a lot harder using the git command line.\n\nDo they do something significantly different from https://github.com/GunnarFarneback/LocalRegistry.jl/blob/7f26935a56cfc16e9cbed8fe316df5276280cd06/src/LocalRegistry.jl#L339 ? | [msavael]: > \n> \n> I'm working on adding a system git fallback for 1.6, so that might address this.\n\nHi @StefanKarpinski - do you think this is something that could still get into 1.6? | [StefanKarpinski]: No: The 1.6 release has been feature frozen for months and is entering the release candidate phase. Using SSH without using ssh-agent is just a world of pain in general, even outside of libgit2. Fortunately, ssh-agent exists, is excellent, solves all of these problems, and there's no good reason not to use it. | [Gertian]: > Per [libgit2/pygit2#836 (comment)](https://github.com/libgit2/pygit2/issues/836#issuecomment-501620594), generating a new SSH key passing `-m PEM` to `ssh-keygen` fixed the `Private key location for 'git@github.com'` issue for me on macOS.\n\nFor me this : ssh-keygen -m PEM -t ed25519 -C """"your_email@example.com"""" worked.\n | [abhinavsns]: I keep getting: error: GitError(Code:ERROR, Class:SSH, Failed to authenticate SSH session: Unable to open public key file) when giving path to the ssh key file. in the pkg command line `add """"private_repo_path""""` does not work. | [GunnarFarneback]: The easiest way to get around such problems is usually to set the environment variable `JULIA_PKG_USE_CLI_GIT` to `true`. | [abhinavsns]: > The easiest way to get around such problems is usually to set the environment variable `JULIA_PKG_USE_CLI_GIT` to `true`.\n\n`Thanks! that worked` Could you please explain more so that I learn about Julia Pkg.jl? Does it mean that Pkg.jl has it's own git program inside? | [GunnarFarneback]: Reading through the comments in this issue should give some enlightenment. The summary is that Julia internally uses libgit2, which gets its ssh functionality from libssh2, which is infamously less capable than command line ssh. `JULIA_PKG_USE_CLI_GIT` is a workaround for that shortcoming, which didn't exist when this issue was started.\n",31,false,22,13,0,0,0,0,9,0,0
3898,Don't factor JLLs into the resolver decision when multiple update options are possible,open,IanButterworth,,resolver,,8,2024-05-09T16:18:42.0,2024-07-03T19:55:52.0,436,381,https://github.com/JuliaLang/Pkg.jl/issues/3898,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3898,"The package is usually the user-facing version not the JLL.\n\nIn some cases new JLL versions being available can force packages to be downgraded.\n\nFor instance FFMPEG_jll v6.1.1 exists but is incompatible with VideoIO after v1.0.9 (currently), when VideoIO took FFMPEG_jll on as a direct dep (to control compat), so this happens\n```\n(Foo) pkg> up\n    Updating registry at `~/.julia/registries/General.toml`\n   Installed BinaryProvider ─ v0.5.10\n   Installed FFMPEG ───────── v0.2.4\n   Installed FFMPEG_jll ───── v6.1.1+0\n   Installed VideoIO ──────── v1.0.8\n  Downloaded artifact: FFMPEG\n  No Changes to `~/Documents/GitHub/Foo/Project.toml`\n    Updating `~/Documents/GitHub/Foo/Manifest.toml`\n  [b99e7846] + BinaryProvider v0.5.10\n⌃ [c87230d0] ↓ FFMPEG v0.4.1 ⇒ v0.2.4\n⌃ [d6d074c3] ↓ VideoIO v1.1.0 ⇒ v1.0.8\n  [b22a6f82] ↑ FFMPEG_jll v4.4.4+1 ⇒ v6.1.1+0\n```\n\nThis can't cleanly be fixed in the registry too, because before v1.0.9 VideoIO didn't have FFMPEG_jll as a direct dep, so we would have to add deps to old versions, which feels nonideal.\n\n\nOne strategy would be to ignore JLLs when counting the cost of different resolver update paths.\nThe other would be some reduced weighting for JLLs.\n\nI prefer just ignoring JLLs.","[ChrisRackauckas]: I just hit this and agree, the user wants a working Julia package, not the latest JLL. | [IanButterworth]: @carlobaldassi do you think this would be simple to implement? I tried to give it a go but couldn't figure out how to. | [carlobaldassi]: I'll have a look, it might be doable. It would help having a reproducible case for testing though.\nAlso, what's the cleanest way to get the info about whether a package is a JLL into the resolver call? | [IanButterworth]: I think the name suffix is the defining characteristic | [carlobaldassi]: I started looking into this, and in particular I tried to reproduce the issue. As it turns out, I can only reproduce it if I explicitly `add FFMPEG_jll`, whereas if I only install `FFMPEG` and `VideoIO` I get the latest versions of the explicitly required packages and a lower version for the jll, as expected.\n\nThis is on a clean temp environment:\n```\n(jl_OSTqmb) pkg> add FFMPEG VideoIO\n   Resolving package versions...\n    Updating `/tmp/jl_OSTqmb/Project.toml`\n  [c87230d0] + FFMPEG v0.4.1\n  [d6d074c3] + VideoIO v1.1.0\n    Updating `/tmp/jl_OSTqmb/Manifest.toml`\n...other packages...\n⌅ [b22a6f82] + FFMPEG_jll v4.4.4+1\n...other packages...\n```\nCalling `up` doesn't do anything, then installing `FFMPEG_jll` also doesn't change the other packages...\n```\n(jl_OSTqmb) pkg> add FFMPEG_jll\n   Resolving package versions...\n    Updating `/tmp/jl_OSTqmb/Project.toml`\n⌅ [b22a6f82] + FFMPEG_jll v4.4.4+1\n  No Changes to `/tmp/jl_OSTqmb/Manifest.toml`\n```\nOnly calling `up` at this point leads to downgrading `VideoIO` and `FFMPEG`:\n```\n(jl_OSTqmb) pkg> up\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `/tmp/jl_OSTqmb/Project.toml`\n⌃ [c87230d0] ↓ FFMPEG v0.4.1 ⇒ v0.2.4\n⌃ [d6d074c3] ↓ VideoIO v1.1.0 ⇒ v1.0.8\n  [b22a6f82] ↑ FFMPEG_jll v4.4.4+1 ⇒ v6.1.1+0\n    Updating `/tmp/jl_OSTqmb/Manifest.toml`\n  [b99e7846] + BinaryProvider v0.5.10\n⌃ [c87230d0] ↓ FFMPEG v0.4.1 ⇒ v0.2.4\n  [92933f4c] + ProgressMeter v1.10.0\n⌃ [d6d074c3] ↓ VideoIO v1.1.0 ⇒ v1.0.8\n  [b22a6f82] ↑ FFMPEG_jll v4.4.4+1 ⇒ v6.1.1+0\n...other packages...\n```\nSo the idea of """"ignoring JLLs"""" runs against the general idea (that is currently implemented) of giving precedence to explicitly requested packaged. That is: what if I explicitly request a JLL, should its version still be ignored? It would seem a bit strange, no? | [IanButterworth]: When I was seeing this I didn't have FFMPEG_jll as a direct dep and I doubt the reports from the wild do either, it's not a jll people directly dep on, generally. \nNote from my OP ```No Changes to `~/Documents/GitHub/Foo/Project.toml` ```\n```\n(Foo) pkg> up\n    Updating registry at `~/.julia/registries/General.toml`\n   Installed BinaryProvider ─ v0.5.10\n   Installed FFMPEG ───────── v0.2.4\n   Installed FFMPEG_jll ───── v6.1.1+0\n   Installed VideoIO ──────── v1.0.8\n  Downloaded artifact: FFMPEG\n  No Changes to `~/Documents/GitHub/Foo/Project.toml`\n    Updating `~/Documents/GitHub/Foo/Manifest.toml`\n  [b99e7846] + BinaryProvider v0.5.10\n⌃ [c87230d0] ↓ FFMPEG v0.4.1 ⇒ v0.2.4\n⌃ [d6d074c3] ↓ VideoIO v1.1.0 ⇒ v1.0.8\n  [b22a6f82] ↑ FFMPEG_jll v4.4.4+1 ⇒ v6.1.1+0\n```\n\nI'm trying to find a reproducer. I wish I'd included `st`.. | [IanButterworth]: @KristofferC just experienced this where there was no direct dep on `FFMPEG_jll`. Hopefully we can figure out a reproducer | [KristofferC]: This is my repro.\n\nCheckout Plots.jl at f32247a819bc938a133bb34. Then, with that as active project:\n\n```\njulia> using Pkg\n\njulia> Pkg.develop([(;path=""""./RecipesBase""""), (;path=""""./RecipesPipeline""""), (;path=""""./PlotsBase"""")])\n   Resolving package versions...\n    Updating `~/JuliaPkgs/Plots.jl/Project.toml`\n...\n    Updating `~/JuliaPkgs/Plots.jl/Manifest.toml`\n...\n⌃ [c87230d0] + FFMPEG v0.2.4\n...\n\n  \n(Plots) pkg> add FFMPEG@0.4\n   Resolving package versions...\n    Updating `~/JuliaPkgs/Plots.jl/Project.toml`\n  [c87230d0] + FFMPEG v0.4.1\n    Updating `~/JuliaPkgs/Plots.jl/Manifest.toml`\n  [b99e7846] - BinaryProvider v0.5.10\n  [c87230d0] ↑ FFMPEG v0.2.4 ⇒ v0.4.1\n⌅ [b22a6f82] ↓ FFMPEG_jll v6.1.1+0 ⇒ v4.4.4+1\n\njulia> VERSION\nv""""1.10.4""""\n```\n\n",8,false,0,0,0,0,0,0,0,0,0
3937,Bad resolution for SHA in manager,open,jd-lara,,,,0,2024-07-01T23:30:17.0,2024-07-01T23:30:17.0,383,383,https://github.com/JuliaLang/Pkg.jl/issues/3937,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3937,I have this situation in the CI for GitHub where randomly the package manager resolves the SHA version to 1.6.7 even if the available in base version is 0.7. \n\nHere is an example: \n\nhttps://github.com/NREL-Sienna/InfrastructureSystems.jl/actions/runs/9752434390/job/26915911782\n\nThis only happens recurrently in the documenter pipelines.,,0,false,0,0,0,0,0,0,0,0,0
3936,Docstring for `Registry`,open,GHTaarn,,,,0,2024-07-01T01:36:48.0,2024-07-01T01:36:48.0,384,384,https://github.com/JuliaLang/Pkg.jl/issues/3936,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3936,"`Registry` has no docstring (in a recent nightly build). `Registry` is an exported symbol, so I feel that it would be relevant to have a docstring.\n\n<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including:\n\n1. The output of `versioninfo()`\n2. How you installed Julia\n3. A minimal working example (MWE), also known as a minimum reproducible example\n\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n",,0,false,0,0,0,0,0,0,0,0,0
3933,very unsound assumptions about REPL state injection,open,vtjnash,,,,5,2024-06-22T15:39:58.0,2024-06-22T18:59:54.0,392,392,https://github.com/JuliaLang/Pkg.jl/issues/3933,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3933,"This code runs on a thread, which makes this an unsafe data race to call this function:\nhttps://github.com/JuliaLang/Pkg.jl/blob/8c996799b0ae3d6cccf8a5f25744deb6640adb9e/ext/REPLExt/REPLExt.jl#L311-L321\n\nIt is VERY strongly inadvisable to have an `__init__` function defined in this code, due to the unreliability of the environment it runs in, and the corruption this will cause to the REPL module.",[KristofferC]: I'm missing a solution here. This is how external REPL modes are installed AFAIU. | [vtjnash]: You install REPL hooks by calling `empty!`? that doesn't seem very scalable 😭 | [IanButterworth]: `empty!` explained and fixed here https://github.com/JuliaLang/Pkg.jl/pull/3934 | [KristofferC]: > You install REPL hooks by calling empty!\n\nYou linked a much larger piece of code than that single one. | [vtjnash]: The other major mistake here is calling `Base.active_repl` and assuming that returns `REPL.active_repl`,5,false,0,0,0,0,0,0,0,0,0
3146,Feature request: function to precompile all projects,open,cserteGT3,,precompile,,3,2022-07-27T13:00:01.0,2024-06-20T15:50:50.0,1089,394,https://github.com/JuliaLang/Pkg.jl/issues/3146,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3146,"I'm thinking on this feature for a long time: it would be nice, if one could precompile all projects with one function call. It would be useful for example when a new julia version comes out and you want to precompile all projects. It doesn't save time, but saves you from """"surprise"""" precompilation when you play with an older project and forget, that it wasn't used with the new julia version.\n\nI'm planning to work on it and submit a PR, but wanted first to gather opinions on the idea.","[roflmaostc]: As discussed on [Discourse](https://discourse.julialang.org/t/precompilation-after-julia-update/113792/3?u=roflmaostc):\n\n```julia\nusing TOML\nusing Dates\nusing Pkg\n\n""""""""""""\n    precompile_envs(fname="""".julia/logs/manifest_usage.toml""""; \n                    time_diff=Dates.CompoundPeriod(Dates.Day(30)))\n\nPrecompile the environments listed in the TOML file `fname` if the last time they were used is greater than `time_diff`.\n`fname` is the path to the TOML file that contains the information about the last time an environment on your machine was used.\nAs default `time_diff` is set to 30 days. \n\nSo this script precompiles the environments that were used in the last 30 days. \nThis is especially useful to save time after updating Julia.\n\n""""""""""""\nfunction precompile_envs(fname="""".julia/logs/manifest_usage.toml""""; time_diff=Dates.CompoundPeriod(Dates.Day(30)))\n    # Load the project file\n    toml = TOML.parsefile(fname)\n    now = Dates.now()\n\n    # Loop over the keys in the TOML file\n    for key in keys(toml)\n\n        for minor in 1:(Int(VERSION.minor)-1)\n            if occursin(""""/v1.$(minor)/"""", key)\n                continue\n            end\n        end\n        time = toml[key][1][""""time""""]\n\n        try\n            # if time difference greater than time_diff, precompile\n            if now - time < time_diff\n                # Precompile the project if possible and catch errors\n                try\n                    @info """"Precompiling $key""""\n                    Pkg.activate(dirname(key))\n                    Pkg.precompile()\n                catch e\n                end\n                # deactivate the project\n                Pkg.activate()\n            end\n        catch e\n            if isa(e, InterruptException)\n                @info """"Interrupted""""\n                return\n            else\n                rethrow(e)\n            end\n        end\n    end\nend\n``` | [roflmaostc]: Now registered as a small package\n\nhttps://github.com/roflmaostc/PrecompileAfterUpdate.jl | [IanButterworth]: Something you'll want to factor in is that julia only keeps a certain number of cache files around for each package. So if you're precompiling all envs at once, you might be evicting work you just did.\n\nSo you might want to tell the user to increase https://docs.julialang.org/en/v1/manual/environment-variables/#env-max-num-precompile-files in conjunction with using that tool.",3,false,1,1,0,0,0,0,0,0,0
3925,restrict package by version,open,rveltz,,,,2,2024-06-12T15:34:17.0,2024-06-12T15:40:49.0,402,402,https://github.com/JuliaLang/Pkg.jl/issues/3925,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3925,"Hi,\n\nI lost a manifest and I know when I ran some code. Say November 2022. I want to install packages at the latest version given the time uper bound  November 2022.\n\nWould it be possible to do so?\n\nBest regards","[KristofferC]: You can clone the General registry (`.julia/registires`) and check it out at a commit at that time. | [rveltz]: Yes, I was told the same solution on discourse. I merely open this issue to see if there is an interest in a solution within `Pkg`",2,false,0,0,0,0,0,0,0,0,0
3923,Afterimages of the download progress bar,open,kimikage,,,,3,2024-06-11T17:23:29.0,2024-06-12T00:37:51.0,403,403,https://github.com/JuliaLang/Pkg.jl/issues/3923,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3923,"Afterimages of the download progress bar may be visible.\n![progress](https://github.com/JuliaLang/Pkg.jl/assets/12679384/abb3bb10-2565-43c5-bf79-34508e02f15c)\n\nThis is probably due to the redirection. I.e., once the download progress reaches """"100.0 %"""", the actual download restarts from """"0.0 %"""".\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/78bca42272aac3f3b1f9d621a2f995babfc23f2e/src/PlatformEngines.jl#L275-L279\n\n```julia\njulia> versioninfo()\nJulia Version 1.12.0-DEV.706\nCommit e7893a1fa4 (2024-06-11 09:53 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: 8 × 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\n  WORD_SIZE: 64\n  LLVM: libLLVM-17.0.6 (ORCJIT, tigerlake)\nThreads: 1 default, 0 interactive, 1 GC (on 8 virtual cores)\n```\n\nThis bug seems to be old and can be traced back to at least Julia v1.6.7.\n","[IanButterworth]: There's also an overprinting bug around this code somewhere https://github.com/JuliaLang/Pkg.jl/issues/3581 | [kimikage]: Fixing the number of characters in the percentage would solve this problem.\nE.g., use `""""%5.1f %%""""`\nhttps://github.com/JuliaLang/Pkg.jl/blob/78bca42272aac3f3b1f9d621a2f995babfc23f2e/src/MiniProgressBars.jl#L51\n\nAlternatively, a measure to perform line clearing when the value of `max` changes from the last time would also be effective. | [kimikage]: This is off-topic, but the comment below has not been updated and has multiple typos.\nhttps://github.com/JuliaLang/Pkg.jl/blob/78bca42272aac3f3b1f9d621a2f995babfc23f2e/src/MiniProgressBars.jl#L78-L89",3,false,0,0,0,0,0,0,0,0,0
3918,`pkg> registry add https://github.com/staticfloat/General#sf/foo` does not work properly,open,staticfloat,,feature request,,2,2024-06-06T21:57:22.0,2024-06-07T07:18:50.0,408,408,https://github.com/JuliaLang/Pkg.jl/issues/3918,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3918,"Attempting to add a specific branch of a registry using the same form as `add` for a package results in cloning the right repository, but with an invalid fetch refspec:\n\n```\n(@v1.10) pkg> registry add https://github.com/staticfloat/General#bb2/bb2\n     Cloning registry from """"https://github.com/staticfloat/General#bb2/bb2""""\n       Added registry `General` to `./registries/General`\n```\n\nThis kind of looks like it works, but if you inspect the registry:\n\n```\nsabae@bb8:/tmp/foo$ cd registries/General/\nsabae@bb8:/tmp/foo/registries/General$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nnothing to commit, working tree clean\n```\n\nNo such luck, and looking at the remote, we can see it's clearly not what I wanted:\n```\n$ git remote show origin\nfatal: https://github.com/staticfloat/General#bb2/bb2/info/refs not valid: is this a git repository?\n```","[staticfloat]: As far as a motivating reason for this, [BinaryBuilder2](https://github.com/JuliaPackaging/BinaryBuilder2.jl) will push up registry branches with stacks of new JLLs built and registered within it, [like this](https://github.com/staticfloat/General/tree/bb2/bb2).  Eventually, I would like to make it very easy for users to test out Yggdrasil PRs by just running something like:\n\n```\n$ JULIA_DEPOT_PATH=/tmp/deleteme julia\n...\npkg> registry add https://github.com/JuliaBinaryWrappers/General#bb2/pr/1234\npkg> add Foo_jll\njulia> using Foo_jll\njulia> run_my_test()\n``` | [KristofferC]: I don't think there is any support att all for branches in the regsitry and it just sets the URL field as that string:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/4e43058c264e0117478f901e36b2be563418f7d3/src/REPLMode/argument_parsers.jl#L199-L200",2,false,0,0,0,0,0,0,0,0,0
3914,REPL completions with `~` have incorrect offset,open,staticfloat,,,,1,2024-06-03T18:41:38.0,2024-06-03T18:54:55.0,411,411,https://github.com/JuliaLang/Pkg.jl/issues/3914,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3914,"If I type `dev ~/.jul`, it tries to auto-expand to `/Users/sabae/.julia`, but uses the wrong offset because of `expanduser()` turning `~` into `/Users/sabae`:\n\n<img width=""""475"""" alt=""""image"""" src=""""https://github.com/JuliaLang/Pkg.jl/assets/130920/dff34e09-c9b7-485e-b2cf-7a78b5fcaef2"""">\n\nThis is happening with Pkg ed7a8dca87fa58d80053abf68fb7dfefa54d554e\n",[IanButterworth]: Ah yes. Needs something similar to https://github.com/JuliaLang/julia/pull/54311,1,false,0,0,0,0,0,0,0,0,0
3908,`expanduser` can fail causing a REPL error in completion,open,KristofferC,,REPL,,0,2024-05-28T08:01:07.0,2024-05-28T08:01:08.0,418,418,https://github.com/JuliaLang/Pkg.jl/issues/3908,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3908,"```\n(WAV) pkg> dev ~.┌ Error: Error in the keymap\n│   exception =\n│    ArgumentError: ~user tilde expansion not yet implemented\n│    Stacktrace:\n│      [1] expanduser(path::String)\n│        @ Base.Filesystem ./path.jl:529\n│      [2] complete_local_dir(s::String, i1::Int64, i2::Int64)\n│        @ REPLExt ~/julia1.11/usr/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:30\n│      [3] complete_add_dev(options::Dict{Symbol, Any}, partial::String, i1::Int64, i2::Int64)\n│        @ REPLExt ~/julia1.11/usr/share/julia/stdlib/v1.11/Pkg/ext/REPLExt/completions.jl:150\n```",,0,false,0,0,0,0,0,0,0,0,0
3907,More direct resolver error when julia compat is a factor,open,ericphanson,,,,0,2024-05-27T21:59:26.0,2024-05-27T21:59:26.0,418,418,https://github.com/JuliaLang/Pkg.jl/issues/3907,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3907,"in https://discourse.julialang.org/t/unclear-error-message-when-trying-to-install-package-with-incompatible-julia-version it came up that the default resolver error could be made more clear when julia compat is a factor in the unresolvability of the package. Specifically, the user was using Julia 1.6 and tried to use EcologicalNetworksDynamics whose latest version needs v1.10. They got this message:\n\n```julia\n(test) pkg> add EcologicalNetworksDynamics\n  Installing known registries into `~/.julia`\n       Added registry `General` to `~/.julia/registries/General`\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package SciMLBase [0bca4576]:\n SciMLBase [0bca4576] log:\n ├─possible versions are: 1.0.0-2.38.0 or uninstalled\n ├─restricted by compatibility requirements with EcologicalNetworksDynamics [2fd9189a] to versions: 2.30.0-2.38.0\n │ └─EcologicalNetworksDynamics [2fd9189a] log:\n │   ├─possible versions are: 0.2.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 0.2.0\n └─restricted by julia compatibility requirements to versions: 1.0.0-2.6.0 or uninstalled — no versions left\n\n```\n\nThis is confusing since it is not clear what SciMLBase has to do with it at first. I think this message would work better if the first line showed which versions of EcologicalNetworksDynamics were compatible with Julia 1.6 (somehow mentioning that the latest version is not compatible), and then showing for the versions which are compatible with Julia 1.6 what the issue is.\n\n",,0,false,2,1,0,0,0,0,1,0,0
3902,Pkg.test sandbox resolve merge doesn't respect JLL build numbers in manifest,open,IanButterworth,,bug,,0,2024-05-16T14:02:19.0,2024-05-16T16:30:30.0,430,429,https://github.com/JuliaLang/Pkg.jl/issues/3902,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3902,"I have a setup where we\n\n1) Freeze the manifest\n2) Build a sysimage\n3) Use sysimage to run Pkg.test\n\nThe manifest had Cairo_jll v1.18.0+1, and v1.18.0+2 became available and caused the error seen here during the `Pkg.test` sandbox resolve.\n```\nERROR: Unsatisfiable requirements detected for package Cairo_jll [83423d85]:\n Cairo_jll [83423d85] log:\n ├─possible versions are: 1.18.0 or uninstalled (package in sysimage!)\n ├─restricted to versions 1.18.0 by an explicit requirement, leaving only versions: 1.18.0\n └─restricted by compatibility requirements with Pixman_jll [30392449] to versions: uninstalled — no versions left\n   └─Pixman_jll [30392449] log:\n     ├─possible versions are: 0.42.2 or uninstalled (package in sysimage!)\n     └─restricted to versions 0.42.2 by an explicit requirement, leaving only versions: 0.42.2\n```\n\nNote #3901 covers that the resolver error doesn't show build numbers where it should.\n\n\nThe resolver was taught about build numbers that shouldn't be upgraded in https://github.com/JuliaLang/Pkg.jl/pull/3371\nPerhaps that needs to be brought over to this resolve operation.",,0,false,0,0,0,0,0,0,0,0,0
3901,Resolver errors don't show build numbers,open,IanButterworth,,resolver,,0,2024-05-16T13:56:19.0,2024-05-16T13:56:19.0,430,430,https://github.com/JuliaLang/Pkg.jl/issues/3901,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3901,"This happened because Cairo_jll v1.18.0+1 was in the sysimage, but resolver wanted Cairo_jll v1.18.0+2\n```\nERROR: Unsatisfiable requirements detected for package Cairo_jll [83423d85]:\n Cairo_jll [83423d85] log:\n ├─possible versions are: 1.18.0 or uninstalled (package in sysimage!)\n ├─restricted to versions 1.18.0 by an explicit requirement, leaving only versions: 1.18.0\n └─restricted by compatibility requirements with Pixman_jll [30392449] to versions: uninstalled — no versions left\n   └─Pixman_jll [30392449] log:\n     ├─possible versions are: 0.42.2 or uninstalled (package in sysimage!)\n     └─restricted to versions 0.42.2 by an explicit requirement, leaving only versions: 0.42.2\n```",,0,false,0,0,0,0,0,0,0,0,0
3896,[1.10] Pkg.precompile crash exits when package hits redefinition error,open,IanButterworth,,bug; precompile,,4,2024-05-08T14:47:24.0,2024-05-08T17:25:25.0,438,437,https://github.com/JuliaLang/Pkg.jl/issues/3896,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3896,"Note that `precompile` exits when hitting the `CPUSummary` error that causes the `?` classification, without letting all jobs finish, and following this another call to `precompile` had more work to do.\n```\n(Foo) pkg> precompile\nPrecompiling project...\n  ? CPUSummary\n  ◒ TiffImages\n  ◒ DataFrames\n  ◒ Polynomials\n  ◐ ImageCore\n  ◐ UnicodePlots\n  ◓ Zygote\n  ◒ Distributions → DistributionsChainRulesCoreExt\n\n  2 dependencies had output during precompilation:\n┌ Interpolations\n│  WARNING: method definition for checkbounds at /home/user/.julia/packages/Interpolations/USkTk/src/Interpolations.jl:454 declares type variable N but does not use it.\n│  WARNING: method definition for checkbounds at /home/user/.julia/packages/Interpolations/USkTk/src/Interpolations.jl:457 declares type variable N but does not use it.\n│  WARNING: method definition for GriddedInterpolation at /home/user/.julia/packages/Interpolations/USkTk/src/gridded/gridded.jl:37 declares type variable pad but does not use it.\n│  WARNING: method definition for GriddedInterpolation at /home/user/.julia/packages/Interpolations/USkTk/src/gridded/gridded.jl:60 declares type variable pad but does not use it.\n│  WARNING: method definition for interpolate! at /home/user/.julia/packages/Interpolations/USkTk/src/deprecations.jl:30 declares type variable TWeights but does not use it.\n└  \n┌ CPUSummary\n│  WARNING: Method definition cache_size(Union{Base.Val{1}, Static.StaticInt{1}}) in module CPUSummary at /home/user/.julia/packages/CPUSummary/LAKF1/src/x86.jl:26 overwritten on the same line (check for duplicate calls to `include`).\n│  ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n└ \n```\n```\njulia> versioninfo()\nJulia Version 1.10.3\nCommit 0b4590a5507 (2024-04-30 10:59 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 32 × 13th Gen Intel(R) Core(TM) i9-13900K\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, goldmont)\nThreads: 1 default, 0 interactive, 1 GC (on 32 virtual cores)\n```","[KristofferC]: I guess not a Pkg.jl issue anymore. | [IanButterworth]: Shouldn't it be because 1.10? | [KristofferC]: Oh, ok, yes. Fixed in 1.11? | [IanButterworth]: I've not tested on 1.11",4,false,0,0,0,0,0,0,0,0,0
3890,[workspace] Preserve top level dependencies better,open,fredrikekre,,workspace,,6,2024-05-03T08:57:38.0,2024-05-08T13:37:48.0,443,438,https://github.com/JuliaLang/Pkg.jl/issues/3890,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3890,"When adding package that is already in the manifest because of a top level dependency of a different project (or as a transient dependency, but those almost always track the registry) we should try to preserve the version. For example:\n```\n$ tree .\n.\n├── Manifest.toml\n├── Project.toml\n└── test\n    └── Project.toml\n\n$ cat Project.toml\n[deps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\n\n[workspace]\nprojects = [""""test""""]\n\n$ julia -e 'using Pkg; Pkg.status()'\nStatus `/tmp/tmp.C9bJWtPVPR/Project.toml`\n  [7876af07] Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n\n$ julia --project=test -e 'using Pkg; Pkg.status()'\nStatus `/tmp/tmp.C9bJWtPVPR/test/Project.toml` (empty project)\n\n$ julia --project=test -e 'using Pkg; Pkg.add(""""Example"""")'\n   Resolving package versions...\n    Updating `/tmp/tmp.C9bJWtPVPR/test/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/tmp/tmp.C9bJWtPVPR/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\n$ julia -e 'using Pkg; Pkg.status()'\nStatus `/tmp/tmp.C9bJWtPVPR/Project.toml`\n  [7876af07] Example v0.5.3\n```\n\nI think this would be fixed by pinning top level dependencies of all projects in the first stage of the tiered resolver.","[fredrikekre]: `PRESERVE_ALL` should probably consider the full manifest (not just the subgraph for the project) then? And then perhaps there should be a `PRESERVE_WORKSPACE_DIRECT` before `PRESERVE_DIRECT` that preserve all top level deps in all workspace projects. | [KristofferC]: > PRESERVE_ALL should probably consider the full manifest (not just the subgraph for the project) then? \n\nI think this is already true. The behavior here is identical to when not using a workspace. | [fredrikekre]: Yea, I thought that adding a package that was in the manifest already was more of a no-op like `rm` is.\n\nPerhaps `add` of a package that is already in the manifest should just not resolve at all like `rm`? Wouldn't result in precompilation at least which would be pretty nice. | [KristofferC]: Currently `add Package` is kind of used as a combined `free + add` in case the package is added by URL or devved. A bit convenient at times but perhaps not worth it. | [fredrikekre]: Yea, but `add Package` could also be thought of as """"any version of Package"""". If you require a specific one you `add Package@...`, put in `[compat]` or add by url I guess? | [KristofferC]: Yes, I don't think people would complain about that behavior.",6,false,0,0,0,0,0,0,0,0,0
3895,bad error message when adding 2 packages with a trailing space before `add`,open,lmiq,,,,0,2024-05-08T11:43:08.0,2024-05-08T11:43:08.0,438,438,https://github.com/JuliaLang/Pkg.jl/issues/3895,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3895,"\nExample, note that there is a trailing space before `add`:\n\n```julia\n(jl_J2yZSt) pkg>  add Test, LinearAlgebra\nERROR: Unable to parse `Test,` as a package.\n\n```\n\n\n\n",,0,false,0,0,0,0,0,0,0,0,0
3891,[workspace] Misleading printing of Manifest.toml change,open,fredrikekre,,workspace,,2,2024-05-03T09:00:31.0,2024-05-03T15:31:46.0,443,442,https://github.com/JuliaLang/Pkg.jl/issues/3891,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3891,"Example:\n```\n$ tree .\n.\n├── Manifest.toml\n├── Project.toml\n└── test\n    └── Project.toml\n\n$ cat Project.toml\n[deps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\n\n[workspace]\nprojects = [""""test""""]\n\n$ julia -e 'using Pkg; Pkg.status()'\nStatus `/tmp/tmp.C9bJWtPVPR/Project.toml`\n  [7876af07] Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n\n$ julia --project=test -e 'using Pkg; Pkg.status()'\nStatus `/tmp/tmp.C9bJWtPVPR/test/Project.toml` (empty project)\n\n$ julia --project=test -e 'using Pkg; Pkg.add(""""Example"""")'\n   Resolving package versions...\n    Updating `/tmp/tmp.C9bJWtPVPR/test/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/tmp/tmp.C9bJWtPVPR/Manifest.toml`\n  [7876af07] + Example v0.5.3\n```\n\nThe last line there should be\n```\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n```\ninstead of\n```\n  [7876af07] + Example v0.5.3\n```","[KristofferC]: The reason this happens is that the status printer does a filter of everything that is reachable from the current project and uses that as a diff. Here, Example was not reachable before so it just has it as a `+`. | [fredrikekre]: Okay, that explains why it works correctly when the thing you add is already a transient dependency in the current project.",2,false,0,0,0,0,0,0,0,0,0
3892,dev .. : Relative directory failing under Windows when having cd'ed with incorrect case,open,divbyzerofordummies,,,,3,2024-05-03T08:00:34.0,2024-05-03T12:22:56.0,443,443,https://github.com/JuliaLang/Pkg.jl/issues/3892,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3892,"I have a minor issue when trying to `dev` a relative directory in REPL package mode.\n\nMy package has uppercase letters, say `MyPackage`, but I have moved there using the shell environment, having used a lower case letter by mistake:\n```\nshell> cd mypackage/test\n```\nwhich works.\n\n`pwd()` gives the global path with `mypackage` in lower case letters, so the mistake is not """"corrected"""".\n\nIf I activate the environment there (still works) and try to `dev` the parent folder, I get\n```\n(test) pkg> dev ..\nERROR: `..` appears to be a local path, but directory does not exist\n```\n\nFunnily, `FileSystem` does not have any issues:\n```\njulia> Base.Filesystem.readdir("""".."""")\n```\nworks as expected.\n\nAlso, this is not a `Pkg.jl` bug since\n```\njulia> import Pkg; Pkg.develop(path="""".."""")\n```\nworks as well.\n\n\nMy `versioninfo()` output is:\n```\nJulia Version 1.9.3\nCommit bed2cd540a (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: 12 × 12th Gen Intel(R) Core(TM) i5-12400\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, alderlake)\n  Threads: 4 on 12 virtual cores\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = 4\n```","[fredrikekre]: Does `(test) pkg> dev ./..` work? | [KristofferC]: It is explicitly checking case sensitively in \n\nhttps://github.com/JuliaLang/Pkg.jl/blob/c26ad23e9084c8f714d7d866d6e28e95bacb172b/src/REPLMode/argument_parsers.jl#L146\n\nNot sure if it should | [divbyzerofordummies]: > Does `(test) pkg> dev ./..` work?\n\nNo, same error:\n```\nERROR: `./..` appears to be a local path, but directory does not exist\n```",3,false,0,0,0,0,0,0,0,0,0
2679,stop using libgit2,open,StefanKarpinski,,,,15,2021-07-30T21:33:02.0,2024-04-25T19:47:37.0,1450,450,https://github.com/JuliaLang/Pkg.jl/issues/2679,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2679,"Using libgit2 has not been a walk in the park. The original motivation for using it is was that Pkg2 worked with git repos for all package installs and did a lot of small git operations which were quite slow when using CLI `git` to spawn an external process for each operation (especially on Windows). So at the time using libgit2 seemed like a git win. However, libgit2 has a complex sprawling API that's hard to wrap and use. We've mostly struggled through that. But there are still problems: it's very common for people to find themselves in situations where CLI `git` can do something fine but Pkg can't because `libgit2` can't — this is typically an issue with authentication, but not always. Some example problem issue for libgit2: https://github.com/JuliaLang/Pkg.jl/issues/1247, https://github.com/JuliaLang/Pkg.jl/issues/911, https://github.com/JuliaLang/Pkg.jl/issues/2329, https://github.com/JuliaLang/Pkg.jl/issues/2485 — there are more. Each of these could be fixed, but still, it's a drag that libgit2 so often doesn't work when `git` just works.\n\nNow we face a seemingly insurmountable [security problem](https://github.com/JuliaLang/julia/issues/40297#issuecomment-890132684) with continuing to use libgit2: it depends on libssh2 for SSH functionality, which is unmaintained and has multiple open CVEs. Moreover, libgit2 has seemingly [no intention](https://github.com/libgit2/libgit2/issues/4338) of supporting a different SSH engine like libssh.\n\nSo the time has come to stop using libgit2+libssh2 entirely and switch back to only using an external `git` CLI tool. This issue is to discuss the strategy for doing that.\n\n\n","[StefanKarpinski]: High level, at this point we pretty much only use git for two things (that I can think of):\n\n1. To dev a package. For this we can use `git clone` instead.\n\n2. To install specific trees for `] add` with a commit/tree hash, including in cases where we can't install via package server or github tarball download. For this we can make a bare clone of the repo and pipe the output of `git archive` to `Tar.extract` in order to install a specific tree hash the same way.\n\nThere's also the issue that some users might not have `git` installed. For the dev case it would be reasonable to instruct them to just install `git` themselves since without they're not going to be able to work with the dev'ed repo. For the `add` case, however, we may want something more automatic. One option would be to ship Julia with `git` but on Windows that's pretty heavyweight since it includes a whole UNIX emulation system. But maybe we could, instead of shipping with it, ask the user if they want to install it via artifacts in the relatively rare case that they (a) can't install using the pkg server, (b) can't install via GitHub/GitLab tarball downloads and (c) don't already have a `git` binary somewhere in their path. I.e. in that situation prompt the user if they want to automatically install and use `git_jll` or give up and if they say yes, install `git_jll` for them and use it. Or we could just install and use it. | [KristofferC]: Just swap the default in https://github.com/JuliaLang/Pkg.jl/blob/74643bee0bf446bb649280c36749c29f6114aa33/src/GitTools.jl#L13? We can still use libgit2 for everything else that is just handling repos locally.\n\nOut of curiosity, it would be interesting to see the Rust peoples view on libgit2 since I know they take security pretty seriously and also use it for Cargo. | [StefanKarpinski]: That would be an easy first cut of the change, but I'd rather not maintain two very different sets of code and I'd love to ditch LibGit2 as a dependency of Julia (although we may have to keep it around as a compatibility relic). If we can do everything we need to do with CLI `git` and we can either use the user's `git` or install our own via BinaryBuilder, then we can use one code base for everything and just decide which `git` to use. | [DilumAluthge]: I'm a big fan of removing `libgit2` and only having a single set of code, which would use command-line Git.\n\nI'd suggest a user API like this:\n\nWe look at an environment variable with a name like e.g. `JULIA_PKG_USE_SYSTEM_GIT`, and based on the value of that environment variable:\n1. If the environment variable is set to `true` or `1`, we use the system Git.\n2. If the environment variable is set to `false` or `0`, we automatically download `Git_jll` the first time that we need to do a Git operation.\n3. If the environment variable is set to something other than the above values, or if the environment variable is not set, then we try to auto-detect whether or not the system has Git installed. If the system has Git installed (e.g. if `Sys.which(""""git"""") !== nothing`), then we use the system Git, otherwise we automaticallydownload `Git_jll` the first time that we need to do a Git operation.\n\nI think for most users, the """"automatically download `Git_jll` the first time that we need to do a Git operation"""" approach will work best, because then we don't need to ship `Git_jll` with Julia. In fact, we have precedence in Julia/Pkg for """"automatically download X the first time we need to do a Y operation"""". Specifically, we don't ship the General registry with Julia. Instead, we automatically download the General registry the first time we need to do a Pkg operation.\n\nHowever, it would be nice to have some option (maybe an option in `Make.user`) to build Julia with `Git_jll` already included. That way, if you want to e.g. install Julia on a machine that doesn't have internet access and doesn't have a system Git, you can do so, and then you can `Pkg.Registry.add` local registries on that machine and `Pkg.add` local Git package repos on that machine without needing to worry about the internet access for downloading `Git_jll`. This is a use case that I use a lot. | [DilumAluthge]: > Out of curiosity, it would be interesting to see the Rust peoples view on libgit2 since I know they take security pretty seriously and also use it for Cargo.\n\nYeah it would be good to hear what the Cargo people think about the ~~`libssh`~~ `libssh2` security issues. | [DilumAluthge]: > But maybe we could, instead of shipping with it, ask the user if they want to install it via artifacts in the relatively rare case that they (a) can't install using the pkg server, (b) can't install via GitHub/GitLab tarball downloads and (c) don't already have a `git` binary somewhere in their path. I.e. in that situation prompt the user if they want to automatically install and use `git_jll` or give up and if they say yes, install `git_jll` for them and use it. Or we could just install and use it.\n\nI would just automatically download and use `Git_jll`, instead of prompting the user. | [KristofferC]: Just to get a reference, what Cargo does is https://doc.rust-lang.org/cargo/appendix/git-authentication.html for HTTPS + SSH authentication, and for more complicated authentication you opt-in to use a git CLI (https://doc.rust-lang.org/cargo/reference/config.html#netgit-fetch-with-cli) which is also what we do right now.\n\nRegarding completely swapping out LibGit2, that feels like a lot of extra churn for no real reason. Having to rewrite all the nice library API calls into parsing ugly text from CLI calls will be a maintenance burden and it also prevents using nice features like custom progress bars. Having the option to use the CLI git exactly at the point where libgit2 has issues (fancy authentication when downloading something) sounds good enough to me.\n\n | [StefanKarpinski]: Note that it's libssh2 that has outstanding security issues and isn't maintained; libssh is fine but isn't what libgit2 uses. | [mkitti]: There is a PR to add libssh to libgit2: https://github.com/libgit2/libgit2/pull/5253 | [KristofferC]: I've been against this in the past because of the API being kind of nice when dealing with git repos internally and it also allows you to get a nice progress bar but the fact of the matter is that every time someone has a problem with git it seems that using the external git fixes it...\n\nSo I'm coming around that maybe we should try to get rid of libgit2. This would also allow to move LibGit2.jl from an stdlib to a normal package.\n\nI think this can be done in multiple steps:\n\n1. Use git if it is found, otherwise fall back to libgit2.\n2. Use git if it is found, otherwise download git (e.g. Git_jll)\n3. Move over functions using LibGit2 to Git one by one. \n4. Stop depending on LibGit2. | [ericphanson]: > 2\. Use git if it is found, otherwise download git (e.g. Git_jll)\n\nJust as a small practical matter, my understanding is that Git_jll directly doesn’t work well and one needs to use Git.jl, but that also doesn’t work well with private packages on MacOS: https://github.com/JuliaVersionControl/Git.jl/issues/40 | [giordano]: > but that also doesn’t work well with private packages on MacOS: https://github.com/JuliaVersionControl/Git.jl/issues/40\n\nSide note, I attempted to work around the problem on macOS in https://github.com/JuliaPackaging/Yggdrasil/pull/4987, but last time I tried it, it didn't seem to actually solve that problem. | [GunnarFarneback]: The `Git.jl` issue on MacOS was resolved in https://github.com/JuliaVersionControl/Git.jl/pull/45. | [StefanKarpinski]: Since this is a fair bit of work and in the mean time we have a broken default, how about instead of requiring `JULIA_PKG_USE_CLI_GIT=true` we could automatically use CLI git if it exists? That way libgit2 would only be a fallback for users who don't have CLI git. We could still allow opting out of CLI git with `JULIA_PKG_USE_CLI_GIT=false`. | [ethomson]: 👋 libgit2 maintainer here. I  found this issue linked from a different issue, and I’m obviously sad to see it. I certainly won’t begrudge any decisions that you make but I’d be very pleased to work with you to overcome any challenges that you have with libgit2.\n\nConcretely, we agree that libssh2 is … not an ideal choice for many users. We recently added support to use the command line `ssh` which may be a good choice for many CLIs that use libgit2. But I’d love feedback on what we should improve, and if there’s ways that I can help you continue to use libgit2.",15,false,15,14,1,0,0,0,0,0,0
3503,switching between pkg servers with different registries,open,johnnychen94,,,,0,2023-05-31T15:45:57.0,2024-04-23T18:36:27.0,780,452,https://github.com/JuliaLang/Pkg.jl/issues/3503,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3503,"In summary, I believe we can improve Pkg's behavior on two small issues:\n\n- case 2: support installing all available registries of used pkg server. -- I believe this was a bug.\n- case 4: when the pkg server is used, optionally disable the git operation for packages not available in registries served by the pkg server. -- This provides a better user experience (clearer error messages).\n\nBefore I start to put my hands on this, I'd like to know if you think the same.\n\n---\n\nI don't know if there's a public pkg server that serves multiple registries, thus I use the private pkg server we use in [TongYuan](https://github.com/Suzhou-Tongyuan) to provide the example.\n\n```\n❯ curl -L https://releases-dev.tongyuan.cc/registries\n/registry/fe1a5c12-5b3e-461d-9252-adc475b18e8c/c159bd9903151fcba081a0dfe18228cbf27108cd\n/registry/23338594-aafe-5451-b93e-139f81909106/dea1026b1d1e51f165a6e5c95fbf4fcf038f5feb\n```\n\nEdit: we now have a public pkg server to test: https://releases.tongyuan.cc/juliapkg\n\nThe `23338594` is the public """"General"""" registry, and `fe1a5c12` is the private """"Syslab"""" registry.\n\n## Case 1: a new depot with no registry installed\n\nWhen `Pkg.status()` or `Pkg.add()` get called, it installs both registries recorded in the pkg server.\n\n```julia\n❯ export JULIA_PKG_SERVER=""""https://releases-dev.tongyuan.cc""""\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; Pkg.status(); Pkg.Registry.status()'\n  Installing known registries into `~/tmp`\nStatus `~/tmp/environments/v1.9/Project.toml` (empty project)\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)\n [fe1a5c12] Syslab (https://git.tongyuan.cc/syslab-release/stream/SyslabRegistry.git)\n```\n\n## Case 2: an existing depot with General installed\n\nThis case often happens when one needs to switch from the default public pkg server to the private pkg server.\n\nIn this case, extra registries served by pkg server are ignored when General is installed.\n\nFirst we set the default depot up using default pkg server:\n\n```\n❯ rm -rf tmp\n\n❯ export JULIA_PKG_SERVER=""""https://pkg.julialang.org""""\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; Pkg.status(); Pkg.Registry.status()'\n  Installing known registries into `~/tmp`\nStatus `~/tmp/environments/v1.9/Project.toml` (empty project)\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)\n```\n\nthen we switch to the private pkg server:\n\n```\n❯ export JULIA_PKG_SERVER=""""https://releases-dev.tongyuan.cc""""\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; Pkg.status(); Pkg.Registry.status()'\nStatus `~/tmp/environments/v1.9/Project.toml` (empty project)\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)\n```\n\nIn this case, Pkg doesn't install the extra Syslab registry recorded in the pkg server. That would make `pkg> add <some_private_package>` fail.\n\n## Case 3: switch back to the public pkg server\n\nWith a clean depot, let's add a private pkg first, then switch back to the public pkg server. The private registry doesn't get updated, and the private package doesn't get updated (which is great).\n\n```\n❯ rm -rf tmp\n\n❯ export JULIA_PKG_SERVER=""""https://releases-dev.tongyuan.cc""""\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; Pkg.add(""""TyExample"""")'\n  Installing known registries into `~/tmp`\n    Updating registry at `~/tmp/registries/General.toml`\n    Updating registry at `~/tmp/registries/Syslab.toml`\n   Resolving package versions...\n   Installed TyExample ─ v0.2.0\n   Installed TyAPI ───── v0.3.8\n    Updating `~/tmp/environments/v1.9/Project.toml`\n  [7876af07] + TyExample v0.2.0\n    Updating `~/tmp/environments/v1.9/Manifest.toml`\n  [47291b8a] + TyAPI v0.3.8\n  [7876af07] + TyExample v0.2.0\nPrecompiling project...\n  2 dependencies successfully precompiled in 1 seconds\n\n❯ export JULIA_PKG_SERVER=""""https://pkg.julialang.org""""\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; Pkg.update()'\n    Updating registry at `~/tmp/registries/General.toml`\n    Updating registry at `~/tmp/registries/Syslab.toml`\n  No Changes to `~/tmp/environments/v1.9/Project.toml`\n  No Changes to `~/tmp/environments/v1.9/Manifest.toml`\n[ Info: We haven't cleaned this depot up for a bit, running Pkg.gc()...\n      Active manifest files: 1 found\n      Active artifact files: 0 found\n      Active scratchspaces: 0 found\n     Deleted no artifacts, repos, packages or scratchspaces\n```\n\n## Case 4: switch back to the public pkg server with compat conflict\n\nTyGaloisFieldNumbers is a private version of [GaloisFieldNumbers](https://github.com/Suzhou-Tongyuan/GaloisFieldNumbers.jl). There are two things to make it special here:\n\n- TyGaloisFieldNumbers v0.1.4 requires `Polynomials=""""3 - 3.2.8""""`\n- TyGaloisFieldNumbers v0.1.5 requires `Polynomials=""""3""""`\n\nTo create a case that has compat conflict, I first installed `TyGaloisFieldNumbers v0.1.4` with the private pkg server, and then switched to install Polynomials v3.2.12 with the public pkg server. Then Julia will try to fallback to git clone the package and give """"encrypted"""" error messages.\n\n```julia\n❯ rm -rf tmp\n\n❯ export JULIA_PKG_SERVER=""""https://releases-dev.tongyuan.cc""""\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; pkg""""add TyGaloisFieldNumbers@0.1.4""""'\n┌ Warning: The Pkg REPL mode is intended for interactive use only, and should not be used from scripts. It is recommended to use the functional API instead.\n└ @ Pkg.REPLMode /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/REPLMode/REPLMode.jl:382\n  Installing known registries into `~/tmp`\n    Updating registry at `~/tmp/registries/General.toml`\n    Updating registry at `~/tmp/registries/Syslab.toml`\n   Resolving package versions...\n   Installed TyCEI ──────────────── v0.3.6\n   Installed Polynomials ────────── v3.2.8\n   Installed TyGaloisFieldNumbers ─ v0.1.4\n...\n\n❯ JULIA_DEPOT_PATH=$PWD/tmp julia -e 'using Pkg; pkg""""add Polynomials@3.2.12""""'\n┌ Warning: The Pkg REPL mode is intended for interactive use only, and should not be used from scripts. It is recommended to use the functional API instead.\n└ @ Pkg.REPLMode /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/REPLMode/REPLMode.jl:382\n    Updating registry at `~/tmp/registries/General.toml`\n    Updating registry at `~/tmp/registries/Syslab.toml`\n   Resolving package versions...\n   Installed Polynomials ────────── v3.2.12\n     Cloning [0b0ef4ed-0311-459f-9fa8-24d44fa913b9] TyGaloisFieldNumbers from ssh://git@git.tongyuan.cc:222/syslab-msp/packages/TyGaloisFieldNumbers.jl.git\n    Updating git-repo `ssh://git@git.tongyuan.cc:222/syslab-msp/packages/TyGaloisFieldNumbers.jl.git` <---- trying to add TyGaloisFieldNumbers v0.1.5\nERROR: TyGaloisFieldNumbers: git object 90db8b2ca303faf7d3cd06f805205c909e5cce1e could not be found\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n  [2] install_git(io::Base.TTY, uuid::Base.UUID, name::String, hash::Base.SHA1, urls::Set{String}, version_path::String)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:694\n  [3] download_source(ctx::Pkg.Types.Context; readonly::Bool)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:905\n  [4] download_source\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:791 [inlined]\n...\n```",,0,false,0,0,0,0,0,0,0,0,0
3880,proposal: distinguish explicitly vs implicitly added registries,open,StefanKarpinski,,,,1,2024-04-23T15:00:13.0,2024-04-23T18:34:04.0,453,452,https://github.com/JuliaLang/Pkg.jl/issues/3880,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3880,"Right now we don't distinguish between whether a registry was added explicitly by the user via `registry add X` or it was automatically/implicitly added because the user didn't have any registries added and the package server offers it. This leads to various confusions:\n\n- If the user happens to add a registry first, then they won't get any registries from the package server.\n- If what registries the package server offers changes, then the old ones linger and the new ones may not be picked up.\n\nInstead, I would propose that we have two kinds of registries:\n\n1. Explicitly added registries, which are always considered until the user explicitly removes them.\n2. Implicitly added registries, which are only considered if the current package server offers them.\n\nWe could consider gc'ing implicitly added registries if they haven't been offered in a long time, so we may want to keep track of the last time we talked to a package server that offered an implicitly added registry. This would alleviate the above issues:\n\n- If a user adds a registry first, it doesn't matter—they'll use that as well as whatever registries their package server offers and the order of events doesn't matter.\n- If the user switches package servers or what registries a package server offers changes, we'll only consider packages included in the explicit registries as well as the ones included in the registries offered by the current package server.\n\nThoughts on this approach. Spurred by having long wanted this and conversation with @KristofferC and @keno.","[johnnychen94]: FYI, #3503 is a concrete example for this.",1,false,1,1,0,0,0,0,0,0,0
1967,proposal for package tags and descriptions in registry,open,Roger-luo,,,,2,2020-08-18T19:03:03.0,2024-04-17T13:50:52.0,1796,459,https://github.com/JuliaLang/Pkg.jl/issues/1967,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1967,"I feel it could be nice to allow storing some description about the package itself in the registry, such as tags and a short description. This would make things more viable, I once proposed this on discourse as a reply, but I can't find the post anymore.\n\nThis proposal is partly inspired by PyPI's classifiers (https://www.python.org/dev/peps/pep-0301/#distutils-trove-classification).\n\nTL;DR\n\nI'm basically proposing two new fields `tags` and `description` in the `Package.toml` and `Project.toml`, a typical new `Package.toml` would look like the following\n\n```toml\nname = """"Yao""""\nuuid = """"5872b779-8223-5990-8dd0-5abbb0748c8c""""\nrepo = """"https://github.com/QuantumBFS/Yao.jl.git""""\ntags=[\n  """"physics"""",\n  """"quantum"""",\n]\ndescription=""""Extensible, Efficient Quantum Algorithm Design for Humans.""""\n```\n\nThe corresponding `Project.toml` can be \n\n```toml\nname = """"Yao""""\nuuid = """"5872b779-8223-5990-8dd0-5abbb0748c8c""""\nversion = """"0.6.3""""\ntags=[\n  """"physics"""",\n  """"quantum"""",\n]\ndescription=""""Extensible, Efficient Quantum Algorithm Design for Humans.""""\n\n\n[deps]\n...\n```\n\n### Tags\n\nTags are categories that a package belongs, I think at least in principle, available tags it should be managed by registry owners to make sure there are not too many close meaning tags (e.g """"quantum"""" and """"quantum-physics"""" etc.) they can be generated automatically from GitHub tags as well (but one might want to filter out some tags or redirect them to make things less duplicate).\n\nA package can belong to multiple category and categories in the registry don't have to contain hierarchy, but a frontend to the registry may provide such hierarchy, e.g quantum category can be inside `physics` category: `physics/quantum`. This is a major difference comparing to PyPI's classifiers.\n\n### Description\n\nThe description should be a short sentence that briefly describes what does the package do and what feature it contains. I think also up to the registry owner, they can limit the total length of this description (e.g 120 characters) to make sure it's simple and brief to read for the user. \n\n**Why can't I just read them from GitHub?**\n\n1. Reading a single package from GitHub is actually fine, but if we want to allow someone to search a package with description, we need to actually store things. e.g with this new feature, this will allow people to do some simple search on packages directly from their REPL/terminal/IDE without sending request to GitHub. Given currently without authentication, GitHub only allows 50 requests per day. I implemented this feature as an example in [IonCLI](https://github.com/Roger-luo/IonCLI.jl) (but now it has to send a request to GitHub for every search result):\n\n![image](https://user-images.githubusercontent.com/8445510/90553469-6c67ad80-e162-11ea-952e-dbf16723dd14.png)\n\n2. packages may not be hosted on GitHub, if the project is hosted on somewhere else that do not provide a github-like tag and description service, then one cannot search it in this way at all, and it can be quite common that one do not remember what exactly the package name is, but a quite vague name want to search.\n\n3. This feature will allow one to search behind a firewall with only a package server available if GitHub is not fully accessible.","[adigitoleo]: Is this blocked by anything in particular or is pkg.jl still moving too fast for this to be worked on? It's not clear to me as a user (and someone who wants Julia to have a larger slice of the pie) why the community has had to adopt workarounds such as [Julia.jl](https://github.com/svaksha/Julia.jl). It is known that Julia promotes development of smaller, proliferated packages due to ease of composability. In such an ecosystem, having good package metadata, provided by package authors, that feeds snappy web aggregators would seem to be a significant benefit for users. Unfortunately, the current [options](https://julialang.org/packages/) don't compare favourably with e.g. PyPi or cargo in either performance or """"usability"""" (in my opinion). | [Roger-luo]: There might not be a specific reason, as I don't see any comments against it; it's a lack of people/bandwidth implementing it - like all other UX features. Maybe someone can start a draft PR to push this forward, I personally don't have that much bandwidth this year due to graduation.",2,false,3,3,0,0,0,0,0,0,0
3871,Precompiling when using a single package causes unnecessary precompilation of other packages,open,mkitti,,,,5,2024-04-13T21:37:39.0,2024-04-13T23:45:23.0,462,462,https://github.com/JuliaLang/Pkg.jl/issues/3871,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3871,1. Create an environment with ThreadsX and DataFrames\n2. Remove the files in ~/.julia/compiled/v#.#/DataValueInterfaces\n3. Activate the environment\n4. Invoke using ThreadsX\n\nInvoking `using ThreadsX` will result in DataFrames precompiling although DataFrames did not need to be precompiled to use ThreadsX.\n\n![image](https://github.com/JuliaLang/Pkg.jl/assets/8062771/86163d64-9959-4824-bdd7-0d750b6b5427)\n\nReproduced when using Julia 1.10.2 and Julia 1.11.0-beta1\n,"[mkitti]: ```\n(jar) pkg> st\nStatus `~/jar/Project.toml`\n  [a93c6f00] DataFrames v1.6.1\n  [ac1d9e8a] ThreadsX v0.1.12\n```\n\nProject.toml:\n```\n[deps]\nDataFrames = """"a93c6f00-e57d-5684-b7b6-d8193f3e46c0""""\nThreadsX = """"ac1d9e8a-700a-412c-b207-f0111f4b6c0d""""\n```\n\n`] st -m`  for v1.10:\n```\n(jar) pkg> st -m\nStatus `~/jar/Manifest.toml`\n  [7d9f7c33] Accessors v0.1.36\n  [79e6a3ab] Adapt v4.0.4\n  [dce04be8] ArgCheck v2.3.0\n  [198e06fe] BangBang v0.4.1\n  [9718e550] Baselet v0.1.1\n  [34da2185] Compat v4.14.0\n  [a33af91c] CompositionsBase v0.1.2\n  [187b0558] ConstructionBase v1.5.5\n  [a8cc5b0e] Crayons v4.1.1\n  [9a962f9c] DataAPI v1.16.0\n  [a93c6f00] DataFrames v1.6.1\n  [864edb3b] DataStructures v0.18.19\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [22cec73e] InitialValues v0.3.1\n  [842dd82b] InlineStrings v1.4.0\n  [3587e190] InverseFunctions v0.1.13\n  [41ab1584] InvertedIndices v1.3.0\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [b964fa9f] LaTeXStrings v1.3.1\n  [1914dd2f] MacroTools v0.5.13\n  [128add7d] MicroCollections v0.2.0\n  [e1d29d7a] Missings v1.2.0\n  [bac558e1] OrderedCollections v1.6.3\n  [69de0a69] Parsers v2.8.1\n  [2dfb63ee] PooledArrays v1.4.3\n  [aea7be01] PrecompileTools v1.2.1\n  [21216c6a] Preferences v1.4.3\n  [08abe8d2] PrettyTables v2.3.1\n  [189a3867] Reexport v1.2.2\n  [42d2dcc6] Referenceables v0.1.3\n  [ae029012] Requires v1.3.0\n  [91c51154] SentinelArrays v1.4.1\n  [efcf1570] Setfield v1.1.1\n  [a2af1166] SortingAlgorithms v1.2.1\n  [171d559e] SplittablesBase v0.1.15\n  [1e83bf80] StaticArraysCore v1.4.2\n  [892a3eda] StringManipulation v0.3.4\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.11.1\n  [ac1d9e8a] ThreadsX v0.1.12\n  [28d57a85] Transducers v0.4.81\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8ba89e20] Distributed\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays v1.10.0\n  [10745b16] Statistics v1.10.0\n  [fa267f1f] TOML v1.0.3\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll v1.1.0+0\n  [4536629a] OpenBLAS_jll v0.3.23+4\n  [bea87d4a] SuiteSparse_jll v7.2.1+1\n  [8e850b90] libblastrampoline_jll v5.8.0+1\n```\n | [mkitti]: Script to reproduce:\n\n```\nusing Pkg\nenvname = """"Pkg_jl_PR3871""""\nmkpath(envname)\nPkg.activate(envname)\nPkg.add([""""ThreadsX"""", """"DataFrames""""])\nrm(joinpath(DEPOT_PATH[1], """"compiled"""", """"v$(VERSION.major).$(VERSION.minor)"""", """"DataValueInterfaces""""), recursive=true)\nrun(`$(Base.julia_cmd()) --project=$envname -i -e """"using ThreadsX""""`)\n``` | [IanButterworth]: Can you add the output of `st --extensions` | [mkitti]: ```\n(jar) pkg> st\n(jar) pkg> st\nStatus `~/jar/Project.toml`\n  [a93c6f00] DataFrames v1.6.1\n  [ac1d9e8a] ThreadsX v0.1.12\n\n(jar) pkg> st --extensions\nStatus `~/jar/Project.toml`\n\n(jar) pkg> st -m --extensions\nStatus `~/jar/Manifest.toml`\n  [7d9f7c33] Accessors v0.1.36\n              ├─ AccessorsIntervalSetsExt [IntervalSets]\n              ├─ AccessorsStructArraysExt [StructArrays]\n              ├─ AccessorsStaticArraysExt [StaticArrays]\n              ├─ AccessorsAxisKeysExt [AxisKeys]\n              └─ AccessorsUnitfulExt [Unitful]\n  [79e6a3ab] Adapt v4.0.4\n              └─ AdaptStaticArraysExt [StaticArrays]\n  [198e06fe] BangBang v0.4.1\n              ├─ BangBangChainRulesCoreExt [ChainRulesCore]\n              ├─ BangBangStaticArraysExt [StaticArrays]\n              ├─ BangBangTypedTablesExt [TypedTables]\n              ├─ BangBangStructArraysExt [StructArrays]\n              ├─ BangBangDataFramesExt [DataFrames]\n              └─ BangBangTablesExt [Tables]\n  [34da2185] Compat v4.14.0\n              └─ CompatLinearAlgebraExt [LinearAlgebra]\n  [a33af91c] CompositionsBase v0.1.2\n              └─ CompositionsBaseInverseFunctionsExt [InverseFunctions]\n  [187b0558] ConstructionBase v1.5.5\n              ├─ ConstructionBaseStaticArraysExt [StaticArrays]\n              └─ ConstructionBaseIntervalSetsExt [IntervalSets]\n  [3587e190] InverseFunctions v0.1.13\n              └─ DatesExt [Dates]\n  [28d57a85] Transducers v0.4.81\n              ├─ TransducersDataFramesExt [DataFrames]\n              ├─ TransducersOnlineStatsBaseExt [OnlineStatsBase]\n              ├─ TransducersBlockArraysExt [BlockArrays]\n              ├─ TransducersReferenceablesExt [Referenceables]\n              └─ TransducersLazyArraysExt [LazyArrays]\n``` | [IanButterworth]: So this is happening because ThreadsX depends on Transducers which has TransducersDataFramesExt, and when we go to collect all the deps of ThreadsX we include any extensions that could be loaded in the env.\n\nWe could narrow it to just extensions that would be loaded based on the current loaded modules. So if DataFrames isn't currently loaded, don't precompile TransducersDataFramesExt which would mean DataFrames wouldn't be added to the list.",5,false,1,1,0,0,0,0,0,0,0
3869,Pkg tree hash issues on linux with CIFS mounted network file server,open,JeffFessler,,,,0,2024-04-12T20:44:39.0,2024-04-12T20:44:39.0,463,463,https://github.com/JuliaLang/Pkg.jl/issues/3869,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3869,"For completeness I am noting that Pkg does not work for installing some packages due to tree hash issues when running the linux version (julia 1.10.2) with a home directory on a CIFS mounted network file server.\n\nSee discussion here:\nhttps://discourse.julialang.org/t/wayland-protocols-jll-install-tree-hash-error/112816/13\n\nThe local workaround is to use `export JULIA_PKG_IGNORE_HASHES=""""true""""` per the\n[manual](https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_PKG_IGNORE_HASHES).\n\nIt's ok if maintainers close this issue because combining linux with CIFS may be an unholy marriage.  But I report it in case it saves someone else time later.\n\nThere is a possible fix mentioned in #2317 (in 2021) that would avoid hashing based on the filesystem.\n",,0,false,0,0,0,0,0,0,0,0,0
3067,"Document ""shared depot"" setup tips",open,staticfloat,,,,5,2022-04-22T21:01:07.0,2024-04-10T22:28:47.0,1184,465,https://github.com/JuliaLang/Pkg.jl/issues/3067,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3067,"I've received the same question a few times now about the proper way to set up a Julia installation such that it includes an extra entry on the `DEPOT_PATH` for the purposes of a """"shared depot"""", e.g. lab-provided packages, global preference defaults, etc....\n\nI know there are a few options for setting this up, (`JULIA_DEPOT_PATH` in the environment, pushing onto `DEPOT_PATH` in `startup.jl`, etc...) but most of the users who have asked are doing something like running a computer lab, and they don't want each user to have to modify their own `startup.jl`, or modify their `.bash_profile` to pick these things up.  It would be nice if there were some way we could modify something in the Julia distribution itself that caused the `DEPOT_PATH` to be altered at startup.\n\nRight now, I'm thinking the best way to do this is to modify the Julia installation to have the following put into `etc/julia/startup.jl`:\n\n```\npush!(Base.DEPOT_PATH, """"/path/to/shared/environment"""")\n```\n\nNote that this will not work if the user starts up Julia with `--startup-file=no`, but I consider that a feature, not a bug.  Is this the best thing we should suggest that folks do in this case, or is there a better idea?","[omlins]: I think the following brought up in #3061, would still be good to dicuss further (@staticfloat, any further comments?):\n\nMe:\n> @staticfloat , @vchuravy : how about having in the loadpath a default location where the default preferences are looked up - analogue to @stdlib? It would be nice if we could be 100% sure that preferences defined in the Julia installation by cluster administrators are taken always into account if not explicitly and intentionally overwritten by the user- even in cases where the Pkg manager wants to create a """"clean"""" environment etc.\n\n@staticfloat :\n> This can be done by having users define a default JULIA_DEPOT_PATH that includes a system-wide depot. I don't suggest using @stdlib as this, since @stdlib has kind of a special meaning; it doesn't act like a true """"depot"""". Let's open a new issue about the best way for system administrators to provide defaults (preferences, packages, etc...) for their users: https://github.com/JuliaLang/Pkg.jl/issues/3067\n\nMe:\n> > I don't suggest using https://github.com/stdlib as this, since https://github.com/stdlib has kind of a special meaning; it doesn't act like a true """"depot"""".\n\n> My suggestion is not to abuse @stdlib for preferences, but to create in Pkg.jl an analogue to @stdlib for preferences, e.g. @stdprefs, which points to the standard location of preferences in the Julia installation.\n\n@vchuravy :\n> Please add it as a comment to https://github.com/JuliaLang/Pkg.jl/issues/3067, I don't have any strong opinions, but we need to build community consensus around it. | [omlins]: @giordano ? | [vchuravy]: Also note that Elliot is currently on vacation | [einzigsue]: HI @omlins and @staticfloat, \n\nPlease, it would be super useful. \n\nI read the Julia documentation about JULIA_DEPOT_PATH [https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH] and DEPOT_PATH [https://docs.julialang.org/en/v1/base/constants/#Base.DEPOT_PATH] but I don't think it works for me like a stack of environment Pkg.jl would search through for a package. \n\nFor example when length(DEPOT_PATH)=3 it only reads through the first path, see details below. \n\nDid I miss anything?\n\n```\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.2 (2022-02-06)\n _/ |\__'_|_|_|\__'_|  |  HEAD/bf53498635 (fork: 461 commits, 337 days)\n|__/                   |\n\njulia> versioninfo()\nJulia Version 1.7.2\nCommit bf53498635 (2022-02-06 15:21 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin21.2.0)\n  CPU: Apple M1\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, cyclone)\nEnvironment:\n  JULIA_DEPOT_PATH = /Users/Sue/Julia/tenv1:/Users/Sue/Julia/tenv2:/Users/Sue/Julia/tenv3\n\njulia> DEPOT_PATH\n3-element Vector{String}:\n """"/Users/Sue/Julia/tenv1""""\n """"/Users/Sue/Julia/tenv2""""\n """"/Users/Sue/Julia/tenv3""""\n\n(v1.7) pkg> st\n      Status `/Users/sue/Julia/tenv1/environments/v1.7/Project.toml`\n  [179af706] CFTime v0.1.2\n\njulia> using CFTime\n\njulia> using CSV\n │ Package CSV not found, but a package named CSV is available from a registry. \n │ Install package?\n │   (v1.7) pkg> add CSV \n └ (y/n) [y]: n\nERROR: ArgumentError: Package CSV not found in current path:\n- Run `import Pkg; Pkg.add(""""CSV"""")` to install the CSV package.\n\nStacktrace:\n [1] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:967\n\njulia> using NLopt\n │ Package NLopt not found, but a package named NLopt is available from a\n │ registry. \n │ Install package?\n │   (v1.7) pkg> add NLopt \n └ (y/n) [y]: n\nERROR: ArgumentError: Package NLopt not found in current path:\n- Run `import Pkg; Pkg.add(""""NLopt"""")` to install the NLopt package.\n\nStacktrace:\n [1] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:967\n\njulia> popfirst!(DEPOT_PATH)\n""""/Users/Sue/Julia/tenv1""""\n\njulia> using CSV\n[ Info: Precompiling CSV [336ed68f-0bac-5ca0-87d4-7b16caf5d00b]\n\njulia> pathof(CSV)\n""""/Users/Sue/Julia/tenv2/packages/CSV/jFiCn/src/CSV.jl""""\n\njulia> DEPOT_PATH\n2-element Vector{String}:\n """"/Users/Sue/Julia/tenv2""""\n """"/Users/Sue/Julia/tenv3""""\n\njulia> using NLopt\n │ Package NLopt not found, but a package named NLopt is available from a registry. \n │ Install package?\n │   (v1.7) pkg> add NLopt \n └ (y/n) [y]: n\nERROR: ArgumentError: Package NLopt not found in current path:\n- Run `import Pkg; Pkg.add(""""NLopt"""")` to install the NLopt package.\n\nStacktrace:\n [1] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:967\n\njulia> popfirst!(DEPOT_PATH)\n""""/Users/Sue/Julia/tenv2""""\n\njulia> using NLopt\n[ Info: Precompiling NLopt [76087f3c-5699-56af-9a33-bf431cd00edd]\n...\n\njulia> pathof(NLopt)\n""""/Users/Sue/Julia/tenv3/packages/NLopt/OIUOZ/src/NLopt.jl""""\n\njulia> \n```\n | [GregPlowman]: > but I don't think it works for me like a stack of environment Pkg.jl would search through for a package.\n> \n> For example when length(DEPOT_PATH)=3 it only reads through the first path, see details below.\n> \n> Did I miss anything?\n\nI also expected stacked environments to work as you described, but also observe that it seems only the first entry in `DEPOT_PATH` is searched.",5,false,1,1,0,0,0,0,0,0,0
2549,Unable to install JLL package from private repo,open,sloede,,,,1,2021-05-04T04:12:04.0,2024-04-04T20:06:46.0,1538,471,https://github.com/JuliaLang/Pkg.jl/issues/2549,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2549,"Right now, trying to install a JLL package from a private repository fails during the artifact download stage. I believe the reason is that even though the package itself can be installed, e.g., in my case due to presence of an authorized SSH key, downloading the artifacts will use `https` and then silently fails. Or, rather it fails verbosely but without giving a clear indication of what actually went wrong (the latter issue of nondescript error messages seems already to be tracked in #1659).\n\n```julia\njulia> import Pkg\n\njulia> Pkg.add(url=""""git@github.com:sloede/MySecretPackage_jll.jl"""")\n    Updating git-repo `git@github.com:sloede/MySecretPackage_jll.jl`\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n  Downloaded artifact: MySecretPackageBinary\n  Downloaded artifact: MySecretPackageBinary\nERROR: Unable to automatically install 'MySecretPackageBinary' from '/home/mschlott/.julia/packages/MySecretPackage_jll/CqbjC/Artifacts.toml'\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:33\n  [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n    @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443\n  [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n    @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508\n  [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706\n  [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683\n  [6] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Vector{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1237\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Iterators.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:203\n  [8] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:79\n  [9] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:77\n [10] #add#22\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:74 [inlined]\n [11] add\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:74 [inlined]\n [12] add(; name::Nothing, uuid::Nothing, version::Nothing, url::String, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:97\n [13] top-level scope\n    @ REPL[2]:1\n```\n\n@giordano @imciner2 Thanks for helping to figure out the likely root cause!",[sairus7]: Same issue discussed here: https://discourse.julialang.org/t/artifacts-can-basic-authentication-be-used/54453,1,false,0,0,0,0,0,0,0,0,0
3845,Specifying registries needed for a project in the Project file,open,KristofferC,,,,3,2024-03-14T16:41:57.0,2024-04-01T20:06:42.0,492,474,https://github.com/JuliaLang/Pkg.jl/issues/3845,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3845,"From https://github.com/JuliaLang/Pkg.jl/pull/3783#issuecomment-1974794079\n\n> Could it make sense to be able to specify a registry in the sources block? Maybe with a separate registries block to have the url. That way a Project/Manifest does not need to depend on the registries already being installed.\n\n`[sources]` made it easier to resolve a manifest with unregistered dependencies without having to manually add these dependencies by URL. However, you still need to make sure that the registries are available. So the next step would be to store the set of registries needed in the project file as well so that they are automatically installed for you.\n\nThis issue is about how to specify that information in the project file.\n\nThe first question is if we need to store the UUID of the registry somewhere. It's kind of silly since there are so few registries. If we then only look at the registry name we could have:\n\n```toml\n[registries]\nCustomRegistry = """"https://my.custom.registry/CustomRegistry""""\n...\n```\n\nor maybe this should be a dict and be\n\n```toml\n[registries]\nCustomRegistry = {url = """"https://my.custom.registry/CustomRegistry""""}\n...\n```\n\n------\n\nShould custom registries be auto-added to the project file once a package is added to the project that is not available in general?\n\n---------\ncc @ericphanson, @Seelengrab","[Seelengrab]: I don't have much of an opinion on how exactly the data is stored, but IMO having the UUID doesn't really cost us all that much but is a gain UX wise. We should already check for uniqueness when doing `]registry add` right?\n\n> Should custom registries be auto-added to the project file once a package is added to the project that is not available in general?\n\nI think so, yeah. Without that information, the project is still not instantiable from just Project.toml alone. Making `General` less special in that regard seems fruitful to me, so that other installations can e.g. completely remove `General` and just have their (perhaps vetted) registry. In that sense, `General` should also be added to `[registries]` as soon as a package is added that's sourced from it. | [vchuravy]: Copying what I just posted in Slack here:\n\n> One thought with regards to [sources] I just came across a package that has dependencies that exist in a different registry. It would be nice if we had a section in the Project.toml that would prompt the user upon a Pkg.add(url) to add the corresponding registries.\n> Maybe in [sources] we could even state the registry the package is coming from allowing for version resolution over just tracking a branch.\n\n> Should custom registries be auto-added to the project file once a package is added to the project that is not available in general?\n\nHm, my gut went with asking before adding the registry, but maybe auto-adding is fine.\n\n\n\n> The first question is if we need to store the UUID of the registry somewhere. It's kind of silly since there are so few registries. If we then only look at the registry name we could have:\n\nWe could make it follow the same semantics as a Pkg.\n\n```\n[registries]\nCustomRegistry = UUID\n\n[sources]\nCustomRegistry = """"https://my.custom.registry/CustomRegistry""""\n``` | [GunnarFarneback]: Until we have a satisfactory solution to #2393 (dependency confusion), I'd be wary of adding registries without confirmation.",3,false,5,3,0,0,0,0,2,0,0
3859,resolve errors if some packages are missing on disk,open,fredrikekre,,,,2,2024-04-01T14:40:00.0,2024-04-01T15:05:39.0,475,475,https://github.com/JuliaLang/Pkg.jl/issues/3859,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3859,Requires `instantiate` + `resolve`.,"[IanButterworth]: Isn't this expected because of `dev`-ed packages and the resolver needing to read their Project.toml rather than the registry info?\n\nOr is it happening in the absence of `dev`-ed packages? | [fredrikekre]: The error wasn't for a `dev`d package, but I think for a `add`ed-by-branch one.",2,false,0,0,0,0,0,0,0,0,0
3853,Things get very confusing when putting the wrong name to a UUID in the project file,open,KristofferC,,,,2,2024-03-22T17:51:48.0,2024-03-22T19:01:32.0,484,484,https://github.com/JuliaLang/Pkg.jl/issues/3853,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3853,"Try a project file with:\n\n```\n[deps]\nForwardDiff = """"0f1e0344-ec1d-5b48-a673-e5cf874b6c29""""\n```\n\nactivate it and then do:\n\n```\njulia> Pkg.add(""""ForwardDiff"""")\n   Resolving package versions...\n    Updating `/tmp/jl_RX2R13/TestWeakDepProject/Project.toml`\n  [0f1e0344] + ForwardDiff v0.8.21\n    Updating `/tmp/jl_RX2R13/TestWeakDepProject/Manifest.toml`\n```\n\nThis now actually installed version 0.8.12 of WebIO (https://github.com/JuliaGizmos/WebIO.jl/releases/tag/v0.8.21) for which this is the UUID for. \n","[DilumAluthge]: 😬 | [staticfloat]: Probably worthwhile to have the package printing recognize when you've locally altered the name of your package in opposition to what the loaded registry would call it, and print something like:\n\n```\njulia> Pkg.add(""""ForwardDiff"""")\n   Resolving package versions...\n    Updating `/tmp/jl_RX2R13/TestWeakDepProject/Project.toml`\n  [0f1e0344] + WebIO (mapped as ForwardDiff) v0.8.21\n    Updating `/tmp/jl_RX2R13/TestWeakDepProject/Manifest.toml`\n```",2,false,0,0,0,0,0,0,0,0,0
669,Store packages in different place than user folder - change DEPOT_PATH,open,MaWo2,,documentation,,3,2018-08-17T14:51:43.0,2024-03-20T13:36:48.0,2529,487,https://github.com/JuliaLang/Pkg.jl/issues/669,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/669,"Dear developers.\n\nFollowing up on my discussion with @KristofferC in the Julia forum (see [here](https://discourse.julialang.org/t/where-or-how-to-edit-depot-path/13501)) I want to suggest to make it more clear, how the user can change the ```DEPOT_PATH``` or to adjust the hard-coded paths to some other folder than the user folder. Storing basically tens of thousands of files in the user folder makes login/logout in corporate environments extremely slow, if the folder get synchronised with a server.\n\nI am working in a Windows environment with Active Domain Directory syncing the user folder and profiles on every login/logout. When I installed ```julia``` 1.0 and added a few larger packages (amongst them Plots, Images, Taro) I was already looking at 40,000 new files in the user folder. Restarting the computer took basically ages, because each login and logout needed 10 minutes.\n\nI wanted to change the package folder then. I found two resources that seemed helpful: The documentation of [Pkg](https://docs.julialang.org/en/latest/stdlib/Pkg/) and [this](https://stackoverflow.com/questions/36398629/change-package-directory-in-julia) discussion. The discussion provided code to change the environment variable, but the markdown looks like it was done from the REPL (although the leading ```pkg>```, ```shell>``` or ```julia>``` is missing). Accordingly, I tried to change the ```JULIA_DEPOT_PATH``` variable from the REPL and obviously failed, because it had to be set for the Windows operating system. Re-reading the stackoverflow discussion now, after I got help from the ```julia``` forum, I see where I was misinterpreting things. However, I think other users - especially unexperienced - might have the same problem.\n\nI think the easiest/fastest way to make things clearer would be to extend the documentation.\n\n1. Please include one or two sentences that make it clear, that the environment variables are OS-settings. On Windows they are accessed by ```Win+R``` (run) ```sysdm.cpl``` --> Advanced tab --> environment variables (button at the bottom of the tab).\n2. Make it clear how to adjust the DEPOT_PATH variable from within the REPL (using ```empty!``` and ```push!``` commands, for instance) and that this change is not permanent. To make it permanent, it needs to be included in the ```startup.jl```.\n\nBoth points might also be an example for the [FAQ](https://github.com/JuliaLang/Pkg.jl/issues/615)'s.\n\nTwo more options came to my mind.\n\n1. The Windows-installer for ```julia``` lets me choose the folder for the installation. Although it is preset to the user folder, I can change it to any folder I have writing permission for. It would be helpful, if the user could chose the DEPOT_PATH during this step as well.\n2. If it is too difficult to include the first step, would it be possible to change the default storage to a path relative to the install folder for ```julia```? Example: I want to install ```julia``` to ```C:\Julia```, then - in my eyes - a good position for the package depot would be e.g. ```C:\Julia\packages```. If the packages are installed in the same directory as ```julia``` then the user would also notice possible """"left-overs"""" after uninstallation.\n","[StefanKarpinski]: @MozzyTrd: the new system is not any less capable—on the contrary, you can do much more with it—it's just unfamiliar to you. It would be helpful if you can open issues with your specific problems. | [00vareladavid]: @MozzyTrd's issue seems to have been resolved on [discourse](https://discourse.julialang.org/t/v1-0-pkg-cant-copy-packages/18764). As you say, the system was perfectly capable. It just takes time for best practices to become apparent | [StefanKarpinski]: Glad to hear it all worked out.",3,false,5,5,0,0,0,0,0,0,0
3828,`]compat` REPL menu throws when pressing backspace one too many times,open,LilithHafner,,bug; REPL,,1,2024-03-05T16:12:59.0,2024-03-05T16:23:04.0,501,501,https://github.com/JuliaLang/Pkg.jl/issues/3828,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3828,"Conjectured problem:\nWhen editing compat entries, the UI lets me press backspace one to many times, deleting the entire string and one additional character. This causes a bounds error when I type a new character.\n\nKeystrokes:\n`]compat[enter][enter][backspace][backspace][space]`\n\nResult:\n```julia\nChairmarks) pkg> compat\n      Compat `~/.julia/dev/Chairmarks/Project.toml`\n  Select an entry to edit:\n >            julia         1\n   [de0858da] Printf        <0.0.1, 1\n   [9e88b42a] Serialization 1.11.0\n  Edit compat entry for julia:ERROR: BoundsError: attempt to access empty String at index [0:0]\nStacktrace:\n  [1] checkbounds\n    @ ./strings/basic.jl:216 [inlined]\n  [2] getindex(s::String, r::UnitRange{Int64})\n    @ Base ./strings/string.jl:468\n  [3] compat(ctx::Pkg.Types.Context; io::Nothing)\n    @ Pkg.API ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/API.jl:2065\n  [4] compat\n    @ ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/API.jl:1986 [inlined]\n  [5] compat()\n    @ Pkg.API ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/API.jl:2109\n  [6] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:409\n  [7] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:390\n  [8] do_cmd\n    @ ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:380 [inlined]\n  [9] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/Pkg/src/REPLMode/REPLMode.jl:557\n [10] #invokelatest#2\n    @ ./essentials.jl:892 [inlined]\n [11] invokelatest\n    @ ./essentials.jl:889 [inlined]\n [12] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/REPL/src/LineEdit.jl:2656\n [13] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/REPL/src/REPL.jl:1312\n [14] (::REPL.var""""#62#68""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ~/.julia/juliaup/julia-1.10.2+0.aarch64.linux.gnu/share/julia/stdlib/v1.10/REPL/src/REPL.jl:386\n```\n\nPresent in 1.10.2 and 1.11.0-alpha0",[KristofferC]: Moved to Pkg repo.,1,false,0,0,0,0,0,0,0,0,0
2626,better diagnostic for write failures during registry download,open,stevengj,,error handling,,1,2021-06-16T16:21:24.0,2024-03-04T15:30:55.0,1494,502,https://github.com/JuliaLang/Pkg.jl/issues/2626,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2626,"As I commented [on discourse](https://discourse.julialang.org/t/debugging-registry-download-problem/63021), we got a mysterious `ERROR: could not download` message during registry installation from a fresh Julia download (empty `.julia`), even though the download progress bar apparently completed and a manual `download` call succeeded for the same URL. \n\nSwitching to `JULIA_PKG_SERVER=""""""""` yielded a more informative error from `git clone`: the problem was that the `/tmp` directory had a quota that we were exceeding (perhaps not from the download itself but from a subsequent unpacking step?).\n\nIt would be good if the pkgserver-based registry installation provided more informative error messages for write failures like this.  (""""could not download"""" sounds like misleadingly like a network problem.)","[anshibanov]: It's actual. For example, we need message when access denied",1,false,2,2,0,0,0,0,0,0,0
3808,Make spinners spin more slowly,open,eschnett,,,,2,2024-02-24T17:19:40.0,2024-02-24T18:26:44.0,511,511,https://github.com/JuliaLang/Pkg.jl/issues/3808,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3808,"I was updating Julia packages over an unstable internet connection and I didn't like how fast the spinners were running. I think they spin about twice per second.\n\nI looked at the Pkg.jl code, and I found that setting the environment variable `CI=true` would disable all progress output. That's good, but I was looking for something fancier – just slowing down the progress output, not eliminating it.\n\nI think it would be possible to make the spinner speed configurable with a rather small code change. I think this line https://github.com/JuliaLang/Pkg.jl/blob/e7e8ce38359330441b1340046add367761035f69/src/API.jl#L1389 defines how fast the spinners are.\n\nOne could add a new global variable\n```Julia\nconst PRECOMPILE_SPINNER_INTERVAL = Ref(0.1)\n```\nto the code, and then create the Timer via `Timer(0; interval=PRECOMPILE_SPINNER_INTERVAL[])`. This would allow changing the spinners by setting a global variable. A similar mechanism is already used in `MiniProgressBars.jl` where two variables are defined https://github.com/JuliaLang/Pkg.jl/blob/e7e8ce38359330441b1340046add367761035f69/src/MiniProgressBars.jl#L21-L22\n","[KristofferC]: How does the precompile spinner relate to your internet connection? | [eschnett]: I was logged in via a slow connection and issued an `]update` command from the Julia REPL, which lead to precompiling a few package that take a minute to do so (CairoMakie?) while showing the spinners. The spinners didn't spin smoothly.",2,false,0,0,0,0,0,0,0,0,0
1062,Introduce `down` as opposite of `up`,open,oxinabox,,feature,,13,2019-02-14T15:34:01.0,2024-02-20T02:20:43.0,2347,516,https://github.com/JuliaLang/Pkg.jl/issues/1062,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1062,"I wish to test that I have set the lower bounds in my project.toml correctly.\nI thus want to check that with the oldest package versions that can be compatibly installed,\nmy tests still pass.\n\nSo I want to do the oppoite of `]up`","[fredrikekre]: This should probably just be flag to `pkg> test` rather than a `pkg> down` command. | [oxinabox]: No, because when debugging I want to instantiate the set of package versions I am testing on.\nAnd then I can incrementally raise my lower bound, and run `pkg> resolve` and then test again.\n\nIf it is important to me to have the lowest lower bound I can, \nI might fiddle around with the code to make it work on an older version,\nand so I will want that older version loaded so I can do prototyping in the REPL etc.\n\nand especially when your tests take a long time\nretesting just the snippet of code that breaks is good. | [StefanKarpinski]: `pkg> down` seems reasonable to me although it might just be a shortcut for `pkg> up --lower` or something like that. | [oxinabox]: matching this\n`pkg> rand`\nor `pkg> up --random`\n\nTo get a random set of compatible versions. | [cossio]: Related post from rust: https://users.rust-lang.org/t/psa-please-specify-precise-dependency-versions-in-cargo-toml/71277. | [marius311]: Are there any hacks to do this right now? I agree it'd be really useful for exactly the reason stated by OP. The place I'd really want to use it is for my CI; if available, I'd test with both the highest and lowest possible compatible dependency versions. | [KristofferC]: @carlobaldassi, what would be required in the resolver to support this? I am guessing just redefining some stuff in https://github.com/JuliaLang/Pkg.jl/blob/master/src/Resolve/versionweights.jl but are there more things? If you could have some example code I could integrate it easily. | [carlobaldassi]: @KristofferC I think that the main change would be to reverse the sorting order of versions of the required packages (while leaving the rest unchanged) here: https://github.com/JuliaLang/Pkg.jl/blob/76070d295fc4a1f27f852e05400bbc956962e084/src/Resolve/graphtype.jl#L128\n\nThen I think it might be sufficient to negate the second argument `vweight[p0][v0]` here: https://github.com/JuliaLang/Pkg.jl/blob/76070d295fc4a1f27f852e05400bbc956962e084/src/Resolve/maxsum.jl#L61\n\nI suspect this may be all (plus of course passing around some flags), but it's hard to tell without testing. Unfortunately, due to personal matters, I don't have the time for doing that myself at the moment.\n\nOn the other hand, I wonder whether it would be best to simply call the solver with the versions of the explicitly required dependencies fixed to their declared lower bounds. In my mind, that would be simpler, safer, and more precise.\nThere would be no need to further increase the complexity of the resolver code, and it would actually test that the declared lower bounds work. After all, if the resolver finds that it cannot set a package version to its declared lower bound due to an incompatibility with some other required package, then the lower bound should be raised, no? Or am I missing something?\n | [KristofferC]: Thanks! I will experiment with those changes.\n\n>  On the other hand, I wonder whether it would be best to simply call the solver with the versions of the explicitly required dependencies fixed to their declared lower bounds.\n\nSo in this case you would get the lowest version of your direct dependencies but with those fixed you would maximize the versions of the transitive dependencies. I think that makes sense, it's definitely worth trying, I will try that too and see what happens. | [oxinabox]: > On the other hand, I wonder whether it would be best to simply call the solver with the versions of the explicitly required dependencies fixed to their declared lower bounds. \n\nAnd would we then error if those lower bounds can not all be concurrently achieved?\nIf so that seems like it would have a few problems.\nBecause we don't want errors\n\nFirstly, they may not ever all be possible to take to their lower bounds at once, but possible to each take to lower bounds individually. In contrast, using the resolver might not take all the their lowerest bounds, but would at least hit a point on the pareto frontier of lowness. \n\nSecondly, it means that if you update lower bounds on one package, and it is no longer compatible with other old lower bounds, then this will cause errors  that don't correspond to anything real. Since it isn't a version the resolver could ever give. And this would mean the author has to go and update all the other lower bounds. Which is make work.\nForcing the human to do the work of the resolver for no reason.\n\nThirdly just fixing based on Project.toml will miss out that the oldest version may have been yanked from the registry, so will at least need to instersect with that, since that is also not a case that the resolver will ever return.\nIf you do intersect with registry like that it will be possible for people to break your CI testing by yanking their package even if you are compatible with other non-yanked versions.\n\nIn short this seems no more sensible than making `] up` fix the versions to the upper bounds declared, for basically the same reasons. | [KristofferC]: \n> In short this seems no more sensible than making `] up` fix the versions to the upper bounds declared, for basically the same reasons.\n\nI am not sure about that because the reason you have a lower bound is that you require something specific and known that happened in that version, while for an upper bound you are protecting yourself against future unknown breakage. So it isn't self evident to me that these are completely symmetric things and that `down` should be handled completely equal to `up` except with version checking inverted.\n\nFor example, even with `down` I think you still want the highest version possible of transitive dependencies because you cannot change `compat` to directly influence which of those you are going to get. So I like the suggestion that `down` would only try to downgrade direct dependencies while leaving transitive dependencies to still be maximized under that constraint. | [KristofferC]: The reason for having `down` is specifically to test that your lower bounds are correct and it feels important to actually hit exactly those lower bounds in `down`. If all you are testing is lower versions of your package (but these are still higher than your lower bounds), then it feels like the point of doing this at all is more or less lost. | [oxinabox]: > I am not sure about that because the reason you have a lower bound is that you require something specific and known that happened in that version, while for an upper bound you are protecting yourself against future unknown breakage. \n\nA fair point.\nthing I really don't like though is if changes in other peoples code (like one of my dependencies no longer supporting the same lower bound I do) can cause me to have to change my Project.toml.\n\n> The reason for having down is specifically to test that your lower bounds are correct and it feels important to actually hit exactly those lower bounds in down.\n\nI would argue the point is to pick somewhere on the downward parento-fountier of achievable (not declared) downness.\nIdeally would check every point on the pareto-frontier of downness, but that is potentially too much work.\n\n\n> Even with down I think you still want the highest version possible of transitive dependencies because you cannot change compat to directly influence which of those you are going to get. So I like the suggestion that down would only try to downgrade direct dependencies while leaving transitive dependencies to still be maximized under that constraint.\n\nI very much agree with this.\nBecause we are looking primarily for how you might have messed up by how your code might be called a method that doesn't exist, or doesn't work as you think it does in older versions.\nAnd methods you call are normally in your direct dependencies (and if they are not then they really should be)\n\n\n",13,false,5,0,0,0,0,0,0,5,0
3801,Request: keep `complete_remote_package` reacheable via REPLMode,open,j-fu,,,,0,2024-02-18T20:52:31.0,2024-02-18T20:52:31.0,517,517,https://github.com/JuliaLang/Pkg.jl/issues/3801,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3801,"With the creation of `REPLExt`, `complete_remote_package` is not anymore visible in REPLMode. \n\nFor use in Pluto.jl (see https://github.com/fonsp/Pluto.jl/issues/2810) it would be good to declare this function in `REPLMode.jl` and extend it in `REPLExt.jl`. \n\nAlso it would probably be good to mark this as public API (1.11 style).\n",,0,false,0,0,0,0,0,0,0,0,0
3044,"LibGit2 Clone Fails: ""Unable to exchange encryption keys""",open,jmulcahy,,,,3,2022-03-28T21:53:11.0,2024-02-18T07:03:18.0,1209,518,https://github.com/JuliaLang/Pkg.jl/issues/3044,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3044,"Cloning git repos from a private Gitlab instance via Pkg is failing for me on Julia 1.6 and 1.7. The current Julia 1.8 beta works for some reason. Setting `JULIA_PKG_USE_CLI_GIT=true` with Julia 1.7 also works. I'm using an RSA SSH key. \n\nThe error returned is `GitError(Code:ERROR, Class:SSH, failed to start SSH session: Unable to exchange encryption keys)`. \n\nI have no doubt this is due to my peculiar and specific Gitlab set up, but I don't know how to debug this. Any ideas?","[barucden]: #3030 is this related? | [jmulcahy]: I don't think so. It worked on Julia 1.8 on a machine that only had an RSA key, but not 1.6 and 1.7 with that same key. Maybe it works in 1.8 due to some other upgrade that has happened in the SSH stack? | [judober]: I have the same Problem since 1.10. Setting `JULIA_PKG_USE_CLI_GIT` helped.",3,false,0,0,0,0,0,0,0,0,0
3795,Bad resolve if different build metadata versions have different dependencies,open,mortenpi,,,,0,2024-02-14T10:41:50.0,2024-02-14T10:41:50.0,522,522,https://github.com/JuliaLang/Pkg.jl/issues/3795,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3795,"Not 100% clear I understand everything here, but it looks like a bug to me:\n\nConsider the following (valid) Manifest (+all the deps; full MWE environment [in this gist](https://gist.github.com/mortenpi/ecf9de3c00c59f344f039887df9f9b02); can almost be recreated with `pkg> add Wayland_jll#Wayland-v1.21.0+0`):\n\n```toml\n[[deps.Wayland_jll]]\ndeps = [""""Artifacts"""", """"Expat_jll"""", """"JLLWrappers"""", """"Libdl"""", """"Libffi_jll"""", """"Pkg"""", """"XML2_jll""""]\ngit-tree-sha1 = """"ed8d92d9774b077c53e1da50fd81a36af3744c1c""""\nuuid = """"a2964d1f-97da-50d4-b82a-358c7fce9d89""""\nversion = """"1.21.0+0""""\n```\n\nwhen resolving this manifest (including on `1.11.0-DEV.1593 (2024-02-14)`), you end up with this diff:\n\n```diff\n+[[deps.EpollShim_jll]]\n+deps = [""""Artifacts"""", """"JLLWrappers"""", """"Libdl""""]\n+git-tree-sha1 = """"8e9441ee83492030ace98f9789a654a6d0b1f643""""\n+uuid = """"2702e6a9-849d-5ed8-8c21-79e8b8f9ee43""""\n+version = """"0.0.20230411+0""""\n+\n\n [[deps.Wayland_jll]]\n-deps = [""""Artifacts"""", """"Expat_jll"""", """"JLLWrappers"""", """"Libdl"""", """"Libffi_jll"""", """"Pkg"""", """"XML2_jll""""]\n+deps = [""""Artifacts"""", """"EpollShim_jll"""", """"Expat_jll"""", """"JLLWrappers"""", """"Libdl"""", """"Libffi_jll"""", """"Pkg"""", """"XML2_jll""""]\n git-tree-sha1 = """"ed8d92d9774b077c53e1da50fd81a36af3744c1c""""\n uuid = """"a2964d1f-97da-50d4-b82a-358c7fce9d89""""\n version = """"1.21.0+0""""\n```\n\nThe `Wayland_jll` version does not get updated, but `EpollShim_jll` gets added as a new dependency, leading to an invalid manifest. This is because [Wayland_jll added EpollShim_jll as a dependency when going from `1.21.0+0` -> `1.21.0+1`](https://github.com/JuliaBinaryWrappers/Wayland_jll.jl/commit/3f61b6046748dc6a94b706498a8dea48a34daeca#diff-72ed386c2a0cd1d23c0968297e70023ed98c22490d146dd89fc91f48369bad4d).\n\nNot really sure whose """"fault"""" it is here, but it feels like Pkg should not generate invalid manifests, even if there's the build metadata magic happening. Instead, it should either update the version or don't update dependency list.\n\nX-ref: https://github.com/JuliaLang/Pkg.jl/issues/1568",,0,false,0,0,0,0,0,0,0,0,0
3774,"Base.runtests([""Pkg""]) hangs",open,vtjnash,,test,,5,2024-02-01T15:34:02.0,2024-02-13T14:57:10.0,534,523,https://github.com/JuliaLang/Pkg.jl/issues/3774,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3774,"```\njulia> Base.runtests([""""Pkg""""])\nRunning parallel tests with:\n  getpid() = 5539\n  nworkers() = 1\n  nthreads() = 1\n  Sys.total_memory() = 7.274 GiB\n  Sys.free_memory() = 1.777 GiB\n\nTest  (Worker) | Time (s) | GC (s) | GC % | Alloc (MB) | RSS (MB)\nPkg        (1) |        started at 2023-12-17T08:10:38.155\n┌ Info: Pkg Server metadata:\n│ HTTP/2 301 \n│ server: Varnish\n│ retry-after: 0\n│ location: https://us-east.pkg.julialang.org/\n[...]\n    Updating `/tmp/jl_CXNkw2/environments/v1.11/Project.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl#master`\n    Updating `/tmp/jl_CXNkw2/environments/v1.11/Manifest.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl#master`\n    Updating `/tmp/jl_CXNkw2/environments/v1.11/Project.toml`\n  [7876af07] - Example v0.5.4 `https://github.com/JuliaLang/Example.jl#master`\n    Updating `/tmp/jl_CXNkw2/environments/v1.11/Manifest.toml`\n  [7876af07] - Example v0.5.4 `https://github.com/JuliaLang/Example.jl#master`\n     Cloning git-repo `https://github.com/DoesNotExist/DoesNotExist.jl`\nUsername for 'https://github.com': \n```\n\n`Base.runtests([""""sorting"""", """"Pkg""""]; ncores=2)`, on the other hand, works fine. Presumably because in the latter case Pkg tests are run in a separate worker with a stdin other than stdin, so Pkg can detect that prompting for credentials is fruitless.\n\n_Originally posted by @LilithHafner in https://github.com/JuliaLang/julia/issues/52562_\n","[IanButterworth]: To fix this we can either:\n- Go back to not testing `JULIA_PKG_USE_CLI_GIT=1` https://github.com/IanButterworth/Pkg.jl/blob/b13bd2ddf6049865ddd8f7984bc9aa2790c14d21/test/new.jl#L2730\n- Figure out how to tell git on CI that it should never prompt for credentials | [vtjnash]: `GIT_TERMINAL_PROMPT=0`? Or `GIT_ASKPASS=true` | [IanButterworth]: We already set the former. I can try the latter | [vtjnash]: Still hangs. After mucking around a bit with the process, I ended up being able to extract this trace:\n```\n     ---- Task 4 (0x7ffaa52a92d0)\n          (sticky: 1, started: 1, state: 0, tid: 1)\njl_swap_fiber at /home/vtjnash/julia/src/task.c:1366\nctx_switch at /home/vtjnash/julia/src/task.c:571\nijl_switch at /home/vtjnash/julia/src/task.c:650\ntry_yieldto at ./task.jl:934\nwait at ./task.jl:1008\n#wait#720 at ./condition.jl:130\nwait at ./condition.jl:125 [inlined]\nwait_readnb at ./stream.jl:416\neof at ./stream.jl:106\niterate at ./io.jl:1380 [inlined]\n_copyuntil at ./io.jl:1005\n#copyuntil#493 at ./io.jl:994 [inlined]\ncopyuntil at ./io.jl:994 [inlined]\n#copyline#517 at ./iobuffer.jl:587 [inlined]\ncopyline at ./iobuffer.jl:586 [inlined]\n#readline#483 at ./io.jl:617\nreadline at ./io.jl:617 [inlined]\n#prompt#1107 at ./util.jl:391\nprompt at ./util.jl:388\nunknown function (ip: 0x7ffa8e5b77d2)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\n#prompt#1108 at ./util.jl:399\nprompt at ./util.jl:399 [inlined]\nauthenticate_userpass at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/callbacks.jl:217\ncredentials_callback at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/callbacks.jl:332\ncredentials_callback at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/callbacks.jl:355\nunknown function (ip: 0x7ffa8e5b6e61)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njlcapi_cfunction_45231 at /home/vtjnash/julia/usr/share/julia/compiled/v1.11/Pkg/tUTdb_OHcd8.so (unknown line)\nhandle_auth at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\nhandle_response.constprop.5 at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\nhttp_stream_read at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\ngit_smart__recv at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\ngit_smart__store_refs at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\ngit_smart__connect at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\ngit_remote_connect_ext at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\ngit__clone at /home/vtjnash/julia/usr/bin/../lib/libgit2.so.1.7 (unknown line)\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/error.jl:113 [inlined]\nclone at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/repository.jl:459\n#clone#123 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/LibGit2.jl:585\nclone at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/LibGit2.jl:558 [inlined]\n#clone#3 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/GitTools.jl:121\nclone at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/GitTools.jl:88\nunknown function (ip: 0x7ffa8e5bafdd)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\ndo_apply at /home/vtjnash/julia/src/builtins.c:831\n#103#104 at ./error.jl:298\n#103 at ./error.jl:293 [inlined]\n#50 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:238\n#mktempdir#28 at ./file.jl:819\nunknown function (ip: 0x7ffa8e5ba06d)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\nmktempdir at ./file.jl:815\nmktempdir at ./file.jl:815 [inlined]\n#48 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:202\n#mkpidlock#7 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/FileWatching/src/pidfile.jl:95\nmkpidlock at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/FileWatching/src/pidfile.jl:92 [inlined]\n#mkpidlock#6 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/FileWatching/src/pidfile.jl:90 [inlined]\nmkpidlock at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/FileWatching/src/pidfile.jl:90 [inlined]\ndownload_registries at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:168\n#add#34 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:47\nunknown function (ip: 0x7ffa8e5b788e)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\nadd at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:43\n#add#31 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:40 [inlined]\nadd at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/src/Registry/Registry.jl:40 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/new.jl:2754 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Test/src/Test.jl:773 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/new.jl:2754 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Test/src/Test.jl:1700 [inlined]\n#708 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/new.jl:2752\n#10 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/utils.jl:82\nwithenv at ./env.jl:265\n#isolate#9 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/utils.jl:73\nisolate at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/utils.jl:51 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/new.jl:2735 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Test/src/Test.jl:1700 [inlined]\n#707 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/new.jl:2735\nwithenv at ./env.jl:265\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\ndo_call at /home/vtjnash/julia/src/interpreter.c:126\neval_value at /home/vtjnash/julia/src/interpreter.c:223\neval_stmt_value at /home/vtjnash/julia/src/interpreter.c:174 [inlined]\neval_body at /home/vtjnash/julia/src/interpreter.c:675\njl_interpret_toplevel_thunk at /home/vtjnash/julia/src/interpreter.c:815\ntop-level scope at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/new.jl:2733\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:943\njl_eval_module_expr at /home/vtjnash/julia/src/toplevel.c:215 [inlined]\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:743\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:886\nijl_toplevel_eval_in at /home/vtjnash/julia/src/toplevel.c:994\neval at ./boot.jl:428 [inlined]\ninclude_string at ./loading.jl:2260\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\n_include at ./loading.jl:2320\ninclude at ./Base.jl:556\njfptr_include_43348 at /home/vtjnash/julia/usr/lib/julia/sys.so (unknown line)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\njl_f__call_latest at /home/vtjnash/julia/src/builtins.c:875\ninclude at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/runtests.jl:10 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/runtests.jl:83 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Test/src/Test.jl:1789 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/runtests.jl:63 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Test/src/Test.jl:1700 [inlined]\n#1 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/runtests.jl:62\nwith_logstate at ./logging.jl:515\nunknown function (ip: 0x7ffa99b57a53)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\nwith_logger at ./logging.jl:625\nunknown function (ip: 0x7ffa99b4bce6)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\ndo_call at /home/vtjnash/julia/src/interpreter.c:126\neval_value at /home/vtjnash/julia/src/interpreter.c:223\neval_stmt_value at /home/vtjnash/julia/src/interpreter.c:174 [inlined]\neval_body at /home/vtjnash/julia/src/interpreter.c:675\njl_interpret_toplevel_thunk at /home/vtjnash/julia/src/interpreter.c:815\ntop-level scope at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Pkg/test/runtests.jl:37\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:943\njl_eval_module_expr at /home/vtjnash/julia/src/toplevel.c:215 [inlined]\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:743\njl_eval_module_expr at /home/vtjnash/julia/src/toplevel.c:215 [inlined]\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:743\njl_toplevel_eval_flex at /home/vtjnash/julia/src/toplevel.c:886\nijl_toplevel_eval_in at /home/vtjnash/julia/src/toplevel.c:994\neval at ./boot.jl:428 [inlined]\ninclude_string at ./loading.jl:2260\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\n_include at ./loading.jl:2320\ninclude at ./Base.jl:556 [inlined]\nmacro expansion at /home/vtjnash/julia/test/testdefs.jl:33 [inlined]\nmacro expansion at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Test/src/Test.jl:1700 [inlined]\nmacro expansion at /home/vtjnash/julia/test/testdefs.jl:26 [inlined]\nmacro expansion at ./timing.jl:578 [inlined]\n#runtests#53 at /home/vtjnash/julia/test/testdefs.jl:24\nruntests at /home/vtjnash/julia/test/testdefs.jl:5 [inlined]\nruntests at /home/vtjnash/julia/test/testdefs.jl:5\nunknown function (ip: 0x7ffa99b4166d)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\njl_f__call_latest at /home/vtjnash/julia/src/builtins.c:875\n#invokelatest#2 at ./essentials.jl:1027 [inlined]\ninvokelatest at ./essentials.jl:1022 [inlined]\n#153 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Distributed/src/remotecall.jl:425 [inlined]\nrun_work_thunk at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Distributed/src/process_messages.jl:70\nunknown function (ip: 0x7ffa99b3159b)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\n#remotecall_fetch#158 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Distributed/src/remotecall.jl:450\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\ndo_apply at /home/vtjnash/julia/src/builtins.c:831\nremotecall_fetch at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Distributed/src/remotecall.jl:449\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\ndo_apply at /home/vtjnash/julia/src/builtins.c:831\n#remotecall_fetch#162 at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Distributed/src/remotecall.jl:492\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\ndo_apply at /home/vtjnash/julia/src/builtins.c:831\nremotecall_fetch at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/Distributed/src/remotecall.jl:492\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\n#39 at /home/vtjnash/julia/test/runtests.jl:264\nunknown function (ip: 0x7ffa99b30bdf)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\njl_apply at /home/vtjnash/julia/src/julia.h:2165 [inlined]\nstart_task at /home/vtjnash/julia/src/task.c:1258\n     ---- End task 4\n``` | [IanButterworth]: I'm not sure why we needed to move this issue discussion over, but in the other issue you said\n\n> According to gdb, the problem is in Pkg not in git. \n\n\nbut in the trace it shows\n```\n_copyuntil at ./io.jl:1005\n#copyuntil#493 at ./io.jl:994 [inlined]\ncopyuntil at ./io.jl:994 [inlined]\n#copyline#517 at ./iobuffer.jl:587 [inlined]\ncopyline at ./iobuffer.jl:586 [inlined]\n#readline#483 at ./io.jl:617\nreadline at ./io.jl:617 [inlined]\n#prompt#1107 at ./util.jl:391\nprompt at ./util.jl:388\nunknown function (ip: 0x7ffa8e5b77d2)\n_jl_invoke at /home/vtjnash/julia/src/gf.c:2941 [inlined]\nijl_apply_generic at /home/vtjnash/julia/src/gf.c:3118\n#prompt#1108 at ./util.jl:399\nprompt at ./util.jl:399 [inlined]\nauthenticate_userpass at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/callbacks.jl:217\ncredentials_callback at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/callbacks.jl:332\ncredentials_callback at /home/vtjnash/julia/usr/share/julia/stdlib/v1.11/LibGit2/src/callbacks.jl:355\n```\n\nSo it's the credentials prompt, no?",5,false,0,0,0,0,0,0,0,0,0
3781,Move `Unregistered.jl` used in testing to `JuliaLang` org?,open,Seelengrab,,,,1,2024-02-06T20:16:59.0,2024-02-07T02:10:18.0,529,529,https://github.com/JuliaLang/Pkg.jl/issues/3781,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3781,"https://github.com/JuliaLang/Pkg.jl/blob/dbf114fa92a6b367e225aea504cce6f361b584e6/test/new.jl#L105\n\nIt's probably not a good idea to have Pkg add a somewhat random package not under the control of the JuliaLang org during its tests.\n\nNot that I think this is malicious, to be clear :) The code is just a generated """"Hello world"""" package after all.","[DilumAluthge]: Yeah, it would make sense to have it under JuliaLang.",1,false,2,2,0,0,0,0,0,0,0
3780,Add back recurring precompile tests,open,IanButterworth,,,,0,2024-02-06T20:16:29.0,2024-02-06T20:16:29.0,529,529,https://github.com/JuliaLang/Pkg.jl/issues/3780,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3780,See https://github.com/JuliaLang/Pkg.jl/pull/3361 which has been reverted,,0,false,0,0,0,0,0,0,0,0,0
621,Introduce `env` command to manage environments,open,carstenbauer,,feature request; REPL,,19,2018-08-11T15:09:31.0,2024-02-05T23:05:40.0,2535,530,https://github.com/JuliaLang/Pkg.jl/issues/621,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/621,"It would be nice to have a command for listing all environments. Currently the best one can do is `gc`, which will output a list at the top. Also, autocompletion for environment names when doing activate would be nice.","[00vareladavid]: At the very least: adding tab completion for `pkg> activate --shared` should be straightforward. | [carstenbauer]: It feels strange to me that julia manages environments in a somewhat hidden manner. It keeps a list of all active manifests (environments), as can be seen by `gc`,  but doesn't let me see the list easily (this issue), doesn't have autocompletion (this issue), and also doesn't let me remove environments without deleting them on disk.\n\nWhy not make this more transparent?\n\n`activate` could add an environment to the list, `listenvs` could list all known environments, and `rmenv` could remove an environment. The user would have more control over what julia tracks. | [fredrikekre]: It seems iffy that Pkg should be able to remove environments. What should be deleted? The `Project.toml` and `Manifest.toml` files? | [carstenbauer]: Nothing should actually be deleted. Julia should just stop keeping track of that particular environment (manifest). I.e. the manifest should be removed from the list that I see when I do `gc`. | [carstenbauer]: I have this use case in mind: My collaborator sends me a project folder. I wanna check it out so I do `activate .` and `instantiate`. However, from that point on I have the projects dependencies installed and can't free them up without deleting the whole project folder.\n\nWhy can't the user tell Julia to ignore this environment again? I mean it also didn't track it automatically when I created it on my disk. Only when I did activate it at some point. | [fredrikekre]: How about\n```\n(v1) pkg> listenv\n[1] `/home/fredrik/.julia/environments/v0.7/Manifest.toml`\n[2] `/home/fredrik/.julia/environments/v1.0/Manifest.toml`\n[3] `/home/fredrik/TestProject/Manifest.toml`\n\n(v1) pkg> activate 3\n\n(TestProject) pkg>\n``` | [carstenbauer]: Looks great! | [carstenbauer]: > It seems iffy that Pkg should be able to remove environments. What should be deleted? The Project.toml and Manifest.toml files?\n\nMaybe, to avoid the confusion, the command to remove an environment from the list should be called `untrack` or similar rather than `rmenv`. | [StefanKarpinski]: What about an `env` command and an `env list` subcommand? | [carstenbauer]: > What about an `env` command and an `env list` subcommand?\n\nAnd `env untrack`? Sounds great to me.\n\nAlthough I'd love to make a PR to get this merged soonish, I feel I'm not the right person for this. So hopefully someone else will give it a shot soon. I'd appreciate it! | [00vareladavid]: I renamed the issue to focus on `env`. #834 exists for tab completion on `activate` (which should be made a lot simpler by #839). | [carstenbauer]: Is someone working on this? I'd love to see this in 1.1 and I heard feature freeze is mid Nov. | [carstenbauer]: @fredrikekre talk at juliacon yesterday reminded me of this feature request. Someone from the audience basically wanted the `env untrack` functionality.\n\nTo add to the list of features that go under `env`, it would be cool to make stacking/unstacking environments (i.e modifying the load path) easier, such that one could use autocomplete for this as well. Something like `env stack --shared SomeEnv`. What do you think? | [Datseris]: I'm just adding an argument about why all of this is very useful. Just asked on Slack if there is some command exactly like `env untrack` described here. There isn't one yet.\n\nHere is a reason why deleting the `Manifest.toml` or renaming it does not work. Scientists (at least in my workplace) are required to keep an archive of the code and data base they used in a scientific project, for several years after the project has been published. I have such bases, which are currently tracked by the package manager, thereby keeping installations of old packages (without much use). I do not want to (and legally, I also cannot) alter these archived code bases by removing or renaming any file, much less so such an important file as a `Manifest.toml`.\n\nThis is the currently best standing workaround by @fredrikekre \n```\n$ mv Project.toml _Project.toml\n$ mv Manifest.toml _Manifest.toml\n$ pkg gc\n$ mv _Project.toml Project.toml\n$ mv _Manifest.toml Manifest.toml\n``` | [carstenbauer]: FWIW, came up on slack again (someone was looking for `env untrack` functionality). | [KristofferC]: I think something like described here makes sense. | [carstenbauer]: Brought up once more: https://discourse.julialang.org/t/which-files-or-subdirectories-in-julia-can-i-delete/62230 | [StefanKarpinski]: `env untrack --old` might work nicely with `gc` to allow reclaiming stuff that's rooted by environments that haven't been used in a long time. cf #2685 | [halleysfifthinc]: I just bumped into needing/wanting this (I had 72Gb of artifacts) and making do with PkgCleanup from `@giordano` (removed 60Gb of artifacts after """"untracking"""" old manifests). The default behavior of Pkg to never forget an manifest is somewhat inconsistent with the officially(?) blessed workflow recommendation to limit use of the default environment and use local env's for everything. How does that not lead to an enormous group of artifacts only kept around for old environments?",19,false,16,16,0,0,0,0,0,0,0
3766,`Add` requires weakdeps to be accessible in the available registries,open,agerlach,,,,1,2024-01-19T20:31:05.0,2024-01-19T20:49:49.0,547,547,https://github.com/JuliaLang/Pkg.jl/issues/3766,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3766,"Currently adding a package with a weakdep requires the weakdep to be present in an available registry. However, it seems reasonable that a package may have a weakdep that isn't available to all potential users or is a local dev package. \n\n## Example\n\nI have PkgA on local registry A and PkgB on local registry B. Is it possible to make PkgB a weakdep to PkgA where a user of PkgA may not have access to registry B. I would think this should be possible but I get something like the following, where the UUID is for PkgB.\n\n```\npkg> add PkgA\n   Resolving package versions...\nERROR: cannot find name corresponding to UUID 5f2853af-5fcd-4df5-818b-ccf2a074bbd0 in a registry\n```\n\n```\njulia> versioninfo()\nJulia Version 1.10.0\nCommit 3120989f39b (2023-12-25 18:01 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin22.4.0)\n  CPU: 12 × Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, skylake)\n  Threads: 14 on 12 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = 10\n  JULIA_EDITOR = code\n```\n\nJulia installed via juliaup","[KristofferC]: Yeah, I think that should be allowed.",1,false,0,0,0,0,0,0,0,0,0
3765,Having a dependency in an uninstalled registry,open,aaruni96,,,,0,2024-01-19T12:43:33.0,2024-01-19T12:43:33.0,548,548,https://github.com/JuliaLang/Pkg.jl/issues/3765,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3765,"[Feature Request]\n\nI am trying to create a julia package which I could publish on the general registry (for discoverability and ease of installation), which depends on some packages in a custom registry. Is such a thing possible?\n\nOne solution I could imagine is, in the package's Project.toml, in the deps section, we could have the link mentioned (no link = the default registry), and the package resolver could simply add the registry to the depot whenever it encounters such a dependency ?\n\n```toml\n[deps]\nPackage = """"UUID"""" @ https://link/to/registry.git\n```\n",,0,false,0,0,0,0,0,0,0,0,0
3412,"`]update` always downloads registries, no matter the options",open,aplavin,,,,7,2023-03-17T08:59:34.0,2024-01-16T14:17:51.0,856,551,https://github.com/JuliaLang/Pkg.jl/issues/3412,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3412,"Seems like there's no way to disable redownloading all registries every time `]update` is run. In particular, it ignores `UPDATED_REGISTRY_THIS_SESSION`:\n```julia\njulia> import Pkg\n\njulia> Pkg.UPDATED_REGISTRY_THIS_SESSION[] = true\ntrue\n\n(@v1.9) pkg> up\n    Updating registry at `~/.julia/registries/General`\n```\nPresumably, this is an oversight? Aside from rare circumstances (where one can use `]registry up`), it's not necessary to update registries every time `]update` is run in some environment, potentially many times a day.","[fredrikekre]: I would guess it is deliberate since it would be pretty strange if update didn't update. What is the problem with updating the registry? | [aplavin]: It's just annoying to switch to another env, run `]up`, and again wait for all (two in my case) registries to redownload. Even though it's not needed the majority of the time.\nIsn't it the purpose of `UPDATED_REGISTRY_THIS_SESSION` setting to avoid unnecessary registry updates? | [fredrikekre]: But if the updates result in downloading new package, artifacts, precomilation etc, isn't the registry update the least time consuming thing? For me it is instant. | [aplavin]: If it's basically instant, why Pkg went with reducing the number of registry updates at all? :) Eg https://github.com/JuliaLang/Pkg.jl/pull/3320 and the whole `UPDATED_REGISTRY_THIS_SESSION` setting.\n\nFor me:\n```julia\njulia> @time Registry.update()\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n    Updating registry at `~/.julia/registries/MyRegistry`\n    Updating git-repo `git@github.com:aplavin/MyRegistry.git`\n  4.812394 seconds (444.05 k allocations: 33.018 MiB, 0.48% gc time, 11.76% compilation time)\n```\nIt's not a dealbreaker, but would be nice to shave these 5 seconds, especially when very few package updates are actually done. | [aplavin]: And it may take much more time on flaky connections. | [fredrikekre]: > If it's basically instant, why Pkg went with reducing the number of registry updates at all?\n\nBecause it used to be slow, in particular on Windows. #3320 was to decrease the chance of having to re-precompile.\n\nI guess you have disabled the Pkg server deliberately, but just for comparison\n```\njulia> @time Pkg.Registry.update()                                      # with Pkg server\n  0.054385 seconds (1.96 k allocations: 124.258 KiB)\n\njulia> @time Pkg.Registry.update()                                      # with git\n  1.858832 seconds (28.12 k allocations: 2.856 MiB, 1.11% compilation time)\n``` | [aplavin]: Would be nice to have the ability to """"update packages given the current registries state"""". Especially given that precompilation times increased a lot in the recent years, and it often makes sense to use the same package versions in several envs when possible. `]update` that always updates the registries makes it more difficult.\n\nGenerally, there are two sets of Pkg operations: package operations like `]add` and `]rm`, and registry operations like `]registry add`. The latter always download/update the registry, while the former only do it from time to time, and depending on `UPDATED_REGISTRY_THIS_SESSION`. In this scheme of things, `]update` is an outlier: it's fundamentally a package operation, but it _always_ redownloads registries no matter what options are set.",7,false,1,1,0,0,0,0,0,0,0
3762,Folder with Project misinterpreted as being a package,open,jakobnissen,,,,2,2024-01-16T08:24:04.0,2024-01-16T11:22:10.0,551,551,https://github.com/JuliaLang/Pkg.jl/issues/3762,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3762,"I was running a scientific project in a folder with the following layout:\n```\nBinbench\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── src\n│  ├── 20231130.jl\n│  └── main.jl\n[ more files and folders ... ]\n```\nWhen installing packages into my project, I got:\n```\nERROR: expected the file `src/Binbench.jl` to exist for package `Binbench` at `/home/jakni/Documents/binbench`\n```\nWhen adding `src/Binbench.jl`, I got the even more obscure:\n```\nWARNING: --output requested, but no modules defined during run\nlld: error: cannot open /home/jakni/.julia/compiled/v1.10/Binbench/jl_HRxkzA: No such file or directory\n  ◑ Binbench\n```\nThis is not a package, it's just a scientific project with an associated Project.toml.\nMy issues are twofold:\n\n1. Why does Julia insist this has to be formatted like a package? Why can't I just have a bunch of scripts in a directory with a Project file?\n2. The error message is not great.\n\nI didn't use to have this problem on earlier versions of Julia IIRC.","[KristofferC]: I think it believes it is a package if it has a `name` entry in the Project file. | [jakobnissen]: Ah, I see. Yes indeed I manually typed in the `name` field, and removing that resolves the issue. Perhaps the error message could be improved.",2,false,0,0,0,0,0,0,0,0,0
3753,Avoid re-cloning registries with `Pkg.Registry.add`,open,omus,,,,1,2024-01-09T20:36:42.0,2024-01-09T21:30:19.0,557,557,https://github.com/JuliaLang/Pkg.jl/issues/3753,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3753,"If you use `Pkg.Registry.add` to add an already existing registry the entire registry will be downloaded first before the conflict is noticed:\n\n```sh\n$ mkdir -p /tmp/julia-depot\n$ export JULIA_DEPOT_PATH=/tmp/julia-depot JULIA_PKG_SERVER=""""""""\n$ time julia -e 'using Pkg; Pkg.Registry.add(""""General"""")'\n     Cloning registry from """"https://github.com/JuliaRegistries/General.git""""\n       Added registry `General` to `/tmp/julia-depot/registries/General`\njulia -e 'using Pkg; Pkg.Registry.add(""""General"""")'  26.10s user 7.72s system 80% cpu 41.826 total\n\n$ time julia -e 'using Pkg; Pkg.Registry.add(""""General"""")'\n     Cloning registry from """"https://github.com/JuliaRegistries/General.git""""\nRegistry `General` already exists in `/tmp/julia-depot/registries/General`.\njulia -e 'using Pkg; Pkg.Registry.add(""""General"""")'  26.37s user 11.05s system 86% cpu 43.262 total\n```","[omus]: Mainly this is an issue for CI. Specifically if you were to use `julia-actions/cache` with registry caching and later use `julia-actions/julia-buildpkg` the `Pkg.Registry.add(""""General"""")` call in that action can result in wasting time cloning a repository that is already present on disk.",1,false,2,2,0,0,0,0,0,0,0
3744,"In a monorepo, if any vendored package has an unregistered dep, all the other vendored packages fail to resolve their env",open,Drvi,,bug,,2,2024-01-04T10:59:47.0,2024-01-05T10:00:28.0,563,562,https://github.com/JuliaLang/Pkg.jl/issues/3744,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3744,"<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including:\n\n1. The output of `versioninfo()`\n2. How you installed Julia\n3. A minimal working example (MWE), also known as a minimum reproducible example\n\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n\nRepo with a MRE: https://github.com/Drvi/MonorepoResolverIssue, the README provides more details.\n\nI would expect that vendored packages would not fail to resolve in this situation (since they are failing due to a dependency that resolves fine for the packages that actually need it).\n\nMy `versioinfo()` (installed via `juliaup`)\n```\nJulia Version 1.10.0\nCommit 3120989f39b (2023-12-25 18:01 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 10 × Apple M1 Max\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, apple-m1)\n  Threads: 1 on 8 virtual cores\n```\n","[NHDaly]: (This works for `dev`'d dependencies, right? so it's specific to `add`ing an unregistered dep?) | [Drvi]: Right! We don't get issues with `dev`'d packages.",2,false,2,2,0,0,0,0,0,0,0
3509,`]update` removes entries owned by projects from a shared Manifest.toml,open,lassepe,,,,1,2023-06-08T12:00:19.0,2023-12-22T10:20:53.0,773,576,https://github.com/JuliaLang/Pkg.jl/issues/3509,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3509,"While playing around with the new `manifest = """"path/to/shared/Manifest.toml""""` feature of the `Project.toml` in Julia 1.9, I noticed some surprising behavior:\n\nContext/Setup\n- I have a repo with """"subprojects"""" A, B, and C, with B depending on A and C depending on B.\n- At this same root, I have a `Project.toml` to define an environment which also uses this `Manifest.toml`. From within this project, I did `dev ./A ./B ./C`\n- In each subproject I set `manifest = ../Manifest.toml` to point to the shared Manifest at the root of the project\n\nIssue:\nIf I issue `]update` while having activated environment A, this will delete all the (direct and indirect) dependencies of B and C from the global `Manifest.toml` , and also B and C themselves. The video below illustrated this issue and you can play with it yourself by cloning this repo: https://github.com/lassepe/HelloJuliaMonoRepo.jl\n\nhttps://github.com/JuliaLang/Pkg.jl/assets/10076790/af8895a6-e8ea-458b-b098-c49bb2543568\n\nI suspect that this happens because A does not know that the additional content in it's manifest is there due to the fact that this file is shared with other projects.\n\nAs @KristofferC noted on Slack, this should have been handled by this check:\nhttps://github.com/JuliaLang/Pkg.jl/blob/edc137f46792d9373ca6d6f91907d55341226a52/src/Operations.jl#L925-L926\n\n",[lassepe]: I just took a look at this again. I suspect that the problem is that we `empty!(manifest)` even before we `prune_manifest(env)`:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/2c04d5a981042292fa71ce87acfee6b44d6c0b7b/src/Operations.jl#L138\n\nI do not understand the internals of Pkg.jl sufficiently to judge if this `empty!` can just be unconditionally dropped; I guess it's there for a good reason.,1,false,0,0,0,0,0,0,0,0,0
3545,Cannot `pkg> dev .` a package with extensions inside a shared environment?,open,gdalle,,,,2,2023-07-10T08:48:44.0,2023-12-21T08:20:58.0,741,577,https://github.com/JuliaLang/Pkg.jl/issues/3545,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3545,"Following a [recent discussion on dev environments](https://discourse.julialang.org/t/how-should-i-use-revise-jl-and-other-developer-tools-to-develop-a-package/101344/13), I tried this new workflow with a shared environment. But when I used `pkg> dev .` on a locally downloaded package with extensions (aka weakdeps, introduced in Julia 1.9), this failed spectacularly.\nWeirdly enough, it works with a temporary environment.\n\nSee here for a reproducible example with a lightweight package of mine called HiddenMarkovModels.jl:\n\n[https://asciinema.org/a/595665 3](https://asciinema.org/a/595665)\n\nThe error is the following one (HMMBase.jl is a weakdep of HiddenMarkovModels.jl):\n\n```julia\nERROR: `HiddenMarkovModels=84ca31d5-effc-45e0-bfda-5a68cd981f47` depends on `HMMBase=b2b3ca75-8444-5ffa-85e6-af70e2b64fe7`, but no such entry exists in the manifest.\n```\n\nSteps to reproduce:\n```\ncd /tmp\ngit clone https://github.com/gdalle/HiddenMarkovModels.jl\ncd HiddenMarkovModels.jl\njulia                                    \n```\n```julia\npkg> activate @mytemporarydevenvironment  # using activate --temp this works\npkg> dev .\n```\n\nMy Julia is installed with `juliaup`, here's the version info:\n```julia\njulia> versioninfo()\nJulia Version 1.9.2\nCommit e4ee485e909 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 1 on 8 virtual cores\n```","[johnomotani]: I ran into a similar issue. Playing around a bit, if I remove the `@` it seems to work for me, i.e. do\n```julia\npkg> activate mytemporarydevenvironment\n```\nI have no idea why though!\n\nAlso sometimes (I haven't figured out when though...) I also seem to need to create an empty `Project.toml`. | [gdalle]: For anyone looking at this, HiddenMarkovModels.jl no longer has HMMBase.jl as an extension so my MWE will now fail. But the same should happen with other packages",2,false,1,0,0,0,0,1,0,0,0
3741,Pkg.rm should be able to remove weakdeps and extras,open,IanButterworth,,,,0,2023-12-20T18:44:37.0,2023-12-20T18:44:37.0,577,577,https://github.com/JuliaLang/Pkg.jl/issues/3741,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3741,"```\n(jl_sUKZ8X) pkg> rm Example\nERROR: The following package names could not be resolved:\n * Example (not found in project or manifest)\n ```\n\nAlso in the case that you have the following, it won't be able to find Example because of the way it is treated as a weakdep, which is consistent, but a little unfriendly.\n```\n[deps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\n\n[weakdeps]\nExample = """"7876af07-990d-54b4-ab0e-23690620f79a""""\n```\n",,0,false,0,0,0,0,0,0,0,0,0
3518,`resolve` complains if a dependency is not instantiated,open,staticfloat,,,,1,2023-06-13T20:17:32.0,2023-12-19T18:13:55.0,767,578,https://github.com/JuliaLang/Pkg.jl/issues/3518,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3518,"Recently, I have noticed that on builds of Julia `master`, I am getting errors such as the following:\n\n```\npkg> resolve\n\nExpected package Foo to exist at path ...\n```\n\nIt was my understanding that `resolve` should not really care about whether packages are instantiated or not (indeed, `instantiate` recommends running `resolve` first if the project requirements have changed).  I thought `resolve` should only read in the project, the registry, and then write out a new manifest?","[staticfloat]: Just ran into this again, it's especially annoying when trying to `free` something or similar, and it fails because you haven't instantiated.",1,false,0,0,0,0,0,0,0,0,0
3713,Resolve should notice when you are being version bound to require something apparently not released yet (due to registry being out of date),open,oxinabox,,,,1,2023-11-28T11:40:03.0,2023-12-13T03:27:00.0,600,585,https://github.com/JuliaLang/Pkg.jl/issues/3713,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3713,"If my registry is out of date, but I close a project that someone else has been working on (perhaps with a manifest),\n then I can have a (direct or indirect) dependency that `resolve` thinks it can't satisfy due to it being a **larger version number than anything in the registry.** \n\nFor example \n ```\n(MyProject) pkg> resolve\nERROR: Unsatisfiable requirements detected for package MathTeXEngine [0a4f8689]:\n MathTeXEngine [0a4f8689] log:\n ├─possible versions are: 0.1.0 - 0.5.6 or uninstalled\n └─restricted to versions 0.5.7 by an explicit requirement — no versions left\n ```\n\nThe solution in this case is to update the registry, either directly via `registry update` or via something like `up` which will trigger an update.\nPkg could notice this and prompt you to update registry,\nthat would be clearer than this error.\n\nTechnically there are 4 ways I know this can occur\n\n1. Out of date registry (as described above)\n2. Direct dependency, which is supposed to be `dev`ed to a version that has the update in its Project.toml (love that feature that that works)\n3. the release has been made but it is in a registry you don't have installed\n4. there was a mistake in the `[compat]` section of the Project.toml\n\nI think 1 is the most likely so we could have a helpful message suggesting that as a first thing to try?",[oxinabox]: Arguably this is a duplicate of https://github.com/JuliaLang/Pkg.jl/issues/3649,1,false,1,1,0,0,0,0,0,0,0
1233,"Proposal for ""sub-projects"".",open,KristofferC,,enhancement; feature,,55,2019-06-19T10:53:18.0,2023-12-12T21:05:00.0,2223,585,https://github.com/JuliaLang/Pkg.jl/issues/1233,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1233,"I have had an idea for a while which I call """"sub-projects"""" and we discussed it on the pkg-dev call yesterday. The post here is to summarize that discussion.\n\n1. What problem does sub-projects try to solve?\n\n    There are cases where we use multiple Project.toml in a package. One common such scenario is for documentation where there is a Project typically containing Documenter.jl and the package (which has a relative path in the Manifest.toml). The documentation Manifest.toml file contains the full resolved state (independent of the """"main Manifest.toml). The problem is that, with time, it is very likely that the version of dependencies in the docs Manifest.toml drift away from the version of dependencies in the main Manifest.toml. This is likely not desired since things like doctest might pass with the docs Manifest.toml but might not pass when the main Manifest.toml is used.\n    The same applies to having a test specific Project / Manifest but there it is arguably even worse because now you are not sure that the tests that are run are representative for running the package with the main Project.toml active. What we want here is to be able to use the main Manifest.toml, but give some extra additional dependencies that are only used for docs / testing.\n\n    Another problem area is shown by looking at the """"model-zoo"""" for machine learning models in Julia: https://github.com/FluxML/model-zoo. Each model has a separate Project / Manifest and to run a model you set that as the active project and then include the model. The problem here is that each model can potentially use vastly different versions of packages that all models have in common (Flux, NNLib, CuArrays etc). Actually using code from the model zoo then becomes very annoying since it is hard to get your own project in the same state as the models run in. What we want here is to be able to give a set of packages at a fixed version (Flix, NNlib, CuArrays etc), have all models run on those versions, but also have each model add some extra dependencies because it needs to do something special (e.g. read image files).\n\n    So to summarize, the core issue is that there is no way to """"incrementally"""" add a chunk of a dependency graph to an existing project. If you want to add extra dependencies in a scenario, you need a full copy of Project.toml / Manifest.toml and this will eventually lead to divergence between versions in that Manifest and the main-project.\n\n2. What is a sub-project?\n\n    A sub-project is in essence an incremental addition of packages to an already existing """"main-project"""". There needs to be some way to identify the main-project from the sub-project, and right now, the details for how this is done is not important but we could envision a `main-project = """"..""""` entry into the sub-project `Project.toml` to give a relative path to the main-project which is here one directory above.\n\n    The core property of a sub-project is that when you resolve it, *versions for dependencies in the manifest for the main-project are fixed*. In other words, the resolved state of a sub-project is only an incremental addition to the existing dependency graph that is set by the main-project. That means that the compat info in a sub-project *must* be consistent (resolvable) with the existing versions in the main project.\n\n    This would allow us to have a test or documentation project which simply is a sub-project to the main project. Since the version of the dependencies are forced to be the same in the sub-project we know (modulo type piracy and similar issues) that the tests we run in these sub-projects will work with the manifest in the main-project.\n\n3. Implementation questions:\n    1. How should sub-projects be identified?\n        Firstly, it is desirable to be able to see that a project is a sub-project """"locally"""" (i.e. by only looking at the directory of the sub-project).\n        Thus, we want to have some information in the sub-project to show that it, in fact, is a subproject. One proposal is to have a `main-project = $path_to_main_project` entry in the Project.toml.\n\n        Relevant for point 3.2 is also if the main project should have some mapping to sub-projects. It feels annoying to have to specify both `main-project` in the sub-project and a list of `sub-projects` in the main-project so preferable that can be avoided.\n\n    2. What should resolve do in a main-project in the presence of sub-projects?\n\n        If we re-resolve the main-project (upon e.g. an `update`), the main Manifest will change. The sub-manifests are now """"out of sync"""" with the main-manifest, so they are potentially in a non-resolvable state. This is bad. One possible solution to this is that, if any sub-projects exist, resolving the main-project also resolves and updates all sub-projects. If any of these resolves fail, the resolve it rejected. That would keep all sub-manifests in sync at all times.\n\n    3. What changes are needed to code-loading?\n\n        Sub-projects are different from main-projects in that they only specify additional dependencies outside the main-project. This has some problems when it comes to the current implementation of code-loading in Julia.\n        As an example, in the case where package `A` is in the main project and package `B` depending on `A` is in the sub-project, activating the subproject and loading `B` will error because we cannot find `A` in the current project. Code loading needs to know that it should look in the main-project for the UUID to `A`.\n\n        A related issue is what should go into the sub-manifest.\n        There are two choices. Either the full Manifest is stored or only the addition of dependencies that comes from the sub-project is stored.\n        In isolation, the latter choice is clearly preferable since it doesn't repeat any redundant information. This might however mean that we need to slightly complicate the code loading to also deal with partial manifests. Since it seems we might need to touch code loading anyway, I think only storing the extra info is the way to go.\n\n\n\n\n","[tpapp]: > Relevant for point 3.2 is also if the main project should have some mapping to sub-projects.\n\nA reasonable default could be all `**/Project.toml` in the directory tree of the original `Project.toml`. This would work out of the box for documentation sub-projects, and also for the model zoo example.\n\nIf necessary, we could have a syntax for excluding from and adding to this, but I would save that for later. | [davidanthoff]: It seems to me that at least for packages, there just shouldn't be `Manifest.toml` files at all, certainly not in the git repo for a package. That seems to apply both to the package itself, as well as any `Project.toml`s that are in the test or docs folder.\n\nI've tried to sort of facilitate this with the latest version of the VS Code extension for docs: the doc build task now actually copies the `Project.toml` from the docs folder into a temporary directory, instantiates it there, and then runs the doc build in that temporary environment. So at that point, if a user relies on the VS Code UI to run their doc builds, no `Manifest.toml` will be created, which seems like the best option to me.\n\nMaybe a much simpler solution would be to try to move to a world where these `Manifest.toml` files just never get created inside packages? A pretty radical suggestion would be to introduce a new file `JuliaPackage.toml` that one could use instead of `Project.toml`, and when that is present, `Manifest.toml`s just don't get created, nor read if present. So at that point, if I activate a package (which I still find weird in general, TBH), it will just resolve to the latest versions of everything, subject to the compat bounds in `JuliaPackage.toml`. If I want to force certain versions during dev, I just create a separate (potentially shared) environment, dev the package into that, and record any specific versions of packages in that outer env. | [KristofferC]: > It seems to me...\n\nThis post is terribly off topic. Please open a separate issue / discourse post to discuss this. | [KristofferC]: > A reasonable default could be all **/Project.toml in the directory tree of the original Project.toml. This would work out of the box for documentation sub-projects, and also for the model zoo example.\n\nIt would then be all Project.toml in subdirectories that have a `main-project = ` entry that points to that main-project. It works but since there is no explicit mapping you need to look for them all the time. Might be no problem but if the project contains a huge number of folders and files, it might be slow? | [DilumAluthge]: Out of curiosity, what is the status on this?\n\nUnfortunately I don’t have time to implement this myself, but if someone else is working on it, I’d be happy to help test a prototype. | [tkf]: > The problem is that, with time, it is very likely that the version of dependencies in the docs Manifest.toml drift away from the version of dependencies in the main Manifest.toml.\n\nI think this is sometimes a desired property.  I'm using `test/environments/jl10/Manifest.toml` for running CI with `julia` 1.0 and using `test/Manifest.toml` for the latest `julia` https://github.com/tkf/Transducers.jl/pull/116.  This is required because many packages started to drop `julia` < 1.3 due to the new artifacts facility.  Another scenario is testing with oldest compatible upstream packages.  If all sub-projects have to have shared dependencies, it becomes impossible to test packages in such scenarios.\n | [KristofferC]: Read this now https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html, which seems to be a quite similar thing. | [KristofferC]: Some updates here after talking with @fredrikekre \n\n- There should be one Manifest, and that is next to the main project. That collects the full dependency graph.\n- The main project lists the subprojects, `subprojects = [""""SubProject""""]`.\n- A subproject can only live one level deeper than the main project.\n- A subproject has a normal Project.toml and becomes a subproject if the path above it has a Project.toml with a `subprojects` entry pointing to it.\n- The resolver collects dependencies from the main project and all sub projects, same for compat, runs the resolver and outputs it to the main Manifest.\n- Code loading would have to be updated to look for the main project in case it doesn't find the uuid for a package at a top-level package, or if it doesn't find a manifest next to the current project. \n- A sub project shouldn't have other sub projects. | [00vareladavid]: > The resolver collects dependencies from the main project and all sub projects, same for compat, runs the resolver and outputs it to the main Manifest.\n\nThis is the real tricky part. With only one subproject, things work fine. The problem is 2+ subprojects. Say A is the root project and has B and C as subprojects. We want to express """"A dependends on B and C, but not simultaneously"""". The """"not simultaneous"""" will place less restrictions on the resolver, but AFAIU there is no easy way to express that. Have you put any thought into this problem? | [KristofferC]: Everything gets resolved in one step. You collect all deps, and all compat and then run the resolver. The result gets put in the main `Manifest.toml`. I don't get what\n\n> We want to express """"A dependends on B and C, but not simultaneously"""".\n\nmeans. | [00vareladavid]: Say subproject A restricts dependency X to version 1, but subproject B restricts dependency X to version 2. This is not a problem because only one subproject is active at a time, but if you shove everything into the resolver at once, it will error.\n\nPerhaps this will not be a problem in practice? | [KristofferC]: It is a problem and will not resolve. All your subprojects need to be compatible. One of the major points is to be able to use one manifest for all subprojects. | [00vareladavid]: Gotcha, just making sure. It might be annoying, but it seems like potentially just an edge case. In any case I see no clear solution to that problem. | [davidanthoff]: I like it! In particular that there is only one `Manifest.toml`, that will make supporting subprojects _sooo_ much easier in LanguageServer.jl.\n\n> - A subproject can only live one level deeper than the main project.\n> - A subproject has a normal Project.toml and becomes a subproject if the path above it has a Project.toml with a subprojects entry pointing to it.\n\nCould the sub-project `Project.toml` have an entry `parentproject` in it instead that points to the parent `Project.toml`, and then the one level deeper constraint could be dropped?\n\nOne thing that has turned out really tricky in the LS implementation are situations where the meaning of a file like `Project.toml` depends on surrounding context. For example, if `Project.toml` just had a flag in it that indicated whether this is a `Project.toml` for a package or not, things would be a lot easier than what we do now (where we try to figure the answer to that question out by looking at various other stuff). This here strikes me as a similar situation: it would a lot easier for us if we could just look at the content of a `Project.toml`, and purely based on the content figure out whether this is a sub-project, rather than having to deduce that from the surrounding files. | [KristofferC]: > Could the sub-project Project.toml have an entry parentproject in it instead that points to the parent Project.toml, and then the one level deeper constraint could be dropped?\n\nIn that case, we would just keep searching upwards, having to define a bidirectional mapping would be too annoying imo. But it seems best to be conservative at first.\n\n\n> This here strikes me as a similar situation: it would a lot easier for us if we could just look at the content of a Project.toml, and purely based on the content figure out whether this is a sub-project, rather than having to deduce that from the surrounding files.\n\nThe reason for this is that if you have a set of packages that you want to share a manifest, you just put a Project.toml in the directory above, list the packages as subprojects and you are done. Having to go in into each package and add some subpackage flag everywhere would be annoying. \nI don't really think that would be hard to implement. | [goretkin]: > There should be one Manifest\n\nWould this change the current advice about not checking in a `Manifest.toml` for a """"library"""" package? I mentioned in https://github.com/JuliaLang/Pkg.jl/issues/1714#issuecomment-594179793 that I think it's beneficial to have, even for a library package, a `Manifest.toml` for the tests, including for test-specific dependencies. There could also be perf-benchmarking specific dependencies. | [tkf]: > There should be one Manifest\n\nIn addition to the concern @goretkin raised, I'd like to mention that this makes it difficult for package authors to reliably test the package with different sets of dependencies (e.g., additionally testing against the oldest compatible dependencies). Supporting multiple upstream versions is important for avoiding fragmentation of the ecosystem.\n | [KristofferC]: > that I think it's beneficial to have, even for a library package, a Manifest.toml for the tests, including for test-specific dependencies. There could also be perf-benchmarking specific dependencies.\n\nYou would have a sub-project for test and one for benchmarks. All of this would resolve into one manifest.\n\n> I'd like to mention that this makes it difficult for package authors to reliably test the package with different sets of dependencies (e.g., additionally testing against the oldest compatible dependencies).\n\nWhy? You would need to do something along the lines of `pkg> resolve --strategy=oldest` before you run the tests. | [goretkin]: > You would have a sub-project for test and one for benchmarks. All of this would resolve into one manifest.\n\nIf I'm understanding correctly, my response is that I don't want the `Manifest.toml` to be resolved from scratch. I would like to specify (at least partially) the exact dependencies.\n | [KristofferC]: > I would like to specify (at least partially) the exact dependencies.\n\nYou mean using the `[compat]` section? I'm not sure what you mean otherwise, the exact dependencies are those in the manifest? | [goretkin]: I think so. the `Project.toml` on its own can exactly specify dependencies that are in a package registry, right?  Whereas the `Manifest.toml` can specify e.g. a branch of a git repository, not just registered tags. | [KristofferC]: The manifest records the exact versions of everything in your project. The `Project.toml` can set version bounds on packages so that the resolver will always give versions within those bounds. This is how things are right now and I am not sure how this is related to the sub-project idea. | [goretkin]: It's related to the idea of sub-projects because, to me, the most natural idea is that each logical project can have a `Project.toml` and a `Manifest.toml`, where nested sub-projects overlay the parents. So if you have a project hierarchy like\n\n```\n - Top.jl\n  - test\n  - benchmark\n```\n\nif `test/Manifest.toml` exists, then there is no need to merge any manifest files. Just take `test/Manifest.toml` as the Manifest for the `test` subproject. \n\n\nIt seems like the alternative idea that is winning out here, which I'm more than willing to adopt if it's the way Pkg is moving, is that there is a single manifest at the top-level, and it includes information for all subprojects. It's a flat representation of the exact versions of everything in your project.\n\nI don't yet understand the benefits of that approach. It enforces a constraint that your benchmark subproject and your test subproject use the same version of any shared dependencies. Is there a benefit to that? This is related to @tkf's concern above. | [KristofferC]: > It enforces a constraint that your benchmark subproject and your test subproject use the same version of any shared dependencies. Is there a benefit to that? This is related to @tkf's concern above.\n\nYeah, you are advocating for the original strategy where you have """"sub-manifests"""". It is more tricky to implement but it would indeed have higher flexibility in the case you just mentioned, | [goretkin]: > more tricky to implement\n\nI don't think I appreciate why, yet. It it because of the merging? Why is it necessary to merge two `Manifest.toml`? | [tkf]: > > I'd like to mention that this makes it difficult for package authors to reliably test the package with different sets of dependencies (e.g., additionally testing against the oldest compatible dependencies).\n>\n> Why? You would need to do something along the lines of `pkg> resolve --strategy=oldest` before you run the tests.\n\nSorry, my comment was cryptic. I was considering the case where you check-in the manifest files. By """"reliably"""" I meant """"reproducible."""" So, you don't need the extra resolve strategy to use it (although it would be great to have it). In fact, it's already doable today and I am using it; e.g., https://github.com/tkf/BangBang.jl/blob/91dfa73d587deee4b7047e80b968d0b5267ca405/.travis.yml#L32-L38\n\n> It is more tricky to implement\n\nI don't understand why. If the sub-project manifest has a full set of direct and transitive dependencies, there is nothing to resolve. Isn't it simpler?\n | [KristofferC]: \n\n>  If the sub-project manifest has a full set of direct and transitive dependencies, there is nothing to resolve. Isn't it simpler?\n\nI mean, the point of a sub-project is that it shares the versions it has with the ones that the main project resolved to. So every time you do a package operation on the main project you need to re-resolve all sub-projects (pairwise).\n\nThe sub-manifest would have the """"incremental"""" addition to the manifest that is resolved | [KristofferC]: We talked about this a bit on the Pkg meeting and the original idea with having sub manifest might be better for the reason earlier discussed here. | [goretkin]: Sorry if this is outside the scope of this conversation. Is the idea of a partial manifest attractive? I don't know the exact way in which it would not be fully specified. If it's a full manifest, then it completely shadows the parent manifest. If it's partial, then you can try to jointly resolve it with a parent manifest. | [StefanKarpinski]: So how did we decide on determining when something is a subproject? Look for a project file and then keep looking for another project file that has a list of subprojects, one of which points to the first project file's directory? | [tkf]: > the point of a sub-project is that it shares the versions it has with the ones that the main project resolved to.\n\nI don't understand why that's the point.  I've been trying to mention that there are concrete use cases this is not a desirable property.\n\nI think it's better to separate thinking about the data structure/format (single manifest vs per-subproject manifest) and the algorithm (synchronizing sub-projects).  You can still synchronize per-subproject manifest files with single UI command (which can be the default). OTOH, de-synchronizing subprojects is hard/impossible by the algorithm if a single root manifest file is shared (I think you need additional structure in the manifest file to do this).\n | [KristofferC]: > I don't understand why that's the point. I've been trying to mention that there are concrete use cases this is not a desirable property.\n\nJust don't use sub-projects then if you don't want that? You can still make a full project in your test directory. The way I defined a subproject in the first post was :\n\n> A sub-project is, in essence, an incremental addition of packages to an already existing """"main-project"""".\n\n | [KristofferC]: >  Is the idea of a partial manifest attractive? I don't know the exact way in which it would not be fully specified. If it's a full manifest, then it completely shadows the parent manifest. If it's partial, then you can try to jointly resolve it with a parent manifest.\n\nThe idea is that the sub-manifest would be a partial manifest. It would include the extra dependencies the sub-project brings in. | [KristofferC]: > So how did we decide on determining when something is a subproject? Look for a project file and then keep looking for another project file that has a list of subprojects, one of which points to the first project file's directory?\n\nFor now, I think we said that we look one directory up if there is a `Project.toml` there with a `subprojects = [""""subproject_folder""""]` entry that points to the `Project` file, then it is a subproject. | [tkf]: > > I don't understand why that's the point. I've been trying to mention that there are concrete use cases this is not a desirable property.\n>\n> Just don't use sub-projects then if you don't want that?\n\nYes, that's another option. It'll be great if I can use `test/Project.toml` as a non-subproject and `Pkg.test` can handle it.\n\n#1707 seems to be going to the direction to treat `test/Project.toml` as a subproject without the explicit listing `subprojects = [""""test""""]`.\n | [KristofferC]: I want `Pkg.test()` to be pretty much equivalent to `Pkg.activate(""""test""""); Pkg.instantiate(); include(""""test/runtests.jl"""")` So if you put a full Project there, then it will just use that. | [goretkin]: To check my understanding, `test/Project.toml` would still make a reference to `./Project.toml`, to avoid re-listing all the dependencies of the main project? And it would include additional test-specific dependencies, such as `Test`. | [KristofferC]: > to avoid re-listing all the dependencies of the main project? And it would include additional test-specific dependencies, such as Test.\n\nYes | [StefanKarpinski]: To clarify what I think @KristofferC is saying, if `test` is a standalone project then `test/Project.toml` and `test/Manifest.toml` must be self-contained and going `] test` will instantiate that project file to run tests. If, on the other hand, `test` is a subproject then it is not self-contained and depends on the top-level `Project.toml`, in which case `] test` will instantiate the main project manifest and then the subproject manifest and then run using all of those. | [davidanthoff]: What will the user experience for all of this be if folks don't have `Manifest.toml` files in package folders? | [StefanKarpinski]: They get generated. | [StefanKarpinski]: One detail is that the resolution process is this:\n* resolve the core manifest first in isolation\n* fix the versions of the core manifest and then resolve the rest of the subproject manifest | [jlperla]: If I understand what is being proposed:  Another usecase of this is for sets of lecture notes/notebooks where only some packages are used in some lectures.\n\nThat is, imagine I have a base set of packages I use for all of my lecture notes, and then a subset used for a lecture.  For example\n```\n/lectures\n    Project.toml  # has Plots.jl, etc.\n    Manifest.toml  # Nice default for projects without special requirements.\n    /differential_equations\n        Project.toml  # Adds in DifferentialEaquations, Flux, etc.\n        Manifest.toml  # presumably is a manifest supporting the nested inheritence?\n        sciml_notebook.ipynb  # activates the local Project whrn run\n    /bayesian\n       Project.toml  # adds in Turing\n       Manifest.toml  # compatible with the /lectures/Project.toml and /lectures/bayesian/Project.toml superset\n       bayesian.ipynb\n    /intro\n       intro.ipynb   # activates the default /lectures/Project.toml\n```\nThis would make maintenance far easier.  With huge books and lecture notes, it is otherwise a collosal pain in the ass to bump a package version i n each `Project.toml` and test that there are no regressions.\n\nWhat I ended up doing, out of practical necessity, was just to have a superset project.toml file in the main directory, but it is a decidedly anti-pattern for many reasons. | [StefanKarpinski]: Seems better for a book or lecture series to have a single global manifest that has all the dependencies you use anywhere with a single set of mutually compatible versions that work for everything. | [jlperla]: @StefanKarpinski   Yeah, that is what I did.\n\nBut the problem is that Julia has so many cool packages that you if you take the superset of what you want to use in a book or set of lectures, what happens is:\n- If you update one package you are in a whack-a-mole where it upgrades things in other lectures due to the dependency graph, and breaks something else.  This is the nature of Julia with its chaotic and innovative packages, and I don't see it as a fundamental problem (as long as you can keep to smaller Manifest files!)\n- If you try to add in a new dependency, there is a decent chance that somewhere in the graph of dependencies you have some sort of an unsatisfiability issue.  And as the superset of packages used in your lectures get bigger, it approaches `P(1)`.\n- If someone wants to use a single lecture, when then `]instantiate` it has to do everything all at once for the whole book/lecture series.  Which can take **a long time** if you start using all of the cool things julia has to offer for machine learning/differential equations/etc.\n\nNone of these are completely insurmountable, but it is a maintenance burden and means you end up with the `Manifest.toml` of the lectures being far from the latest released versions of packages because it is too painful to update it very often.\n\nIt also might be that with the newer CompatHelper/etc. stuff and some more stability in the dependencies that things are less painful than they used to be. | [goretkin]: Maybe this is already clear to others in the thread, but I think this is the clearest way to explain what I hope for\n\n- `toplevel/Project.toml` expresses package dependencies\n- `toplevel/test/Project.toml` expresses test-specific dependencies *only* (i.e. not redundant with `toplevel/Project.toml`, but used in conjunction with it. e.g. `toplevel/test/Project.toml` `[deps]` lists the project `toplevel/Project.toml` name and UUID)\n- `toplevel/test/Manifest.toml` that captures the resolution of the `test` project (package deps and test-specific deps)\n\nThe specific paths are not so important to me. Those three files would be version controlled.\n\nIt's not important to me that `toplevel/Manifest.toml` and `toplevel/test/Manifest.toml` can be in anyway reconciled with one another. | [StefanKarpinski]: I think the things we need to make this really useful and start switching to it are:\n\n- when resolving, resolve main project by itself first\n- then resolve each subproject, taking the manifest of the main project as fixed\n- for simplicity, probably best to just save complete subproject manifest in `test/Manifest.toml`\n- probably fine for the subproject to explicitly depend on the main project\n\nSo in short, the subproject by itself looks like a standalone project and can mostly be treated as one. The exception is when resolving, we'll want to make sure to resolve the superproject first as described above.\n\nIn terms of UI to make this useful, being able to activate a subproject environment would take care of most of it. An orthogonal but useful feature would be being able to manipulate non-active environments by referring to them with some syntax in commands. For example (straw man syntax): `add ./test TestDep`. Note that while this would be especially useful for subprojects, it would not need to be limited to them; you could, for example, be in a development project and do `add @v1.6 DevTool` to add a dev tool to the `@v1.6` environment. In order to really make this work, we'd want unambiguous syntax for all kinds of environments, but I think we could work that out. | [jlperla]: If find the current test dependencies in the Project.toml file to be imperfect but workable if just writing code and doing a `]test`.\n\nThe real pain point right now is the interaction with the tooling and project/manifest activation during development in an IDE.  i.e. the `--project = @.` can't activate the test dependencies, so if you `ctrl-enter` through a unit tests while tweaking stuff, it doesn't work.  Then if you use `test/Project.toml` and `test/Manifest.toml` it is very cumbersome to keep things in sync, and opening up the project in vscode doesn't activate it, so manual steps are required.  For this, I am not really thinking about big packages, but rather the sorts of smaller packages where you really want a Manifest.toml checked into source code control for reproducibility of a paper.\n\nI say this to reiterate that syncing up with what @davidanthoff  is discussing above is especially important for these sorts of use cases. | [StefanKarpinski]: Part of the point of subprojects is that it would be possible to activate a subproject environment. I don't know that involving more people in the discussion here will further the goal of getting something that works instead of the current state of perpetual """"we're still using an old abandoned targets feature that definitely doesn't work, but no one has agreed to how subprojects should work, so we're stuck with nothing that really works"""". Instead, I think we should just pick a thing and make some kind of progress here. | [jlperla]: > I don't know that involving more people in the discussion here will further the goal of getting something that works\n\nProbably true.  Especially if the definition of """"that works"""" includes GUI implementation in vscode.  Regardless, I am the least useful person in the discussion so this is my last comment. | [StefanKarpinski]: Anything that we do that works well can have a GUI interface put on top of it, so I don't think much feedback is necessary in that direction. | [ufechner7]: Any update on this proposal? What is missing? | [MarkNahabedian]: See https://github.com/JuliaLang/Pkg.jl/issues/3297, which proposes that the """"extras"""" and """"target's"""" fields in Project.toml be generalized so that they could be used for """"docs"""" and other targets, not just """"test"""" and """"build"""", which are special cased in Operations.jl. | [Roger-luo]: Just an idea, if we allow a subproject, it would be nice to allow it inside `src` and load the corresponding module lazily, e.g `Package/Project.toml` and `Package/src/A/Project.toml`, if the user only calls `using Package` it will not load `module A` so it can act like an extension but within the provided package. And it will only load `A` if one types `using Package.A`\n\nThis would help reduce the development work of trying to split packages into `Base`, `Core` etc. which is not necessary anymore, and one can just type `XXX.Base` instead of `using XXX.XXXBase`. It should remove the usage of meta-packages in a lot of places too.\n | [Roger-luo]: I'd like to add a few use cases to this proposal. While maintaining a somewhat large project with multiple defacto """"sub-package""""s because we want to reduce the overhead for those who only use one of the subpackages. Bumping breaking versions of a package is quite painful at the moment, let me take the following example\n\nthe `Bloqade` packages as a whole want a breaking release `0.2.0`, which is because several changes within the sub-packages, currently this requires one bump to the version of `BloqadeExpr` to `0.2.0` update the corresponding `compat` of other sub-packages, then bump the next dependency. This results in an order of packages to release. This results in a rather convoluted release process. But you may ask, if in this case, why don't you just put all of them in one package? We don't because if you put all of them in one package, the user only needs one of the features will now need to load everything and most of them they don't need.\n\nSo one feature I'd hope to have is to allow sub-packages to share the same version number with the main package, while lazily loading the corresponding module explicitly. So this means the source code will ship with the main package, only loading is different.\n\n\n",55,false,52,40,0,0,12,0,0,0,0
3726,Edit links broken for files in the main Julia repo,open,freemin7,,,,0,2023-12-10T23:40:01.0,2023-12-10T23:40:01.0,587,587,https://github.com/JuliaLang/Pkg.jl/issues/3726,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3726,https://pkgdocs.julialang.org/v1/creating-packages/#Adding-tests-to-the-package has the edit link https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/creating-packages.md which does not lead to the file in question. I am not sure if there is anything that can be done about this.,,0,false,0,0,0,0,0,0,0,0,0
3717,Allow passing a list of root manifests to Pkg.gc(),open,ettersi,,,,1,2023-12-05T06:04:01.0,2023-12-05T07:40:17.0,593,593,https://github.com/JuliaLang/Pkg.jl/issues/3717,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3717,"We are using Julia in an embedded, offline system, and therefore when we make a release we have to bundle the Julia depot into the release so all the packages are available when we need them. For this purpose, it would be super useful if there was a way to convert a set of manifest files into a depot that is both lazy and pure. By this I mean: \n\n- Lazy: Don't redownload / recompile packages that are already installed. \n- Pure: The final depot should contain only packages mentioned in the current manifest files, i.e. packages which were used at some point but then removed should be deleted from the depot. \n\nCurrently, I can *almost* achieve this objective using the following steps.\n\n1. Delete `depot/logs` to clear the list of """"active"""" manifest files. \n2. Instantiate all the relevant projects. \n3. Run `Pkg.gc(; collect_delay = Second(0))` to delete all the packages not used by the projects in Step 2. \n\nThe one catch with this solution is that `Artifacts.toml` files only get marked as used when artifacts are downloaded. This means that if I do the above on an empty depot, I get the result I want, but then when I run it again, I lose all the artifacts because they are already downloaded and so the artifact files don't get marked as used. It would be great if there was a way to make this work, and even better if I could do this using `Pkg.gc(manifest_files)`.","[ettersi]: Replacing Step 2 with this seems to work: \n\n```julia\nusing Pkg, Artifacts;\nconst world_age = Base.get_world_counter();\nfunction Artifacts.load_artifacts_toml(artifacts_toml::String; kwargs...)\n    Pkg.Types.write_env_usage(artifacts_toml, """"artifact_usage.toml"""")\n    Base.invoke_in_world(\n        world_age,\n        Artifacts.load_artifacts_toml,\n        artifacts_toml;\n        kwargs...\n    )\nend;\nPkg.instantiate()\n```\n\nBut it's very hacky, so it would still be nice to have a better solution.",1,false,0,0,0,0,0,0,0,0,0
3339,`status --outdated` did not tell me why I couldn't update my package,open,Keno,,,,2,2023-01-25T17:00:22.0,2023-11-27T10:58:45.0,906,601,https://github.com/JuliaLang/Pkg.jl/issues/3339,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3339,"The output from `status --outdated` seemed to indicate to me that `NonlinearSolve` was upgradable,\nbut attempting to do that failed. The issue turned out to be the `dev`'ed `LoopVectorization`, but it\nwas somewhat frustrating to find that out.\n\n```\n(@v1.8) pkg> status --outdated\nStatus `~/.julia/environments/v1.8/Project.toml`\n⌃ [10f19ff3] LayoutPointers v0.1.8 (<v0.1.12)\n  [bdcacae8] LoopVectorization v0.12.95 `~/.julia/dev/LoopVectorization` (<v0.12.148)\n⌃ [8913a72c] NonlinearSolve v0.3.22 (<v1.3.0)\n\n(@v1.8) pkg> up NonlinearSolve\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n  No Changes to `~/.julia/environments/v1.8/Manifest.toml`\n\n(@v1.8) pkg> add NonlinearSolve#master\n     Cloning git-repo `https://github.com/SciML/NonlinearSolve.jl.git`\n    Updating git-repo `https://github.com/SciML/NonlinearSolve.jl.git`\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package DiffEqBase [2b5f629d]:\n DiffEqBase [2b5f629d] log:\n ├─possible versions are: 3.13.2-6.114.2 or uninstalled\n ├─restricted to versions 6 by NonlinearSolve [8913a72c], leaving only versions 6.0.0-6.114.2\n │ └─NonlinearSolve [8913a72c] log:\n │   ├─possible versions are: 1.3.0 or uninstalled\n │   └─NonlinearSolve [8913a72c] is fixed to version 1.3.0\n ├─restricted by compatibility requirements with ArrayInterface [4fba245c] to versions: [3.13.2-5.16.5, 6.55.0-6.114.2] or uninstalled, leaving only versions: 6.55.0-6.114.2\n │ └─ArrayInterface [4fba245c] log:\n │   ├─possible versions are: 0.0.1-6.0.25 or uninstalled\n │   └─restricted to versions 3.1.32-3 by LoopVectorization [bdcacae8], leaving only versions 3.1.32-3.2.2\n │     └─LoopVectorization [bdcacae8] log:\n │       ├─possible versions are: 0.12.95 or uninstalled\n │       └─LoopVectorization [bdcacae8] is fixed to version 0.12.95\n ├─restricted by compatibility requirements with DocStringExtensions [ffbed154] to versions: 3.13.2-6.108.0 or uninstalled, leaving only versions: 6.55.0-6.108.0\n │ └─DocStringExtensions [ffbed154] log:\n │   ├─possible versions are: 0.4.6-0.9.3 or uninstalled\n │   └─restricted to versions 0.8 by LoopVectorization [bdcacae8], leaving only versions 0.8.0-0.8.6\n │     └─LoopVectorization [bdcacae8] log: see above\n ├─restricted by compatibility requirements with NonlinearSolve [8913a72c] to versions: [3.13.2-6.48.2, 6.108.0-6.114.2] or uninstalled, leaving only versions: 6.108.0\n │ └─NonlinearSolve [8913a72c] log: see above\n └─restricted by compatibility requirements with Static [aedffcd0] to versions: 3.13.2-6.95.2 or uninstalled — no versions left\n   └─Static [aedffcd0] log:\n     ├─possible versions are: 0.1.0-0.8.3 or uninstalled\n     └─restricted to versions 0.3.3-0.4 by LoopVectorization [bdcacae8], leaving only versions 0.3.3-0.4.1\n       └─LoopVectorization [bdcacae8] log: see above\n```\n","[felixcremer]: It would be nice to get the output that one gets by trying to install the newest version of a dependency directly from the `status --outdated PackageName`. \nThis way as a user I don't have to look at the version number and type that by hand and see directly what is holding my package back. \n\n\n\n```julia\n(@v1.8) pkg> status --outdated NonlinearSolve\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package DiffEqBase [2b5f629d]:\n DiffEqBase [2b5f629d] log:\n ├─possible versions are: 3.13.2-6.114.2 or uninstalled\n ├─restricted to versions 6 by NonlinearSolve [8913a72c], leaving only versions 6.0.0-6.114.2\n │ └─NonlinearSolve [8913a72c] log:\n │   ├─possible versions are: 1.3.0 or uninstalled\n │   └─NonlinearSolve [8913a72c] is fixed to version 1.3.0\n ├─restricted by compatibility requirements with ArrayInterface [4fba245c] to versions: [3.13.2-5.16.5, 6.55.0-6.114.2] or uninstalled, leaving only versions: 6.55.0-6.114.2\n │ └─ArrayInterface [4fba245c] log:\n │   ├─possible versions are: 0.0.1-6.0.25 or uninstalled\n │   └─restricted to versions 3.1.32-3 by LoopVectorization [bdcacae8], leaving only versions 3.1.32-3.2.2\n │     └─LoopVectorization [bdcacae8] log:\n │       ├─possible versions are: 0.12.95 or uninstalled\n │       └─LoopVectorization [bdcacae8] is fixed to version 0.12.95\n ├─restricted by compatibility requirements with DocStringExtensions [ffbed154] to versions: 3.13.2-6.108.0 or uninstalled, leaving only versions: 6.55.0-6.108.0\n │ └─DocStringExtensions [ffbed154] log:\n │   ├─possible versions are: 0.4.6-0.9.3 or uninstalled\n │   └─restricted to versions 0.8 by LoopVectorization [bdcacae8], leaving only versions 0.8.0-0.8.6\n │     └─LoopVectorization [bdcacae8] log: see above\n ├─restricted by compatibility requirements with NonlinearSolve [8913a72c] to versions: [3.13.2-6.48.2, 6.108.0-6.114.2] or uninstalled, leaving only versions: 6.108.0\n │ └─NonlinearSolve [8913a72c] log: see above\n └─restricted by compatibility requirements with Static [aedffcd0] to versions: 3.13.2-6.95.2 or uninstalled — no versions left\n   └─Static [aedffcd0] log:\n     ├─possible versions are: 0.1.0-0.8.3 or uninstalled\n     └─restricted to versions 0.3.3-0.4 by LoopVectorization [bdcacae8], leaving only versions 0.3.3-0.4.1\n       └─LoopVectorization [bdcacae8] log: see above\n``` | [KristofferC]: > The output from status --outdated seemed to indicate to me that NonlinearSolve was upgradable, but attempting to do that failed. \n\nThe `^` means that there is a new version and there is nothing in your environment that directly holds that package back from upgrading. Unfortunately, that does not mean that the package can be upgraded. Determining that pretty much requires an attempt for a full resolve. Maybe the distinction of `⌅` and `^` is not useful in practice.\n\nEdit: I now noticed this was an old issue that got bumped from the new comment.",2,false,0,0,0,0,0,0,0,0,0
3688,[weakdep] [extensions] [extras] and [targets] not mentioned in documentation,open,ufechner7,,,,2,2023-11-06T02:07:58.0,2023-11-25T01:06:12.0,622,603,https://github.com/JuliaLang/Pkg.jl/issues/3688,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3688,Here https://pkgdocs.julialang.org/v1/toml-files/ these sections of `Project.toml` are neither mentioned nor explained.,"[sjkelly]: See also: https://github.com/JuliaLang/Pkg.jl/pull/3694\n | [ericphanson]: The [compat section](https://pkgdocs.julialang.org/v1/toml-files/#The-[compat]-section) also only mentions the `deps` section but it should also mention the `extras` section, as pointed out by @amontoison on Slack. Currently it's awkward to add that mention since `[extras]` isn't mentioned at all. So I think when we add `extras` we should also mention it in the `compat` section.",2,false,1,1,0,0,0,0,0,0,0
1788,Clarify current fragility of `test/Project.toml` approach,open,cscherrer,,,,10,2020-04-20T20:43:20.0,2023-11-16T16:27:39.0,1916,611,https://github.com/JuliaLang/Pkg.jl/issues/1788,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1788,"@fredrikekre 's comment [here](https://github.com/JuliaLang/Pkg.jl/issues/1585#issuecomment-578187367) says,\n> Don't use the functionality of `test/Project.toml`s which is pretty beta (and documented as such) \n\nBut this is not clear at all from current documentation [here](https://julialang.github.io/Pkg.jl/v1/creating-packages/#Test-specific-dependencies-in-Julia-1.2-and-above-1), which only says\n\n> The exact interaction between `Project.toml`, `test/Project.toml` and their corresponding `Manifest.toml`s are not fully worked out, and may be subject to change in future versions. The old method of adding test-specific dependencies, described in the next section, will therefore be supported throughout all Julia 1.X releases.\n\nThe section title here is """"Test-specific dependencies in Julia 1.2 and above"""", and the qualification seems to me to only indicate that the current approach may change in the future, not that it's """"beta"""" in any way.\n\nI have set up a few repositories using this approach, only to find out today that it's extremely brittle. Can the current documentation be updated to clarify this?","[phipsgabler]: There's something else that's not entirely clear here -- the docs say that """"Pkg will add the tested package itself implictly"""".  This works fine when running `] test`, but I also expected the following to behave the same (that's on Julia 1.3.1):\n\n```\n(AutoGibbs) pkg> activate test\nActivating environment at `~/.julia/dev/AutoGibbs/test/Project.toml`\n\njulia> using AutoGibbs\nERROR: ArgumentError: Package AutoGibbs not found in current path:\n- Run `import Pkg; Pkg.add(""""AutoGibbs"""")` to install the AutoGibbs package.\n```\n\nI guess this is related to the fact that the sub-project thing is still very much under discussion? | [KristofferC]: > I guess this is related to the fact that the sub-project thing is still very much under discussion?\n\nYes, this would work with subprojects but with the current design, `Pkg.test` does """"magic"""" to put these things into a new project that includes everything. My goal is to get subprojects into 1.6 (which will likely be the new LTS). | [FelixBenning]: I just tried this approach and I can not get it to work:\n\n`test/Project.toml`\n```toml\n[deps]\nTest = """"8dfed614-e22c-5e08-85e1-65c5234f0b40\n```\n\nif I `activate .` :\n\n```julia\n(MyProject) pkg> test\n....\nERROR: LoadError: ArgumentError: Package Tests not found in current path:\n- Run `import Pkg; Pkg.add(""""Tests"""")` to install the Tests package.\n```\n\nif I `activate ./test` I can neither do\n\n```julia\n(test) pkg> test\nERROR: trying to test unnamed project\n```\n\nnor\n```julia\n(test) pkg>  test MyPackage\nERROR: The following package names could not be resolved:\n * MyPackage (not found in project or manifest)\n```\n\nI also tried adding the uuid of MyPackage to the `test/Project.toml` which complains about the package not being registered (of course). | [fonsp]: @FelixBenning from your error (`Package Tests not found in current path`) it looks like you did `using Tests` instead of `using Test`. *(Which is an [understandable](https://pkgdocs.julialang.org/v1/creating-packages/#Package-naming-guidelines) mistake! 🙃)* | [cossio]: Are there any updates on which direction test dependencies (and subprojects generally, such as docs) will move?\nShould we continue to use `test/Project.toml`? | [acdupont]: `test/Project.toml` helps with startup time of the main project because test specific dependencies don't have to be in the main `Project.toml`. I hope that `test/Project.toml` is continued to be supported. | [dpinol]: We find this feature very useful as we don't only have test/Project.toml, but also test-performance/Project.toml and others | [IanButterworth]: @acdupont That's not the case. Test dependencies in `Project.toml` listed in the `[extras]` section do not get installed or precompiled during `Pkg.add` and obviously not loaded. | [acdupont]: > @acdupont That's not the case. Test dependencies in `Project.toml` listed in the `[extras]` section do not get installed or precompiled during `Pkg.add` and obviously not loaded.\n\nWhat do you mean by """"That's not the case""""? You proposed an alternate way for sub-project dependencies to be ignored by the main project, but using separate `Project.toml` would work for this as well. I prefer sub-project dependencies to not be listed in the  main `Project.toml` at all. | [IanButterworth]: > test/Project.toml helps with startup time of the main project because test specific dependencies don't have to be in the main Project.toml\n\nWith `Project.toml` test-only (and build-only) deps can be listed in an `[extras]` section, with a target for `test` assigning them as test-only deps.\n\nWhat you wrote gives the impression that the only way to do that is via `test/Project.toml`, which is not true.",10,false,20,20,0,0,0,0,0,0,0
3686,Allow comments in `[compat]` entries,open,eschnett,,,,2,2023-11-04T15:51:34.0,2023-11-04T19:08:53.0,623,623,https://github.com/JuliaLang/Pkg.jl/issues/3686,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3686,"Ensuring that the `[compat]` version bounds for a package are correct can be tedious, and often requires experience and historic knowledge. It is thus important to be able to document why a particular compat entry is there.\n\nI am thinking of comments along these lines: """"version x.y.z doesn't work, try again after the next minor release"""", or """"this breaks on BSD"""", or """"doesn't handle snarfblurbs larger than 2 GByte"""", etc. This allows maintainers to codify their knowledge about version bounds, what was tried in the past, what the symptoms were, whether it is worthwhile to relax a version bound, etc.\n\nIt would be convenient to have these comments in the `[compat]` section, attaches to a particular version bound. Just spinning yarn – maybe such a syntax might work?\n```toml\nDependency = """"<1.2.3   # function `flexdup` was accidentally removed in 1.2.3""""\nMisery = """"=4.5.5   # keep this fixed, Misery doesn't use semver""""\nChirp1 = """"0.1, 0.2, 0.3   # 0.4 doesn't work, try 0.5 next""""\nChirp2 = """"0.1, 0.2, 0.3   # try 0.4 once it's available""""\n```\n",[IanButterworth]: Duplicate of https://github.com/JuliaLang/julia/issues/42697 ? | [KristofferC]: Not really dup since this puts the comment inside the string to work around it..,2,false,1,1,0,0,0,0,0,0,0
3684,Pkg.test(force_latest_compatible_version=true) errors with unregistered dependencies trying to reduce over an empty collection,open,anowacki,,bug; used by downstream tooling,,2,2023-11-03T15:17:20.0,2023-11-03T16:36:07.0,624,624,https://github.com/JuliaLang/Pkg.jl/issues/3684,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3684,"If a project contains unregistered dependencies and is tested with `Pkg.test(force_latest_compatible_version=true)`, an error is thrown in the call to `maximum` at https://github.com/JuliaLang/Pkg.jl/blob/4b8e3904d35f737962b9df33fe2b7f9d2cf04ede/src/Operations.jl#L2602 because the vector `compatible_versions` is empty.\n\nThis gives you a stacktrace like below.  Should this case be tested for and a more helpful error be thrown instead?\n\n```\n     Testing Tester\nERROR: LoadError: MethodError: reducing over an empty collection is not allowed; consider supplying `init` to the reducer\nStacktrace:\n  [1] reduce_empty(op::Base.BottomRF{typeof(max)}, #unused#::Type{VersionNumber})\n    @ Base ./reduce.jl:355\n  [2] reduce_empty_iter\n    @ ./reduce.jl:379 [inlined]\n  [3] reduce_empty_iter\n    @ ./reduce.jl:378 [inlined]\n  [4] foldl_impl\n    @ ./reduce.jl:49 [inlined]\n  [5] mapfoldl_impl\n    @ ./reduce.jl:44 [inlined]\n  [6] #mapfoldl#288\n    @ ./reduce.jl:170 [inlined]\n  [7] mapfoldl\n    @ ./reduce.jl:170 [inlined]\n  [8] #mapreduce#292\n    @ ./reduce.jl:302 [inlined]\n  [9] mapreduce\n    @ ./reduce.jl:302 [inlined]\n [10] #maximum#302\n    @ ./reduce.jl:759 [inlined]\n [11] maximum\n    @ ./reduce.jl:759 [inlined]\n [12] get_latest_compatible_version\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:2596 [inlined]\n [13] apply_force_latest_compatible_version!(ctx::Pkg.Types.Context, dep::NamedTuple{(:name, :uuid), Tuple{String, Base.UUID}}; target_name::String, allow_earlier_backwards_compatible_versions::Bool)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:2564\n [14] apply_force_latest_compatible_version!\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:2548 [inlined]\n [15] apply_force_latest_compatible_version!(ctx::Pkg.Types.Context; target_name::String, allow_earlier_backwards_compatible_versions::Bool)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:2537\n [16] apply_force_latest_compatible_version!\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:2530 [inlined]\n [17] (::Pkg.Operations.var""""#117#122""""{String, Bool, Bool, Bool, Pkg.Operations.var""""#130#134""""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.PackageSpec})()\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1795\n [18] with_temp_env(fn::Pkg.Operations.var""""#117#122""""{String, Bool, Bool, Bool, Pkg.Operations.var""""#130#134""""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.PackageSpec}, temp_env::String)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1701\n [19] (::Pkg.Operations.var""""#115#120""""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""""#130#134""""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String})(tmp::String)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1790\n [20] mktempdir(fn::Pkg.Operations.var""""#115#120""""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""""#130#134""""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String}, parent::String; prefix::String)\n    @ Base.Filesystem ./file.jl:760\n [21] mktempdir(fn::Function, parent::String)\n    @ Base.Filesystem ./file.jl:756\n [22] mktempdir\n    @ ./file.jl:756 [inlined]\n [23] sandbox(fn::Function, ctx::Pkg.Types.Context, target::Pkg.Types.PackageSpec, target_path::String, sandbox_path::String, sandbox_project_override::Pkg.Types.Project; preferences::Dict{String, Any}, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1748\n [24] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool)\n    @ Pkg.Operations /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1958\n [25] test\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1902 [inlined]\n [26] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool, kwargs::Base.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/API.jl:441\n [27] test(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:force_latest_compatible_version,), Tuple{Bool}}})\n    @ Pkg.API /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/API.jl:156\n [28] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:force_latest_compatible_version,), Tuple{Bool}}})\n    @ Pkg.API /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Pkg/src/API.jl:171\n [29] top-level scope\n    @ /private/tmp/Tester/bin/mwe.jl:4\nin expression starting at /private/tmp/Tester/bin/mwe.jl:4\n```\n\nThis came up for me when testing a CompatHelper pull request, and only on Julia v1.9: https://github.com/anowacki/Beamforming.jl/actions/runs/6746373999/job/18340164600?pr=3.\n\n","[DilumAluthge]: I think we have a couple different options, including:\n\n1. Option 1: if there is an unregistered dependency, throw an error, but just make it a more informative error message.\n2. Option 2: if there is an unregistered dependency, print an informative warning, and proceed. I.e. we just wouldn't apply the """"force latest compatible"""" constraint to the unregistered dependency. | [anowacki]: You guys will I'm sure have your own reasoned opinions which I wouldn't want to contradict, but from my perspective your Option 2 is what I would expect to occur and which I would prefer.",2,false,2,2,0,0,0,0,0,0,0
3347,Ability to easily repeatedly add a fixed group of packages,open,gaurav-arya,,,,1,2023-01-30T11:30:44.0,2023-11-02T16:18:49.0,902,625,https://github.com/JuliaLang/Pkg.jl/issues/3347,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3347,"I often would like to bring in a group of packages, e.g. some utilities for data analysis, into an existing environment. I'd like to be able to do something like\n```\npkg] add @analysis\n```\nwhere `@analysis` is a named environment, and bring all of the packages in `@analysis` in at once, i.e. treat them as a single entity that goes together, rather than have to add them one-by-one.\n\nI'm imaging that the above would not introduce a stacked environment, but rather add each package in `@analysis` one-by-one into the environment so it's totally reproducible and there's no hidden backedge to `@analysis`. However, the versions added would be fixed to exactly the same as in `@analysis`, so if `@analysis` is already pre-compiled the `add` operation should be fast.\n\nI think this suggestion has a relation to https://github.com/JuliaLang/Pkg.jl/issues/1233, in the sense that subprojects are """"a manifest (dependency graph) that is shared between multiple projects."""" Although, calling this use case a """"subproject"""" doesn't sound right, and in fact there could be multiple parents (`@analysis`, `@benchmarking`, the dev env of the original package, etc.)\n\nAnother technical difference is that I'm not proposing there to be any backpointers to `@analysis` here (if `@analysis` is changed later, the environment where it was added would not know about it unless `add @analysis` is run again). That makes this suggestion simpler (almost just syntactic sugar), but it may not actually be the best idea; another possibility would be for this use case to be supported as part of the sub-project effort.\n\nEdit: just noticed #3345 and #3305, which seem closely related.\n\n","[Roger-luo]: My use case is for dev dependencies, I think it's a bit implicit and not sustainable if we just ask everyone to install tools like `Revise`, `Cthulu` etc in the global env, it would be nice to let a package specify a dev dependency or just dependency groups in general, and one can ask `Pkg` to install these dependencies when the package/project environment is the current active environment (perhaps install `dev` by default?)",1,false,1,1,0,0,0,0,0,0,0
3682,Suggestion: Allow for SubString{String} to be passed to `RegistrySpec` constructor,open,lukasgrunwald,,,,0,2023-11-02T14:03:41.0,2023-11-02T14:03:41.0,626,626,https://github.com/JuliaLang/Pkg.jl/issues/3682,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3682,"https://github.com/JuliaLang/Pkg.jl/blob/4b8e3904d35f737962b9df33fe2b7f9d2cf04ede/src/Registry/Registry.jl#L12-L24\nIt would be convenient to be able to pass views of strings (e.g. generated with the `split()` function) to RegistrySpec. This can be achieved by replacing `Union{String,Nothing}` -> `Union{AbstractString,Nothing}` in the constructor. \n\nI'm happy to open a PR if you are open to doing this :)",,0,false,0,0,0,0,0,0,0,0,0
2648,Unhandled InterruptException during precompilation,open,Octogonapus,,bug; precompile,,7,2021-06-25T17:48:04.0,2023-10-27T12:52:06.0,1485,632,https://github.com/JuliaLang/Pkg.jl/issues/2648,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2648,"I interrupted the automatic precompilation with ^C and the subsequent `InterruptException` was not handled, causing Julia to crash:\n```\nPrecompiling project...\n  Progress [========================>                ]  6/10\n  ✓ PrettyTables\n  ◒ Flux\n^Cfatal: error thrown and no exception handler available.\nInterruptException()\njl_mutex_unlock at /buildworker/worker/package_linux64/build/src/locks.h:134 [inlined]\njl_task_get_next at /buildworker/worker/package_linux64/build/src/partr.c:475\npoptask at ./task.jl:760\nwait at ./task.jl:768 [inlined]\ntask_done_hook at ./task.jl:494\n_jl_invoke at /buildworker/worker/package_linux64/build/src/gf.c:2237 [inlined]\njl_apply_generic at /buildworker/worker/package_linux64/build/src/gf.c:2419\njl_apply at /buildworker/worker/package_linux64/build/src/julia.h:1703 [inlined]\njl_finish_task at /buildworker/worker/package_linux64/build/src/task.c:208\nstart_task at /buildworker/worker/package_linux64/build/src/task.c:850\nunknown function (ip: (nil))\n```\n\n```\njulia> versioninfo()\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 16\n  JULIA_EDITOR = /usr/bin/code\n  JULIA_PKG_SERVER =\n```","[IanButterworth]: @vtjnash i don't believe this is a Pkg issue. Any idea? | [IanButterworth]: Seen in 1.6.3\n\n```\nPrecompiling project...\n  Progress [========>                                ]  14/76\n  ◓ ModernGL\n  ◒ GPUArrays\n  ◓ MutableArithmetics\n  ✓ ChainRulesCore\n...\n^Cfatal: error thrown and no exception handler available.\nInterruptException()\njl_task_get_next at /Applications/Julia-1.6.app/Contents/Resources/julia/lib/julia/libjulia-internal.1.6.dylib (unknown line)\npoptask at ./task.jl:760\nwait at ./task.jl:769\ntask_done_hook at ./task.jl:494\njl_apply_generic at /Applications/Julia-1.6.app/Contents/Resources/julia/lib/julia/libjulia-internal.1.6.dylib (unknown line)\njl_finish_task at /Applications/Julia-1.6.app/Contents/Resources/julia/lib/julia/libjulia-internal.1.6.dylib (unknown line)\nstart_task at /Applications/Julia-1.6.app/Contents/Resources/julia/lib/julia/libjulia-internal.1.6.dylib (unknown line)\n``` | [KristofferC]: I think that the interruption has to be disabled until a  known safe point if this is supposed to work reliably. | [IanButterworth]: That sounds reasonable, but I don't know where to start. I don't really know how to tell what a non-safe point is. | [vtjnash]: You need to detect and handle it explicitly if you intend this to work. See how runtests.jl does it in the Base tests, for example. | [ericphanson]: just to say, this also happens on 1.8.3:\n```\nPrecompiling project...\n  Progress [==>                                      ]  3/70\n  ◒ Parsers\n  ◑ Colors\n  ◐ Interpolations\n  ◒ HTTP\n  ✓ Glib_jll\n  ◑ GeometryBasics\n^Cfatal: error thrown and no exception handler available.\nInterruptException()\njl_mutex_unlock at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/julia_locks.h:129 [inlined]\nijl_task_get_next at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/partr.c:569\npoptask at ./task.jl:921\nwait at ./task.jl:930\ntask_done_hook at ./task.jl:634\njfptr_task_done_hook_35125.clone_1 at /home/ubuntu/.julia/juliaup/julia-1.8.3+0.x64.linux.gnu/lib/julia/sys.so (unknown line)\n_jl_invoke at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/gf.c:2365 [inlined]\nijl_apply_generic at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/gf.c:2547\njl_apply at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/julia.h:1839 [inlined]\njl_finish_task at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/task.c:254\nstart_task at /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/src/task.c:942\n``` | [IanButterworth]: One of the effects of this is creating orphaned pidfiles.\n\nCc. @oxinabox",7,false,0,0,0,0,0,0,0,0,0
3678,Misunderstanding of ≥ in the compat section of Project.toml?,open,kawild,,,,0,2023-10-26T06:48:38.0,2023-10-26T06:48:38.0,633,633,https://github.com/JuliaLang/Pkg.jl/issues/3678,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3678,"The [compat section of JDBC.jl](https://github.com/JuliaDatabases/JDBC.jl/blob/master/Project.toml) includes:\n`JavaCall = """"≥ 0.7.0""""`\n\nBut with Julia 1.9.3 `pkg> status --outdated -m` shows `⌅ [494afd89] JavaCall v0.7.8 (<v0.8.0): JDBC`\n\nWhen changing to `JavaCall = """">= 0.7.0""""` in the Project.toml JavaCall  gets updated to v0.8.0\n\nIs the error in Pkg or JDBC?\n<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including:\n\n1. The output of `versioninfo()`\n2. How you installed Julia\n3. A minimal working example (MWE), also known as a minimum reproducible example\n\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n",,0,false,0,0,0,0,0,0,0,0,0
3675,Include system image packages in Pkg.status output,open,andreasnoack,,feature request,,4,2023-10-24T21:15:02.0,2023-10-25T23:09:23.0,634,633,https://github.com/JuliaLang/Pkg.jl/issues/3675,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3675,"It would be handy if `Pkg.status()` displayed packages made available via the system image. Otherwise, it is hard to record the environment in a report.","[vchuravy]: Contained in the sysimg or available as part of `@stdlib`?\n\n | [KristofferC]: Imo packages in the sysimage that are not stdlibs is what people want to see, or? | [DilumAluthge]: ~~I think I would want to see every package in `Base.loaded_modules`, except for packages that are already listed earlier in the `Pkg.status()` output.~~\n\nDisregard this. | [DilumAluthge]: I think I would want to see every package in the system image, except for packages that are already listed earlier in the `Pkg.status()` output.\n\nI'd want to see the sysimage packages listed whether or not they are stdlibs.",4,false,3,3,0,0,0,0,0,0,0
3673,target option for Pkg.add,open,BeastyBlacksmith,,,,0,2023-10-20T15:10:47.0,2023-10-20T15:10:47.0,639,639,https://github.com/JuliaLang/Pkg.jl/issues/3673,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3673,"I would like to have `Pkg.add(pkg, target=""""test"""")` that does the whole thing of adding `pkg` to `[extras]` and add it to the `test` array under `[targets]`.\n\nThe REPL mode syntax could look like\n\n```julia\npkg> add pkg target=""""test""""\n```\nor\n```julia\npkg> add target test pkg\n```",,0,false,0,0,0,0,0,0,0,0,0
3672,FR: add a `clean` command,open,prbzrg,,,,0,2023-10-19T22:40:05.0,2023-10-19T22:40:05.0,639,639,https://github.com/JuliaLang/Pkg.jl/issues/3672,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3672,"Having a command to delete `.julia` or part of it, like `compiled`, is very appreciating.\nIt would help in issues like https://github.com/SciML/LinearSolve.jl/issues/395\n\nI know there is `rm(joinpath(homedir(), """".julia""""))` but having a `clean` command help us document situations that removing part of `.julia` fix the problem.",,0,false,0,0,0,0,0,0,0,0,0
3251,Unable to install unregistered package in Julia >=1.7 (when providing a Context),open,fcdimitr,,binarybuilder,,12,2022-11-04T23:12:28.0,2023-10-07T06:25:21.0,988,652,https://github.com/JuliaLang/Pkg.jl/issues/3251,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3251,"Installing an unregistered package currently fails. I am attaching a MWE:\n\n```julia \nusing Pkg\nPkg.add(Pkg.Types.Context(), [PackageSpec(; name = """"Box2D_jll"""", uuid = """"6756b63d-2e54-5dc6-816b-1fc83e1ae834"""", url = """"https://github.com/cirocavani/Box2D_jll.jl"""")])\n```\n\nwhich results in the following error:\n\n```julia\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General`\n   Resolving package versions...\nERROR: expected package `Box2D_jll [6756b63d]` to be registered\nStacktrace:\n [1] pkgerror(msg::String)\n   @ Pkg.Types /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/Types.jl:67\n [2] check_registered\n   @ /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1190 [inlined]\n [3] targeted_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n   @ Pkg.Operations /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1252\n [4] tiered_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n   @ Pkg.Operations /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1225\n [5] _resolve(io::Base.TTY, env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n   @ Pkg.Operations /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1260\n [6] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Set{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n   @ Pkg.Operations /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1276\n [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Pkg.API /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/API.jl:275\n [8] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n   @ Pkg.API /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/Pkg/src/API.jl:226\n [9] top-level scope\n   @ REPL[4]:1\n```\n\nThe output of `versioninfo()`:\n```julia\nJulia Version 1.8.2\nCommit 36034abf260 (2022-09-29 15:21 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin21.4.0)\n  CPU: 4 × Intel(R) Core(TM) i7-4558U CPU @ 2.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, haswell)\n  Threads: 1 on 4 virtual cores\nEnvironment:\n  JULIA_PKG_DEVDIR = /Users/fcdimitr/Workspace/julia-dev\n```\n\nJulia is installed as a `cask` via `homebrew`.\n\nThe issue also appears on a `Linux` machine. It has also been discussed at https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1173","[KristofferC]: Remove the context argument. If you have to use it (knowing it is an implementation detail) then you need to read the source to know how to use it properly. | [fcdimitr]: Thank you, @KristofferC! I am trying to understand [the issue with BinaryBuilder](https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1173); I am not using this directly in my module. I will continue the discussion there and update this issue appropriately. | [fcdimitr]: It seems that using the context argument is a requirement of the `BinaryBuilder.jl` package.\n\nI do not know why and how it is used. If I understand more about the internals of `BinaryBuilder.jl`, I will follow up here. \n\nThank you! | [sloede]: This issue severely degrades the ability to use BB.jl and Julia for rapid prototyping with existing C/C++ libraries in a reproducible manner. Is there any way this will be fixed in the foreseeable future? I know everyone is busy, thus I am not complaining, just kindly asking to know what the status is 🙂 | [IanButterworth]: This issue needs more information on why the given internal (evidently incorrect) format is being used, and why this cannot simply be used.\n\n```\njulia> Pkg.add(url = """"https://github.com/cirocavani/Box2D_jll.jl"""")\n     Cloning git-repo `https://github.com/cirocavani/Box2D_jll.jl`\n    Updating git-repo `https://github.com/cirocavani/Box2D_jll.jl`\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n  Downloaded artifact: Box2D\n  Downloaded artifact: Box2D\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [6756b63d] + Box2D_jll v2.4.1+0 `https://github.com/cirocavani/Box2D_jll.jl#main`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [6756b63d] + Box2D_jll v2.4.1+0 `https://github.com/cirocavani/Box2D_jll.jl#main`\nPrecompiling project...\n  4 dependencies successfully precompiled in 5 seconds. 51 already precompiled.\n```\non julia 1.8.5 | [sloede]: > This issue needs more information on why the given internal (evidently incorrect) format is being used, and why this cannot simply be used.\n\nAccording to @giordano (not pointing fingers, just citing the source), the context argument seems to be required by BinaryBuilder.jl (https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1173#issuecomment-1304352215). Unfortunately, I am completely out of my depth to say whether this is correct or what do do about it.\n\nI am just observing that it used to work for BB with unregistered packages, now it doesn't, and that it seems to be related to a change in Pkg. | [IanButterworth]: For the record dropping the name and uuid causes another issue, that the error message seems to imply should be supported\n```\njulia> Pkg.add(Pkg.Types.Context(), [Pkg.Types.PackageSpec(; url = """"https://github.com/cirocavani/Box2D_jll.jl"""")])\nERROR: name, UUID, URL, or filesystem path specification required when calling `add`\nStacktrace:\n [1] pkgerror(msg::String)\n   @ Pkg.Types ~/.julia/juliaup/julia-1.8.5+0.x64.apple.darwin14/share/julia/stdlib/v1.8/Pkg/src/Types.jl:67\n [2] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Pkg.API ~/.julia/juliaup/julia-1.8.5+0.x64.apple.darwin14/share/julia/stdlib/v1.8/Pkg/src/API.jl:237\n [3] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n   @ Pkg.API ~/.julia/juliaup/julia-1.8.5+0.x64.apple.darwin14/share/julia/stdlib/v1.8/Pkg/src/API.jl:226\n [4] top-level scope\n   @ REPL[8]:1\n``` | [IanButterworth]: You need to call `handle_package_input!` on the list of packages\n```julia\njulia> pkgs = [Pkg.Types.PackageSpec(; name = """"Box2D_jll"""", uuid = """"6756b63d-2e54-5dc6-816b-1fc83e1ae834"""", url = """"https://github.com/cirocavani/Box2D_jll.jl"""")]\n1-element Vector{Pkg.Types.PackageSpec}:\n PackageSpec(\n  name = Box2D_jll\n  uuid = 6756b63d-2e54-5dc6-816b-1fc83e1ae834\n  url = https://github.com/cirocavani/Box2D_jll.jl\n  version = *\n)\n\njulia> foreach(Pkg.API.handle_package_input!, pkgs)\n\njulia> pkgs\n1-element Vector{Pkg.Types.PackageSpec}:\n PackageSpec(\n  name = Box2D_jll\n  uuid = 6756b63d-2e54-5dc6-816b-1fc83e1ae834\n  url = https://github.com/cirocavani/Box2D_jll.jl\n  version = *\n  repo/source = """"https://github.com/cirocavani/Box2D_jll.jl""""\n)\n\njulia> Pkg.add(Pkg.Types.Context(), pkgs)\n    Updating git-repo `https://github.com/cirocavani/Box2D_jll.jl`\n   Resolving package versions...\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n  No Changes to `~/.julia/environments/v1.8/Manifest.toml`\n``` | [giordano]: > You need to call `handle_package_input!` on the list of packages\n\nI was waiting for someone to suggest that.  No, it doesn't work: https://github.com/JuliaPackaging/BinaryBuilderBase.jl/pull/212 | [IanButterworth]: If that's the case then it would be good to have a MWE that it doesn't work for.\n\nI think a lot of the BB issues are because providing a `Context()` (which is [intentionally an internal mode](https://github.com/JuliaLang/Pkg.jl/pull/2952)) skips over the conditioning that happens for the majority of the API functions here, the key being `handle_package_input!`  https://github.com/JuliaLang/Pkg.jl/blob/1c6ba558c673d22f8ff41b3f2ebaf72e3d8b1e44/src/API.jl#L141-L180 | [sloede]: > You need to call `handle_package_input!` on the list of packages\n\nBased on your suggestion, I found a workaround for BB until the underlying issue is fixed: https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1173#issuecomment-1476370661 | [youwuyou]: > This issue severely degrades the ability to use BB.jl and Julia for rapid prototyping with existing C/C++ libraries in a reproducible manner. Is there any way this will be fixed in the foreseeable future? I know everyone is busy, thus I am not complaining, just kindly asking to know what the status is 🙂\n\nSame opinion too :D would be amazing if it could be fixed in the near future\n",12,false,0,0,0,0,0,0,0,0,0
1070,Discussion: Standardised Metadata in Project.toml,open,pfitzseb,,enhancement; Discussion,,10,2019-02-19T16:08:18.0,2023-09-30T08:52:18.0,2342,659,https://github.com/JuliaLang/Pkg.jl/issues/1070,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1070,"It would be great to have a standardised way for specifying metadata in a package's Project.toml. The following is heavily inspired by npm.\n\n#### Package Discoverability\n\n- `keywords`/`tags` -> array of strings (could be autopopulated from GitHubs tags by some third party utility)\n- `description`/`tagline` -> string with a short (one line) description of the package\n\n#### Utility\n\n- `license` -> string with license name\n- `version` (I know this is controversial but would still be nice to have...)\n- `issue-url` -> URL where the user can report issues with the package \n\n#### Documentation\n\nWe need to support multiple cases here:\n\n- `built-docs-url` -> URL to git repo + branch (+ directory) that contains built documentation\n- `hosted-docs-url` -> URL to hosted docs\n- `docs-directory` -> path to the dir containing the packages Documenter.jl source, falls back to `docs/`\n\nThose three options should span all sane use cases -- we have a default where the package author doesn't have to worry about docs deployment *at all* (because we'll build them), the current standard where you set up Documenter.jl on travis yourself and have it push to a `gh-pages` branch somewhere, and an option that allows you complete freedom with your self-hosted docs.\n\n------\nSo for DifferentialEquations.jl the following metadata could be supplied:\n```toml\n[metadata]\nkeywords = [""""differential-equations"""", """"julia"""", """"ode"""", """"sde"""", """"pde"""", """"dae""""]\ndescription = """"Julia suite for high-performance solvers of differential equations.""""\nlicense = """"MIT""""\nissue-url = """"https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/new""""\nversion = """"v6.3.0""""\n\n[metadata.documentation]\nbuilt-docs-url = """"https://github.com/JuliaDiffEq/DiffEqDocs.jl.git#gh-pages""""\n```\n`keywords`, `description`, `license` and one of the docs keys are the most important for discoverability and usability, imho, so we should heavily encourage people to fill those in, e.g. when registering a package. Would also be sensible to sanity check the different fields.\n\nThe `[metadata]` section could of course contain arbitrary information (maybe a DOI or whatever).","[fredrikekre]: Oh wow, this was next on my todolist and planned to do it this week. Also discussed this with Kristoffer yesterday :smile:. | [fredrikekre]: To elaborate; my plan was to simply document that you can put whatever you want under `[metadata]` and Pkg will leave it alone. Other fields are Pkg free to ignore/overwrite/whatever.\n\nFrom the things you list above I think that `version` should still be top-level (or possibly under a `[package]` section, see #179) since it is pretty important, and should be required. Other non-essential things can go under `[metadata]`. | [StefanKarpinski]: Some context about why this came up now. @pfitzseb and @SimonDanisch are working on [DocumentationGenerator](https://github.com/JuliaDocs/DocumentationGenerator.jl) and we want to be able to search packages based on metadata in addition to data (package code and documentation content) and to facilitate that we want to have a standard for structured content and verify that it's followed, e.g. at package registration time. So Pkg can not care about the structure of this, but I think that we do want to have a well-defined schema for it and enforce it for registered packages at least. That way you'll be able to do things like search for only MIT/BSD-licensed packages with a certain numbers of GitHub stars, etc. | [Nosferican]: I had brought the issue a while ago in https://github.com/JuliaLang/julia/issues/27567. In my own research, I have had to develop a few tools to understand various OSS ecosystems and have experienced many edge cases. For example, CRAN metadata is quite on the high-quality spectrum, but it still has more than a couple bad entries / conflicting information, etc. I have used the Github API both v3 and v4 to gather statistics on Julia packages as well as developed tools for other measures of interest (e.g., [DependenciesParser.jl](https://github.com/Nosferican/DependenciesParser.jl), [JuliaEcosystem](https://github.com/Nosferican/JuliaEcosystem.jl)). I think standardizing the metadata would be a huge step towards having a better ecosystem infrastructure. | [fingolfin]: For `license` I would recommend using SPDX ids, see https://spdx.org/licenses/ ; this allows also for expressing things like """"GPL 2 or later""""  or """"dual licensed as GPL or MIT"""" etc. | [bilderbuchi]: > this allows also for expressing things like """"GPL 2 or later"""" or """"dual licensed as GPL or MIT"""" etc.\n\nFor those not already aware, this is achieved with [""""SPDX license expressions""""](https://spdx.github.io/spdx-spec/v2.2.2/SPDX-license-expressions/). For the above examples, the license strings would be e.g. `GPL-2.0-or-later` (no operators needed) and `GPL-2.0-only OR MIT`. | [bilderbuchi]: Another thing that would be great to cover with the license metadata is the licenses of wrapped/packaged libraries (like e.g. many `*_jll` packages have). This would enable automated discovery of the licenses to observe when installing/distributing said packages, e.g. from a `license_wrapped` key or similar (in addition to `license` for the code of the package _itself_), using the same SPDX license expression syntax as above.\n\nFor example, a wrapper package might be licensed `MIT`, but the underlying library might be licensed `LGPL` ([QML.jl](https://github.com/JuliaGraphics/QML.jl/issues/150)) or `GPL` ([P4est.jl](https://github.com/trixi-framework/P4est.jl) / [P4est_jll](https://github.com/JuliaBinaryWrappers/P4est_jll.jl) / [p4est](https://github.com/cburstedde/p4est))\n\nAs it is now, correctly identifying this manually for a project with probably dozens+ transitive dependencies is quite tedious. Having this information in the Project.toml metadata would enable automated license scanning.\n\nSee also [this thread](https://discourse.julialang.org/t/how-does-licensing-work-for-packages-that-wrap-other-licensed-binaries/104350) split off from a discussion about QML.jl. | [mkitti]: To be clear, the JLL packages themselves do not contain binaries; however, they invoke the artifact system to download binaries which may be covered under a more restrictive license (LGPL or GPL). | [bilderbuchi]: Yeah, to account for this I wrote """"wrapped"""" and """"licenses to observe when installing"""". \nThe jlls know the license(s) of the things they are downloading """"through the artifact system"""", so they should indicate those, as they are the """"deepest layer"""" of the entities still present in the project/manifest metadata files. | [bilderbuchi]: Another alternative to a `license_wrapped` key in Project.toml would be a `license` key in Artifacts.toml (https://julialang.github.io/Pkg.jl/v1/artifacts/#Artifacts.toml-files-1).\nI dont know how straightforward it is to enumerate affected artifacts from a package's project.toml or manifest, though.",10,false,7,7,0,0,0,0,0,0,0
3629,"""Warning: The call to compilecache failed to create a usable precompiled cache file..."" when sharing depot across Julia versions",open,topolarity,,bug,,1,2023-09-21T01:14:08.0,2023-09-21T01:52:25.0,668,668,https://github.com/JuliaLang/Pkg.jl/issues/3629,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3629,"MWE:\n```julia\n$ JULIA_DEPOT_PATH=tmp_depot julia-15f34aa649 -e """"using Pkg; Pkg.add(\""""Distributions\"""")""""\n$ JULIA_DEPOT_PATH=tmp_depot julia-2cee483bce -e """"using Pkg; Pkg.add(\""""Distributions\"""")"""" --project=tmp_project \n...\n┌ Distributions [31c24e10-a181-5473-b8eb-7969acd0382f]\n│  ┌ Warning: The call to compilecache failed to create a usable precompiled cache file for StatsBase [2913bbd2-ae8a-5f71-8c99-4fb6c76f3a91]\n│  │   exception = Required dependency Statistics [10745b16-79ce-11e8-11f9-7d13ad32a3b2] failed to load from a cache file.\n│  └ @ Base loading.jl:1986\n└\n```\n\n`julia-15f34aa649` is a newer Julia v1.11 from after https://github.com/JuliaLang/julia/pull/46501, while `julia-2cee483bce` is from before.\n\nI was able to bypass the issue by (a) deleting the git-tree-sha1 entry in the Statistics entry of the Manifest, or (b) `JULIA_DEPOT_PATH=tmp_depot julia-2cee483bce -e """"using Pkg; Pkg.update()""""`\n\nNeither of those should be necessary though. `julia-2cee483bce` is fully capable of loading either the old built-in Statistics (v1.9.0) or the new liberated version (v1.11.0)","[topolarity]: The challenging part of the user experience is that `] resolve` and `] update` both succeed and report no errors, despite the problem with the stacked Manifest:\n\n```julia\n$ JULIA_DEPOT_PATH=tmp_depot julia-2cee483bce --project=tmp_project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.0-DEV.116 (2023-07-18)\n _/ |\__'_|_|_|\__'_|  |  Commit 2cee483bce (64 days old master)\n|__/                   |\n\n(tmp_project) pkg> resolve\n  No Changes to `~/repos/DAECompiler.jl/tmp_project/Project.toml`\n  No Changes to `~/repos/DAECompiler.jl/tmp_project/Manifest.toml`\n\n(tmp_project) pkg> update\n    Updating registry at `tmp_depot/registries/General.toml`\n  No Changes to `~/repos/DAECompiler.jl/tmp_project/Project.toml`\n  No Changes to `~/repos/DAECompiler.jl/tmp_project/Manifest.toml`\nPrecompiling project...\n  ? Distributions\n  3 dependencies successfully precompiled in 17 seconds. 36 already precompiled.\n  1 dependency failed but may be precompilable after restarting julia\n  2 dependencies had warnings during precompilation:\n┌ Distributions [31c24e10-a181-5473-b8eb-7969acd0382f]\n│  ┌ Warning: The call to compilecache failed to create a usable precompiled cache file for StatsBase [2913bbd2-ae8a-5f71-8c99-4fb6c76f3a91]\n│  │   exception = Required dependency Statistics [10745b16-79ce-11e8-11f9-7d13ad32a3b2] failed to load from a cache file.\n│  └ @ Base loading.jl:1986\n└\n```",1,false,0,0,0,0,0,0,0,0,0
3628,Standard libraries tagged in package conflict reports,open,ablaom,,,,2,2023-09-19T22:01:19.0,2023-09-20T18:26:34.0,669,668,https://github.com/JuliaLang/Pkg.jl/issues/3628,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3628,"As Statistics is a standard library, the following """"package"""" conflict was unexpected.\n\n```julia\nloading model code: Error During Test at /home/runner/work/MLJModels.jl/MLJModels.jl/test/runtests.jl:15\n  Test threw exception\n  Expression: include(""""loading.jl"""")\n  LoadError: Unsatisfiable requirements detected for package Statistics [10745b16]:\n   Statistics [10745b16] log:\n   ├─possible versions are: 0.0.0 or uninstalled\n   ├─restricted to versions * by MLJModels [d491faf4], leaving only versions 0.0.0\n   │ └─MLJModels [d491faf4] log:\n   │   ├─possible versions are: 0.16.10 or uninstalled\n   │   └─MLJModels [d491faf4] is fixed to version 0.16.10\n   ├─Statistics [10745b16] is fixed to version 0.0.0\n   └─found to have no compatible versions left with MLJBase [a7f614a8]\n     └─MLJBase [a7f614a8] log:\n       ├─possible versions are: 0.1.0-0.21.14 or uninstalled\n       ├─restricted to versions * by an explicit requirement, leaving only versions 0.1.0-0.21.14\n       └─restricted by compatibility requirements with ScientificTypes [321657f4] to versions: [0.1.0-0.3.0, 0.15.0-0.18.11, 0.19.2-0.21.14] or uninstalled, leaving only versions: [0.1.0-0.3.0, 0.15.0-0.18.11, 0.19.2-0.21.14]\n         └─ScientificTypes [321657f4] log:\n           ├─possible versions are: 0.1.0-3.0.2 or uninstalled\n           └─restricted to versions 3 by MLJModels [d491faf4], leaving only versions 3.0.0-3.0.2\n             └─MLJModels [d491faf4] log: see above\n```\n\n### Context\n\nThis is happening in the context of a `Pkg.test`; see [this package CI log](https://github.com/JuliaAI/MLJModels.jl/actions/runs/6195477075/job/16820269378?pr=526). The line of code triggering the fail is this one:\n\nhttps://github.com/JuliaAI/MLJModels.jl/blob/ba5de1bd48c865b36625baf4e928ff126dee342b/test/loading.jl#L29\n\nThe `@load` macro here calls `Pkg.add(...)` within the test script, so not very standard. \n\n\n### To reproduce\n\nThe fail is Ubuntu, julia 1.6.7, but I can reproduce a similar (but not identical error) on a mac as below. I cannot reproduce under latest Julia 1.9\n\nJulia 1.6.5\n```julia\njulia> versioninfo()\nJulia Version 1.6.5\nCommit 9058264a69 (2021-12-19 12:30 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.6.0)\n  CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LTS_PATH = /Applications/Julia-1.6.app/Contents/Resources/julia/bin/julia\n  JULIA_PATH = /Applications/Julia-1.9.app/Contents/Resources/julia/bin/julia\n  JULIA_EGLOT_PATH = /Applications/Julia-1.6.app/Contents/Resources/julia/bin/julia\n  JULIA_NUM_THREADS = 5\n  JULIA_NIGHTLY_PATH = /Applications/Julia-1.9.app/Contents/Resources/julia/bin/julia\n\n] activate --temp\n] add MLJModels@0.16.10\n] test MLJModels\n\nLoadError: Unsatisfiable requirements detected for package StatsBase [2913bbd2]:\n   StatsBase [2913bbd2] log:\n   ├─possible versions are: 0.24.0-0.34.0 or uninstalled\n   ├─restricted to versions 0.32-0.34 by an explicit requirement, leaving only versions 0.32.0-0.34.0\n   └─restricted by compatibility requirements with Statistics [10745b16] to versions: uninstalled — no versions left\n     └─Statistics [10745b16] log:\n       ├─possible versions are: 0.0.0 or uninstalled\n       └─Statistics [10745b16] is fixed to version 0.0.0\n```\n","[ablaom]: A slack user has posted this possible explanation:\n\nThis issue happens when one does a package operation inside a Pkg.test session. When Pkg.test runs, stdlibs are actually """"devved"""" so they are considered fixed. The issue then is this line: https://github.com/JuliaLang/Pkg.jl/blob/da8bae795e007e878bef4d2926434670f411add9/src/Operations.jl#L261-L262 which will consider the stdlib version to be 0.0.0, which is inconsistent with the assumption that unversioned stdlibs are versioned with the same version as the Julia version running, hence:\n```\n├─Statistics [10745b16] is fixed to version 0.0.0\n```\n\nand this workaround:\n\nAdd: \n```\nPkg.add(name=""""Statistics"""", version=VERSION)\n``` | [ablaom]: The workaround works in my case. See PR cross-referenced above.",2,false,0,0,0,0,0,0,0,0,0
3171,Support packages that use git lfs,open,bradcarman,,,,2,2022-08-13T11:02:02.0,2023-09-19T13:48:32.0,1072,670,https://github.com/JuliaLang/Pkg.jl/issues/3171,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3171,"I have developed a Julia package that hosts data that I need for testing.  Normally Julia packages are not intended for this purpose, but there are some nice advantages this gives me:\n\n1. The Julia data package can be a test only dependency for my other packages, therefore I don't need to bloat my code packages with data.\n2. My code packages can reference a single source for the data source, which is simply a reference to a Julia package.  I don't need to worry about paths.\n3. Data is automatically downloaded, which means this works well with CI.\n4. No additional dependencies or setup is required, this is just applying the already working Pkg.jl infrastructure.\n\nIn my Julia data package, it would be great if I could use git lfs to make the downloads faster and cloud storage smaller.  But as I unfortunately just learned, git lfs is (maybe) not supported by Pkg or maybe LibGit2.  If I run `pkg""""add <julia package with git lfs>""""` then the files using lfs are only downloaded as 1kB files.  If I simply run `git clone <julia package with git lfs>` then I do get the full file sizes, so I'm assuming LibGit2 is not running a full clone.\n\nI do see that in Pkg.jl has the `JULIA_PKG_USE_CLI_GIT` that can be used.  I thought this would solve my problem, but still when I test my package  with `Pkg.test()` the Julia data package is not fully cloned.  \n\nTherefore if Pkg.jl could support git lfs in the future, this would be great for my use case!\n","[lazzarello]: *update, update:* don't forget to install `git-lfs` in your CI system. Without this it'll fail silently and not download the binary objects.\n\n~~*update:* this doesn't work in my CI system and I have no idea why it's not cloning the full URL like it is locally~~\n\nI too would like this feature, or at least a way to avoid future people spending multiple days debugging why their NASA data from the Planetary Data Service (which I added as LFS objects in a to-be-open-source library) didn't make it into other (private) projects. For example, I have a library that has a """"kernel"""" (a binary object in NASA jargon) for [this Mars mission](https://pds.jpl.nasa.gov/ds-view/pds/viewDataset.jsp?dsid=MEX-E%2FM-SPICE-6-V2.0). I add it to my library repository as a LFS object. All is good. That library's tests pass locally, on other users computers and in my CI system.\n\nThen another project adds this library to their own project as a git URL. As @bradcarman said above, the Julia package on disk only has the git LFS pointers to the objects. The quick fix, which I'm doing right now is to add the package in develop mode.\n\n```\nimport Pkg\nPkg.activate(""""."""")\nPkg.develop(url=""""git url to private project"""")\nPkg.test()\n```\n\nThis works fine. But this is not terribly obvious to a user of this library. I don't have a solution but it could be interesting to have some kind of parameter added to indicate that a package has (optional) git LFS dependencies. | [cserteGT3]: I would also use this feature. I have a package, that uses .NET dlls and decided to store the dlls in the julia package's repository as lfs objects. Now I can't install the package by `add`ing, only by `develop`ing. Would be great to have the feature to automatically pull lfs objects as well. Or an option to do so.\n\n(p.s. I am aware of the whole _jll and BinaryBuilding ecosystem, but it's easier for my usecase to store the dlls at the package repo.)",2,false,0,0,0,0,0,0,0,0,0
3622,precompile verbose output,open,xgdgsc,,,,2,2023-09-14T02:03:26.0,2023-09-14T09:00:37.0,675,675,https://github.com/JuliaLang/Pkg.jl/issues/3622,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3622,"There doesn' t seem a verbose mode for precompile, how do I debug why my Pacakge hangs forever in precompile REPL., while runs fine when using the julia process?","[timholy]: I'd like to turn on verbose mode on this issue 🙂. For starters, what's your Julia version and what's the package? Is there any kind of output? | [xgdgsc]: Julia 1.9.3. The package is a project with deps like\n```\n[deps]\nBlosc = """"a74b3585-a348-5f62-a45c-50e91977d574""""\nCSV = """"336ed68f-0bac-5ca0-87d4-7b16caf5d00b""""\nCSVFiles = """"5d742f6a-9f54-50ce-8119-2520741973ca""""\nCodecLz4 = """"5ba52731-8f18-5e0d-9241-30f10d1ec561""""\nCodecZstd = """"6b39b394-51ab-5f42-8807-6242bab2b4c2""""\nConfParser = """"88353bc9-fd38-507d-a820-d3b43837d6b9""""\nDataFrames = """"a93c6f00-e57d-5684-b7b6-d8193f3e46c0""""\nDataFramesMeta = """"1313f7d8-7da2-5740-9ea0-a2ca25f37964""""\nDataStructures = """"864edb3b-99cc-5e75-8d2d-829cb0a9cfe8""""\nDates = """"ade2ca70-3891-5945-98fb-dc099432e06a""""\nDelimitedFiles = """"8bb1440f-4735-579b-a4ab-409b98df4dab""""\nDictionaries = """"85a47980-9c8c-11e8-2b9f-f7ca1fa99fb4""""\nDistributed = """"8ba89e20-285c-5b6f-9357-94700520ee1b""""\nDistributions = """"31c24e10-a181-5473-b8eb-7969acd0382f""""\nFormatting = """"59287772-0a20-5a39-b81b-1366585eb4c0""""\nIterableTables = """"1c8ee90f-4401-5389-894e-7a04a3dc0f4d""""\nJSON = """"682c06a0-de6a-54ab-a142-c8b1cf79cde6""""\nJSON3 = """"0f8b85d8-7281-11e9-16c2-39a750bddbf1""""\nLogRoller = """"c41e01d8-14e5-11ea-185b-e7eabed7be4b""""\nLogging = """"56ddb016-857b-54e1-b83d-db4d58db5568""""\nLoggingExtras = """"e6f89c97-d47a-5376-807f-9c37f3926c36""""\nMemoization = """"6fafb56a-5788-4b4e-91ca-c0cea6611c73""""\nNaNStatistics = """"b946abbf-3ea7-4610-9019-9858bfdeaf2d""""\nNamedTupleTools = """"d9ec5142-1e00-5aa0-9d6a-321866360f50""""\nProgressBars = """"49802e3a-d2f1-5c88-81d8-b72133a6f568""""\nProgressMeter = """"92933f4c-e287-5a05-a399-4b506db050ca""""\nPythonCall = """"6099a3de-0909-46bc-b1f4-468b9a2dfc0d""""\nRandom = """"9a3f8284-a2c9-5f02-9a11-845980a1fd5c""""\nRedis = """"0cf705f9-a9e2-50d1-a699-2b372a39b750""""\nReexport = """"189a3867-3050-52da-a836-e630ba90ab69""""\nShiftedArrays = """"1277b4bf-5013-50f5-be3d-901d8477a67a""""\nStatistics = """"10745b16-79ce-11e8-11f9-7d13ad32a3b2""""\nStatsBase = """"2913bbd2-ae8a-5f71-8c99-4fb6c76f3a91""""\nStatsModels = """"3eaba693-59b7-5ba5-a881-562e759f1c8d""""\nStrFs = """"299745a8-1dd2-5813-967e-1153b019bdef""""\n```\nSorry the project source code cannot be shared. Hang on the last step of precompile MyPackage when doing `up`. No output other than the circling progress.",2,false,0,0,0,0,0,0,0,0,0
3616,`gc` should also run `git gc`,open,berquist,,,,0,2023-09-09T18:42:12.0,2023-09-09T18:42:12.0,679,679,https://github.com/JuliaLang/Pkg.jl/issues/3616,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3616,"Apparently [`gc` doesn't run `git gc`](https://julialang.slack.com/archives/C67EFTEF3/p1694284540901499?thread_ts=1694283956.517709&cid=C67EFTEF3) and I was surprised to find that this is part of the reason why my `~/.julia` was so big.  It's likely the checkout hasn't been GCed since it was created several years ago:\n```\n/home/eric/.julia/registries/General\n[eric@osmium]$ stat .\n  File: .\n  Size: 4096            Blocks: 8          IO Block: 4096   directory\nDevice: 259,2   Inode: 51916279    Links: 32\nAccess: (0755/drwxr-xr-x)  Uid: ( 1000/    eric)   Gid: ( 1000/    eric)\nAccess: 2023-09-08 21:47:21.531384624 -0400\nModify: 2023-07-16 18:14:52.968403148 -0400\nChange: 2023-07-16 18:14:52.968403148 -0400\n Birth: 2020-04-29 22:20:04.255378475 -0400\n/home/eric/.julia/registries/General\n[eric@osmium]$ du -sh .git\n8.7G    .git\n/home/eric/.julia/registries/General\n[eric@osmium]$ git gc\nEnumerating objects: 753532, done.\nCounting objects: 100% (753532/753532), done.\nDelta compression using up to 32 threads\nCompressing objects: 100% (341727/341727), done.\nWriting objects: 100% (753532/753532), done.\nTotal 753532 (delta 409869), reused 751283 (delta 407620), pack-reused 0\n/home/eric/.julia/registries/General\n[eric@osmium]$ du -sh .git\n700M    .git\n```",,0,false,0,0,0,0,0,0,0,0,0
3612,Feature request: different dependencies on different operating systems,open,cmcaine,,,,0,2023-09-07T03:03:56.0,2023-09-07T03:03:56.0,682,682,https://github.com/JuliaLang/Pkg.jl/issues/3612,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3612,"Sometimes packages, especially binary packages, [require different dependencies on different operating systems][libcurl].\n\n[BinaryBuilder.jl has an interface to capture this information for runtime use](https://docs.binarybuilder.org/dev/building/#Platform-specific-dependencies), but Pkg.jl can not yet represent this concept.\n\nIf Pkg.jl supported this concept, then we would skip some unnecessary downloads and precompiling.\n\n[libcurl]: https://github.com/JuliaPackaging/Yggdrasil/blob/b7a316f38e8b6baad74e86940f50b71d66705cdf/L/LibCURL/common.jl#L120-L122\n",,0,false,0,0,0,0,0,0,0,0,0
3611,GitHub actions Pkg checkout of private dep hangs on Windows,open,imciner2,,,,1,2023-09-04T16:15:29.0,2023-09-04T17:01:59.0,684,684,https://github.com/JuliaLang/Pkg.jl/issues/3611,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3611,"I have a private repository that has a private dependency in the same GitHub repository, and Pkg is unable to clone it normally. That on its own isn't the problem, the problem is when this happens it actually just hangs the Windows CI runner and has to be killed by the timeout. This chews up the private minutes and is not good.\n\nOn a Windows runner, it gives the following output:\n```julia\nRun import Pkg\n┌ Warning: The active manifest file is an older format with no julia version entry. Dependencies may have been resolved with a different julia version.\n└ @ D:\a\<redacted>\Manifest.toml:0\n     Cloning git-repo `[https://github.com/<redacted>`](https://github.com/<redacted>%60)\nfatal: Cannot prompt because user interactivity has been disabled.\nError: The operation was canceled.\n```\n\nOn a macOS runner, it gives the following output:\n\n```julia\nRun import Pkg\n  import Pkg\n  VERSION >= v""""1.5-"""" && Pkg.Registry.add(""""General"""")\n  VERSION >= v""""1.1.0-rc1"""" ? Pkg.build(verbose=true) : Pkg.build()\n  shell: /Users/runner/hostedtoolcache/julia/1.9.2/x64/bin/julia --color=yes --project=@. {0}\n  env:\n    ARTIFACTS_PATH: ~/.julia/artifacts\n    PACKAGES_PATH: ~/.julia/packages\n    REGISTRIES_PATH: \n    PRECOMPILATION_CACHE_PATH: \n    JULIA_PKG_SERVER_REGISTRY_PREFERENCE: eager\n    JULIA_PKG_PRECOMPILE_AUTO: no\n┌ Warning: The active manifest file is an older format with no julia version entry. Dependencies may have been resolved with a different julia version.\n└ @ ~/work/<redacted>/Manifest.toml:0\n     Cloning git-repo `[https://github.com/<redacted>`](https://github.com/<redacted>%60)\nERROR: LoadError: failed to clone from https://github.com/<redacted>, error: GitError(Code:EUSER, Class:Callback, Aborting, user cancelled credential request.)\nStacktrace:\n  [1] pkgerror(msg::String)\n    @ Pkg.Types ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/Types.jl:69\n  [2] clone(io::IOContext{Base.PipeEndpoint}, url::String, source_path::String; header::Nothing, credentials::Nothing, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:isbare,), Tuple{Bool}}})\n    @ Pkg.GitTools ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:127\n  [3] clone\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:88 [inlined]\n  [4] #ensure_clone#2\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:74 [inlined]\n  [5] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:1733\n  [6] instantiate\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:1653 [inlined]\n  [7] build(ctx::Pkg.Types.Context, uuids::Set{Base.UUID}, verbose::Bool)\n    @ Pkg.Operations ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:988\n  [8] build(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; verbose::Bool, kwargs::Base.Pairs{Symbol, IOContext{Base.PipeEndpoint}, Tuple{Symbol}, NamedTuple{(:io,), Tuple{IOContext{Base.PipeEndpoint}}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:1053\n  [9] build(pkgs::Vector{Pkg.Types.PackageSpec}; io::IOContext{Base.PipeEndpoint}, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:156\n [10] build(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:171\n [11] top-level scope\n    @ ~/work/_temp/e50e516a-c742-452d-b693-da7ac381c687:3\nin expression starting at /Users/runner/work/_temp/e50e516a-c742-452d-b693-da7ac381c687:3\n\ncaused by: GitError(Code:EUSER, Class:Callback, Aborting, user cancelled credential request.)\nStacktrace:\n  [1] macro expansion\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/LibGit2/src/error.jl:111 [inlined]\n  [2] clone(repo_url::SubString{String}, repo_path::String, clone_opts::LibGit2.CloneOptions)\n    @ LibGit2 ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/LibGit2/src/repository.jl:459\n  [3] clone(repo_url::SubString{String}, repo_path::String; branch::String, isbare::Bool, remote_cb::Ptr{Nothing}, credentials::LibGit2.CachedCredentials, callbacks::Dict{Symbol, Tuple{Ptr{Nothing}, Any}})\n    @ LibGit2 ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/LibGit2/src/LibGit2.jl:583\n  [4] clone\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/LibGit2/src/LibGit2.jl:556 [inlined]\n  [5] clone(io::IOContext{Base.PipeEndpoint}, url::String, source_path::String; header::Nothing, credentials::Nothing, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:isbare,), Tuple{Bool}}})\n    @ Pkg.GitTools ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:116\n  [6] clone\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:88 [inlined]\n  [7] #ensure_clone#2\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:74 [inlined]\n  [8] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:1733\n  [9] instantiate\n    @ ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:1653 [inlined]\n [10] build(ctx::Pkg.Types.Context, uuids::Set{Base.UUID}, verbose::Bool)\n    @ Pkg.Operations ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:988\n [11] build(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; verbose::Bool, kwargs::Base.Pairs{Symbol, IOContext{Base.PipeEndpoint}, Tuple{Symbol}, NamedTuple{(:io,), Tuple{IOContext{Base.PipeEndpoint}}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:1053\n [12] build(pkgs::Vector{Pkg.Types.PackageSpec}; io::IOContext{Base.PipeEndpoint}, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:156\n [13] build(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}})\n    @ Pkg.API ~/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Pkg/src/API.jl:171\n [14] top-level scope\n    @ ~/work/_temp/e50e516a-c742-452d-b693-da7ac381c687:3\nUsername for 'https://github.com/': \nError: Process completed with exit code 1.\n```\n",[imciner2]: The source of the error messages:\n\nThe `GitError` on macOS is being generated by the libgit2 wrappers in Julia itself:\nhttps://github.com/JuliaLang/julia/blob/8e14322b5aa344639dd86bf9eabb84afe831fcba/stdlib/LibGit2/src/callbacks.jl#L48\n\nThe `fatal: Cannot prompt because user interactivity has been disabled.` error on Windows is being generated by git-credential-manager:\nhttps://github.com/git-ecosystem/git-credential-manager/blob/9902e8febb5aa07167c9342ff360dc13e6b8bd38/src/shared/Core/Authentication/AuthenticationBase.cs#L99,1,false,0,0,0,0,0,0,0,0,0
3609,"If a test segfaults, we don't print the test process's stacktrace",open,NHDaly,,test,,0,2023-08-30T20:32:22.0,2023-08-30T20:32:22.0,689,689,https://github.com/JuliaLang/Pkg.jl/issues/3609,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3609,"Consider this reproduction:\n```julia\njulia> pkgdir = tempdir()\n""""/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T""""\n\njulia> using Pkg\n\njulia> Pkg.generate(""""$pkgdir/Foo"""")\n  Generating  project Foo:\n    /var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo/Project.toml\n    /var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo/src/Foo.jl\nDict{String, Base.UUID} with 1 entry:\n  """"Foo"""" => UUID(""""5cf5b73a-ea20-4e74-a23f-58b5b0724252"""")\n\njulia> mkdir(""""$pkgdir/Foo/test/""""); write(""""$pkgdir/Foo/test/runtests.jl"""", """"""""""""\n           unsafe_load(Ptr{Int}(10)); unsafe_load(Ptr{Int}(100))\n           """""""""""")\n54\n\njulia> Pkg.activate(""""$pkgdir/Foo"""")\n  Activating project at `/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo`\n\njulia> Pkg.test()\n  No Changes to `/private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo/Project.toml`\n  No Changes to `/private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo/Manifest.toml`\n     Testing Foo\n      Status `/private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/jl_hQ75Sn/Project.toml`\n  [5cf5b73a] Foo v0.1.0 `/private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo`\n      Status `/private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/jl_hQ75Sn/Manifest.toml`\n  [5cf5b73a] Foo v0.1.0 `/private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo`\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds\n     Testing Running tests...\n\n[42139] signal (11.2): Segmentation fault: 11\nin expression starting at /private/var/folders/nw/lxdth34x7s57tqdbp26xmscr0000gn/T/Foo/test/runtests.jl:1\nunsafe_load at ./pointer.jl:111 [inlined]\nunsafe_load at ./pointer.jl:111\nunknown function (ip: 0x100df801f)\nAllocations: 3000 (Pool: 2988; Big: 12); GC: 0\nERROR: Package Foo errored during testing (received signal: 11)\nStacktrace:\n [1] pkgerror(msg::String)\n   @ Pkg.Types ~/builds/julia-1.9/usr/share/julia/stdlib/v1.9/Pkg/src/Types.jl:69\n [2] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool)\n   @ Pkg.Operations ~/builds/julia-1.9/usr/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:2021\n [3] test\n   @ ~/builds/julia-1.9/usr/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:1902 [inlined]\n[...]\n\njulia>\n```\nIt seems to me like we don't care much about the `Pkg.test()` stacktrace, but we _do_ want to get the stacktrace of the process that crashed! Or maybe we want to print both.\n\nCan we fix that?",,0,false,0,0,0,0,0,0,0,0,0
3607,`--code-coverage` path in `Base.julia_cmd()` is shadowed if `coverage=true`,open,jishnub,,documentation,,0,2023-08-30T11:51:36.0,2023-08-30T18:56:46.0,690,689,https://github.com/JuliaLang/Pkg.jl/issues/3607,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3607,"The kwarg `coverage` to `Pkg.test` is documented to be a `Bool`. If one calls `Pkg.test(coverage=true)`, the following section shows that the command line argument passed when launching `julia` will be ignored, as `""""@$source_path""""` is appended to the command.\nhttps://github.com/JuliaLang/Pkg.jl/blob/5e07cfed0b86412242407bed8f25c3b5ea7febe2/src/Operations.jl#L1674-L1683\n\nThe way to set a coverage path appears to be to pass `coverage=path` directly to `Pkg.test`, as `coverage` may be a `String` as well. However, this behavior isn't documented.\n\nEither the docs should be updated, or the coverage path shouldn't be set if this is already provided.",,0,false,0,0,0,0,0,0,0,0,0
3608,No easy way to see all package versions resolved in environment stack,open,3f6a,,,,0,2023-08-30T16:25:07.0,2023-08-30T16:25:07.0,689,689,https://github.com/JuliaLang/Pkg.jl/issues/3608,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3608,"If I want to see the versions of all packages (and dependencies) in a project, all I have to do is look at `Manifest.toml`. However this does not work in an environment stack, which can include dependencies from projects higher up in the stack and the versions resolved for their dependencies are not explicit anywhere, as far as I can see.\n\nWould be nice to have a way to generate an """"effective"""" `StackManifest.toml` file, containing ALL the dependencies resolved for an environment stack.",,0,false,0,0,0,0,0,0,0,0,0
3558,"""Edit on GitHub"" button on REPL docs results in a 404",open,numbermaniac,,documentation,,0,2023-07-28T05:23:42.0,2023-08-28T09:19:58.0,723,692,https://github.com/JuliaLang/Pkg.jl/issues/3558,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3558,"<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including:\n\n1. The output of `versioninfo()`\n2. How you installed Julia\n3. A minimal working example (MWE), also known as a minimum reproducible example\n\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n\n\nOn the REPL Mode Reference docs page (https://pkgdocs.julialang.org/v1/repl/), if I click """"Edit on GitHub"""" at the top of the page, it links to a """"404 - page not found"""" error.\n\n<img width=""""1456"""" alt=""""Screenshot 2023-07-28 at 3 22 38 pm"""" src=""""https://github.com/JuliaLang/Pkg.jl/assets/5206120/0c358d35-d872-43ba-8e6e-39b44efd9b8c"""">",,0,false,0,0,0,0,0,0,0,0,0
1683,advice for recovering from corrupted depot in the manual,open,tpapp,,,,12,2020-02-18T09:33:25.0,2023-08-27T22:31:09.0,1979,692,https://github.com/JuliaLang/Pkg.jl/issues/1683,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1683,"Occasionally parts of the depot become corrupted (because of interrupted downloads/processes, bugs in Pkg, etc). While this is not part of the normal workflow, it would be great if the manual could have a section on how to recover from these situations, that could be linked eg on Discourse.\n\nEg \n\n1. establish the depot path (examples below assume the default)\n2. remove `~/.julia/packages`\n3. remove the global manifest,\n4. restart julia and do a `pkg> resolve`?","[StefanKarpinski]: Might be worth adding a `pkg> fsck` command that goes through verifying things and trying to fix them and/or delete/recreate them. | [DilumAluthge]: 1. Commit all changes in any packages that you have checked out for development\n2. Push all changes to a remote (GitHub, GitLab, etc.)\n3. `rm -rf ~/.julia`\n\nAnd of course, if you don't have any packages checked out for development, then you simply do:\n1. `rm -rf ~/.julia` | [giordano]: I'd never suggest to people to nuke the julia directory. Why not just move it? | [tpapp]: I agree with @giordano on this --- we should never recommend just deleting things.\n\nUntil `pkg> fsck` is added, it would be great to determine the gentlest minimum solution. It is needed occasionally to recover from various problems, and we should have a standard way.\n\nMy understanding is the following:\n\n1. one can remove `artifacts`, `clones`, `compiled`, `packages`, `registries`, they will just be downloaded at no cost if the machine is online (we should mention this, some environments have no net connection)\n\n2. when `dev` exists, it may contain uncommitted stuff, and it is generally harmless\n\n3. `logs`, `prefs`, and `config` are generally not a source of inconsistent state, so they can be left alone\n\n4. `environments` is really small, and should be just moved to a backup location, eg \n    ```sh\n    mv ~/.julia/environments ~/.julia/environments-backup-`date +%Y-%m-%d`\n    ```\n\nIs this correct? Did I miss anything? | [StefanKarpinski]: Can't think of anything else. However, `logs` can cause problems since manifest usage is tracked there and the file can become corrupted (invalid TOML due to multiple writers). | [fredrikekre]: For 1.: `compiled` is not downloaded but generated, safe to remove just like the others though. | [tpapp]: Thinking about this, it may be preferable to include something in Pkg instead of a shell script that people copy-paste. I am thinking of something like the following:\n```julia\npkg> nuke\nThis command needs to be invoked with --yes to do anything; this is just a message.\n\nIt can be used to recover from an inconsistent state of the package depot by removing \nfiles that were downloaded or automatically generated. The removed files will be\nsaved to a backup directory (which is displayed).\n\nUsed with --environment, it also resets your default environment.\n```\n\n`--yes` would not autocomplete.\n\n```\npkg> nuke --yes\nMoving files to /home/tamas/.julia_depot_backup_2020-03-23_1042.\n\npkg> nuke --yes --environment\nMoving files to /home/tamas/.julia_depot_backup_2020-03-23_1044, resetting environment.\n``` | [StefanKarpinski]: Was thinking of something similar myself. | [tpapp]: Since corrupted registry questions come up daily on Discourse, I am wondering how to move forward with this. In order of increasing difficulty:\n\n1. write up a bunch of commands for users to copy/paste,\n2. implement `nuke` above,\n3. implement `fsck` (cf #1717) | [3f6a]: > one can remove artifacts, clones, compiled, packages, registries, they will just be downloaded at no cost if the machine is online (we should mention this, some environments have no net connection)\n\nI'm not sure about `registries`. One can have a `LocalRegistry` there, with changes not synced to GitHub. | [3f6a]: I think I might have a corrupted depot now, so I'm going through this.\n\n> logs can cause problems ...\n\nIs `logs` safe to delete?\n\nThere is `repl_history.jl` there which I wouldn't want to lose. But the other files:\n\n```\nartifact_usage.toml, manifest_usage.toml, orphaned.toml, scratch_usage.toml\n```\n\ncan be safely deleted? | [3f6a]: Okay, not sure if this might be relevant here. But I tried to delete: artifacts, clones, compiled, packages. Then I reopened julia and did `pkg> up`, and it started generating everything but eventually got this error:\n\n```\nPrecompiling project...\n  267 dependencies successfully precompiled in 142 seconds. 8 already precompiled.\n  1 dependency had warnings during precompilation:\n┌ ChainRulesCore [d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4]\n│  ┌ Warning: The call to compilecache failed to create a usable precompiled cache file for CompatLinearAlgebraExt [dbe5ba0b-aecc-598a-a867-79051b540f49]\n│  │   exception = ArgumentError: Invalid checksum in cache file ~/.julia/compiled/v1.9/CompatLinearAlgebraExt/Zxpzq_nrSU6.dylib.\n│  └ @ Base loading.jl:1818\n│  ┌ Error: Error during loading of extension CompatLinearAlgebraExt of Compat, use `Base.retry_load_extensions()` to retry.\n│  │   exception =\n│  │    1-element ExceptionStack:\n│  │    Declaring __precompile__(false) is not allowed in files that are being precompiled.\n│  │    Stacktrace:\n```\n\n\n",12,false,4,4,0,0,0,0,0,0,0
3588,User can acidentially add external version of stdlib to Manifest,open,vchuravy,,,,0,2023-08-16T00:40:43.0,2023-08-16T00:40:43.0,704,704,https://github.com/JuliaLang/Pkg.jl/issues/3588,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3588,"I was messing about and I did:\n\n```\n(@v1.10) pkg> add https://github.com/JuliaStats/Statistics.jl\n...\n  [10745b16] + Statistics v1.9.0 `https://github.com/JuliaStats/Statistics.jl#master`\n```\n\nRestarting Julia I got:\n```\njulia> using Statistics\nERROR: ArgumentError: Package Statistics [10745b16-79ce-11e8-11f9-7d13ad32a3b2] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n@v1.10) pkg> rm Statistics\n    Updating `~/.julia/environments/v1.10/Project.toml`\n  [10745b16] - Statistics v1.9.0 `https://github.com/JuliaStats/Statistics.jl#master`\n  No Changes to `~/.julia/environments/v1.10/Manifest.toml`\n```\n\nNote the """"No Changes to Manifest.toml""""\n\n```\nvchuravy@odin ~> julia --project=new\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.10.0-beta1 (2023-07-25)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(new) pkg> st -m\nStatus `~/new/Manifest.toml` (empty manifest)\n\njulia> using Statistics\nERROR: ArgumentError: Package Statistics [10745b16-79ce-11e8-11f9-7d13ad32a3b2] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n```\n\n```\nvchuravy@odin ~> rm ~/.julia/environments/v1.10/Manifest.toml\nvchuravy@odin ~> julia --project=new\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.10.0-beta1 (2023-07-25)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> using Statistics\n```\n\n",,0,false,0,0,0,0,0,0,0,0,0
3374,`] registry update` not consistently updating,open,mcmcgrath13,,,,3,2023-02-14T17:27:21.0,2023-08-07T19:18:51.0,886,712,https://github.com/JuliaLang/Pkg.jl/issues/3374,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3374,"I was having trouble getting package versions to resolve and found that when I ran `] registry update` and there was no output (which implied to me things were fine), but after going in circles for a while I tried `] registry update General` and that actually did an update and solved my problem.\n\nIt seems like actively asking for registry update should always actively try to update all registries, so this would be a bug.\n\n1. versioninfo:\n```\nJulia Version 1.8.2\nCommit 36034abf260 (2022-09-29 15:21 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin21.3.0)\n  CPU: 10 × Apple M1 Max\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, apple-m1)\n  Threads: 10 on 8 virtual cores\nEnvironment:\n  JULIA_DEPOT_PATH = /Users/...\n  JULIA_NUM_THREADS = 10\n  JULIA_LOAD_PATH = /Users/...\n  JULIA_EDITOR = codium\n  JULIA_PROJECT = /Users/...\n```\n\n2. I install Julia via `asdf`\n\n3. MRE\n```julia\n] registry update # did nothing\n] registry update General # actually updated\n```\n\n<!--\nIf you have a question please search or post to our Discourse site: https://discourse.julialang.org.\nWe use the GitHub issue tracker for bug reports and feature requests only.\n\nIf you're submitting a bug report, be sure to include as much relevant information as\npossible, including:\n\n1. The output of `versioninfo()`\n2. How you installed Julia\n5. A minimal working example (MWE), also known as a minimum reproducible example\n\nIf you're experiencing a problem with a particular package, open an issue on that\npackage's repository instead.\n\nThanks for contributing to the Julia project!\n-->\n","[KristofferC]: It only updates the registry sitting in the first slot of DEPOT_PATH. Not sure if that is the issue but could be related. | [mcmcgrath13]: Ah, that is definitely related.  I set up a depot for this repo, but there is no registries folder in there so it falls back to the main one. If there is no registry there, should Pkg.jl look up a step (or at least warn about it)? Or is this working as intended? | [NHDaly]: Aha! Thanks, very interesting. +1 that this is surprising.\n\n-----\n\nAt RAI, many of us use separate DEPOTs for each checkout of our application repository, because things tend to get buggy when developing projects with the same name and hash from multiple directories. We've seen all kinds of stateful issues with that, so many of us keep a separate DEPOT per checkout.\n\nWouldn't the separate DEPOT have its own registries directory that would be updated, though? If we haven't done anything special there, shouldn't it still work just like normal?",3,false,2,2,0,0,0,0,0,0,0
3569,"Move the ""Creating Packages"" section of the documentation to the Julia manual",open,LilithHafner,,,,0,2023-08-07T16:17:36.0,2023-08-07T16:17:36.0,712,712,https://github.com/JuliaLang/Pkg.jl/issues/3569,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3569,"> In general I think things like [this](https://github.com/JuliaLang/Pkg.jl/pull/3511) are better off in the Julia manual. In some sense, Pkg is """"just"""" a package manager and someone could in theory write another better one. And we should IMO then try to keep the documentation to package management and less about general julia package information. I realize that things are pretty muddy now (for example the extension documentation is in Pkg, which it probably shouldn't be), but I think it is something to strive for.\n\n_Originally posted by @KristofferC in https://github.com/JuliaLang/Pkg.jl/issues/3511#issuecomment-1587347262_\n\nThis page is not Pkg specific: https://pkgdocs.julialang.org/v1/creating-packages/",,0,false,0,0,0,0,0,0,0,0,0
1860,Tree Hash mismatch Error on Pkg installation,open,fritzratna,,,,6,2020-06-10T17:05:57.0,2023-08-02T00:27:38.0,1865,718,https://github.com/JuliaLang/Pkg.jl/issues/1860,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1860,"Issues occurs when  installing packages (like OpenSpecFun, Zlib,CompilerSupportLibraries) or after package installation (Flux). \n\n```\n``using (""""Flux"""")\n  Installed OpenSpecFun_jll ────────────── v0.5.3+3\n  Installed CodecZlib ──────────────────── v0.7.0\n  Installed BinaryProvider ─────────────── v0.5.10\n  Installed Flux ───────────────────────── v0.10.4\n  Installed Zygote ─────────────────────── v0.4.20\n  Installed ZipFile ────────────────────── v0.9.2\n  Installed CompilerSupportLibraries_jll ─ v0.3.3+0\n  Installed Zlib_jll ───────────────────── v1.2.11+10\n  Installed ZygoteRules ────────────────── v0.2.0\n  Installed SpecialFunctions ───────────── v0.10.3\nError: Tree Hash Mismatch!\n│   Expected git-tree-sha1:   0fd0fb67de786e5d7b2eb67181d35e4bcab639cf\n│   Calculated git-tree-sha1: b5dfbf709a492a96aa4dcaf46616293ce08b7eab\nERROR: LoadError: LoadError: InitError: Unable to automatically install 'CompilerSupportLibraries' from '/home/johndoe/.julia/packages/CompilerSupportLibraries_jll/kmL78/Artifacts.toml'\n``\n```\n\nFor some reason, the computation of the git-tree-sha1 is not correct for many packages in Julia.\nSimilar error message is being displayed for OpenSpecFun, Zlib packages (Platform Red Hat Linux cluster  x86-64). \n\nOne workaround to install the packages successfully is to define:\n `export JULIA_DEPOT_PATH=dir `\nwhere dir has to be a non NFS directory. \n\nAnother solution is  to install CompilerSupportLibraries manually by creating a folder (named with the git tree sha1 # expected 0fd0fb67de786e5d7b2eb67181d35e4bcab639cf) and install the package in that folder from github:\n\n```\njohndoe@mcn19: mkdir –p ~/.julia/artifacts/0fd0fb67de786e5d7b2eb67181d35e4bcab639cf\njohndoe@mcn19: wget -O - https://github.com/JuliaBinaryWrappers/CompilerSupportLibraries_jll.jl/releases/download/CompilerSupportLibraries-v0.3.3+0/CompilerSupportLibraries.v0.3.3.x86_64-linux-gnu-libgfortran4.tar.gz | tar -xzvf - -C ~/.julia/artifacts/0fd0fb67de786e5d7b2eb67181d35e4bcab639cf\n```\n\nYou can find all the releases of CompilerSupportLibraries_jll here https://github.com/JuliaBinaryWrappers/CompilerSupportLibraries_jll.jl/releases\nselect the package based on your Linux architecture (it is very important to download the package specific to the Linux arch, use this following lines in Julia to find your Linux Arch)\n\n```\njulia> using Pkg.BinaryPlatforms\njulia> triplet(platform_key_abi())\n""""x86_64-linux-gnu-libgfortran4-cxx11""""\n```\nIs there a fix for installation of packages in NFS location?\n\n","[giordano]: @fritzratna can you please try this code on that system:\n```julia\nusing Pkg\n_permissions_blind_filesystem_cache = Dict{String,Bool}()\n""""""""""""\n    permissions_blind_filesystem(path::AbstractString)\nDetermine whether the given directory is a permissions-blind filesystem,\nsuch as a FAT32 volume, or an NFS mount with permissions-modifications.\nThis method assumes that `path` is a directory and that  we have write\npermissions on the given `path`.\n""""""""""""\nfunction permissions_blind_filesystem(path::AbstractString)\n    global _permissions_blind_filesystem_cache\n\n    # Immediately normalize `path`\n    path = Pkg.safe_realpath(path)\n    if !isdir(path)\n        error(""""Must provide a directory as `path`"""")\n    end\n\n    if haskey(_permissions_blind_filesystem_cache, path)\n        return _permissions_blind_filesystem_cache[path]\n    end\n\n    # Otherwise, check for the ability to give executable permissions\n    # as well as take them away:\n\n    try\n        blind = mktemp(path) do filepath, io\n            blind = false\n\n            # Set it as executable\n            chmod(filepath, 0o755)\n            blind |= Sys.isexecutable(filepath) != true\n\n            # Set it as non-executable\n            chmod(filepath, 0o644)\n            blind |= Sys.isexecutable(filepath) != false\n\n            # Set it back to executable, to be sure, just in case our default files are executable\n            chmod(filepath, 0o755)\n            blind |= Sys.isexecutable(filepath) != true\n\n            # cache this result\n            return blind\n        end\n\n        # Cache this result, then return it\n        _permissions_blind_filesystem_cache[path] = blind\n        return blind\n    catch e\n        if isa(e, InterruptException)\n            rethrow(e)\n        end\n\n        # In case we hit an error, default to permissions-blind, but don't cache it\n        # so we will try again in the future.\n        return true\n    end\nend\n\npermissions_blind_filesystem(""""/PATH/TO/DIRECTORY"""")\n```\nreplacing `/PATH/TO/DIRECTORY` with a path to a directory on the NFS filesystem?  This is related to #1573 | [fritzratna]: It is going to the error part from the Try/Catch error and returns true (default to permission-blind).  Any idea where and why it is returning error when installing package in a NFS filesystem? | [giordano]: > It is going to the error part from the Try/Catch error and returns true\n\nOk, this is probably the confirmation why you get the mismatch in the computation of the git tree sha1.  Anyway, #1885 made this failure non fatal.  I think this is already in Julia v1.5, if you want to try it out: https://julialang.org/downloads/#upcoming_release_vupcoming_release_upcoming_release_date | [fredrikekre]: > https://julialang.org/downloads/#upcoming_release_vupcoming_release_upcoming_release_date\n\nNice URL.\n\nEdit: https://github.com/JuliaLang/www.julialang.org/pull/936 | [bjarthur]: i'm getting a similar error installing packages in WSL2 but with DEPOT_PATH pointing to a mounted directory on the MS Windows side.  is there a workaround?\n\n```\nERROR: Unable to automatically download/install artifact 'JpegTurbo' from sources listed in '/mnt/c/users/public/julia-1.9.2/local/share/julia/packages/JpegTurbo_jll/eOw3k/Artifacts.toml'.\nSources attempted:\n- https://pkg.julialang.org/artifact/22a0f38792d33b65e35189101e60e1fab0a56030\n    Error: Tree Hash Mismatch!\n  Expected git-tree-sha1:   22a0f38792d33b65e35189101e60e1fab0a56030\n  Calculated git-tree-sha1: 29fd7d0100e682abd6225073630eca4a844c2eae\n- https://github.com/JuliaBinaryWrappers/JpegTurbo_jll.jl/releases/download/JpegTurbo-v2.1.91+0/JpegTurbo.v2.1.91.x86_64-linux-gnu.tar.gz\n    Error: Tree Hash Mismatch!\n  Expected git-tree-sha1:   22a0f38792d33b65e35189101e60e1fab0a56030\n  Calculated git-tree-sha1: 29fd7d0100e682abd6225073630eca4a844c2eae\n``` | [IanButterworth]: You can use `JULIA_PKG_IGNORE_HASHES=1`",6,false,2,0,0,0,0,2,0,0,0
3551,Develop can create an incorrect Manifest; moves `weakdeps` to `deps`,open,kmp5VT,,,,2,2023-07-20T15:04:04.0,2023-07-31T11:16:50.0,731,720,https://github.com/JuliaLang/Pkg.jl/issues/3551,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3551,"Hi I reported this problem on the julia discourse and this is a repost here because I think its actually a bug see \nhttps://discourse.julialang.org/t/does-pkg-develop-have-different-behavior-with-and-without-path/101325\n\nI am having an interesting issue with the Package manager system and wondering if its related to the way my Project.toml is set up.  The issue is that when I call `Pkg.develop` with and without a path to a project in `.julia/dev` two different `Manifest.toml` are instantiated. One seems to have an error where `Pkg` is not properly creating a `weakdeps` section. Here is my julia info\n\n```\nJulia Version 1.9.2\nCommit e4ee485e909 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 32 × Intel(R) Xeon(R) Gold 6244 CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake)\n  Threads: 1 on 32 virtual cores\nEnvironment:\n  LD_LIBRARY_PATH = /mnt/sw/nix/store/wxp5xscxcqq0l1nlrv8k136qs5wqaln6-vscode-1.73.1/lib:/mnt/sw/nix/store/hayjz1l94cb2ky37bhcv71aygjzq7fci-openblas-0.3.21/lib:/cm/shared/apps/slurm/current/lib64:/run/opengl-driver/lib\n```\nI installed julia using `juliaup` and am using `juliaup default release`\n\nHere is the project.toml\n```\nname = """"NDTensors""""\nuuid = """"23ae76d9-e61a-49c4-8f12-3f1a16adf9cf""""\nauthors = [""""Matthew Fishman <mfishman@flatironinstitute.org>""""]\nversion = """"0.2.0""""\n\n[deps]\nsomedeps = """"UUID""""\n\n[compat]\nsomedeps = """"version#""""\n\n[weakdeps]\nCUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\n\n[extensions]\nNDTensorCUDA = """"CUDA""""\n```\nThe issue happens when I try to dev my project so I have the folder `.julia/dev/NDTensors` and `cd` to `.julia/dev`.  When I run this command `$julia --project=temp -e 'using Pkg; Pkg.develop(path=""""./NDTensors"""")'` or this `$julia --project=temp -e 'using Pkg; Pkg.develop(path=""""NDTensors"""")'` I get this error\n```\nResolving package versions...\nERROR: `NDTensors=23ae76d9-e61a-49c4-8f12-3f1a16adf9cf` depends on `CUDA=052768ef-5323-5732-b1bb-66c8b64840ba`, but no such entry exists in the manifest.\nand Pkg has created a manifest (temp/Manifest.toml) that looks like this\n[[deps.NDTensors]]\npath = """"../NDTensors""""\nuuid = """"23ae76d9-e61a-49c4-8f12-3f1a16adf9cf""""\nversion = """"0.2.0""""\n\n    [deps.NDTensors.deps]\n    somedeps = """"UUID""""\n    CUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\n```\nwhich looks like Pkg has incorrectly put my weakdeps in deps. However if I run this command `$julia --project=temp -e 'using Pkg; Pkg.develop(""""NDTensors"""")` Pkg generates this manifest\n```\n[[deps.NDTensors]]\ndeps = [""""somedeps""""]\npath = """"/home/.julia/dev/NDTensors""""\nuuid = """"23ae76d9-e61a-49c4-8f12-3f1a16adf9cf""""\nversion = """"0.2.0""""\n\n    [deps.NDTensors.extensions]\n    NDTensorCUDA = """"CUDA""""\n\n    [deps.NDTensors.weakdeps]\n    CUDA = """"052768ef-5323-5732-b1bb-66c8b64840ba""""\n```\n","[IanButterworth]: I wonder if this is related to https://github.com/JuliaLang/Pkg.jl/issues/3327 given I saw it when dev-ing | [evetion]: Just hit this as well in testing for GeoInterface, in which the common design for testing subpackages does a `julia --project=monorepo`, and than devs all (sub)packages.\n\nI also made a new package from scratch to confirm this issue (ofcourse only on 1.9+) as well. Doing a dev with path=("""".""""), converts the weakdep in the package Project.toml to a dep in the Manifest of the project.",2,false,0,0,0,0,0,0,0,0,0
3562,`compat` tab completion should return a string of existing versions,open,jishnub,,,,0,2023-07-29T11:14:18.0,2023-07-29T11:14:18.0,722,722,https://github.com/JuliaLang/Pkg.jl/issues/3562,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3562,"Currently, if I tab complete in a package with the compat declaration\n```julia\nInfiniteArrays = """"0.11, 0.12, 0.13""""\n```\nit auto-completes to\n```julia\n(ApproxFunBase) pkg> compat InfiniteArrays 0.11, 0.12, 0.13\nERROR: Wrong number of arguments\n```\nas we see, this isn't a valid input, whereas the following works:\n```julia\n(ApproxFunBase) pkg> compat InfiniteArrays """"0.11, 0.12, 0.13""""\n      Compat entry set:\n  InfiniteArrays = """"0.11, 0.12, 0.13""""\n[...]\n```",,0,false,0,0,0,0,0,0,0,0,0
3555,`instantiate` on a Project without a `Manifest.toml` insists on reupdating the registry,open,wnoise,,,,0,2023-07-25T21:19:51.0,2023-07-25T21:20:18.0,725,725,https://github.com/JuliaLang/Pkg.jl/issues/3555,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3555,"## Summary\n\nAs title.  Even when the registry has been updated this session.\n\nThis is very annoying on slow or flaky network connections, such as one might encounter at crowded conference workshop sessions.  One clones the repo, and eager to reproduce the environment, runs `instantiate`.  And promptly hits a thirty second wait on the congested wi-fi.  Not only does it do it once unnecessarily, the `instantiate` can itself fail to download all the deps, and thus not create a `Manifest.toml`.  As a result it leaves any retry to do the exact same thing.\n\nNor does `instantiate` take any flag that can prevent this.\n\n## Analysis\n\nThis behavior stems from [`instantiate()`](https://github.com/JuliaLang/Pkg.jl/blob/b612bfdcca6faacca36eacfeead2ef10d8f1c00a/src/API.jl#L1703-L1709)\n```julia\n    if (!isfile(ctx.env.manifest_file) && manifest === nothing) || manifest == false\n        # given no manifest exists, only allow invoking a registry update if there are project deps\n        allow_registry_update = isfile(ctx.env.project_file) && !isempty(ctx.env.project.deps)\n        up(ctx; update_registry = update_registry && allow_registry_update)\n        allow_autoprecomp && Pkg._auto_precompile(ctx, already_instantiated = true)\n        return\n    end\n```\n\nThis is aggravated by issue #3412 in that `up()` ignores the setting of `Pkg.UPDATED_REGISTRY_THIS_SESSION[]` to specifically not need to recheck the registry.  If that bug were fixed, this would be next to unobservable.\n\n## Workarounds:\n\nRun `resolve` before `instantiate`.  It will run `up()` with flags to not download a new registry, and create a `Manifest.toml`.\n\nIf one is intimately familiar with the internal `Pkg` implementations details, one could use the function `Pkg.instantiate()` rather than the REPL.\n\n## Platform Info\n\n```\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 12 × Intel(R) Core(TM) i7-9850H CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 1 on 12 virtual cores\nEnvironment:\n  JULIA_PKG_USE_CLI_GIT = true\n```\n\n## Minimum working example\n\n```julia\nusing Pkg #Needed for project() call\npkg""""activate --temp""""\npkg""""registry up""""\npkg""""add Example""""\nrm(dirname(Pkg.project().path) * """"/Manifest.toml"""")\npkg""""instantiate""""\n```\n\nObserve that the `instantiate` line redownloads the registry.",,0,false,1,1,0,0,0,0,0,0,0
3550,Deadlock in freeing `dev`ed packages after fetching upstream,open,jishnub,,,,0,2023-07-18T05:39:58.0,2023-07-18T05:40:34.0,733,733,https://github.com/JuliaLang/Pkg.jl/issues/3550,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3550,"In this case, the Project.toml has been modified upstream, and after fetching the changes, I can't seem to update dependencies anymore.\n\n```julia\n(InfiniteLinearAlgebra) pkg> st\nProject InfiniteLinearAlgebra v0.6.22\nStatus `~/Dropbox/JuliaPackages/InfiniteLinearAlgebra.jl/Project.toml`\n  [4c555306] ArrayLayouts v1.0.12 `../ArrayLayouts.jl`\n  [aae01518] BandedMatrices v0.17.30\n⌃ [8e7c35d0] BlockArrays v0.16.35\n  [ffab5731] BlockBandedMatrices v0.12.1\n  [717857b8] DSP v0.7.8\n⌃ [1a297f60] FillArrays v1.4.0\n  [4858937d] InfiniteArrays v0.12.14\n⌃ [5078a376] LazyArrays v1.2.1\n⌃ [d7e5e226] LazyBandedMatrices v0.8.11\n  [a3b82374] MatrixFactorizations v2.0.0\n  [f8ebbe35] SemiseparableMatrices v0.3.7\n  [37e2e46d] LinearAlgebra\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\nWarning The project dependencies or compat requirements have changed since the manifest was last resolved. It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.\n\n(InfiniteLinearAlgebra) pkg> free ArrayLayouts\n   Resolving package versions...\nERROR: empty intersection between LazyArrays@1.2.1 and project compatibility 1.3.0-1\n\n(InfiniteLinearAlgebra) pkg> resolve\nERROR: empty intersection between LazyArrays@1.2.1 and project compatibility 1.3.0-1\n\n(InfiniteLinearAlgebra) pkg> free ArrayLayouts\n   Resolving package versions...\nERROR: empty intersection between LazyArrays@1.2.1 and project compatibility 1.3.0-1\n\n(InfiniteLinearAlgebra) pkg> up\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\nERROR: empty intersection between ArrayLayouts@1.0.11 and project compatibility 1.0.12-1\n\n(InfiniteLinearAlgebra) pkg> up LazyArrays\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\nERROR: empty intersection between ArrayLayouts@1.0.11 and project compatibility 1.0.12-1\n```\n\nI want to free `ArrayLayouts`, but I can't seem to figure out the steps to update the other dependencies. Removing the manifest and starting afresh works, but is there a more systematic approach in such cases?\n\n<details>\n\n<summary> Project.toml </summary>\n\n```\nname = """"InfiniteLinearAlgebra""""\nuuid = """"cde9dba0-b1de-11e9-2c62-0bab9446c55c""""\nversion = """"0.6.22""""\n\n[deps]\nArrayLayouts = """"4c555306-a7a7-4459-81d9-ec55ddd5c99a""""\nBandedMatrices = """"aae01518-5342-5314-be14-df237901396f""""\nBlockArrays = """"8e7c35d0-a365-5155-bbbb-fb81a777f24e""""\nBlockBandedMatrices = """"ffab5731-97b5-5995-9138-79e8c1846df0""""\nDSP = """"717857b8-e6f2-59f4-9121-6e50c889abd2""""\nFillArrays = """"1a297f60-69ca-5386-bcde-b61e274b549b""""\nInfiniteArrays = """"4858937d-0d70-526a-a4dd-2d5cb5dd786c""""\nLazyArrays = """"5078a376-72f3-5289-bfd5-ec5146d43c02""""\nLazyBandedMatrices = """"d7e5e226-e90b-4449-9968-0f923699bf6f""""\nLinearAlgebra = """"37e2e46d-f89d-539d-b4ee-838fcccc9c8e""""\nMatrixFactorizations = """"a3b82374-2e81-5b9e-98ce-41277c0e4c87""""\nSemiseparableMatrices = """"f8ebbe35-cbfb-4060-bf7f-b10e4670cf57""""\n\n[compat]\nAqua = """"0.6""""\nArrayLayouts = """"1.0.12""""\nBandedMatrices = """"0.17.19""""\nBlockArrays = """"0.16.14""""\nBlockBandedMatrices = """"0.12""""\nDSP = """"0.7""""\nFillArrays = """"1""""\nInfiniteArrays = """"0.12""""\nLazyArrays = """"1.3""""\nLazyBandedMatrices = """"0.8.7""""\nMatrixFactorizations = """"1, 2""""\nSemiseparableMatrices = """"0.3""""\njulia = """"1.6""""\n\n[extras]\nAqua = """"4c88cf16-eb10-579e-8560-4a9242c79595""""\nRandom = """"9a3f8284-a2c9-5f02-9a11-845980a1fd5c""""\nSpecialFunctions = """"276daf66-3868-5448-9aa4-cd146d93841b""""\nStaticArrays = """"90137ffa-7385-5640-81b9-e52037218182""""\nTest = """"8dfed614-e22c-5e08-85e1-65c5234f0b40""""\n\n[targets]\ntest = [""""Aqua"""", """"Test"""", """"Random"""", """"SpecialFunctions"""", """"StaticArrays""""]\n```\n\n</details>\n\n<details>\n\n<summary> Manifest.toml </summary>\n\n```\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = """"1.9.2""""\nmanifest_format = """"2.0""""\nproject_hash = """"7556162efe4300da5ae01965eb3e4ba01cc936e3""""\n\n[[deps.AbstractFFTs]]\ndeps = [""""LinearAlgebra""""]\ngit-tree-sha1 = """"cad4c758c0038eea30394b1b671526921ca85b21""""\nuuid = """"621f4979-c628-5d54-868e-fcf4e3e8185c""""\nversion = """"1.4.0""""\n\n    [deps.AbstractFFTs.extensions]\n    AbstractFFTsChainRulesCoreExt = """"ChainRulesCore""""\n\n    [deps.AbstractFFTs.weakdeps]\n    ChainRulesCore = """"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""""\n\n[[deps.ArgTools]]\nuuid = """"0dad84c5-d112-42e6-8d28-ef12dabb789f""""\nversion = """"1.1.1""""\n\n[[deps.ArrayLayouts]]\ndeps = [""""FillArrays"""", """"LinearAlgebra"""", """"SparseArrays""""]\npath = """"../ArrayLayouts.jl""""\nuuid = """"4c555306-a7a7-4459-81d9-ec55ddd5c99a""""\nversion = """"1.0.12""""\n\n[[deps.Artifacts]]\nuuid = """"56f22d72-fd6d-98f1-02f0-08ddc0907c33""""\n\n[[deps.BandedMatrices]]\ndeps = [""""ArrayLayouts"""", """"FillArrays"""", """"LinearAlgebra"""", """"PrecompileTools"""", """"SparseArrays""""]\ngit-tree-sha1 = """"206e78eb10c9aaee4e73962b1cbd0ecf688d4b49""""\nuuid = """"aae01518-5342-5314-be14-df237901396f""""\nversion = """"0.17.30""""\n\n[[deps.Base64]]\nuuid = """"2a0f44e3-6c83-55bd-87e4-b1978d98bd5f""""\n\n[[deps.BlockArrays]]\ndeps = [""""ArrayLayouts"""", """"FillArrays"""", """"LinearAlgebra""""]\ngit-tree-sha1 = """"ffb0191c5d1872a8c91a6181e94a365b7d08d5f2""""\nuuid = """"8e7c35d0-a365-5155-bbbb-fb81a777f24e""""\nversion = """"0.16.35""""\n\n[[deps.BlockBandedMatrices]]\ndeps = [""""ArrayLayouts"""", """"BandedMatrices"""", """"BlockArrays"""", """"FillArrays"""", """"LinearAlgebra"""", """"MatrixFactorizations"""", """"SparseArrays"""", """"Statistics""""]\ngit-tree-sha1 = """"edcae60b22a8a6e138b75622a8b50c3f2e9d61ee""""\nuuid = """"ffab5731-97b5-5995-9138-79e8c1846df0""""\nversion = """"0.12.1""""\n\n[[deps.Compat]]\ndeps = [""""UUIDs""""]\ngit-tree-sha1 = """"4e88377ae7ebeaf29a047aa1ee40826e0b708a5d""""\nuuid = """"34da2185-b29b-5c13-b0c7-acf172513d20""""\nversion = """"4.7.0""""\nweakdeps = [""""Dates"""", """"LinearAlgebra""""]\n\n    [deps.Compat.extensions]\n    CompatLinearAlgebraExt = """"LinearAlgebra""""\n\n[[deps.CompilerSupportLibraries_jll]]\ndeps = [""""Artifacts"""", """"Libdl""""]\nuuid = """"e66e0078-7015-5450-92f7-15fbd957f2ae""""\nversion = """"1.0.5+0""""\n\n[[deps.DSP]]\ndeps = [""""Compat"""", """"FFTW"""", """"IterTools"""", """"LinearAlgebra"""", """"Polynomials"""", """"Random"""", """"Reexport"""", """"SpecialFunctions"""", """"Statistics""""]\ngit-tree-sha1 = """"da8b06f89fce9996443010ef92572b193f8dca1f""""\nuuid = """"717857b8-e6f2-59f4-9121-6e50c889abd2""""\nversion = """"0.7.8""""\n\n[[deps.Dates]]\ndeps = [""""Printf""""]\nuuid = """"ade2ca70-3891-5945-98fb-dc099432e06a""""\n\n[[deps.DocStringExtensions]]\ndeps = [""""LibGit2""""]\ngit-tree-sha1 = """"2fb1e02f2b635d0845df5d7c167fec4dd739b00d""""\nuuid = """"ffbed154-4ef7-542d-bbb7-c09d3a79fcae""""\nversion = """"0.9.3""""\n\n[[deps.Downloads]]\ndeps = [""""ArgTools"""", """"FileWatching"""", """"LibCURL"""", """"NetworkOptions""""]\nuuid = """"f43a241f-c20a-4ad4-852c-f6b1247861c6""""\nversion = """"1.6.0""""\n\n[[deps.FFTW]]\ndeps = [""""AbstractFFTs"""", """"FFTW_jll"""", """"LinearAlgebra"""", """"MKL_jll"""", """"Preferences"""", """"Reexport""""]\ngit-tree-sha1 = """"b4fbdd20c889804969571cc589900803edda16b7""""\nuuid = """"7a1cc6ca-52ef-59f5-83cd-3a7055c09341""""\nversion = """"1.7.1""""\n\n[[deps.FFTW_jll]]\ndeps = [""""Artifacts"""", """"JLLWrappers"""", """"Libdl"""", """"Pkg""""]\ngit-tree-sha1 = """"c6033cc3892d0ef5bb9cd29b7f2f0331ea5184ea""""\nuuid = """"f5851436-0d7a-5f13-b9de-f02708fd171a""""\nversion = """"3.3.10+0""""\n\n[[deps.FileWatching]]\nuuid = """"7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee""""\n\n[[deps.FillArrays]]\ndeps = [""""LinearAlgebra"""", """"Random"""", """"SparseArrays"""", """"Statistics""""]\ngit-tree-sha1 = """"e5556303fd8c9ad4a8fceccd406ef3433ddb4c45""""\nuuid = """"1a297f60-69ca-5386-bcde-b61e274b549b""""\nversion = """"1.4.0""""\n\n[[deps.InfiniteArrays]]\ndeps = [""""ArrayLayouts"""", """"FillArrays"""", """"Infinities"""", """"LazyArrays"""", """"LinearAlgebra"""", """"Statistics""""]\ngit-tree-sha1 = """"6caf665a1d25a10c22b4415e9d5b4a5b90f9abdf""""\nuuid = """"4858937d-0d70-526a-a4dd-2d5cb5dd786c""""\nversion = """"0.12.14""""\n\n[[deps.Infinities]]\ngit-tree-sha1 = """"7cafb0d59dabad36e451c80b03505ecd599ce924""""\nuuid = """"e1ba4f0e-776d-440f-acd9-e1d2e9742647""""\nversion = """"0.1.6""""\n\n[[deps.IntelOpenMP_jll]]\ndeps = [""""Artifacts"""", """"JLLWrappers"""", """"Libdl"""", """"Pkg""""]\ngit-tree-sha1 = """"0cb9352ef2e01574eeebdb102948a58740dcaf83""""\nuuid = """"1d5cc7b8-4909-519e-a0f8-d0f5ad9712d0""""\nversion = """"2023.1.0+0""""\n\n[[deps.InteractiveUtils]]\ndeps = [""""Markdown""""]\nuuid = """"b77e0a4c-d291-57a0-90e8-8db25a27a240""""\n\n[[deps.IrrationalConstants]]\ngit-tree-sha1 = """"630b497eafcc20001bba38a4651b327dcfc491d2""""\nuuid = """"92d709cd-6900-40b7-9082-c6be49f344b6""""\nversion = """"0.2.2""""\n\n[[deps.IterTools]]\ngit-tree-sha1 = """"4ced6667f9974fc5c5943fa5e2ef1ca43ea9e450""""\nuuid = """"c8e1da08-722c-5040-9ed9-7db0dc04731e""""\nversion = """"1.8.0""""\n\n[[deps.JLLWrappers]]\ndeps = [""""Preferences""""]\ngit-tree-sha1 = """"abc9885a7ca2052a736a600f7fa66209f96506e1""""\nuuid = """"692b3bcd-3c85-4b1f-b108-f13ce0eb3210""""\nversion = """"1.4.1""""\n\n[[deps.LazyArrays]]\ndeps = [""""ArrayLayouts"""", """"FillArrays"""", """"LinearAlgebra"""", """"MacroTools"""", """"MatrixFactorizations"""", """"SparseArrays"""", """"StaticArrays""""]\ngit-tree-sha1 = """"34c1a2c023a986efa9a7ef0c989793e34604fe7a""""\nuuid = """"5078a376-72f3-5289-bfd5-ec5146d43c02""""\nversion = """"1.2.1""""\n\n[[deps.LazyArtifacts]]\ndeps = [""""Artifacts"""", """"Pkg""""]\nuuid = """"4af54fe1-eca0-43a8-85a7-787d91b784e3""""\n\n[[deps.LazyBandedMatrices]]\ndeps = [""""ArrayLayouts"""", """"BandedMatrices"""", """"BlockArrays"""", """"BlockBandedMatrices"""", """"FillArrays"""", """"LazyArrays"""", """"LinearAlgebra"""", """"MatrixFactorizations"""", """"SparseArrays"""", """"StaticArrays""""]\ngit-tree-sha1 = """"0478b75fdc4bff5da676392dc4e2dd37773814fa""""\nuuid = """"d7e5e226-e90b-4449-9968-0f923699bf6f""""\nversion = """"0.8.11""""\n\n[[deps.LibCURL]]\ndeps = [""""LibCURL_jll"""", """"MozillaCACerts_jll""""]\nuuid = """"b27032c2-a3e7-50c8-80cd-2d36dbcbfd21""""\nversion = """"0.6.3""""\n\n[[deps.LibCURL_jll]]\ndeps = [""""Artifacts"""", """"LibSSH2_jll"""", """"Libdl"""", """"MbedTLS_jll"""", """"Zlib_jll"""", """"nghttp2_jll""""]\nuuid = """"deac9b47-8bc7-5906-a0fe-35ac56dc84c0""""\nversion = """"7.84.0+0""""\n\n[[deps.LibGit2]]\ndeps = [""""Base64"""", """"NetworkOptions"""", """"Printf"""", """"SHA""""]\nuuid = """"76f85450-5226-5b5a-8eaa-529ad045b433""""\n\n[[deps.LibSSH2_jll]]\ndeps = [""""Artifacts"""", """"Libdl"""", """"MbedTLS_jll""""]\nuuid = """"29816b5a-b9ab-546f-933c-edad1886dfa8""""\nversion = """"1.10.2+0""""\n\n[[deps.Libdl]]\nuuid = """"8f399da3-3557-5675-b5ff-fb832c97cbdb""""\n\n[[deps.LinearAlgebra]]\ndeps = [""""Libdl"""", """"OpenBLAS_jll"""", """"libblastrampoline_jll""""]\nuuid = """"37e2e46d-f89d-539d-b4ee-838fcccc9c8e""""\n\n[[deps.LogExpFunctions]]\ndeps = [""""DocStringExtensions"""", """"IrrationalConstants"""", """"LinearAlgebra""""]\ngit-tree-sha1 = """"c3ce8e7420b3a6e071e0fe4745f5d4300e37b13f""""\nuuid = """"2ab3a3ac-af41-5b50-aa03-7779005ae688""""\nversion = """"0.3.24""""\n\n    [deps.LogExpFunctions.extensions]\n    LogExpFunctionsChainRulesCoreExt = """"ChainRulesCore""""\n    LogExpFunctionsChangesOfVariablesExt = """"ChangesOfVariables""""\n    LogExpFunctionsInverseFunctionsExt = """"InverseFunctions""""\n\n    [deps.LogExpFunctions.weakdeps]\n    ChainRulesCore = """"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""""\n    ChangesOfVariables = """"9e997f8a-9a97-42d5-a9f1-ce6bfc15e2c0""""\n    InverseFunctions = """"3587e190-3f89-42d0-90ee-14403ec27112""""\n\n[[deps.Logging]]\nuuid = """"56ddb016-857b-54e1-b83d-db4d58db5568""""\n\n[[deps.MKL_jll]]\ndeps = [""""Artifacts"""", """"IntelOpenMP_jll"""", """"JLLWrappers"""", """"LazyArtifacts"""", """"Libdl"""", """"Pkg""""]\ngit-tree-sha1 = """"154d7aaa82d24db6d8f7e4ffcfe596f40bff214b""""\nuuid = """"856f044c-d86e-5d09-b602-aeab76dc8ba7""""\nversion = """"2023.1.0+0""""\n\n[[deps.MacroTools]]\ndeps = [""""Markdown"""", """"Random""""]\ngit-tree-sha1 = """"42324d08725e200c23d4dfb549e0d5d89dede2d2""""\nuuid = """"1914dd2f-81c6-5fcd-8719-6d5c9610ff09""""\nversion = """"0.5.10""""\n\n[[deps.Markdown]]\ndeps = [""""Base64""""]\nuuid = """"d6f4376e-aef5-505a-96c1-9c027394607a""""\n\n[[deps.MatrixFactorizations]]\ndeps = [""""ArrayLayouts"""", """"LinearAlgebra"""", """"Printf"""", """"Random""""]\ngit-tree-sha1 = """"6507b5bde6500ae31c01a1d893764e130b62256d""""\nuuid = """"a3b82374-2e81-5b9e-98ce-41277c0e4c87""""\nversion = """"2.0.0""""\n\n[[deps.MbedTLS_jll]]\ndeps = [""""Artifacts"""", """"Libdl""""]\nuuid = """"c8ffd9c3-330d-5841-b78e-0817d7145fa1""""\nversion = """"2.28.2+0""""\n\n[[deps.MozillaCACerts_jll]]\nuuid = """"14a3606d-f60d-562e-9121-12d972cd8159""""\nversion = """"2022.10.11""""\n\n[[deps.NetworkOptions]]\nuuid = """"ca575930-c2e3-43a9-ace4-1e988b2c1908""""\nversion = """"1.2.0""""\n\n[[deps.OpenBLAS_jll]]\ndeps = [""""Artifacts"""", """"CompilerSupportLibraries_jll"""", """"Libdl""""]\nuuid = """"4536629a-c528-5b80-bd46-f80d51c5b363""""\nversion = """"0.3.21+4""""\n\n[[deps.OpenLibm_jll]]\ndeps = [""""Artifacts"""", """"Libdl""""]\nuuid = """"05823500-19ac-5b8b-9628-191a04bc5112""""\nversion = """"0.8.1+0""""\n\n[[deps.OpenSpecFun_jll]]\ndeps = [""""Artifacts"""", """"CompilerSupportLibraries_jll"""", """"JLLWrappers"""", """"Libdl"""", """"Pkg""""]\ngit-tree-sha1 = """"13652491f6856acfd2db29360e1bbcd4565d04f1""""\nuuid = """"efe28fd5-8261-553b-a9e1-b2916fc3738e""""\nversion = """"0.5.5+0""""\n\n[[deps.Pkg]]\ndeps = [""""Artifacts"""", """"Dates"""", """"Downloads"""", """"FileWatching"""", """"LibGit2"""", """"Libdl"""", """"Logging"""", """"Markdown"""", """"Printf"""", """"REPL"""", """"Random"""", """"SHA"""", """"Serialization"""", """"TOML"""", """"Tar"""", """"UUIDs"""", """"p7zip_jll""""]\nuuid = """"44cfe95a-1eb2-52ea-b672-e2afdf69b78f""""\nversion = """"1.9.2""""\n\n[[deps.Polynomials]]\ndeps = [""""LinearAlgebra"""", """"RecipesBase""""]\ngit-tree-sha1 = """"3aa2bb4982e575acd7583f01531f241af077b163""""\nuuid = """"f27b6e38-b328-58d1-80ce-0feddd5e7a45""""\nversion = """"3.2.13""""\n\n    [deps.Polynomials.extensions]\n    PolynomialsChainRulesCoreExt = """"ChainRulesCore""""\n    PolynomialsMakieCoreExt = """"MakieCore""""\n    PolynomialsMutableArithmeticsExt = """"MutableArithmetics""""\n\n    [deps.Polynomials.weakdeps]\n    ChainRulesCore = """"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""""\n    MakieCore = """"20f20a25-4f0e-4fdf-b5d1-57303727442b""""\n    MutableArithmetics = """"d8a4904e-b15c-11e9-3269-09a3773c0cb0""""\n\n[[deps.PrecompileTools]]\ndeps = [""""Preferences""""]\ngit-tree-sha1 = """"9673d39decc5feece56ef3940e5dafba15ba0f81""""\nuuid = """"aea7be01-6a6a-4083-8856-8a6e6704d82a""""\nversion = """"1.1.2""""\n\n[[deps.Preferences]]\ndeps = [""""TOML""""]\ngit-tree-sha1 = """"7eb1686b4f04b82f96ed7a4ea5890a4f0c7a09f1""""\nuuid = """"21216c6a-2e73-6563-6e65-726566657250""""\nversion = """"1.4.0""""\n\n[[deps.Printf]]\ndeps = [""""Unicode""""]\nuuid = """"de0858da-6303-5e67-8744-51eddeeeb8d7""""\n\n[[deps.REPL]]\ndeps = [""""InteractiveUtils"""", """"Markdown"""", """"Sockets"""", """"Unicode""""]\nuuid = """"3fa0cd96-eef1-5676-8a61-b3b8758bbffb""""\n\n[[deps.Random]]\ndeps = [""""SHA"""", """"Serialization""""]\nuuid = """"9a3f8284-a2c9-5f02-9a11-845980a1fd5c""""\n\n[[deps.RecipesBase]]\ndeps = [""""PrecompileTools""""]\ngit-tree-sha1 = """"5c3d09cc4f31f5fc6af001c250bf1278733100ff""""\nuuid = """"3cdcf5f2-1ef4-517c-9805-6587b60abb01""""\nversion = """"1.3.4""""\n\n[[deps.Reexport]]\ngit-tree-sha1 = """"45e428421666073eab6f2da5c9d310d99bb12f9b""""\nuuid = """"189a3867-3050-52da-a836-e630ba90ab69""""\nversion = """"1.2.2""""\n\n[[deps.SHA]]\nuuid = """"ea8e919c-243c-51af-8825-aaa63cd721ce""""\nversion = """"0.7.0""""\n\n[[deps.SemiseparableMatrices]]\ndeps = [""""ArrayLayouts"""", """"BandedMatrices"""", """"BlockBandedMatrices"""", """"LazyArrays"""", """"LazyBandedMatrices"""", """"LinearAlgebra"""", """"MatrixFactorizations""""]\ngit-tree-sha1 = """"134d37875eb487c24463201f5521ccba85a67d17""""\nuuid = """"f8ebbe35-cbfb-4060-bf7f-b10e4670cf57""""\nversion = """"0.3.7""""\n\n[[deps.Serialization]]\nuuid = """"9e88b42a-f829-5b0c-bbe9-9e923198166b""""\n\n[[deps.Sockets]]\nuuid = """"6462fe0b-24de-5631-8697-dd941f90decc""""\n\n[[deps.SparseArrays]]\ndeps = [""""Libdl"""", """"LinearAlgebra"""", """"Random"""", """"Serialization"""", """"SuiteSparse_jll""""]\nuuid = """"2f01184e-e22b-5df5-ae63-d93ebab69eaf""""\n\n[[deps.SpecialFunctions]]\ndeps = [""""IrrationalConstants"""", """"LogExpFunctions"""", """"OpenLibm_jll"""", """"OpenSpecFun_jll""""]\ngit-tree-sha1 = """"7beb031cf8145577fbccacd94b8a8f4ce78428d3""""\nuuid = """"276daf66-3868-5448-9aa4-cd146d93841b""""\nversion = """"2.3.0""""\n\n    [deps.SpecialFunctions.extensions]\n    SpecialFunctionsChainRulesCoreExt = """"ChainRulesCore""""\n\n    [deps.SpecialFunctions.weakdeps]\n    ChainRulesCore = """"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""""\n\n[[deps.StaticArrays]]\ndeps = [""""LinearAlgebra"""", """"Random"""", """"StaticArraysCore""""]\ngit-tree-sha1 = """"0da7e6b70d1bb40b1ace3b576da9ea2992f76318""""\nuuid = """"90137ffa-7385-5640-81b9-e52037218182""""\nversion = """"1.6.0""""\nweakdeps = [""""Statistics""""]\n\n    [deps.StaticArrays.extensions]\n    StaticArraysStatisticsExt = """"Statistics""""\n\n[[deps.StaticArraysCore]]\ngit-tree-sha1 = """"1d5708d926c76a505052d0d24a846d5da08bc3a4""""\nuuid = """"1e83bf80-4336-4d27-bf5d-d5a4f845583c""""\nversion = """"1.4.1""""\n\n[[deps.Statistics]]\ndeps = [""""LinearAlgebra"""", """"SparseArrays""""]\nuuid = """"10745b16-79ce-11e8-11f9-7d13ad32a3b2""""\nversion = """"1.9.0""""\n\n[[deps.SuiteSparse_jll]]\ndeps = [""""Artifacts"""", """"Libdl"""", """"Pkg"""", """"libblastrampoline_jll""""]\nuuid = """"bea87d4a-7f5b-5778-9afe-8cc45184846c""""\nversion = """"5.10.1+6""""\n\n[[deps.TOML]]\ndeps = [""""Dates""""]\nuuid = """"fa267f1f-6049-4f14-aa54-33bafae1ed76""""\nversion = """"1.0.3""""\n\n[[deps.Tar]]\ndeps = [""""ArgTools"""", """"SHA""""]\nuuid = """"a4e569a6-e804-4fa4-b0f3-eef7a1d5b13e""""\nversion = """"1.10.0""""\n\n[[deps.UUIDs]]\ndeps = [""""Random"""", """"SHA""""]\nuuid = """"cf7118a7-6976-5b1a-9a39-7adc72f591a4""""\n\n[[deps.Unicode]]\nuuid = """"4ec0a83e-493e-50e2-b9ac-8f72acf5a8f5""""\n\n[[deps.Zlib_jll]]\ndeps = [""""Libdl""""]\nuuid = """"83775a58-1f1d-513f-b197-d71354ab007a""""\nversion = """"1.2.13+0""""\n\n[[deps.libblastrampoline_jll]]\ndeps = [""""Artifacts"""", """"Libdl""""]\nuuid = """"8e850b90-86db-534c-a0d3-1478176c7d93""""\nversion = """"5.8.0+0""""\n\n[[deps.nghttp2_jll]]\ndeps = [""""Artifacts"""", """"Libdl""""]\nuuid = """"8e850ede-7688-5339-a07c-302acd2aaf8d""""\nversion = """"1.48.0+0""""\n\n[[deps.p7zip_jll]]\ndeps = [""""Artifacts"""", """"Libdl""""]\nuuid = """"3f19e933-33d8-53b3-aaab-bd5110c3b7a0""""\nversion = """"17.4.0+0""""\n```\n\n</details>",,0,false,0,0,0,0,0,0,0,0,0
3546,`free` should call `registry up` if needed,open,ericphanson,,,,0,2023-07-12T16:48:04.0,2023-07-12T16:48:04.0,738,738,https://github.com/JuliaLang/Pkg.jl/issues/3546,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3546,"If you have switch from a dev'd dependency to a newly-registered version of it, if you call `free`, it will error if your registry is out of date and your compat bounds are not compatible with the older versions that are in the old copy of the registry:\n```\n(MyPackage) pkg> free MyDependency\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package MyDependency [...]\n```\nI think if Pkg encounters this problem, it should try a `registry up` before issuing that error.",,0,false,1,1,0,0,0,0,0,0,0
3541,Unclear `resolve` behavior when upgrading a `weakdep` to hard `dep`,open,sjkelly,,,,2,2023-07-06T14:50:58.0,2023-07-06T15:37:07.0,745,744,https://github.com/JuliaLang/Pkg.jl/issues/3541,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3541,"You can get caught in a confusing loop if you add a dep to a project that already has said dep as a weakdep. For example (using Plots as an example where we try to promote FileIO from from a weakdep to hard dep):\n\n```\nsjkelly@sjkltp3:~/.julia/dev/Plots (master=)$ julia +master --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.0-DEV.23 (2023-07-06)\n _/ |\__'_|_|_|\__'_|  |  sjk/nixshell_master1/16075e1134* (fork: 2 commits, 0 days)\n|__/                   |\n\n(Plots) pkg> add FileIO\n   Resolving package versions...\n    Updating `~/.julia/dev/Plots/Project.toml`\n  [5789e2e9] + FileIO v1.16.1\n    Updating `~/.julia/dev/Plots/Manifest.toml`\n  [5789e2e9] + FileIO v1.16.1\n\n(Plots) pkg> st\nProject Plots v1.38.16-dev\nStatus `~/.julia/dev/Plots/Project.toml`\n  [d38c429a] Contour v0.6.2\n  [c87230d0] FFMPEG v0.4.1\n  [53c48c17] FixedPointNumbers v0.8.4\n⌃ [28b8d3ca] GR v0.71.5\n  [1019f520] JLFzf v0.1.5\n⌃ [682c06a0] JSON v0.21.3\n  [b964fa9f] LaTeXStrings v1.3.0\n  [23fbe1c1] Latexify v0.15.18 `~/.julia/dev/Latexify`\n  [442fdcdd] Measures v0.3.2\n⌃ [77ba4419] NaNMath v1.0.1\n  [ccf2f8ad] PlotThemes v3.1.0\n⌃ [995b91a9] PlotUtils v1.3.4\n  [aea7be01] PrecompileTools v1.1.2\n⌃ [21216c6a] Preferences v1.3.0\n⌃ [3cdcf5f2] RecipesBase v1.3.3\n⌃ [01d81517] RecipesPipeline v0.6.11\n  [189a3867] Reexport v1.2.2\n  [05181044] RelocatableFolders v1.0.0\n  [ae029012] Requires v1.3.0\n⌃ [6c6a2e73] Scratch v1.1.1\n  [992d4aef] Showoff v1.0.3\n⌃ [2913bbd2] StatsBase v0.33.21\n  [1cfade01] UnicodeFun v0.4.1\n  [45397f5d] UnitfulLatexify v1.6.3\n  [41fe7b60] Unzip v0.2.0\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [f43a241f] Downloads v1.6.0\n  [37e2e46d] LinearAlgebra\n  [44cfe95a] Pkg v1.10.0\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [2f01184e] SparseArrays v1.10.0\n  [10745b16] Statistics v1.9.0\n  [cf7118a7] UUIDs\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\nWarning The project dependencies or compat requirements have changed since the manifest was last resolved. It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.\n\n(Plots) pkg> resolve\n  No Changes to `~/.julia/dev/Plots/Project.toml`\n    Updating `~/.julia/dev/Plots/Manifest.toml`\n  [5789e2e9] - FileIO v1.16.1\n  ```\n\nThe lack of `FileIO` in `st` is immediately confusing because no feedback is given even though it appears that `FileIO` was successfully added to the project (it was not). The subsequent `resolve` then removes `FileIO`, which is even more confusion if you are not aware that FileIO is in `weakdeps`.\n","[KristofferC]: The root cause of this is that something that is both a dep and a weak dep is ignored by Pkg. But this should probably error, yes. | [sjkelly]: Yes, I agree that the correction should at least be a warning or error.",2,false,1,1,0,0,0,0,0,0,0
3532,Contextual test dependencies,open,timholy,,feature request; precompile,,0,2023-07-02T09:49:41.0,2023-07-03T10:31:02.0,749,748,https://github.com/JuliaLang/Pkg.jl/issues/3532,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3532,"With the growing usage of extension packages, greed makes we wish for yet another feature: the ability to """"require"""" certain test-only dependencies contextually. An example may illustrate: imagine a small package (fast to install & precompile) that has an extension package for plotting using Makie (slow to install and precompile). I decide that testing the plotting as part of `runtests.jl` should depend on `ENV[""""CI""""]`, because I want local tests to be quick. It would be ideal if I didn't have to pay the cost of precompiling Makie locally, but only when CI is running.\n\nI would rate this as low priority, because precompiling Makie is *almost* a one-time cost. I say """"almost"""" because during `pkg>test` you still have to precompile the extension package and hence you pay Makie's load cost with every change to the package. But of course, we have TestEnv + Revise.\n\nFeel free to close as a wontfix.\n",,0,false,1,1,0,0,0,0,0,0,0
3527,Flag --preserve=all still allows upgrading a dependency of a package to a version that requires a higher Julia version,open,nantiamak,,,,1,2023-06-26T09:44:43.0,2023-06-28T09:11:42.0,755,753,https://github.com/JuliaLang/Pkg.jl/issues/3527,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3527,"Upgrading the [DuckDB package](https://juliahub.com/ui/Packages/DuckDB/89qwz/0.8.1) to version 0.8.1 using \n\n`add --preserve=all DuckDB@0.8.1 DuckDB_jll@0.8.1`\n\nresults in upgrading the package `CompilerSupportLibraries_jll` to version 1.0.1+0, too.\n\n```\nJulia Version 1.8.5\nCommit 17cfb8e65ea (2023-01-08 06:45 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin21.4.0)\n  CPU: 10 × Apple M1 Max\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, westmere)\n  Threads: 7 on 10 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = 7\n  JULIA_EDITOR = vscode \n```\n\nHowever, `CompilerSupportLibraries_jll` 1.0.1+0 seems to require Julia 1.9 ([https://github.com/JuliaBinaryWrappers/CompilerSupportLibraries_jll.jl/blob/CompilerSupportLibraries-v1.0.1%2B0/Project.toml#L13](https://github.com/JuliaBinaryWrappers/CompilerSupportLibraries_jll.jl/blob/CompilerSupportLibraries-v1.0.1%2B0/Project.toml#L13)).\n\nJulia was installed via the dmg file provided in [https://julialang.org/downloads/](https://julialang.org/downloads/).",[jakobnissen]: The problem can be further simplified: `CompilerSupportLibraries_jll` simply ignores the Julia compat\n```\n$ julia +1.8.5 --startup=no -q                                                                                                                                                                                                                                                                                              \n(@v1.8) pkg> add CompilerSupportLibraries_jll\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [56f22d72] + Artifacts\n  [8f399da3] + Libdl\n  [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0\n````,1,false,0,0,0,0,0,0,0,0,0
3517,Pkg.precompile: don't report interrupt-only warnings when interrupted,open,IanButterworth,,precompile,,0,2023-06-13T13:59:36.0,2023-06-13T13:59:47.0,768,768,https://github.com/JuliaLang/Pkg.jl/issues/3517,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3517,"I think it would make sense, when interrupting Pkg.precompile, to not show processes that only report an interrupt.\n\nFor instance in this case all but `StackViews` should be ignored\n\n```\n^C Interrupted: Exiting precompilation...\n\n  11 dependencies had warnings during precompilation:\n┌ GPUCompiler [61eb1bfa-7361-4325-ad38-22787b887f55]\n│  [48774] signal (2): Interrupt: 2\n│  in expression starting at /Users/ian/.julia/packages/GPUCompiler/NVLGB/src/GPUCompiler.jl:46\n└  \n┌ FFTW [7a1cc6ca-52ef-59f5-83cd-3a7055c09341]\n│  [48691] signal (2): Interrupt: 2\n│  in expression starting at none:0\n└  \n┌ Parsers [69de0a69-1ddd-5017-9359-2bf0b02dc9f0]\n│  [48698] signal (2): Interrupt: 2\n│  in expression starting at /Users/ian/.julia/packages/Parsers/47wo2/src/precompile.jl:3\n└  \n┌ StackViews [cae243ae-269e-4f55-b966-ac2d0dc13c15]\n│  fatal: error thrown and no exception handler available.\n│  InterruptException()\n└  \n┌ ForwardDiffStaticArraysExt [b74fd6d0-9da7-541f-a07d-1b6af30a262f]\n│  [48820] signal (2): Interrupt: 2\n│  in expression starting at /Users/ian/.julia/packages/ForwardDiff/vXysl/ext/ForwardDiffStaticArraysExt.jl:3\n└  \n```\n",,0,false,0,0,0,0,0,0,0,0,0
3512,Support multiple APIs and version numbers per package,open,LilithHafner,,feature request,,2,2023-06-08T22:38:45.0,2023-06-13T09:44:17.0,772,768,https://github.com/JuliaLang/Pkg.jl/issues/3512,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3512,"I want to depend on a package's internals and still safely benefit from automatic update propagation using SymVer. To do this, I want the ability to be able to define multiple APIs for a single package.\n\nLet's consider a case study. DataStructures.jl defines `DataStructures.MultiDict`, and many public functions to work with it including modification and queries. Now let's say I'm making a package and have an uncommon use case that warrants using `DataStructures.MultiDict`s but also requires a specialized high-performance implementation of an obscure operation that DataStructures.jl doesn't support. I read the implementation of `DataStructures.MultiDict` and write some self contained code that takes a `DataStructures.MultiDict`, and efficiently performs my operation by directly manipulating its internal fields. Now I have several choices: 1) add my code to the public API of DataStructures.jl 2) add the internal fields of DataStructures.MultiDict to the public API of DataStructures.jl 3) use the internals and declare a dependency on the exact version of DataStructures `""""=0.18.13""""` requiring me to manually green-light all updates to DataStructures.jl before users of my package can use them 4) use the internals and, declare permissive compat bounds such as `""""^0.18.13""""`, and hope for the best even though it would be totally valid for DataStructures.jl to change their internals and break my code in `0.18.14`.\n\nThere are cases when none of these are great options. I'd like to add yet another option: declare a dependency on `DataStructures.DictInternals`.\n\nIn implementation, packages may declare additional version numbers in their Project.toml, like so\n\n```\nname = """"DataStructures""""\nuuid = """"864edb3b-99cc-5e75-8d2d-829cb0a9cfe8""""\nversion = """"0.18.13""""\nDictInternals.version = """"3.0.9""""\n```\n\nAnd define the scope of """"DictInternals"""" in their documentation. In this example, let's say the API of `DictInternals` includes `DataStructures.MultiDict`, including all its fields and inner constructors, but does not include any other functions.\n\nOther packages can depend on these alternate version numbers in addition to or instead of the primary version number with\n\n```\n[deps]\nDataStructures = """"864edb3b-99cc-5e75-8d2d-829cb0a9cfe8""""\n\n[compat]\nDataStructures = """"0.18.13""""\nDataStructures.DictInternals = """"2.0.6, 3""""\n```\n\nNow, in writing my package, I declare a dependency on DataStructures with version `""""0.18.13""""` and also declare a dependency on DataStrucutres.DictInternals with a version `""""2.0.6, 3""""` (carrot specifiers are implicit).\n\nNow, if DataStructures.jl makes a non-breaking change that also doesn't change dictionary internals, they can release it as\n```\nversion = """"0.18.14""""\nDictInternals.version = """"3.0.10""""\n```\nIf they make some changes to dictionary internals that were not covered by their well-defined `DictInternals` API, then they can also release\n```\nversion = """"0.18.14""""\nDictInternals.version = """"3.0.10""""\n```\nBut if they remove a field or add, remove, or change any invariants covered by DictInternals (such as the interpretation of a `UInt8` metadata field), then that is a breaking change in DictInternals. For example, if they change from storing keys and values in separate arrays to storing them inline together, that would be breaking to DictInternals, even if it doesn't affect DataStructure.jl's public API. In this case, they would release:\n```\nversion = """"0.18.14""""\nDictInternals.version = """"4.0.0""""\n```\n\nIn the first two cases, Pkg would automatically mark my package as compatible with the new version of DataStructures.jl because there were no breaking changes. In the last case, Pkg would mark my package as incompatible but still mark everyone who doesn't depend on DictInternals's packages as compatible.","[dalum]: I quite like this idea. I think a more common use-case for a feature like this, would be to support relying on a subset of the public API that doesn't change during a breaking version bump, though. For example, if you only need `DataStructures.MultiDict`, you may declare dependencies like:\n```\n[compat]\nDataStructures = """">= 0.18.13""""\nDataStructures.MultiDict = """"3""""\n```\nallowing you to freely upgrade `DataStructures`, as long as `MultiDict` is left unchanged. In the bikeshed department, I would probably prefer a variation of something like:\n```\n[compat]\nDataStructures = { version = """">= 0.18.13"""", MultiDict = """"3"""" }\n```\nto make sure these are grouped together in the compat section. I also don't know if it's technically possible to register a package with a dot in the name, in which case `DataStructures.MultiDict` could be ambiguous? | [LilithHafner]: A couple notes,\n\nEverything that is possible with this is also possible to do by adding wrapper packages that re-export subsets of the wrapped package's public and/or private API and which specify an `=` compat with the wrapped package and get new releases each time the wrapped package releases a new version. That's a lot of plumbing, though, and to reduce undeclared dependence on internals, I think it is worth making this as easy as possible.\n\n> relying on a subset of the public API that doesn't change during a breaking version bump\n\nThat's an interesting use-case, thanks for bringing it up! I'd denote it `DataStructures.MultiDict = """"3""""` or `DataStructures = { MultiDict = """"3"""" }`, though. I don't think the `>=` compat specifier is necessary. Either you depend on something in DataStructures which is not covered by MultiDict so `>=` is too permissive and `^` is appropriate, or you don't depend on anything in `setdiff(DataStructures, DataStructures.MultiDict)` and the `"""">= 0.18.13""""` is an unnecessary restriction so long as `DataStructures.MultiDict` has been correctly versioned.\n\nSub-APIs may be added _and removed_ in non-breaking releases of the main package's API without issue. The resolver would assume that a package with a dependency on `DataStructures.DictInternals` is incompatible with a version of `DataStructures` that does not declare a version number for `DictInternals`.\n\n> I also don't know if it's technically possible to register a package with a dot in the name, in which case DataStructures.MultiDict could be ambiguous?\n\nI don't think this is possible.",2,false,0,0,0,0,0,0,0,0,0
3508,Store project hash for dev'd deps,open,jakobnissen,,,,2,2023-06-07T14:48:08.0,2023-06-12T03:33:36.0,774,769,https://github.com/JuliaLang/Pkg.jl/issues/3508,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3508,"Suppose I'm working on develop package A, which depends on package B. When working on A, I have dev'd B, such that I can make changes to B and see it reflected in A. Currently, this works.\n\nHowever, if I make changes to B's _project_, e.g. by adding or changing a dependency, then this is not automatically reflected in A (i.e, A does not automatically resolve). This has two problems:\n* It means the instantiated manifest of A is invalid, but this is not known to Pkg, and\n* The only way to solve this is to manually instantiate B, then manually instantiate A. If you are developing a chain of packages A -> B -> C -> D ..., these must all be manually re-resolved, in order. This is annoying\n\nThis could be solved by storing the project hash for all dev'd dependencies, and checking every dev'd dep recursively to see if the project has been modified.\n\nThis issue was brought up by Jonnie Diegelman on Slack","[jonniediegelman]: I think we might not even need the hash. We really just need the path. But I think more than anything, I'd like to see local dependencies be first-class. We kinda make the assumption that anything that is `dev`ed will eventually be `free`d, so the path info only exists in the Manifest. I'd like to be able to `add` a package by path and have the Project file store its path (the way Rust's `cargo` does it). It seems like it would be worth making a distinction between packages that we're `dev`ing from a repo and those that are truly local. | [xgdgsc]: And I find if I use a patched branch in package B, like https://github.com/xgdgsc/CatViews.jl#patch-1. When `dev B` in package A, it would install the CatViews in registry, not reading from my B manifest to use the patched branch ?",2,false,1,1,0,0,0,0,0,0,0
2764,Lazy artifact without unpacking (non-tarball),open,jonas-schulze,,,,8,2021-10-12T18:03:53.0,2023-06-09T13:46:53.0,1376,772,https://github.com/JuliaLang/Pkg.jl/issues/2764,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2764,"I would like to """"deliver"""" some `mat` data set that I need during package testing as an artifact. The data set happened to be hosted already, though as is and not as a `tar.gz`. IIRC `.mat` support compression on their own, so wrapping them in a `tar.gz` feels odd. \n\nHow do I declare a `lazy` artifact (containing only a single file) that doesn't need to be unpacked?\n\nIf that's not possible (yet), I would like to propose to add a new keyword `unpack` (default: `true` which matches the current behavior) to the `Artifacts.toml`.\n\nSomewhat related:\n* https://github.com/JuliaLang/Pkg.jl/issues/1467 (suggested to me that unpacking does not always happen)\n* https://github.com/JuliaLang/Pkg.jl/issues/1950 (would need the keyword as well)\n* https://discourse.julialang.org/t/creating-artifacts-toml-for-existing-tarball/33365","[DilumAluthge]: The DataDeps.jl package (https://github.com/oxinabox/DataDeps.jl) might be a good solution for your use case. | [KristofferC]: In theory we could look at the magic bytes to see if it is a gzipped file, otherwise, assume it is uncompressed..? | [StefanKarpinski]: Another layer of compression shouldn't really hurt though, and you can use `gzip -1` to minimize the effort. | [jonas-schulze]: Ref https://github.com/oxinabox/DataDeps.jl/issues/113 | [KristofferC]: > Another layer of compression shouldn't really hurt though\n\nBut then you need to rehost the files. | [simonbyrne]: Agreed, there are many dataset hosting providers which expect you to upload the file directly, rather than uploading a tarball wrapping a file. | [StefanKarpinski]: If we allow artifacts to be arbitrary container and non-container formats with arbitrary compression schemes, there's really a never-ending stream of features that would have to be added, which is not something I think it's acceptable to do with a feature like artifacts that's built into the package manager.\n\nConsider something apparently simple like allowing artifacts to be just a single file. This seems straightfoward enough: you just use the git blob hash of the file as its content address and put the file at the the artifact path instead of an extracted artifact directory like we do currently. So the path to this file will be something like `~/.julia/artifacts/a01fab9ad601903eaa0290a41c6a796525313337`. However, many use cases of files require that the file name have a correct extension and a reasonable file name like `data.mat`. The current answer to that is genuinely simple if not always convenient: the artifact is a directory containing the single file `data.mat`. If we're trying to support an artifact being a single file with this extension/file name requirement, we'd need to start adding features: in this case an option to say that the actual path to the artifact is inside the usual top-level location at `~/.julia/artifacts/a01fab9ad601903eaa0290a41c6a796525313337/data.mat`. But then the artifact isn't actually content-addressed anymore: you need to know the content hash *and* the path inside of the directory, and if two different artifact files referenced the same content address with a different hash, then they could extract the data to a different location. So even something simple like """"let an artifact be a single file"""" leads to a whole can of worms. The simplest option is just to require it to be a directory, which is what we've done.\n\nDifferent compression and container formats are more reasonable, imo, since they only complicate the model of _how to deliver an artifact_, rather than complicating the model of _what an artifact is_. The main issue with that is that Pkg needs to be able to extract other container formats. Julia is shipped with the dependencies required to decompress and extract tarballs, but we don't really want to add more dependencies to Julia for every format someone happens to want to use. But we could have a plugin system where a download stanza specifies a registered package/function for handling the content of the download stanza, and then lets the package acquire the artifact content however one wants.\n\nFor example, we could support downloading a single file something like this:\n```toml\n[data_mat]\ngit-tree-sha1 = """"83f7499f0e79ac39a1a34d3e6ac119f5389ee66d""""\n\n    [[data_mat.download]]\n    plugin = """"FileArtifacts""""\n    url = """"https://example.com/path/to/data.mat""""\n    sha256 = """"ab2332e1005836afb236bf8515adf1b0522b640a51c9b8a401d64e3f5fc4478c""""\n```\nWhat this would do is use the package called `FileArtifacts` (which must appear in the `Project.toml` file of the package where the `Artifacts.toml` file lives) to download the `data_mat` artifact. It would do the following:\n\n1. Download the URL `https://example.com/path/to/data.mat`\n2. Check that the SHA256 hash of the file is `ab23...4478c`\n3. Save the file as `data.mat` (derived from the URL) in an empty directory\n4. Compute the `git-tree-sha1` of the _directory_ (not the file) and make sure it's `83f7...e66d`\n5. Install the artifact directory at `~/.julia/artifacts/83f7...e66d`\n\nThe end result is that `data.mat` can be found at `~/.julia/artifacts/83f7...e66d/data.mat`. People could implement artifact downloaders for zip files, different compression formats, etc.\n\nThis is the way forward, but I'm not sure I really want to do this. Among other things, this would entail either not serving such artifacts through the package server system, or running arbitrary package code for artifact downloading in the package server system. Neither option is super appealing to me. We could maybe approve specific packages as """"blessed"""" downloaders that we allow running on the package servers. | [jonas-schulze]: > But then the artifact isn't actually content-addressed anymore: you need to know the content hash _and_ the path inside of the directory, [...]\n\nIsn't this exactly what is required now already from a user's perspective? In order to access anything from an artifact, the user has to `joinpath(artifact""""foo"""", """"data.mat"""")`. Here, `artifact""""foo""""` resolves to the content-addressed hash of the directory and `data.mat` is the object within the user is actually interested in.\n\n> [...] and if two different artifact files referenced the same content address with a different hash, then they could extract the data to a different location.\n\nI think I don't quite understand what you mean. If two artifact files (does this refer to """"descriptors"""", i.e. `artifact""""foo""""` and `artifact""""bar""""`?) refer to the same content, they will by design resolve to the same hash, won't they?\n\nThe considerations you described sound more like implementation details to me -- no offend. All I am asking for is an option to skip a certain part of the download/registration/creation process of an artifact, namely archive inflation. I am not questioning what an artifact is. An artifact remains a single file before and during download (a compressed or un-compressed tar-ball, or an arbitrary file) which becomes a content-addressed directory. This doesn't change at all. And from a user's perspective it doesn't change either. The user shouldn't need to care how the content-hash comes to be, because a user never gets in touch with it anyway. This is a detail hidden within `artifact""""foo""""`, as it should be.",8,false,0,0,0,0,0,0,0,0,0
3505,Test-only artifacts,open,simonbyrne,,test; artifacts,,0,2023-06-03T23:57:05.0,2023-06-03T23:57:05.0,777,777,https://github.com/JuliaLang/Pkg.jl/issues/3505,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3505,"I would like to have test-only artifacts: by that, I mean artifacts that are not aren't installed by a `Pkg.instantiate()`, but are by a `Pkg.test()`.\n\nI tried creating a `test/Artifacts.toml`: this works if the artifact has already been downloaded elsewhere, but fails otherwise with the error (on 1.9.0):\n```\nERROR: LoadError: Artifact """"test_artifact"""" was not found by looking in the paths:\n  ~/.julia/artifacts/4fda5e46a91c2a0cf12c9b46dad3a4189ebcfb37\n  /Applications/Julia-1.9.app/Contents/Resources/julia/local/share/julia/artifacts/4fda5e46a91c2a0cf12c9b46dad3a4189ebcfb37\n  /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/artifacts/4fda5e46a91c2a0cf12c9b46dad3a4189ebcfb37\nTry `using Pkg; Pkg.instantiate()` to re-install all missing resources if the artifact is part of a package or call `Pkg.ensure_artifact_installed` (https://pkgdocs.julialang.org/v1/api/#Pkg.Artifacts.ensure_artifact_installed) if not.\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] _artifact_str(__module__::Module, artifacts_toml::String, name::SubString{String}, path_tail::String, artifact_dict::Dict{String, Any}, hash::Base.SHA1, platform::Base.BinaryPlatforms.Platform, lazyartifacts::Any)\n   @ Artifacts /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Artifacts/src/Artifacts.jl:567\n [3] invokelatest(::Any, ::Any, ::Vararg{Any}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Base ./essentials.jl:816\n [4] invokelatest(::Any, ::Any, ::Vararg{Any})\n   @ Base ./essentials.jl:813\n [5] macro expansion\n   @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/Artifacts/src/Artifacts.jl:701 [inlined]\n [6] top-level scope\n   @ show.jl:1128\n [7] include(fname::String)\n   @ Base.MainInclude ./client.jl:478\n [8] top-level scope\n   @ none:6\nin expression starting at /Users/simon/src/TestProj.jl/test/runtests.jl:9\n```\n\nCalling `Pkg.instantiate()` from within the `test/runtests.jl` doesn't work.\n\nThis issue was also mentioned on discourse https://discourse.julialang.org/t/using-artifacts-for-test-data/46783/5?u=simonbyrne",,0,false,3,3,0,0,0,0,0,0,0
3030,Cannot dev private repos: libgit2 uses protocol phased out by Github today? (SHA-1),open,grahamas,,,,25,2022-03-15T17:20:05.0,2023-06-01T22:48:17.0,1222,779,https://github.com/JuliaLang/Pkg.jl/issues/3030,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3030,"Dev'ing my private repos is failing today, where it worked yesterday. `git pull` works fine. I'm on julia v1.6.2 Ubuntu and v1.6.5 Windows.\n\nAs the final phase in updating their SSH security protocols, today GitHub stopped accepting RSA keys with SHA-1.\n\nPer [GitHub]( https://github.blog/2021-09-01-improving-git-protocol-security-github/):\n```\nMarch 15, 2022 \t\n\nChanges made permanent.\n\nWe’ll permanently stop accepting DSA keys. RSA keys uploaded after the cut-off point above will work only with SHA-2 signatures (but again, RSA keys uploaded before this date will continue to work with SHA-1). The deprecated MACs, ciphers, and unencrypted Git protocol will be permanently disabled.\n```\nIt seems that libgit2 uses SHA-1, so I *think* it's libgit2's fault. At least, yesterday dev'ing worked, and today git pull still works. I'm a little confused because my RSA key was uploaded before today, but I can't argue with the error:\n```\nERROR: failed to clone from git@github.com:[PRIVATE_REPO], error: GitError(Code:EEOF, Class:SSH, ERROR: You're using an RSA key with SHA-1, which is no longer allowed. Please use a newer client or a different key type.\nPlease see https://github.blog/2021-09-01-improving-git-protocol-security-github/ for more information.\n```\nIn theory, you could use a new key type, but libgit2 only notices RSA or something weird like that (see https://github.com/JuliaLang/Pkg.jl/issues/911, I think).\n\nWhere does the recent PR https://github.com/JuliaLang/julia/pull/43250 stand julia release-wise? Is there likely a workaround for older julia versions? (I'm on a cluster and beholden to admins for updating). \n\nRelated to https://github.com/JuliaLang/Pkg.jl/issues/2679\n","[KristofferC]: Don't you just have to generate a new key as described in https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent? | [grahamas]: > Don't you just have to generate a new key as described in https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent?\n\nNo, the issue is not with the RSA key itself, but with the signing algorithm employed by libgit2. My RSA key works fine through command line `git`.\n\nJust to double check, I followed the instructions in the link to generate both an RSA and an ED25519. The RSA failed as above, while the ED25519 could not be found by libgit2 (as in previous issues) | [KristofferC]: From https://github.blog/2021-09-01-improving-git-protocol-security-github/\n\n> If you’re using libgit2 or another piece of code using libssh2, we recommend you use libssh2 1.9.0 or newer and an ECDSA key, since it does not yet support RSA with SHA-2.\n\nJulia 1.6 uses libssh 1.9.1 so it should work with ECDSA? | [grahamas]: I hadn't tried ECDSA before (I did now), but it runs into the same problem as using ED25519: libgit2 fails to automatically detect the private key file, prompts for the location, and then continues to prompt for the location twice more before erroring out due to """"maximum number of prompts reached.""""\n\nFrom all the issues I've read, libgit2 in Julia only can handle RSA keys generated with PEM. (https://github.com/JuliaLang/Pkg.jl/issues/911#issuecomment-640399940; https://github.com/JuliaLang/Pkg.jl/issues/1516#issuecomment-654581794) | [KristofferC]: And you really need to use ssh, you cannot use https for the git remote? | [DilumAluthge]: I ran into this recently, and I was able to fix it simply by doing `export JULIA_PKG_USE_CLI_GIT=true`. Can you try and seee if that works for you? | [KristofferC]: That requires Julia 1.7. | [joaquimg]: > And you really need to use ssh, you cannot use https for the git remote?\n\nhttps is very painful as it requires user and password before every clone/update of private repos | [KristofferC]: So I just tried `dev`ing a private package on GitHub using Julia 1.6 with https and it didn't ask for any user/password and it worked fine so I guess that means it is cached? | [joaquimg]: Two issues\n - with 2FA I needed tokens instead of passwords\nhttps://docs.github.com/pt/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\n - my user/token don't get memorized so it is painful... I am on windows (don't if this is the reason) | [grahamas]: Apparently you need to run `git config credential.helper store` and then it will store your credentials in plain text next time you enter them. I really don't like this solution because of the security concerns, but there is a perfectly fine solution in v1.7 (`export JULIA_PKG_USE_CLI_GIT=true`), so I'm ok considering this workaround one of those unfortunate realities of using an older version, even if it is LTS.\n\nSo, to recap, the workaround is either:\n1) Upgrade to v1.7+ and use `export JULIA_PKG_USE_CLI_GIT=true`, or\n2) Switch all private repos and registries to HTTPS, and use `git config credential.helper store`\n\nI'll close this now, but if there's *any way* to get that env flag into the next release of v1.6, that would be *way* better. I would argue it's a bugfix. | [joaquimg]: Backporting the pkg manager would be amazing in a julia 1.6 patch, since it is LTS.\n | [joaquimg]: @grahamas I could do option 2 in windows, but not in linux.\nWhich system did you use? | [grahamas]: Oh no, I use both but I only tested it on Windows; my Linux system is the one that I can't control the Julia version on, too :/ \n\nI'll poke around a bit more and report back here if I find anything. If we can't find a way to cache username and password on Linux, I'll re-open, because re-entering tokens/passwords for every pull or update is unfeasible. | [joaquimg]: It worked on linux by fixing my .giconfig that was pointing to a netrc file. Now it is back to default and points to .git-credentials.\nFor completeness, you can modify directly the .git-credentials file adding something like the line:\nhttps://MYUSER:MYTOKEN@github.com | [sairus7]: Lost several hours with this... But found a surspising third solution, as they wrote in a blog-post:\n\n> Keys with a valid_after date before the deadline (November 2, 2021) may continue to use SHA-1 signatures for the time being.\n\nSo, look for an old ssh key (maybe on some other machine?), that was generated before November 2021 (If you're lucky enough).\n \nI think github wanted to make a smoooth transition, which instead resulted in a kind of a time bomb, when keys generated after November 2021 - suddenly stopped working at March 2022. | [grahamas]: I strongly suspect that there was a deprecation warning that libgit2 didn't propagate... | [GunnarFarneback]: For those coming here later looking for information:\n> From https://github.blog/2021-09-01-improving-git-protocol-security-github/\n> \n>     If you’re using libgit2 or another piece of code using libssh2, we recommend you use libssh2 1.9.0 or newer and an ECDSA key, since it does not yet support RSA with SHA-2.\n> \n> Julia 1.6 uses libssh 1.9.1 so it should work with ECDSA?\n\nThe ECDSA support is conditional on using `openssl` as crypto backend in `libssh2`. Julia is built with `mbedtls` as crypto backend. To find out what key types are supported for different crypto backends, search for `LIBSSH2_` in the libssh2 sources (for the appropriate release). Specifically in the files `src/libgcrypt.h`, `src/mbedtls.h`, `src/openssl.h`, `src/wincng.h`.\n\nAlso see https://discourse.julialang.org/t/local-registry-rsa-key-problem/78188/4 for more information. | [KristofferC]: Also, I just want to say that we backported the `JULIA_PKG_USE_CLI_GIT` to the next LTS (1.6.6) which should be out in a few days.\n | [KristofferC]: I think we can keep this open for some extra visibility. | [staticfloat]: Looking into this a bit, without any changes to Julia, you can fix the issue by using a different SSH key: you can just generate a new ECDSA key (e.g. those generated by `ssh-keygen -t ecdsa`) instead of an RSA key and use that instead.  Julia v1.8+ contains support to natively read ECDSA keys.  If you're using `ssh-agent` to store your keys, the agent can actually help out and that works all the way back to v1.4 (that's just the earliest version I tested, it may work even farther back).\n\nTo get RSA keys working again, we need libssh2 to implement SHA-256 signing of RSA keys with MbedTLS as the backing crypto library.  I [opened an issue](https://github.com/libssh2/libssh2/issues/687) to ask them to fix it for us, but if they dawdle, it's likely something someone with some C experience can hack together in an afternoon.  It's basically hooking up the pipes from libssh2 to MbedTLS, and ensuring that you don't break SHA-1 while you're at it.\n | [GunnarFarneback]: > Julia v1.8+ contains support to natively read ECDSA keys.\n\nThat's great. Where is it implemented?\n | [staticfloat]: It's [inside of libssh2](https://www.libssh2.org/changes.html) ever since version 1.10.0; it's not in Julia code, it's just the native libgit2->libssh2->mbedtls stack. | [GunnarFarneback]: I guess I was confused when I thought the mbedtls support for ECDSA keys entered libssh2 after the 1.10.0 release and only was available in master. Now it would be nice if the ECDSA key could be found automatically without needing an `SSH_KEY_PATH` hint. | [sairus7]: So, since https://github.com/JuliaLang/julia/pull/44767 is merged, why do I keep running into this and manually provide id_ecdsa path?\n```julia\n    Updating registry at `C:\Users\sairu\.julia\registries\JuliaRegistry`\n    Updating git-repo `git@github.com:MyPrivateOrg/JuliaRegistry.git`\nPrivate key location for 'git@github.com' [C:\Users\sairu\.ssh\id_rsa]: C:\Users\sairu\.ssh\id_ecdsa\n    Updating registry at `C:\Users\sairu\.julia\registries\General.toml`\n```",25,false,4,0,0,0,0,0,4,0,0
3498,"Pkg seems to read dependencies from non-sysimage stdlibs from the stdlib project, even if loaded externally",open,KristofferC,,,,1,2023-05-26T20:06:15.0,2023-05-29T13:13:25.0,785,783,https://github.com/JuliaLang/Pkg.jl/issues/3498,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3498,"Causes things like\n\n```\nERROR: LoadError: ArgumentError: Package SparseArrays does not have SuiteSparse_jll in its dependencies:\n- You may have a partially installed environment. Try `Pkg.instantiate()`\n  to ensure all packages in the environment are installed.\n- Or, if you have SparseArrays checked out for development and have\n  added SuiteSparse_jll as a dependency but haven't updated your primary\n  environment's manifest file, try `Pkg.resolve()`.\n- Otherwise you may need to report an issue with SparseArrays\n```\n\nwhen trying to load SparseArrays master in another package.",[KristofferC]: Also this:\n\n```\n(@v1.10) pkg> activate --temp\n  Activating new project at `/tmp/jl_2LoQSO`\n\n(jl_2LoQSO) pkg> add https://github.com/JuliaSparse/SparseArrays.jl/tree/dk/mul!\n    Updating git-repo `https://github.com/JuliaSparse/SparseArrays.jl`\n   Resolving package versions...\n    Updating `/tmp/jl_2LoQSO/Project.toml`\n  [2f01184e] + SparseArrays v1.10.0 `https://github.com/JuliaSparse/SparseArrays.jl#dk/mul!`\n    Updating `/tmp/jl_2LoQSO/Manifest.toml`\n  [0dad84c5] + ArgTools v1.1.1\n\nIn [3]: using SparseArrays\nERROR: ArgumentError: Package SparseArrays [2f01184e-e22b-5df5-ae63-d93ebab69eaf] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n ```,1,false,0,0,0,0,0,0,0,0,0
3499,Improving the docs for extensions,open,gdalle,,,,3,2023-05-27T10:56:26.0,2023-05-27T11:05:26.0,785,785,https://github.com/JuliaLang/Pkg.jl/issues/3499,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3499,"There have been several discussions on Slack and Discourse about extensions.\nA major focal point seems to be that we cannot / should not define structs in extensions, only extend existing methods.\nLet's try and formulate a clarification for the docs here, before opening a PR?","[gdalle]: Here's where it could go: https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions) | [gdalle]: Some of these conversations:\n- https://discourse.julialang.org/t/are-extension-packages-importable/92527 | [Seelengrab]: Here are some more (perhaps not so obvious?) questions a user may have, that it ought to be good to answer:\n\n * Pkg extensions have me define a module. Can I define & use a struct/function defined exclusively in the extension in my main package?\n * Can I `@eval`/`eval` into my main package from an extension?\n * Can I precompile an extension?\n * How can I query whether an extension is loaded in my main package?\n * Should I query an extension for being loaded? What consequences does that have for precompilation of my package?\n * What happens when I have two mutually exclusive extensions that shouldn't be loaded at the same time? How can I handle this?\n * How can I teach my users about additional functionality being available when a given package is loaded?",3,false,4,4,0,0,0,0,0,0,0
3497,Feature request: `activate --cd Foo` to activate Foo and change working directory to Foo,open,IanButterworth,,feature request,,0,2023-05-25T20:00:26.0,2023-05-25T20:00:26.0,786,786,https://github.com/JuliaLang/Pkg.jl/issues/3497,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3497,I think it would be nice to be able to both activate and move to a given project in one command.\n\nPerhaps\n\n```\npkg> activate --cd Foo\n```\n,,0,false,0,0,0,0,0,0,0,0,0
3477,"`Pkg.project()` returns `nothing` for name, uuid, version for package added via Pkg",open,NHDaly,,bug,,0,2023-05-15T16:26:59.0,2023-05-25T16:27:37.0,796,786,https://github.com/JuliaLang/Pkg.jl/issues/3477,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3477,"This question regards the `Pkg.project()` feature, originally added in https://github.com/JuliaLang/Pkg.jl/issues/385.\n\nThe package in question here is RAI.jl, which attempts to set its _user agent_ for HTTP requests using the project version:\nhttps://github.com/RelationalAI/rai-sdk-julia/blob/93b18be6d7d91385a0854330b5d3bd0fe28f4653/src/RAI.jl#L25-L26\n\nWhen I clone this repo, and open it as a project via `julia --proj`, it works correctly, giving:\n```julia\njulia> using RAI\n\njulia> RAI.PROJECT_VERSION\nv""""0.2.4""""\n\njulia> RAI._user_agent()\n""""rai-sdk-julia/0.2.4""""\n```\nHowever, if I _add the package_ to another project, or to my top-level environment, it gets `nothing`:\n```julia\njulia> using Pkg\n\njulia> Pkg.add(""""RAI"""")\n\njulia> using RAI\n\njulia> RAI._user_agent()\n""""rai-sdk-julia/nothing""""\n\njulia> RAI.PROJECT_VERSION\n```\nYou can see that this is returning nothing:\n```julia\njulia> @eval RAI Pkg.project()\nPkg.API.ProjectInfo(nothing, nothing, nothing, false, Dict{String, Base.UUID}(""""PProf"""" => UUID(""""e4faabce-9ead-11e9-39d9-4379958e3056""""), """"MethodAnalysis"""" => UUID(""""85b6ec6f-f7df-4429-9514-a64bcd9ee824""""), """"Memoize"""" => UUID(""""c03570c3-d221-55d1-a50c-7939bbd78826""""), """"Revise"""" => UUID(""""295af30f-e4ad-537b-8983-00126c2a3abe""""), """"BenchmarkTo\nols"""" => UUID(""""6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf""""), """"Cthulhu"""" => UUID(""""f68482b8-f384-11e8-15f7-abe071a5a75f""""), """"RAI"""" => UUID(""""9c30249a-7e08-11ec-0e99-a323e937e79f""""), """"LookingGlass"""" => UUID(""""1fcbbee2-b350-4a01-aad8-439064dba09e""""), """"CloudStore"""" => UUID(""""3365d9ee-d53b-4a56-812d-5344d5b716d7"""")), """"/Users/nathandaly/.julia/environme\nnts/v1.8/Project.toml"""")\n\njulia> @eval RAI Pkg.project().version\n\njulia>\n```\n\nI see in https://github.com/JuliaLang/Pkg.jl/issues/3267 that this is an experimental feature.\n\nShould we not be using it like this?\n\nThank you!\n",,0,false,0,0,0,0,0,0,0,0,0
3496,]up Foo downloads registry even if Foo is not registered,open,oxinabox,,,,2,2023-05-25T06:13:59.0,2023-05-25T06:29:40.0,787,787,https://github.com/JuliaLang/Pkg.jl/issues/3496,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3496,"I have an unregistered dependency `Foo` that i installed via `] add git@github.com/user/Foo.jl.git`\nthen i can get the latest version version via `] up Foo`, which will pull down the latest version of Foo.jl from git.\nHowever, it will also pull a registry update down.\nWhich seems like it shouldn't be required since this package is unregistered \n\nI am not sure if this is avoidable we might need it in order to check if it has since been registered?","[fredrikekre]: > I am not sure if this is avoidable we might need it in order to check if it has since been registered?\n\nIt will never automatically switch to a registered version anyway, but it might be needed for deps of `Foo`. | [oxinabox]: Possibly we could defer the call to update the registry til we found a registered dep that we were *required* to update? Since if doing `up Foo` it will only update the deps of `Foo` if they hold it back from getting to the latest version, that is likely quite rare",2,false,0,0,0,0,0,0,0,0,0
3494,Сompat does not include DEV version,open,gryumov,,,,4,2023-05-24T06:49:33.0,2023-05-25T06:10:35.0,788,787,https://github.com/JuliaLang/Pkg.jl/issues/3494,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3494,"Сompat does not include DEV version\n\n```toml\nname = """"Bar""""\nuuid = """"26c37dcc-07de-4b08-afb5-6df828475b25""""\nauthors = [""""foo <foo@foo.com>""""]\nversion = """"0.1.0-dev""""\n\n[deps]\nDates = """"ade2ca70-3891-5945-98fb-dc099432e06a""""\nFoo = """"01ba1978-7efe-11ed-2893-03bfe3abf75a""""\n\n[compat]\nFoo = """"=0.5.0-dev""""\njulia = """"1.8""""\n```\n\n```julia\ncaused by: invalid version specifier: """"0.5.0-dev""""\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n```\n\nMoreover, if you specify without a DEV, then he will take this patch, what seems to be unsafe behavior\n\n```\n[compat]\nFoo = """"=0.5.0""""\njulia = """"1.8""""\n\nStatus `~/.julia/environments/v1.8/Project.toml`\n  [26c37dcc] Foo =v0.5.0-dev\n```","[fredrikekre]: Do you have a reproducible example with some (public) package? I don't quite understand what you are doing. | [gryumov]: @fredrikekre I don't have a public example, what I'm doing is:\n\n1. I register package Foo with version 0.5.0-dev from the release branch (not master) in my local registries\n2. Then I connect package Bar with version 0.5.0-dev to package Foo\n\nTry adding this version [JSONWebTokens@1.1.2-dev](https://github.com/felipenoris/JSONWebTokens.jl/blob/404fe6039aa7e9975cf116e4fbfdbf6f069cf7d2/Project.toml) to your project, and you will see an error\n\n```toml\n[compat]\nJSONWebTokens = """"1.1.2-dev""""\njulia = """"1.8""""\n```\n | [KristofferC]: Pkg does not have any special support for pre-releases or build metadata. | [oxinabox]: Not supporting this is basically a feature.\nThe compat section of Project.toml will ignore pre-release info in things you have locally `]dev`ed's Project.toml's version fields\nwhich means you can locally test that your package works with your downstream without cutting a release.\n\nBut you can't explictly depend on them to have that pulled from a registry, since at that point it's not a pre-release it's just a release.\nThe General registry has a CI check to make sure you aren't registering anything with a prerelease tag still on it.",4,false,0,0,0,0,0,0,0,0,0
3483,`force` keyword for Pkg.precompile,open,mkitti,,precompile,,1,2023-05-19T22:18:31.0,2023-05-22T18:15:04.0,792,789,https://github.com/JuliaLang/Pkg.jl/issues/3483,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3483,"Is there a way to force precompilation of a package even though it may have already been cached?\n\nIn a discussion regarding PrecompileTools.jl, I was suggesting that we may want to integrate some error handling there. If one simply catches an error during precompilation rather than letting precompilation fail completely, is there a way for one to resolve the error and then force precompilation.\n\nSome precompilaton workflows may involve disk or network activity. However, there may be transient issues with the disk (it's full) or network activity (no Internet access). If these external issues could be resolved, is there a way to redo precompilation of a package?\n\nI'm aware of two ways:\n1. Wipe out the files in ~/.julia/compiled\n2. Touch the files of a deved package\n\nShould we add a `force` keyword for `Pkg.precompile` to ignore previously cached files?",[mkitti]: I just learned of a new way. `Base.compilecache(Base.identify_package(package_name::String))`,1,false,0,0,0,0,0,0,0,0,0
3482,Remove stacktrace pointing to Pkg when a Pkg.test fails,open,KristofferC,,,,0,2023-05-17T12:08:37.0,2023-05-17T12:08:37.0,795,795,https://github.com/JuliaLang/Pkg.jl/issues/3482,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3482,"```\nERROR: LoadError: Package Tracy errored during testing\nStacktrace:\n [1] pkgerror(msg::String)\n   @ Pkg.Types C:\hostedtoolcache\windows\julia\1.9.0\x64\share\julia\stdlib\v1.9\Pkg\src\Types.jl:69\n [2] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool)\n   @ Pkg.Operations C:\hostedtoolcache\windows\julia\1.9.0\x64\share\julia\stdlib\v1.9\Pkg\src\Operations.jl:2012\n [3] test\n   @ C:\hostedtoolcache\windows\julia\1.9.0\x64\share\julia\stdlib\v1.9\Pkg\src\Operations.jl:1893 [inlined]\n [4] test(ctx::Pkg.Types.Context, pkgs::Vec\n...\n```\n\nThere is no need to print this backtrace, even on CI.",,0,false,1,1,0,0,0,0,0,0,0
3472,`Pkg.activate` doesn't support extensions,open,Tokazama,,,,0,2023-05-13T08:37:16.0,2023-05-13T08:37:16.0,799,799,https://github.com/JuliaLang/Pkg.jl/issues/3472,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3472,"On Julia v1.9.0 I've found that package extensions don't work.\n\n```julia\n\njulia> Pkg.activate(""""TestPkg"""")\n  Activating project at `~/projects/TestPkg`\n\njulia> using TestPkg\n\njulia> Base.get_extension(TestPkg, :TestPkgStaticArraysExt)\n\njulia> using StaticArrays\n\njulia> Base.get_extension(TestPkg, :TestPkgStaticArraysExt)\n\n```\n\nbut it works with `Pkg.develop`\n\n```julia\n\njulia> Pkg.develop(path=""""TestPkg"""")\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [35d55b0c] + TestPkg v0.1.0 `../../../projects/TestPkg`\n    Updating `~/.julia/environments/v1.9/Manifest.toml`\n  [35d55b0c] + TestPkg v0.1.0 `../../../projects/TestPkg`\n\njulia> using TestPkg\n\njulia> Base.get_extension(TestPkg, :TestPkgStaticArraysExt)\n\njulia> using StaticArrays\n\njulia> Base.get_extension(TestPkg, :TestPkgStaticArraysExt)\nTestPkgStaticArraysExt\n\n```\n\n",,0,false,0,0,0,0,0,0,0,0,0
3471,Clarify `up` documentation,open,jariji,,documentation,,3,2023-05-12T20:56:54.0,2023-05-12T21:15:52.0,799,799,https://github.com/JuliaLang/Pkg.jl/issues/3471,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3471,"`] help` says\n\n```\nregistry update, up: update package registries\n```\n\nso I expect `up` to update package registries but not update packages, but apparently it actually does update packages. \n\nI didn't want to update packages and was surprised that happened.","[IanButterworth]: ```\n  update, up: update packages in manifest\n\n  registry add: add package registries\n\n  registry remove, rm: remove package registries\n\n  registry status, st: information about installed registries\n\n  registry update, up: update package registries\n```\n\nPerhaps it could be clearer, but its showing that `registry update` or `registry up` are the options. As opposed to `update` and `up` | [jariji]: I see what you mean. That's sometimes represented as \n\n```\nregistry ( update | up )\n```\n\nbut I guess it's a style question. | [IanButterworth]: Seems reasonable to me. A PR would be good",3,false,0,0,0,0,0,0,0,0,0
3463,Registries with the same name in non-primary depots not being reported by Pkg.Registry.status(),open,mkitti,,bug; registries,,3,2023-05-09T00:56:52.0,2023-05-11T18:28:19.0,803,800,https://github.com/JuliaLang/Pkg.jl/issues/3463,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3463,"From a Slack conversation, https://julialang.slack.com/archives/C6A044SQH/p1683583230799379, a user accidentally had a registry installed at the system level which was providing out-of-date compat information to packages that were retrocapped for compat with OpenSSL_jll. The out of date General registries allowed the installation of incompatible with packages FFMPEG_jll v4.4.2+2 and OpenSSL_jll v3.0.8+0.\n\nAmong many issues was that `] registry status` and `Pkg.Registry.status()` did not report the existence of these out of date registries deeper within the depot stack.","[david-macmahon]: I was the unlucky user here.  @mkitti summed it up pretty well.  Prior to the retrocapping of OpenSSL_jll, I had installed some packages in a system-wide (shared) depot directory, not realizing that this also added General registry files `General.toml` and `General.tar.gz` to this system-wide depot directory.  These files seemed to interact with the files of the same name (and UUID), but different version, in ways that were not at all obvious.  The end result was that the version caps on OpenSSL_jll were not recognized and I got the newer/unwanted OpenSSL_jll v3.0.8+0 when adding `FFMPEG_jll` to a temporary environment.  When I renamed my `~/.julia` directory and added `FFMPEG_jll` to a temporary environment, I got an older than expected version of `OpenSSL_jll` (v1.1.19+0 rather than v1.1.20+0).  Removing the old General files from the system-wide depot directory fixed the problem (even after restoring my original `~/.julia` directory).\n\nIt would be nice if `]registry status` and `Pkg.Registry.status()` would give some sort of indication that there are multiple-but-different copies of a registry (General in this case) on DEPOT_PATH. | [anandijain]: not sure what happened, but im hitting this too. makes Plots unable to precompile for me\n\nhttps://github.com/JuliaPlots/Plots.jl/issues/4727#issuecomment-1539026583 | [david-macmahon]: As mentioned [here](https://discourse.julialang.org/t/openssl-v3-support-released/97710/5), a useful diagnostic is:\n```julia\njulia> for path in joinpath.(DEPOT_PATH, """"registries"""")\n           if isdir(path)\n               println.(joinpath.(path, readdir(path)))\n           end\n       end\n```\nOnly a single `General.tar.gz` and `General.toml` should be present.  If that's the case for you, then your problem is due to something other than having multiple General registries.",3,false,0,0,0,0,0,0,0,0,0
2221,idea: make Pkg.precompile happen when exiting Pkg REPL,open,vtjnash,,feature request; precompile,,6,2020-11-20T20:04:12.0,2023-05-07T01:17:49.0,1702,805,https://github.com/JuliaLang/Pkg.jl/issues/2221,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2221,"I'm not sure I prefer that the mode is sticky, but since it is, it'd be really nice to be able to queue a sequence of operations, and have them all applied when I switch back to the main REPL. (ignore the version number in the prompt, I'm on master, but I like the name v1.1)\n\nFor example:\n```\njulia> ]\n\n(@v1.1) pkg> up\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n    Updating git-repo `https://github.com/chriselrod/VectorizationBase.jl.git`\n   Installed FastGaussQuadrature ─ v0.4.4\n   Installed StatsFuns ─────────── v0.9.6\n   Installed DualNumbers ───────── v0.6.3\n   Installed DiffRules ─────────── v1.0.2\n   Installed Coverage ──────────── v1.2.0\n   Installed NaNMath ───────────── v0.3.5\n   Installed LoweredCodeUtils ──── v1.2.6\n   Installed Requires ──────────── v1.1.1\n   Installed DoubleFloats ──────── v1.1.15\n   Installed Revise ────────────── v3.1.9\n   Installed TimeZones ─────────── v1.5.1\n   Installed DSP ───────────────── v0.6.9\n   Installed Documenter ────────── v0.25.4\nUpdating `~/.julia/environments/v1.1/Project.toml`\n  [a2441757] ↑ Coverage v1.1.1 ⇒ v1.2.0\n  [e30172f5] ↑ Documenter v0.25.3 ⇒ v0.25.4\n  [fa6b7ba4] ↑ DualNumbers v0.6.2 ⇒ v0.6.3\n  [295af30f] ↑ Revise v3.1.7 ⇒ v3.1.9\nUpdating `~/.julia/environments/v1.1/Manifest.toml`\n  [082447d4] + ChainRules v0.6.5\n  [d360d2e6] ↓ ChainRulesCore v0.9.17 ⇒ v0.8.1\n  [a2441757] ↑ Coverage v1.1.1 ⇒ v1.2.0\n  [717857b8] ↑ DSP v0.6.8 ⇒ v0.6.9\n  [b552c78f] ↑ DiffRules v1.0.1 ⇒ v1.0.2\n  [e30172f5] ↑ Documenter v0.25.3 ⇒ v0.25.4\n  [497a8b3b] ↑ DoubleFloats v1.1.13 ⇒ v1.1.15\n  [fa6b7ba4] ↑ DualNumbers v0.6.2 ⇒ v0.6.3\n  [442a2c76] ↑ FastGaussQuadrature v0.4.3 ⇒ v0.4.4\n  [7869d1d1] ↑ IRTools v0.3.3 ⇒ v0.4.1\n  [6f1432cf] ↑ LoweredCodeUtils v1.2.5 ⇒ v1.2.6\n  [77ba4419] ↑ NaNMath v0.3.4 ⇒ v0.3.5\n  [ae029012] ↑ Requires v1.0.3 ⇒ v1.1.1\n  [295af30f] ↑ Revise v3.1.7 ⇒ v3.1.9\n  [4c63d2b9] ↑ StatsFuns v0.9.5 ⇒ v0.9.6\n  [f269a46b] ↑ TimeZones v1.5.0 ⇒ v1.5.1\n  [e88e6eb3] ↑ Zygote v0.4.8 ⇒ v0.4.22\n    Building TimeZones → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/69f312cdb1b3145761d4e5866034efde4608735d/build.log`\n\n(@v1.1) pkg> up\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n    Updating git-repo `https://github.com/chriselrod/VectorizationBase.jl.git`\nNo Changes to `~/.julia/environments/v1.1/Project.toml`\nNo Changes to `~/.julia/environments/v1.1/Manifest.toml`\n\n(@v1.1) pkg> dev RBNF\n     Cloning git-repo `https://github.com/thautwarm/RBNF.jl.git`\n   Resolving package versions...\nUpdating `~/.julia/environments/v1.1/Project.toml`\n  [83ef0002] ~ RBNF v0.2.2 ⇒ v0.2.2 `~/.julia/dev/RBNF`\nUpdating `~/.julia/environments/v1.1/Manifest.toml`\n  [83ef0002] ~ RBNF v0.2.2 ⇒ v0.2.2 `~/.julia/dev/RBNF`\n\n(@v1.1) pkg> ^H\nPrecompiling project...\n  Progress [=>                                       ]  1/49\n  ◐ IRTools\n  ◐ StaticLint\n  ◐ ChainRules\n  ◐ Documenter\n  ◐ RBNF\n  ◐ DiffEqJump\n  ◐ Revise\n  ◐ PlotUtils\n  ◐ DualNumbers\n  ◐ BugReporting\n  ◐ Tracker\n  ◐ TransformVariables\n  ◐ NLPModels\n  ◐ LineSearches\n  ◐ MCMCChains\n  ◐ DiffEqNoiseProcess\n  ◐ Bijectors\n  ◐ KernelDensity\n  ◐ HypothesisTests\n  ◐ AdvancedMH\n  ◐ EllipticalSliceSampling\n  ◐ DSP\n  ◐ DoubleFloats\n^C Interrupted: Exiting precompilation...\n\njulia> \n```","[KristofferC]: It will already have precompiled everything by then? Or do you mean when you have turned off auto precompilation. | [vtjnash]: I mean instead of. Otherwise simple workflows like above can end up recompiling several times, and I've got hundreds of packages installed, so it leads to several minute delays between steps (that I end up skipping with ^C). | [IanButterworth]: I do think there's an elegance to this, lumping everything together does seem beneficial\n\nBut on the other hand it seems like it could be a little jarring from a UX perspective that exiting Pkg REPL would become _complicated and slow_ whereas currently its simple and fast. Feelings of being trapped in Pkg REPL?\n\nOf course this can be almost achieved with turning auto-precomp off, and just writing `pkg> precompile` before exiting. (Maybe there should be a short form too?? `pkg> pc`?)\n\nOr perhaps if the user knows they want to do a series of things in Pkg REPL we could support concatenation of pkg commands?\n```\npkg> up\n     add Foo\n     dev Bar\n     build Bar\n... # do all the stuff\nPrecompiling...\n```\nBut that could get tedious when errors occur. | [IanButterworth]: One proposal over in https://github.com/JuliaLang/Pkg.jl/pull/2248 | [vtjnash]: Is this still possible? I see the referenced PR got rejected. It is very annoying to have to wait a minute between consecutive package operations. | [IanButterworth]: I often think about this too. I don't really see #2248 as being rejected, just postponed. Perhaps I shouldn't have closed it.\nStefan's suggestion in there to make it customizable seems like a good way to go.",6,false,3,3,0,0,0,0,0,0,0
3458,Disallow certain Pkg operations during precompilation,open,vchuravy,,precompile,,0,2023-05-04T22:23:59.0,2023-05-04T23:24:01.0,807,807,https://github.com/JuliaLang/Pkg.jl/issues/3458,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3458,"` PDFIO@0.1.10 ` caused a fun hang/issue where the precompilation of the package, caused precompilation, and voila we had a fork-bomb. This can still happen on current Julia versions.\n\nThis is obviously bad user code and was fixed in https://github.com/sambitdash/PDFIO.jl/commit/57e2c068e009c163c119f39b28a22787cd78b85f\n\nbut we should guard in Pkg.jl and when we are currently running precompilation either error/or decline to auto-precompile.\n",,0,false,3,3,0,0,0,0,0,0,0
3315,Auto precompilation should maybe only try to precompile packages that changed from an operation,open,KristofferC,,precompile,,4,2023-01-15T21:10:21.0,2023-05-03T19:59:35.0,916,808,https://github.com/JuliaLang/Pkg.jl/issues/3315,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3315,"Imo, it is kind of annoying when you add a small package and the auto precompilation starts to re-precompile Plots or something. I think that it would be a better experience to only precompile packages that are related to the change in the environment from a Pkg operation.","[IanButterworth]: If it does that, then you risk hitting slow precompilation during load if Plots was affected somehow by the action. \n\nOf course load precompilation could hook into Pkg.precompile and there's a popular issue open for that. | [KristofferC]: > If it does that, then you risk hitting slow precompilation during load if Plots was affected somehow by the action.\n\nWell as a first step we could only exclude packages from getting precompiled if their dependency graph is completely disjoint from the changes in the pkg operation. | [IanButterworth]: I worry a little that this would be beneficial to julia language developers who have everything invalidated frequently, and detrimental to others who stick to  infrequent releases where they benefit from autoprecomp catching everything | [IanButterworth]: Or perhaps, if autoprecomp did what's proposed AND julia had a mode that did something like\n```\n% julia\n   Info: This appears to be the first time this julia patch version has been used. \n         Your default environment will be precompiled\nPrecompiling project...\n  20 dependencies successfully precompiled in 7 seconds. \n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.x.x\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n```\nthen it would be a net gain",4,false,1,1,0,0,0,0,0,0,0
2393,Dependency confusion between internal registries and General,open,Seelengrab,,registries; security,,50,2021-02-10T11:29:50.0,2023-04-30T17:19:57.0,1621,811,https://github.com/JuliaLang/Pkg.jl/issues/2393,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2393,"[A recent, novel supply chain attack](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610) on some package managers is also possible in certain Pkg/Registry configurations.\n\nThe gist of it is that some package managers, when given a package name, by default look in """"internal"""" repos first, then also check the """"public"""" repos and install whichever returns a higher version number. For this attack to be successful in Pkg, the attacker would also have to know the UUID of the internal package and register a package in General with both the same name and the same UUID, but a higher version number (e.g. 9001.0.0). Once registered, Pkg installs whichever version is higher, thereby allowing """"shadowing"""" of the internal package with a malicious package.\n\nA MWE can be found at https://github.com/DilumAluthge/MWE_multiple_registries_same_package_uuid.\n\nThe intention for all possible fixes is to preserve the ability to have multiple registries available to provide the same package. This should not allow attackers to intentionally register packages with the same name & UUID as another package in a different registry and mislead people into downloading their malicious package.\n\n-----\n\nA non-breaking fix is for each private registry user who also uses General to use the 3 day waiting period to monitor for clashes in new package registrations to General. This should be automatable with some tooling, which comments on the PR to General and thus stops the automerge. As a precaution, private registry users may want to create new UUIDs for their internal packages and investigate how the UUID leaked in the first place.\n\nAnother non-breaking fix on a registry-per-registry basis would be to mirror & vet General manually, though this is somewhat high maintenance and thus unlikely to be useful in practice. This would also require some investigation into how the UUID leaked, should a mismatch be detected.\n\nA possible long-term fix would involve a new `shadowable` entry in `Package.toml`, which would be opt-in and signal that the package is allowed to come from other registries as well. In this model, all installed registries that have the same combination of `(name, UUID)` would also need to have `shadowable=true` set for that package. If any registry doesn't have this set, we error.\n\nThis would be a breaking change, so our options are:\n  1. Do it in Julia 2.0.\n  2. Do it in Julia 1.x, but make a lot of Slack posts and Discourse posts informing people of the change, and make it easy for people (JC, Invenia, Beacon, etc) to make the changes needed. This would only affect local/internal registries that have shared a package with other registries (e.g. by open sourcing them to General). We should work closely with those who are known to have opensourced packages to make their transition as easy as possible.","[Seelengrab]: Many thanks to @ericphanson and @DilumAluthge for brain storming both short- and long-term fixes to this! | [Seelengrab]: Another complication is the case when two intentionally public registries (e.g. General and HolyLabRegistry) are able to shadow each other. This could be prevented by specifying which registries exactly are allowed to shadow the package (or rather, which packages are allowed to be trusted for a specific package). These lists would have to agree on all registries, otherwise we error.\n\nI'm not 100% sure about this, because it requires all registries to be updated & maintained at roughly the same time. Kind of feels like a mismatch is bound to happen eventually here :/ | [ericphanson]: I think they could just both put `shadowable=true`, and then opt-out of this safety check. I don't think that case is really an issue because both packages are controlled by the same maintainers.\n\nI think the security issue is only when PkgX is in RegistryA but not RegistryB, and users of PkgX use both registries, and an adversary has the ability to register a package with the same name and UUID in RegistryB. I think for most practical purposes the only possible RegistryB is General, since it has publicly-available automerge and is installed by default on all Julia installations.\n\nTherefore, if PkgX is already in General, there isn't really a security issue and one can just use the opt-out.\n\nedit: deleted paragraph saying exactly the same thing as you @seelengrab about using a list of registries :). I don't think that's really needed at this point and adds to the burden like you said. | [GunnarFarneback]: The issue of shadowing packages from other public registries with a new package in General could also be mitigated by having auto-merge block registration of UUIDs that exist in public registries it has been configured to know about.\n | [GunnarFarneback]: > A possible long-term fix would involve a new shadowable entry in Package.toml, which would be opt-in and signal that the package is allowed to come from other registries as well. In this model, all installed registries that have the same combination of (name, UUID) would also need to have shadowable=true set for that package. If any registry doesn't have this set, we error.\n\nA non-breaking variation of this would be to only disallow merging if `Registry.toml` contains a field with that meaning, and have an option to allow merging on a package basis by a `mergable` entry in `Package.toml`. Possibly this could also specify exactly which registries to allow merging with. Thus General would not make use of this feature and be completely unaffected but you could set it in your private registry to make sure that your packages cannot be shadowed by General. And in case you do make some of your packages public, there's an override mechanism to allow those to be merged with General.\n | [StefanKarpinski]: I had thought through letting private registries publish a salted, hashed list of UUIDs that could be checked for collisions, but there's a bit of a problem with that: how do you distinguish the original author taking their own package open source from someone else trying to hijack their private package UUID? One answer could be that we examine the situation manually and make a judgement. Otherwise it seems like there needs to be a way of proving that you where the party that submitted the original salted and hashed entry, which gets into tricky crypto territory. Not impossible, but not simple.\n\nMoreover, once package authors need to have proof that they """"own"""" a UUID — in the above scenario, just to be able to take it public at some point — then why bother with the rest? If authors have a private key, they can just sign each release's hash and those signatures can be checked with the private key that's in the registry. If the public keys in different registries don't match, then the client can refuse to install.\n\nYou would want a way for authorities that you trust to sign versions with other keys so that your local admins can publish hotfix versions of public packages, but that can also be arranged. | [GunnarFarneback]: In the public version of this that is implemented in AutoMerge, the rule is to allow registration of a protected UUID if name and repo matches, on the assumption that you can't effectively hijack a package if you still have to point it to the original author's repo.\n\nWasn't the design for the hashed version similar in that respect? | [StefanKarpinski]: Right, but what if you need to change the URL? It's all nice in theory to think that URLs are forever but we know that in reality they are not. If a new hashed record is submitted, how do we decide whether it's ok to let it replace the old one? | [GunnarFarneback]: Fundamentally we have the same problem with repo changes of packages that have already been registered in General, except of course that there is more data to make a judgement call from. The easy way out, with its own problems, is to require someone who has protected a UUID in this way and want to open source the package, to do that with a new UUID.\n | [StefanKarpinski]: That's a bitter pill to swallow given that the current system has made it so smooth and easy for people to open source their private packages and keep using them without issues. And that's something we really want to encourage. | [StefanKarpinski]: We don't have to do something mechanical and rigid here: if an organization has previously published a hashed list of UUIDs, is taking something open source and wants to change the URL, we can always evaluated it using human judgement — the only thing that needs to be automatic is the rejection of attack attempts. But that approach does mean that we need to be able to identify what's going on with the hash lists in order to be able to make judgements about whether a URL change should be allowed or not.\n\n---\n\nUnrelated, but here's my high-level thinking about this problem. Fundamentally this is about who each person trusts to publish new versions of various packages. One generally trusts the original author, so when they make a new release, we're happy to upgrade to it. We also sometimes want to trust some other entity like our own organization's sysadmins to publish new versions of packages they don't maintain for hotfixes and the like. But that should be a conscious choice on the part of the user or a preconfigured policy on corporate machines.\n\n | [cossio]: > A non-breaking fix is for each private registry user who also uses General to use the 3 day waiting period to monitor for clashes in new package registrations to General. This should be automatable with some tooling, which comments on the PR to General and thus stops the automerge.\n\nAre there any tools available for automating these monitoring checks? | [GunnarFarneback]: Not that I've heard of. A simpler but less proactive approach is to periodically (e.g. with a scheduled job) check for UUID collisions between General and your own registry and raise an internal alarm if one is found.\n\nIf your registry is public you can make a PR to add your registry to https://github.com/JuliaRegistries/General/blob/736de1456b8ce65a24ed0003835d370f06451f13/.github/workflows/automerge.yml#L84 so that collisions are stopped by AutoMerge. I'm not sure if that's documented somewhere. | [cossio]: What if we have a list of """"trusted"""" / """"untrusted"""" registries for each package?\n\nWhen a package is installed for the first time, it's registry of origin (call it registry A) is added as trusted and updates coming from this registry can proceed automatically.\n\nIf a new version of this package shows up in another registry (B), Pkg prompts the user what to do. If the user selects to upgrade from B, then registry B is also added as trusted for this package. After that the behavior of Pkg can be the current one regarding the rules for when two registries contain the same package.\nHowever, if the user selects not to """"trust"""" the new version in B, then Pkg adds B as untrusted for this package, and does not consider updates coming from B for this package anymore, only updating the package if new versions appear in A.\n\nCould something like this work? | [ericphanson]: I think a package “should” have only one trusted group allowed to issue versions (org/committer/company/whatever), so if there’s any “untrusted” versions showing up in a registry that’s a big security issue that should be resolved at the registry level, by yanking those versions and investigating, not by someone’s client just ignoring them. I think some kind of alerting thing is good but I think the way we act on that alert shouldn’t be “ok for this particular user, they don’t want these versions”. | [StefanKarpinski]: I think there's two things you need here:\n\n1. Allow a package to declare that certain registries are trusted for it.\n2. Allow a user to declare that certain registries are trusted for them.\n\nWhy do you need both of these? The first is what has already been suggested, and it prevents someone injecting an untrusted version of a package in some other registry, e.g. a malicious version of a private package in the general public registry.\n\nSo why do you need the other? Because it's useful for private registries to be able to release hot-fixes or modified versions of packages in other registries, but they need to trust those registries to do this for them.\n\nThere's a question of how to bootstrap these. The first registry that someone gets a package appears in can be implicitly trusted for it—otherwise we'd need to manually start the trust list somewhere. If a new trust declaration appears in a trusted registry, that can be trusted as well. That would allow transferring a package from one registry to another by adding the destination registry to the trust list and then doing the transfer. I think that not having an explicit trust list for a package in a registry should probably be equivalent to a trust list containing only that registry. So you could do a package transfer like this:\n\n1. Initially RegistryA has an entry for PkgX with no explicit trust list, which means only RegistryA is trusted. RegistryB has no entry for PkgX.\n2. Add an explicit `trust = [RegistryA, RegistryB]` entry in the `Package.toml` file for `RegistryA` (these are registry UUIDs).\n3. Copy the `PkgX` directory from RegistryA to RegistryB. Now new versions from either registry will be trusted.\n4. Delete the `PkgX` directory from RegistryA.\n5. Delete the `trust = [RegistryA, RegistryB]` entry in `PkgX/Package.toml` from RegistryB, leaving only RegistryA in the implicit trust list for PkgX.\n\nIf you want two registries to both be allowed to publish versions of a package, you can just leave both packages in the middle state (step 3) indefinitely. This could be expanded to any number of registries.\n\nAllowing users to declare that they trust certain registries to release versions of packages is the other design question here. We could potentially prompt for that if a new version of a package appears in a registry that isn't in the official trust list for a package. This could look like this:\n```\nPrivateRegistry has a new version of PkgX but isn't an officially trusted registry for PkgX. This could be an attack. Do you want to trust releases of versions from PrivateRegistry?\n [N] No: I do not trust PrivateRegistry to make unofficial releases\n [y] Yes: trust releases of PkgX from PrivateRegistry\n [a] All: trust releases of all packages from PrivateRegistry\n```\nThis information could be saved in the `PrivateRegistry.toml` file in `~/.julia/registries` as something like this:\n```toml\ngit-tree-sha1 = """"666dd7dc07e7949324d20591cde13de3b45ee1a8""""\nuuid = """"20e4b06f-4c3f-4406-9bab-e758a9cb7e70""""\npath = """"PrivateRegistry""""\ntrust = true\n```\nOr for a specific list of packages for which the registry is trusted:\n```toml\ngit-tree-sha1 = """"666dd7dc07e7949324d20591cde13de3b45ee1a8""""\nuuid = """"20e4b06f-4c3f-4406-9bab-e758a9cb7e70""""\npath = """"PrivateRegistry""""\n\n[trust]\n87703c6c-5a47-4a8b-8c61-6f07ed343807 = """"PkgX""""\n```\nThe only other feature I can think of here would be allowing some registries to be trusted but only to provide new releases of packages from some other specific registries. But I'm not sure that's actually a useful feature: trust is pretty much all or nothing here. When you have `trust = true` in a registry's file, there's no reason not to trust it with everything. I'm not even entirely convinced that have a trust list for specific packages is useful. Why would you trust a registry to make unofficial releases of some packages but not others? | [StefanKarpinski]: Some care needs to be taken about the situation where different registries disagree about the set of trusted registries for a package is. For example, what happens when two already-trusted registries list different sets of trusted registries for a package? My gut says that we should take the intersection. But scenarios like the registry transfer one need to be thought through carefully to make sure they're possible. There's also the case where a trusted registry says another registry is trusted for a package, but the other registry doesn't yet have any versions of that package. | [StefanKarpinski]: It occurs to me that we need to keep a """"trust database"""" somewhere anyway, and we could record the flag for """"trust this registry to make unofficial releases"""" flag there as well instead of in the TOML file for the registry (which gets rewritten regularly). | [Seelengrab]: It feels like this discussion is starting to circle back to code signing, trust graphs (PGP/GPG?), CAs and all that entails. We should be careful not to reinvent a bad wheel here and maybe consult someone with professional expertise in establishing trust, signatures and so on. Especially your comment about a """"trust database"""" makes me think of lots of prior art that already does that in various domains.\n\nIt may also be beneficial to tie this in with (possibly future) binary julia artifacts, to link them reproducibly to a given commit/version that artifact got built from. | [cossio]: Why not just ask the user whenever a package is present in more than one registry, which one to use?\nThat is, for each package detected to be present in more than two registries, `Pkg` will maintain locally a list of the registries it trusts for that package, which are manually approved by the user. | [StefanKarpinski]: @Seelengrab, it's not really—I didn't mention signatures or CAs at all 🙂. The """"trust database"""" is literally just a place where you record which package UUIDs have been seen in which registries previously. There's no """"trust graph"""" involved, it's strictly local information.\n\n@cossio: Consider the package transfer scenario—how is the user supposed to know if this situation is safe or it's an attack? They're not actually in a position to know that. | [Seelengrab]: I know you didn't, it just feels like moving in that direction without actually taking the final leap of signing releases & managing which kinds of signatures are ok :) From what I can tell, the """"trust database"""" approach has TOFU (Trust On First Use) problems just like connecting to an SSH server for the first time or receiving a PGP encrypted email from an unknown sender. Just that it's about """"well should I trust this Registry with this new UUID I haven't seen from it before?"""" instead of public key encryption, which is how I got to """"why not have admins install a CA whose signatures are allowed from this registry"""" and hence code signing.\n\nI am aware that it's not backwards compatible, but versions that don't support this can't participate anyway, as mentioned in the OP about whether it's breaking or not. :thinking: | [StefanKarpinski]: Implementing our own PKI is a bad idea, we're definitely not doing that. | [StefanKarpinski]: To elaborate on that: if you need a PKI, you're basically always better off leveraging an existing PKI that's actively maintained—the bigger and more active, the better. Which means you should, instead of building your own, use HTTPS. Which, in our case, means downloading things over HTTPS and trusting that the content of what you downloaded is valid. Rubbing signatures and public key encryption on things is fun and all, but you still need to find out which signatures to trust from somewhere. | [Seelengrab]: > So you could do a package transfer like this\n\nHow would this work with versions that were published before the transfer? Can I still install them after RegistryA got removed (I presume not)? \n\nAnother thought - what's preventing me as a package author to have some malicious code running during `__init__` or during precompilation that changes the `trust` entry for some package, install my custom malicious registry and publish package versions that way? I think as soon as we have a `trust` entry there, we need to ensure the integrity of that information. I just don't see how we can guarantee that without some form of PKI - the most famous form of """"local only verification"""" is in the form of videogame tamper proofing or mobile phones, which is extremely often broken by having the private key for decryption/signature checking stored next to the stuff that's encrypted/signed (storing the keys in hardware like a TPM is what e.g. Apple is doing for their integrity checking on iPhones, but even that is broken into every few months). | [StefanKarpinski]: > How would this work with versions that were published before the transfer?\n\nIf they're transferred to the other repository, then you can install them. The same version info can be published in multiple registries, it's all just unioned together.\n\n> Another thought - what's preventing me as a package author to have some malicious code running during `__init__` or during precompilation that changes the `trust` entry for some package, install my custom malicious registry and publish package versions that way?\n\nIf the attacker is already running arbitrary code on your system, why do they need to do any of the other stuff? | [GunnarFarneback]: > But I'm not sure that's actually a useful feature: trust is pretty much all or nothing here. When you have trust = true in a registry's file, there's no reason not to trust it with everything. I'm not even entirely convinced that have a trust list for specific packages is useful. Why would you trust a registry to make unofficial releases of some packages but not others?\n\nI'm not sure I'm following here. The scenario that is of primary interest to me is having General plus a company internal registry. I want  to merge the registry information in exactly two cases:\n\n1. Private packages have been open sourced and new versions are registered in General.\n2. Private versions of packages from General are published in the internal registry.\n\nIn both cases I want the company registry to dictate whether it is allowed, on a package per package basis, to merge versions with General and not leave that to the individual users, who in a majority of cases won't have any idea. If any UUID appears in both the company registry and in General, which hasn't been explicitly whitelisted, I want Pkg to refuse merging and preferably be noisy enough that the situation is escalated within the company.\n | [StefanKarpinski]: You're describing a situation where you trust your company registry, so it would be a trusted registry.\n\n> If any UUID appears in both the company registry and in General, which hasn't been explicitly whitelisted, I want Pkg to refuse merging and preferably be noisy enough that the situation is escalated within the company.\n\nWhitelisted where? How to do the whitelisting is exactly the question. Let's say there are two registries: Internal and General; Internal is a trusted registry, General is not. If a package appears in General first and then a version is published in Internal, that version will be trusted because Internal is a trusted registry. If a package appears in Internal first and then a version of it appears in General, the question is whether that is an attack or an intentional publication of a previously internal package. How does one distinguish the two situations? Some indication that it's ok for the General registry to publish versions of the package has to appear in the Internal registry. That's what I'm proposing: you indicate that it's ok by putting `trust = """"23338594-aafe-5451-b93e-139f81909106""""` (the General UUID) or something like that in the `Package.toml` file for the package in question—in the Internal registry. | [StefanKarpinski]: In essence, what I'm saying is that you need two things:\n\n1. A way to indicate that a registry (like Internal) is trusted and you can use any version it publishes.\n2. A way for a registry that you trust for some package to delegate its ability to other registries.\n\nThe first one is pretty simple: it's a registry-level boolean flag. Details of the trust delegation feature remain a bit fuzzy, but that's what we need work out.\n\nConsider transitive delegation, for example. If Internal delegates the ability to publish new versions of a package to General and General delegates to Other, is that allowed? As a rule of thumb, conservatism suggests no, but on the other hand, if someone doesn't know about Internal, then the delegation from General to Other would be fine, so it's a little weird if knowing about Internal prevents General from delegating to Other when it would work for people who don't know about Internal. So that suggests that transitive delegation should work.\n\nAnother question is whether delegated trust is persistent or not. If Internal delegates to General and then removes that delegation, do we keep trusting it or stop? What if the Internal registry is deleted or the package in question is deleted from Internal, which would leave the package only in General. In the former case where a delegation is removed, it should not persist. In the latter case, where the package is deleted from Internal entirely (say you want to transfer it to General fully), then that trust should persist. You could, in that situation ask the user to muck around with deleting registries or clearing their trust database, but it seems better if it works automatically.\n\nI'll work on writing up a proposal. | [GunnarFarneback]: I guess we somewhat agree, cf https://github.com/JuliaLang/Pkg.jl/issues/2393#issuecomment-777286926. The way I see it, General should say that it is fine with any merges (at the registry level) and the company registry should say on a registry level that merges are not allowed, unless respective package specifies that they may be be merged with specified registries. Pkg should require that all involved registries allow the merge.\n\nI'm not really seeing the point or value of the temporal ordering. Possibly because I'm not understanding this delegation stuff in the first place. | [GunnarFarneback]: > If a package appears in Internal first and then a version of it appears in General\n\nHow do you determine the ordering of these events? If you do it client side, would an old installation (which can see the new version arrive) handle it differently from a new installation (which can only see that there are some existing versions)? Alternatively, if you add time stamps in the registries, what would stop a malignant registry from forging its time stamps?\n\nUpdate: I realize that I might have misunderstood and that the ordering strictly refers to the version numbers. | [StefanKarpinski]: Yes, what I was thinking was that the client would remember where it saw each UUID first. However, that does require a client-side database, which it would be better to avoid. If I'm understanding where you're coming from, you'd prefer to avoid that and base everything on what's in registries, which I agree would be better if it can cover all the use cases. | [StefanKarpinski]: My first observation about the """"stateless"""" approach is this: just marking a package as """"mergeable"""" isn't sufficient since it opens up any package that's marked that way to confusion attacks from another registry. Example: you need to share a package between two private registries so you mark it as """"mergeable""""; now that package is susceptible to dependency confusion attacks from General.\n\nSo let's consider the variation of the stateless approach where you explicitly list the UUIDs of registries that you want to allow merging with. Here are some of the scenarios we want to allow:\n\n- Package transfer between registries.\n- Publishing all versions of a package that was originally private.\n- Publishing some versions of a package that was originally private.\n- Hot-patching of a public package in a trusted registry.\n- Mirroring a package between multiple registries.\n\nInitially, we can assume that registry updates happen instantaneously so that we can be sure that changes to two different registries appear on clients at the same time. With that assumption wholesale transfer becomes trivial: just move all the versions of a package from one registry to the other. Because of the instantaneous update assumption, there's never a point where it looks both registries have versions for the package.\n\nUnfortunately instantaneous publishing isn't real: it takes a varying and significant amount of time for changes to registries to propagate to package servers. However, this observation helps us deal with that issue: if two registries publish the same set of versions for a package, then there's no danger of dependency confusion. This allows the following procedure for package transfer:\n\n1. Stop publishing new versions of the package\n2. Add all versions to the new registry\n3. Let that propagate to pkg servers\n4. Delete all versions from the old registry\n5. Let that propagate to pkg servers\n6. Resume publishing new versions of the package\n\nThat way the only states a client can see, assuming they pull both registries from servers at the same time, are all versions in one or both registries, which presents no danger. This same observation also allows us to mirror a package between multiple registries so long as all versions are mirrored.\n\nThe main problem that remains is situations where some versions of a package appear in multiple registriest and one registry includes a version of a package that does not appear in the others. For simplicity, let's just consider two registries. This is a situation that one needs to support for some of the scenarios, like """"publishing some versions of a package that was originally private"""" and """"hot-patching of a public package in a trusted registry"""". Depending on interpretation, these are the only two, and they represent the coordinated and uncoordinated versions of the problem.\n\nThe coordinated version is where you can modify both registries. This is the case where the """"mergeable"""" approach works: each registry indicates that the package can be merged with the other registry, by putting something like `mergeable = """"7680a4ac-0009-40d6-ac35-827cc6355475""""` in the `Package.toml` file for the package.\n\nThe uncoordinate version is where you cannot modify one of the registries, but the one you can modify is a trusted registry. This is the scenario where you want to hot-patch a public package in a trusted (typically private) registry. In this case you will have hotfix versions in the private registry that don't appear in the public registry but the public registry doesn't know about your private registry and cannot be modified to have a `mergeable` entry. However, the private registry can be marked as trusted, e.g. by putting `trust = true` in the `Private.toml` file for the registry. We won't raise the alarm when a trusted registry has versions of a package that don't appear in other registries that include that package.\n\nThat arrangement for hotfixes _seems_ ok, except that this is exactly what dependency confusion attack would look like: you have a trusted private registry with some versions of a package and then you have versions of the same package in an untrusted public registry. One option would be to include all the public versions in the private registry. That means none of the public versions can be an attack since they're all included in the trusted registry. However, this has publication delay issues: when a new version appears in the public registry, it will take some time to include it in the private registry, during which gap, it will look like an attack is taking place. Instead, I'd suggest that we allow the private, trusted registry to indicate that it trusts versions from the public registry: i.e. have `mergeable = """"23338594-aafe-5451-b93e-139f81909106""""` entry in the private `Package.toml` file but not in the public one (since the public one doesn't know about the private one).\n\nAnd now you see that we've gotten to something that looks a lot like trust delegation 🙂. You can think of `mergeable = """"$uuid""""` appearing in two registries where each one has the UUID of the other as a mutual declaration of trust... which basically means """"it's ok with me if this other registry has versions that I don't know about."""" In other words, it might be spelled `trust = """"$uuid""""` because it really means, """"I trust versions of this package declared in this other registry."""" However, it's been a very positive exercise because I see now that we can do this without needing to keep any trust database or do anything stateful at all—i.e. no need to remember where we saw a package first. | [GunnarFarneback]: > If I'm understanding where you're coming from, you'd prefer to avoid that and base everything on what's in registries, which I agree would be better if it can cover all the use cases.\n\nYes, that is exactly what I'm after.\n\n> Instead, I'd suggest that we allow the private, trusted registry to indicate that it trusts versions from the public registry: i.e. have mergeable = """"23338594-aafe-5451-b93e-139f81909106"""" entry in the private Package.toml file but not in the public one (since the public one doesn't know about the private one).\n\nThis sounds like what I've been proposing so I believe we are converging.\n | [StefanKarpinski]: Here's my proposal.\n\n## Trust Records\n\nThere are three kinds of trust records:\n\n1. **User trusts a registry:** a user can indicate that they trust all versions of all packages in a registry.\n2. **Registry trusts another registry:** a registry can indicate that it trusts versions of all packages that are published in another registry.\n3. **Registry trusts another registry for a specific package:** A registry can indicate that it trusts versions of a specific package that are published in another registry.\n\nThis information will be encoded in various TOML files:\n\n1. In `$Registry.toml` as a top-level `trusted = true` flag;\n2. In `$Registry/Registry.toml` as a top-level list of trusted registry UUIDs;\n3. In the `Package.toml` file of a specific packages as a list of trusted registry UUIDs.\n\n## Trust Graph for a Package\n\nGiven a collection of installed registries and these trust records, for each package, `P`, we can derive the directed trust graph for that package. The nodes of the graph are all the registries that have a `Package.toml` file for `P` (registries that don't know about `P` are not included in its graph—this is important) and the directed edges are the following from each registry:\n\n1. To every registry that the user has marked as fully trusted;\n2. To every registry it has marked as trusted for all packages;\n3. To every registry it has marked as trusted specifically for `P`.\n\n## Checking for Attacks\n\nTo check for dependency confusion attacks, we must verify two things for each package `P`:\n\n- That no registries make conflicting claims about the meaning of a version number—they all have to agree on the tree hash of every version number.\n- That for every version of `P`, there is a path in the trust graph for `P` to from every registry to some registry in which that version appears.\n\nThe first check is fairly uncontroversial: if two registries claim different meanings for the same version of a package, there's a problem and one of them may be trying to trick you into using an incorrect, potentially malicious version of the package.\n\nThe second check is the meat of the design: it establishes a chain of trust from each registry to each version of each package that it knows about. Another way to think about this, rather than in terms of transitive trust, is that each registry virtually includes all versions from other registries that it trusts. In this perspective, the condition we want to check is that all the registries that know about a package include identical sets of versions of it. This is somewhat intutive: if all the registries that know about a package agree on what the versions of that package are, then a dependency confusion attack is not possible. Of course, actually having all registries literally include all the versions of every package makes having different registries pointless. What the trust/inclusion mechanism allows is for registries to virtually include various versions in other registries, which preserves the usefulness of multiple registies while ensuring that they all agree on what the versions exist of packages that they know about.\n\n## Scenarios\n\nIn what follows, we'll walk through some scenarios to make sure that this actually prevents attacks and that it still allows various useful use cases of registries.\n\n### Dependency confusion attack\n\nFirst, let's consider the scenario we are actually trying to defend against: someone tries a dependency confusion attack. Suppose an organization has an Internal package registry which includes a package, `P`, which does not exist in the General public registry. An attacker learns the UUID of `P` and introduces a malicious fake version of `P` into General. There are a few variations on this that we'll cover.\n\n*Case:* Internal is not trusted by a user (can’t introduce hotfixes to external packages) and General doesn't know about Internal, so there are no trust edges—the trust graph for `P` is disconnected. The malicious version is only in General which isn't reachable from Internal, so the malicious version is correctly detected as an attack. From the inclusion perspective, the malicious version is included in General but not in Internal, which indicates an attack.\n\n*Case:* Internal is trusted (i.e. can introduce hotfixes) so there is a trust edge from General → Internal; there are no other trust edges. Again, the malicious version is only in General which isn't reachable from Internal (the edge goes the other way), so the malicious version is correctly detected as an attack again.\n\n*Case:* Suppose the attacker, in addition to a malicious version of `P` in General, also introduces a trust edge from General to Internal (which can be a trusted registry or not—it doesn't matter for this case). This situation produces the same trust graph as last time: an edge from General to Internal again, so the attack is caught. In order to prevent detection, the attack would need to introduce a trust edge in the other direction, from Internal to General. But if the attacker could modify the Internal registry, then they could directly introduce the malicious version into the Internal registry without needing to use a dependency confusion attack.\n\nWe can conclude that this proposal does actually prevent dependency confusion attacks. In the following scenarios we'll make sure that it still allows useful use cases that aren't attacks.\n\n### Package transfer between two untrusted registries\n\nIf we want to transfer a package from one registry to another, as described in my previous comment, we can stop publishing new versions of the package, copy the entire package directory to the new registry, delete the package from the old registry, let those changes propagate to package servers, and then resume publishing new versions. In this case the trust graph is disconnected—the registries don't trust each other. However, that's not a problem because there are only two states that are ever visible to an end user:\n\n- The package only appears in one registry, so its trust graph only has one node;\n- The package appears in both registries, but the same set of versions appear in both registries, so every version is reachable from both registries.\n\nFrom the inclusion perspective, there's agreement on the set of versions in both cases: in the former because only one of the registries include `P` and it agrees with itself; in the latter because they two registries have identical sets of versions.\n\n### Hot-patching of a public package in a trusted registry\n\nSuppose you have an urgent fix to a public package, `P`, and can't wait until a new version is published in General (maybe the maintainer is on vacation). A useful feature of Pkg's registry system is that a new version of the package, say `v1.2.3-hotfix`, can be registered in an internal registry. How does this work with this proposal? Making this work requires two things:\n\n1. Users have to trust the Internal registry;\n2. The Internal registry must indicate that General is trusted for package `P`.\n\nThe first change causes versions of any package published in Internal to be trusted, allowing it to make hotfixes of any package. The second change prevents versions of `P` in General from being mistaken for a dependency confusion attack, which they otherwise would look like if Internal doesn't include them all. (Internal could explicitly include all of the versions of `P` that are in General, but then any time a new one is released, it would look like an attack again until Internal is updated to include the new version.)\n\nNote that Internal should *not* indicate that it trusts `General` for all packages, as that would open it up to dependency confusion attacks for internal packages!\n\n### Publishing versions of a package that was originally private\n\nSuppose a package, `P`, originally starts out in an Internal registry, but the organization decides to publish it by adding some or all versions of the package to General. In order to signal that this isn't a dependency confusion attack, they need to indicate that Internal trusts versions of `P` that are published in General.\n\nIf they publish all versions of the package, then it doesn't matter if the Internal registry is trusted or not. If they only publish some versions and the Internal registry is not trusted by their users (why wouldn't it be though?), then the presence of private versions that aren't in General will look like a reverse dependency confusion attack. This would be a little unusual, since internal private registries should generally be trusted, but there are some options in such a situation:\n\n- We could have Pkg not error unless it's actually considering installing a version. Since the unpublished versions would be older in this case, there wouldn't be any problem. However, if someone did try to resolve some environment that needed an older internal-only version, it would raise an error, so that's not an ideal solution.\n- The organization can ask for a trust entry from General to Internal for this package. There's no reason we can't do this since it's their package. That means there would some private registry UUID in the General registry, which is weird but not fundamentally wrong. However, this would introduce a risk that an attacker could make a fake registry with that UUID and then convince someone to add it, and then if they try to use `P` the attacker could trick them into using a malicious version from the registry they installed. In general, I think we need to train people that adding registries is an act of trust and that they should only do it with caution, but this also suggests that this option isn't ideal.\n- The organization can split their Internal registry into InternalTrusted and InternalUntrusted. The unpublished versions of the published package go in the InternalTrusted registry. This is probably the best solution even though it's awkward. But again, why wouldn't you trust everything in your internal registry?\n\nUltimately, I don't think this is a real issue—internal registries should be trusted.\n | [DilumAluthge]: > This information will be encoded in various TOML files:\n> \n> 1. In `$Registry.toml` as a top-level `trusted = true` flag;\n\nHow does this work for Git registries, or for Pkg server registries in which we uncompressed and extract the tarball. IIUC, the `$Registryname.toml` file only exists for Pkg server registries that we leave compressed. | [StefanKarpinski]: We can also create the TOML file for git cloned registries. Another option is to put the `trusted = true` flag in the `Registry.toml` file and prompt the user if they trust the registry or not when they install it if it's a trusted registry. In other words, make it the registry maintainers call whether it's trusted or not, but require the user to agree to that upon installation. | [StefanKarpinski]: I think that might make sense: if a registry is intended to be trusted, things are likely to break if someone installs it but doesn't treat it as trusted, e.g. it might contain hotfixes of public packages, which will then be treated as dependency confusion attacks. So having the `trusted = true` flag in the `Registry.toml` file but then prompting the user if they try to add it makes sense to me. That also means we'd need to check when a registry gets updated if some tries to slip that entry into the TOML file, and either prompt them at that point and roll back to the previous registry state? Or delete the registry entirely and require them to add it again?\n\nBasically, adding a trusted registry is an act of trust since it has license to publish hotfixes of any package. Adding an untrusted registry is safe until you add a package from it. This mechanism prevents the untrusted registr from forging versions of packages in other registries. You should only install a trusted registry if you trust everyone who can add things to it; you can safely install an untrusted registry like General that potential attackers can register things in. | [GunnarFarneback]: > In other words, make it the registry maintainers call whether it's trusted or not, but require the user to agree to that upon installation.\n\nI have mixed feelings about the last part. On one hand I can see the scenario where someone makes some useful packages available in their own public registry, which they have set as trusted, then at a later time starts adding malignant packages (or by ignorance allow others to do so). In that case it's not good if the trusted status does not have to be confirmed by the user.\n\nOn the other hand I see the in-organization scenario where you want things to just work. Having your users be forced to confirm that they trust the internal registry is a pointless distraction and there is a risk that they answer the question incorrectly, likely causing more trouble down the road.\n\nOne possibility would be to skip the trustedness confirmation if the registry is installed from a package server. After all, if you connect to a package server under the control of an attacker, they can add new malignant versions to any package at will, regardless of trust flags. | [StefanKarpinski]: That's a good point: for any registry you get via a package server, you might as well trust whatever trust flag they set on it. For example, if you're using an private package server and it includes two registries: Internal and General (mirrored from the public General), then the operator would mark the Internal registry as trusted and the General registry as untrusted, to indicate that the end user can trust anything in the former, but should be wary of the latter. | [GunnarFarneback]: Another minor observation:\n\n> if all the registries that know about a package agree on what the versions of that package are, then a dependency confusion attack is not possible\n\nA weaker version of this could be """"if all the registries that know about a package agree on the package repo URL"""" but unfortunately you can't draw very strong conclusions from this unless you verify or have guarantees that all versions' tree hashes actually exist in the repo.\n | [StefanKarpinski]: We should really implement this. There's been a real dependency confusion attack on PyTorch: https://pytorch.org/blog/compromised-nightly-dependency/, https://medium.com/checkmarx-security/py-torch-a-leading-ml-framework-was-poisoned-with-malicious-dependency-e30f88242964. | [Seelengrab]: I just noticed that the MWE @DilumAluthge and I came up with in the initial post 404s now - I don't think I still have a reference to that, but it would have been good as a test example :/ | [DilumAluthge]: 😬 | [DilumAluthge]: I must have deleted the repo. | [DilumAluthge]: It shouldn't be too hard to create the MWE. You just need to set up two registries that have the same package (with the same package name and same package UUID). | [Seelengrab]: That much is true, I just dread doing it again because the one we came up with back then was super self contained, cleaned up after itself and everything :sob: | [Octogonapus]: I built a tool we use for monitoring for dependency confusion attacks against our private registry and against public registries. We would be up for sharing more details in a call if there is interest.\n\ncc @IanButterworth | [cadojo]: In Python, and Julia, there seems to be a lot of complications to support a use case that I've not yet seen used — an identical package hosted in two different locations, which are both equally valid to the user. \n\nRust takes the approach of specifying each dependency's registry if and only if the registry is _not_ the standard `crates.io` registry. This requires users to specify all non-crates.io dependencies explicitly, but for private organizations that may give some peace of mind to developers anyway.\n\nIf a user wants to ditch `General` completely in favor of their own private mirror, maybe making their own mirror the default registry in `Pkg` could be sufficient here. In other words, we could use Rust's approach with one modification: specify each dependency's registry if and only if the registry is _not_ the ~~standard~~ `Pkg` default registry.\n\n---\n\nAll the text above are just some thoughts I've had. I am not a software supply chain / security / package management expert. I am interested in how this is going to be resolved in Python, so I've been keeping an eye on reported dependency confusion attacks in [PyPI](pypi.org). | [Octogonapus]: > I built a tool we use for monitoring for dependency confusion attacks against our private registry and against public registries. We would be up for sharing more details in a call if there is interest.\n\nThe tool has grown quite a bit and I've been running it since I posted this earlier message. I recently made it public: https://github.com/Octogonapus/RegistryScanner\nIf you run a private registry, I would encourage you to also run this tool and configure it with all the registries you use.",50,false,7,7,0,0,0,0,0,0,0
3442,Errors running tests,open,jmkuhn,KristofferC,,,0,2023-04-19T19:58:25.0,2023-04-19T20:05:23.0,822,822,https://github.com/JuliaLang/Pkg.jl/issues/3442,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3442,"This issue started after https://github.com/JuliaLang/julia/commit/ba9c45566ac0f668a674397f0d84d641e107cab4 and https://github.com/JuliaLang/julia/pull/49135.  When testing `Random` for instance, the following errors are produced before the tests continue and complete successfully.\n\n```\njulia> versioninfo()\nJulia Version 1.10.0-DEV.1065\nCommit dffb33bfc0 (2023-04-19 18:12 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.6.0)\n  CPU: 8 × Intel(R) Core(TM) i7-1068NG7 CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, icelake-client)\n  Threads: 1 on 8 virtual cores\n\n(@v1.10) pkg> test Random\n     Testing Random\n      Status `/private/var/folders/_n/qxr3t0td5lg32xh_4pn25x5n_pzq0g/T/jl_3oPhxf/Project.toml`\n  [9fa8497b] Future `@stdlib/Future`\n  [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`\n  [9a3f8284] Random `@stdlib/Random`\n  [ea8e919c] SHA v0.7.0 `@stdlib/SHA`\n  [9e88b42a] Serialization `@stdlib/Serialization`\n  [2f01184e] SparseArrays v1.10.0 `@stdlib/SparseArrays`\n  [10745b16] Statistics v1.9.0 `@stdlib/Statistics`\n  [8dfed614] Test `@stdlib/Test`\n      Status `/private/var/folders/_n/qxr3t0td5lg32xh_4pn25x5n_pzq0g/T/jl_3oPhxf/Manifest.toml`\n  [56f22d72] Artifacts `@stdlib/Artifacts`\n  [2a0f44e3] Base64 `@stdlib/Base64`\n  [9fa8497b] Future `@stdlib/Future`\n  [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`\n  [8f399da3] Libdl `@stdlib/Libdl`\n  [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`\n  [56ddb016] Logging `@stdlib/Logging`\n  [d6f4376e] Markdown `@stdlib/Markdown`\n  [9a3f8284] Random `@stdlib/Random`\n  [ea8e919c] SHA v0.7.0 `@stdlib/SHA`\n  [9e88b42a] Serialization `@stdlib/Serialization`\n  [2f01184e] SparseArrays v1.10.0 `@stdlib/SparseArrays`\n  [10745b16] Statistics v1.9.0 `@stdlib/Statistics`\n  [8dfed614] Test `@stdlib/Test`\n  [e66e0078] CompilerSupportLibraries_jll v1.0.2+0 `@stdlib/CompilerSupportLibraries_jll`\n  [4536629a] OpenBLAS_jll v0.3.23+0 `@stdlib/OpenBLAS_jll`\n  [8e850b90] libblastrampoline_jll v5.7.0+0 `@stdlib/libblastrampoline_jll`\nERROR: LoadError: ArgumentError: Package Pkg does not have Random in its dependencies:\n- You may have a partially installed environment. Try `Pkg.instantiate()`\n  to ensure all packages in the environment are installed.\n- Or, if you have Pkg checked out for development and have\n  added Random as a dependency but haven't updated your primary\n  environment's manifest file, try `Pkg.resolve()`.\n- Otherwise you may need to report an issue with Pkg\nStacktrace:\n [1] macro expansion\n   @ ./loading.jl:1627 [inlined]\n [2] macro expansion\n   @ ./lock.jl:267 [inlined]\n [3] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1604\n [4] include\n   @ ./Base.jl:488 [inlined]\n [5] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing)\n   @ Base ./loading.jl:2052\n [6] top-level scope\n   @ stdin:2\nin expression starting at /Users/john.m.kuhn/opt/julia/1.10-DEV/julia/usr/share/julia/stdlib/v1.10/Pkg/src/Pkg.jl:3\nin expression starting at stdin:2\nERROR: Failed to precompile Pkg [44cfe95a-1eb2-52ea-b672-e2afdf69b78f] to """"/Users/john.m.kuhn/.julia/compiled/v1.10/Pkg/jl_8sKqTL"""".\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool)\n   @ Base ./loading.jl:2304\n [3] compilecache\n   @ ./loading.jl:2170 [inlined]\n [4] _require(pkg::Base.PkgId, env::Nothing)\n   @ Base ./loading.jl:1813\n [5] _require_prelocked(uuidkey::Base.PkgId, env::Nothing)\n   @ Base ./loading.jl:1655\n [6] _require_prelocked\n   @ ./loading.jl:1653 [inlined]\n [7] macro expansion\n   @ ./lock.jl:267 [inlined]\n [8] require(uuidkey::Base.PkgId)\n   @ Base ./loading.jl:1648\n [9] top-level scope\n   @ none:1\n     Testing Precompilation of test environment failed. Continuing to tests\n     Testing Running tests...\nTest Summary: | Pass  Total  Time\nIssue #6573   |    1      1  0.3s\n...\n     Testing Random tests passed \n```\n",,0,false,0,0,0,0,0,0,0,0,0
3225,Feature request: loading dependencies and/or artifacts from package hooks,open,maleadt,,,,2,2022-10-14T07:06:15.0,2023-04-17T13:06:18.0,1010,825,https://github.com/JuliaLang/Pkg.jl/issues/3225,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3225,"## Context\n\nPackage hooks (e.g. `.pkg/select_artifacts.jl`) are currently designed to execute in a fixed environment where it's only possible to load stdlibs. This has been done to simplify installation, https://github.com/JuliaLang/Pkg.jl/pull/2024#issuecomment-760534026, because (quoting @staticfloat) it makes it possible to install packages and their dependencies without requiring an iterative approach.\n\nI do however think that I'm in a situation where this capability, or at least the capability to access some artifact during execution of the artifact selection hook, is required.\n\n\n## Issue\n\nThe problematic package is, as always, `CUDA.jl`. The situation is as follows:\n\n- `CUDA.jl` requires binaries for the runtime, and the driver. Both are (to be) provided by a JLL;\n- The driver JLL packs a single .so, while the runtime JLL has many artifacts (one for each version of CUDA);\n- After loading the driver, we can query the supported CUDA version and use that to select an artifact.\n\nThis means that the `CUDA_Runtime_jll` artifact selection hook needs to be able to download the driver artifact. However, that's not possible, because we can't load `CUDA_Driver_jll` from the hook as the environment is not yet set-up. The situation could be simplified by removing `CUDA_Driver_jll` and putting its artifact into `CUDA_Runtime_jll` and loading it directly, but that currently does not work either. @staticfloat suggested making it possible to load lazy artifacts, which would mostly resolve this issue.\n\n(I'd still be in favor of the ability to load actual dependencies though, because in reality we don't just want to load `CUDA_Driver_jll`, but a full-blown package, because the driver selection logic is [more complicated](https://github.com/JuliaGPU/CUDA_Driver.jl/blob/main/src/CUDA_Driver.jl) than just loading an .so from an Artifact, and we'd like this functionality to be reusable across several packages. But that's not crucial, and I guess we could inline it all into the `CUDA_Runtime_jll`.)\n\n\n## Workaround\n\nI only ran into this when registering `CUDA_Runtime_jll`, because once the environment has been instantiated the dependency _is_ available and can be loaded from the package hook (which seems to use the global environment). That means that the unavailability of `CUDA_Driver_jll` only happens when initially installing `CUDA.jl`.\n\nGiven that the above issue is so rare, can't I just for now (as a temporary workaround) do:\n\n```\n$ head .pkg/platform_augmentation.jl\n```\n```julia\ntry\n    using CUDA_Driver\ncatch err\n    using Pkg\n    redirect_stdout(stderr) do\n        Pkg.activate(; temp=true)\n        Pkg.add(""""CUDA_Driver"""")\n    end\n\n    using CUDA_Driver\nend\n\n# the rest of the hook\n```\n\nSure, this is pretty cursed, but it works (and lets me continue working on the JLLification of our GPU stack). Or is there something fundamentally broken about this?\n\ncc @vchuravy","[maleadt]: Actually, loading lazy artifacts from the artifact selection hook looks like it already works (@staticfloat said it wouldn't)... Am I missing something? | [maleadt]: > Sure, this is pretty cursed, but it works (and lets me continue working on the JLLification of our GPU stack). Or is there something fundamentally broken about this?\n\n6 months later... Turns out this is somewhat broken, as it ignores compat bounds. Example: CUDA_Runtime_jll 0.5 depends on CUDA_Driver_jll 0.5 (both packages move in lockstep), but during the upgrade from 0.4 -> 0.5 CUDA_Runtime_jll@0.5's augmentation hook gets executed while CUDA_Driver_jll is still at 0.4, resulting in broken user environments (e.g. https://github.com/JuliaGPU/CUDA.jl/issues/1798#issuecomment-1510937779).",2,false,0,0,0,0,0,0,0,0,0
3199,Robustness against corrupt package store,open,maleadt,,,,2,2022-09-13T10:04:25.0,2023-04-07T16:19:40.0,1041,834,https://github.com/JuliaLang/Pkg.jl/issues/3199,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3199,"Recently, PkgEval testing of lots of packages broke because of a corrupt entry in `.julia/packages` (which is shared and persistent). MWE:\n\n```\n$ rm -rf ~/.julia/packages/Distributions/39PV5\n$ mkdir ~/.julia/packages/Distributions/39PV5\n\njulia> using Distributions\nERROR: ArgumentError: Package Distributions [31c24e10-a181-5473-b8eb-7969acd0382f] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n```\n\nActual backtrace:\n\n```\n\n     Testing Bootstrap\n      Status `/tmp/jl_oUIXPn/Project.toml`\n  [e28b5b4c] Bootstrap v2.3.3\n  [a93c6f00] DataFrames v1.3.5\n  [31c24e10] Distributions v0.25.70\n  [38e38edf] GLM v1.8.0\n  [ce6b1742] RDatasets v0.7.7\n  [2913bbd2] StatsBase v0.33.21\n  [3eaba693] StatsModels v0.6.31\n  [9a3f8284] Random `@stdlib/Random`\n  [10745b16] Statistics `@stdlib/Statistics`\n  [8dfed614] Test `@stdlib/Test`\n      Status `/tmp/jl_oUIXPn/Manifest.toml`\n  [e28b5b4c] Bootstrap v2.3.3\n  [336ed68f] CSV v0.10.4\n  [49dc2e85] Calculus v0.5.1\n  [324d7699] CategoricalArrays v0.10.6\n  [d360d2e6] ChainRulesCore v1.15.5\n  [9e997f8a] ChangesOfVariables v0.1.4\n  [944b1d66] CodecZlib v0.7.0\n  [34da2185] Compat v4.2.0\n  [a8cc5b0e] Crayons v4.1.1\n  [9a962f9c] DataAPI v1.10.0\n  [a93c6f00] DataFrames v1.3.5\n  [864edb3b] DataStructures v0.18.13\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [b429d917] DensityInterface v0.4.0\n  [31c24e10] Distributions v0.25.70\n  [ffbed154] DocStringExtensions v0.9.1\n  [fa6b7ba4] DualNumbers v0.6.8\n  [e2ba6199] ExprTools v0.1.8\n  [5789e2e9] FileIO v1.15.0\n  [48062228] FilePathsBase v0.9.20\n  [1a297f60] FillArrays v0.13.4\n  [59287772] Formatting v0.4.2\n  [38e38edf] GLM v1.8.0\n  [34004b35] HypergeometricFunctions v0.3.11\n  [842dd82b] InlineStrings v1.1.4\n  [3587e190] InverseFunctions v0.1.7\n  [41ab1584] InvertedIndices v1.1.0\n  [92d709cd] IrrationalConstants v0.1.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [2ab3a3ac] LogExpFunctions v0.3.18\n  [e1d29d7a] Missings v1.0.2\n⌃ [78c3b35d] Mocking v0.7.2\n  [77ba4419] NaNMath v1.0.1\n  [bac558e1] OrderedCollections v1.4.1\n  [90014a1f] PDMats v0.11.16\n  [69de0a69] Parsers v2.4.0\n  [2dfb63ee] PooledArrays v1.4.2\n  [21216c6a] Preferences v1.3.0\n⌅ [08abe8d2] PrettyTables v1.3.1\n  [1fd47b50] QuadGK v2.5.0\n  [df47a6cb] RData v0.8.3\n  [ce6b1742] RDatasets v0.7.7\n  [3cdcf5f2] RecipesBase v1.2.1\n  [189a3867] Reexport v1.2.2\n  [ae029012] Requires v1.3.0\n  [79098fc4] Rmath v0.7.0\n  [6c6a2e73] Scratch v1.1.1\n  [91c51154] SentinelArrays v1.3.13\n  [1277b4bf] ShiftedArrays v1.0.0\n  [a2af1166] SortingAlgorithms v1.0.1\n  [276daf66] SpecialFunctions v2.1.7\n  [82ae8749] StatsAPI v1.5.0\n  [2913bbd2] StatsBase v0.33.21\n  [4c63d2b9] StatsFuns v1.0.1\n  [3eaba693] StatsModels v0.6.31\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.7.0\n  [f269a46b] TimeZones v1.9.0\n  [3bb67fe8] TranscodingStreams v0.9.9\n  [ea10d353] WeakRefStrings v1.4.2\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [0dad84c5] ArgTools v1.1.1 `@stdlib/ArgTools`\n  [56f22d72] Artifacts `@stdlib/Artifacts`\n  [2a0f44e3] Base64 `@stdlib/Base64`\n  [ade2ca70] Dates `@stdlib/Dates`\n  [f43a241f] Downloads v1.6.0 `@stdlib/Downloads`\n  [7b1f6079] FileWatching `@stdlib/FileWatching`\n  [9fa8497b] Future `@stdlib/Future`\n  [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`\n  [4af54fe1] LazyArtifacts `@stdlib/LazyArtifacts`\n  [b27032c2] LibCURL v0.6.3 `@stdlib/LibCURL`\n  [76f85450] LibGit2 `@stdlib/LibGit2`\n  [8f399da3] Libdl `@stdlib/Libdl`\n  [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`\n  [56ddb016] Logging `@stdlib/Logging`\n  [d6f4376e] Markdown `@stdlib/Markdown`\n  [a63ad114] Mmap `@stdlib/Mmap`\n  [ca575930] NetworkOptions v1.2.0 `@stdlib/NetworkOptions`\n  [44cfe95a] Pkg v1.8.0 `@stdlib/Pkg`\n  [de0858da] Printf `@stdlib/Printf`\n  [3fa0cd96] REPL `@stdlib/REPL`\n  [9a3f8284] Random `@stdlib/Random`\n  [ea8e919c] SHA v0.7.0 `@stdlib/SHA`\n  [9e88b42a] Serialization `@stdlib/Serialization`\n  [6462fe0b] Sockets `@stdlib/Sockets`\n  [2f01184e] SparseArrays `@stdlib/SparseArrays`\n  [10745b16] Statistics `@stdlib/Statistics`\n  [4607b0f0] SuiteSparse `@stdlib/SuiteSparse`\n  [fa267f1f] TOML v1.0.0 `@stdlib/TOML`\n  [a4e569a6] Tar v1.10.0 `@stdlib/Tar`\n  [8dfed614] Test `@stdlib/Test`\n  [cf7118a7] UUIDs `@stdlib/UUIDs`\n  [4ec0a83e] Unicode `@stdlib/Unicode`\n  [e66e0078] CompilerSupportLibraries_jll v0.5.2+0 `@stdlib/CompilerSupportLibraries_jll`\n  [deac9b47] LibCURL_jll v7.84.0+0 `@stdlib/LibCURL_jll`\n  [29816b5a] LibSSH2_jll v1.10.2+0 `@stdlib/LibSSH2_jll`\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0 `@stdlib/MbedTLS_jll`\n  [14a3606d] MozillaCACerts_jll v2022.2.1 `@stdlib/MozillaCACerts_jll`\n  [4536629a] OpenBLAS_jll v0.3.21+0 `@stdlib/OpenBLAS_jll`\n  [05823500] OpenLibm_jll v0.8.1+0 `@stdlib/OpenLibm_jll`\n  [bea87d4a] SuiteSparse_jll v5.10.1+0 `@stdlib/SuiteSparse_jll`\n  [83775a58] Zlib_jll v1.2.12+3 `@stdlib/Zlib_jll`\n  [8e850b90] libblastrampoline_jll v5.1.1+0 `@stdlib/libblastrampoline_jll`\n  [8e850ede] nghttp2_jll v1.48.0+0 `@stdlib/nghttp2_jll`\n  [3f19e933] p7zip_jll v17.4.0+0 `@stdlib/p7zip_jll`\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading.\n     Testing Running tests...\nERROR: LoadError: ArgumentError: Package Distributions [31c24e10-a181-5473-b8eb-7969acd0382f] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\nStacktrace:\n [1] _require(pkg::Base.PkgId, env::String)\n   @ Base ./loading.jl:1390\n [2] _require_prelocked(uuidkey::Base.PkgId, env::String)\n   @ Base ./loading.jl:1281\n [3] macro expansion\n   @ ./loading.jl:1261 [inlined]\n [4] macro expansion\n   @ ./lock.jl:267 [inlined]\n [5] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1224\n [6] include\n   @ ./Base.jl:434 [inlined]\n [7] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String)\n   @ Base ./loading.jl:1638\n [8] top-level scope\n   @ stdin:1\nin expression starting at /home/pkgeval/.julia/packages/Bootstrap/6veet/src/Bootstrap.jl:1\nin expression starting at stdin:1\nERROR: LoadError: Failed to precompile Bootstrap [e28b5b4c-05e8-5b66-bc03-6f0c0a0a06e0] to /home/pkgeval/.julia/compiled/v1.9/Bootstrap/jl_ZDIgbE.\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n  [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool)\n    @ Base ./loading.jl:1789\n  [3] compilecache\n    @ ./loading.jl:1733 [inlined]\n  [4] _require(pkg::Base.PkgId, env::String)\n    @ Base ./loading.jl:1421\n  [5] _require_prelocked(uuidkey::Base.PkgId, env::String)\n    @ Base ./loading.jl:1281\n  [6] macro expansion\n    @ ./loading.jl:1261 [inlined]\n  [7] macro expansion\n    @ ./lock.jl:267 [inlined]\n  [8] require(into::Module, mod::Symbol)\n    @ Base ./loading.jl:1224\n  [9] include(fname::String)\n    @ Base.MainInclude ./client.jl:478\n [10] top-level scope\n    @ ~/.julia/packages/Bootstrap/6veet/test/runtests.jl:8\n [11] include(fname::String)\n    @ Base.MainInclude ./client.jl:478\n [12] top-level scope\n    @ none:6\nin expression starting at /home/pkgeval/.julia/packages/Bootstrap/6veet/test/test-non-parametric.jl:1\nin expression starting at /home/pkgeval/.julia/packages/Bootstrap/6veet/test/runtests.jl:6\n```\n\nIt would be great if Julia/Pkg were robust against such corruption, reinstalling the affected package when needed. Alternatively, avoiding the corruption in the first place would be great as well. I think it was either caused by multiple testers writing to the package store at the same time (which would require locking), or a well-timed cancellation signal leaving the folder in a bad state (which would require the final operation to be atomic). I'm not familiar with Pkg so don't know if either of these is already the case.","[fredrikekre]: Related: #1683, #1717. | [rfourquet]: Another case where corruption happens is when the disk becomes full while downloading a package.",2,false,0,0,0,0,0,0,0,0,0
3434,Bug in Pkg.PackageSpec: breaks when default branch of a repo changes,open,MilesCranmer,,,,2,2023-04-04T10:51:14.0,2023-04-04T14:23:19.0,838,838,https://github.com/JuliaLang/Pkg.jl/issues/3434,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3434,"It seems that `Pkg.PackageSpec` breaks when the default branch of a repository ~~is `main` rather than `master`~~ changes. Somewhere in the pipeline, there is a check which assumes that all packages have a master branch as their default.\n\nFor example, here is installing SymbolicRegression.jl at a specific git tag, which works fine, because `SymbolicRegression.jl` uses `master` as its default:\n\n```julia\nusing Pkg\n\nspec = PackageSpec(; name=""""SymbolicRegression"""", rev=""""v0.16.0"""")\nPkg.add(spec)\n```\n\nHowever, the same seems to fail for LoopVectorization.jl, which uses `main` as its default branch instead of `master`:\n\n```julia\nspec = PackageSpec(; name=""""LoopVectorization"""", rev=""""v0.12.150"""")\nPkg.add(spec)\n```\n\nThis fails with the following error:\n\n```julia\nERROR: invalid git HEAD (reference 'refs/heads/master' not found)\nStacktrace:\n  [1] pkgerror(msg::String)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:69\n  [2] check_valid_HEAD(repo::LibGit2.GitRepo)\n    @ Pkg.GitTools ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:332\n  [3] (::Pkg.Types.var""""#57#58""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String})(repo::LibGit2.GitRepo)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:746\n  [4] with(f::Pkg.Types.var""""#57#58""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String}, obj::LibGit2.GitRepo)\n    @ LibGit2 ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/LibGit2/src/types.jl:1159\n  [5] handle_repo_add!(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:744\n  [6] handle_repos_add!(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:814\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:255\n  [8] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:156\n  [9] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:145\n [10] #add#24\n    @ ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:143 [inlined]\n [11] add(pkg::Pkg.Types.PackageSpec)\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:143\n [12] top-level scope\n    @ REPL[8]:1\n\ncaused by: GitError(Code:EUNBORNBRANCH, Class:Reference, reference 'refs/heads/master' not found)\nStacktrace:\n  [1] macro expansion\n    @ ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/LibGit2/src/error.jl:111 [inlined]\n  [2] head(repo::LibGit2.GitRepo)\n    @ LibGit2 ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/LibGit2/src/reference.jl:44\n  [3] check_valid_HEAD(repo::LibGit2.GitRepo)\n    @ Pkg.GitTools ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/GitTools.jl:330\n  [4] (::Pkg.Types.var""""#57#58""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String})(repo::LibGit2.GitRepo)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:746\n  [5] with(f::Pkg.Types.var""""#57#58""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String}, obj::LibGit2.GitRepo)\n    @ LibGit2 ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/LibGit2/src/types.jl:1159\n  [6] handle_repo_add!(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:744\n  [7] handle_repos_add!(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/Types.jl:814\n  [8] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:255\n  [9] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:156\n [10] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:145\n [11] #add#24\n    @ ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:143 [inlined]\n [12] add(pkg::Pkg.Types.PackageSpec)\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-rc2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.9/Pkg/src/API.jl:143\n [13] top-level scope\n    @ REPL[8]:1\n```\n\nThe curious thing is that this also breaks even if I specify the branch: `PackageSpec(; name=""""LoopVectorization"""", rev=""""main"""")`.\n\n---\n\n(This is on Julia 1.9.0-rc2)","[KristofferC]: I think the issue is when the default branch changes. Pkg has some cache of repos so it doesn't have to reclone from scratch and it doesn't like when the default changes it seems. You can delete `.julia/clones` to workaround it. | [MilesCranmer]: Thanks, that seems like the issue! The workaround patched it on my machine.\nCheers,\nMiles",2,false,0,0,0,0,0,0,0,0,0
3427,Should `up Foo` instantitate first?,open,oxinabox,,,,0,2023-03-31T02:17:50.0,2023-03-31T02:17:50.0,842,842,https://github.com/JuliaLang/Pkg.jl/issues/3427,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3427,Not sure how i ended up in this state but:\nI got an error that was basically.\n\n```\n>pkg up Foo\n... \nError: expected to find Bar at ~/.julia/packages/...\n```\n\nwhich i fixed by running `pkg> instantiate`  then retrying.\n\n,,0,false,0,0,0,0,0,0,0,0,0
3420,Pkg.Registry.rm ERROR: MethodError: no method matching rm(::SubString{String}),open,schlichtanders,,,,0,2023-03-22T14:38:05.0,2023-03-22T14:41:11.0,851,851,https://github.com/JuliaLang/Pkg.jl/issues/3420,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3420,"It turns out `Pkg.Registry.rm` does not support `SubString{String}`, probably others as well.\n\nIt would be great to support any AbstractString to increase user-friendliness\n\n```julia\nERROR: MethodError: no method matching rm(::SubString{String})\nYou may have intended to import Base.rm\nClosest candidates are:\n  rm(!Matched::Union{String, Pkg.Registry.RegistrySpec}; kwargs...) at /usr/local/julia/share/julia/stdlib/v1.8/Pkg/src/Registry/Registry.jl:271\n  rm(!Matched::Vector{String}; kwargs...) at /usr/local/julia/share/julia/stdlib/v1.8/Pkg/src/Registry/Registry.jl:272\n  rm(!Matched::Vector{Pkg.Registry.RegistrySpec}; io) at /usr/local/julia/share/julia/stdlib/v1.8/Pkg/src/Registry/Registry.jl:273\nStacktrace:\n [1] top-level scope\n   @ none:1\n```\n\nusing Julia standard docker v1.8.5\n",,0,false,0,0,0,0,0,0,0,0,0
3417,Official API for `resolve()`,open,staticfloat,,speculative,,4,2023-03-21T22:06:21.0,2023-03-22T13:29:43.0,851,851,https://github.com/JuliaLang/Pkg.jl/issues/3417,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3417,"It would be nice to have an official API for asking Pkg to resolve a set of `PackageSpec` objects.  This is useful as an analogue to the old """"dry run"""" option, but dodges all the complexity that currently exists in `add()`, which must worry about many other things such as artifacts, updating environments, etc...  This API would be much purer, just given a set of `PackageSpec` objects, resolve them.  We don't even need to worry about preservation levels or whatnot because we're not doing it in the context of an existing manifest.\n\nCurrently, I'm using the following snippet:\n\n```julia\nusing Pkg\nusing Pkg.Types: PackageSpec, VersionSpec, Context, registry_resolve!, PRESERVE_NONE\nusing Pkg.Operations: targeted_resolve\n\nusing Pkg\nusing Pkg.Types: PackageSpec, VersionSpec, Context, EnvCache, registry_resolve!, PRESERVE_NONE\nusing Pkg.Operations: targeted_resolve\n\n\nfunction resolve(pkgs::Vector{PackageSpec}; julia_version=VERSION)\n    # There doesn't seem to be a better way to get an """"empty"""" `EnvCache`\n    # than to construct it off of an empty directory, so that's what we do\n    mktempdir() do dir\n        ctx = Context(;env=EnvCache(dir))\n\n        # Don't mutate the user's input\n        pkgs = copy(pkgs)\n\n        # Normalize each pkg to have a UUID and a name, at least\n        registry_resolve!(ctx.registries, pkgs)\n\n        # Resolve to get versions\n        pkgs, deps_map = Pkg.Operations.targeted_resolve(\n            ctx.env,\n            ctx.registries,\n            pkgs,\n            PRESERVE_NONE,\n            julia_version,\n        )\n        return pkgs, deps_map\n    end\nend\n```\n\nAnd I'm using it like so:\n```\npkgs = [\n    PackageSpec(; name=""""Glibc_jll"""", version=VersionSpec(""""2.12"""")),\n    PackageSpec(; name=""""Zlib_jll""""),\n]\nresolved_pkgs = resolve(pkgs; julia_version=nothing)\n@info(""""Glibc_jll"""", pkg=only(filter(p -> p.name == """"Glibc_jll"""", resolved_pkgs)))\n@info(""""Zlib_jll"""", pkg=only(filter(p -> p.name == """"Zlib_jll"""", resolved_pkgs)))\n```\n\nWhich gives:\n```\n┌ Info: Glibc_jll\n│   pkg =\n│    PackageSpec(\n│      name = Glibc_jll\n│      uuid = 452aa2e7-e185-58db-8ff9-d3c1fa4bc997\n│      tree_hash = ce74e85d6feb1b58cb2515c6ca68ae639eb82078\n│      version = v""""2.12.2+6""""\n└    )\n┌ Info: Zlib_jll\n│   pkg =\n│    PackageSpec(\n│      name = Zlib_jll\n│      uuid = 83775a58-1f1d-513f-b197-d71354ab007a\n│      tree_hash = 866bc7103cfb6233c35d6f1b2c6bd23ef9f6fe5f\n│      version = v""""1.2.13+0""""\n└    )\n```\n\nDoes something like this seem generally useful?  Should we include a `resolve()` endpoint similar to this?  I realize that I'm dodging some of the complexity here by using `mktempdir()` to construct an empty environment.","[KristofferC]: You also need to download everything that uses a git rev. | [KristofferC]: Note that there is https://github.com/JuliaLang/Pkg.jl/blob/1c6ba558c673d22f8ff41b3f2ebaf72e3d8b1e44/src/API.jl#L353-L356\n\nWith the `skip_writing_project`, it seems something along what is desired here has been started there. | [staticfloat]: Hmmm, good point.  How am I supposed to feed it the package specs and get the versions out again?  Through the `Ctx.env.manifest`? | [fonsp]: I would love to have this API! I have wished this existed many times before :) This would also resolve dependencies, right? (E.g. `Pkg.resolve([Pkg.PackageSpec(name=""""LiveServer"""")])` would tell me the version of `HTTP` that was resolved.)",4,false,4,1,0,0,1,0,1,1,0
3113,`Pkg.add` doesn't install the requested version of JLL stdlib,open,giordano,,binarybuilder,,2,2022-06-16T21:26:43.0,2023-03-20T18:25:46.0,1129,852,https://github.com/JuliaLang/Pkg.jl/issues/3113,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3113,"```julia\njulia> using Pkg\n\njulia> Pkg.activate(; temp=true, io=devnull)\n\njulia> ctx = Pkg.Types.Context(; julia_version=nothing);\n\njulia> Pkg.add(ctx, [Pkg.Types.PackageSpec(; name = """"LibCURL_jll"""", tree_hash = Base.SHA1(""""cab60d2381bf2a404bcccccb7b3f861aafcb3ad8""""))])\n   Resolving package versions...\n    Updating `/tmp/jl_xnCKPo/Project.toml`\n  [deac9b47] + LibCURL_jll v7.83.1+1\n```\nand\n```julia\njulia> using Pkg, UUIDs\n\njulia> Pkg.activate(; temp=true, io=devnull)\n\njulia> ctx = Pkg.Types.Context(; julia_version=nothing);\n\njulia> spec = Pkg.PackageSpec(\n           ;\n           name = """"LibCURL_jll"""",\n           uuid = UUID(""""deac9b47-8bc7-5906-a0fe-35ac56dc84c0""""),\n           tree_hash = Base.SHA1(""""cab60d2381bf2a404bcccccb7b3f861aafcb3ad8""""),\n           version = Pkg.Types.VersionSpec(""""*""""),\n           repo=Pkg.Types.GitRepo(\n               ;\n               rev=""""4b758d9a039000f3344c8cbb38031b06f1e5148b"""",\n               source=""""https://github.com/JuliaBinaryWrappers/LibCURL_jll.jl.git"""",\n           ),\n       );\n\njulia> Pkg.add(ctx, [spec])\n   Resolving package versions...\n    Updating `/tmp/jl_KwyviO/Project.toml`\n  [deac9b47] + LibCURL_jll v7.73.0+4 `https://github.com/JuliaBinaryWrappers/LibCURL_jll.jl.git#4b758d9`\n```\n\nDespite all our best efforts to ask Pkg to install a very specific version of `LibCURL_jll` ([`7.81.0+0`](https://github.com/JuliaRegistries/General/blob/18fa4e80204518bf81e44b097d90559f6bb08353/L/LibCURL_jll/Versions.toml#L43-L44), with tree hash `cab60d2381bf2a404bcccccb7b3f861aafcb3ad8`, from commit https://github.com/JuliaBinaryWrappers/LibCURL_jll.jl/commit/4b758d9a039000f3344c8cbb38031b06f1e5148b), `Pkg` installs completely different versions.  Of course we rely on `Pkg` providing us precisely the requested version in BinaryBuilder.","[KristofferC]: AFAIK, the only input that Pkg uses from PackageSpec is: `name`, `uuid`, `version`, `repo`. The rest are """"filler"""" fields to be filled in when the package has been downloaded. So specifying e.g `tree_hash` does nothing (there is no functionality in Pkg to add a package based on the tree hash directly).\n\n> Despite all our best efforts to ask Pkg to install a very specific version of LibCURL_jll ([7.81.0+0](https://github.com/JuliaRegistries/General/blob/18fa4e80204518bf81e44b097d90559f6bb08353/L/LibCURL_jll/Versions.toml#L43-L44), with tree hash cab60d2381bf2a404bcccccb7b3f861aafcb3ad8, from commit https://github.com/JuliaBinaryWrappers/LibCURL_jll.jl/commit/4b758d9a039000f3344c8cbb38031b06f1e5148b), Pkg installs completely different versions\n\nLocally (on 1.8): \n\n```\njulia> Pkg.add(ctx, [spec])\n...\n    Updating `/tmp/jl_EJYGaC/Project.toml`\n  [deac9b47] + LibCURL_jll v7.81.0+0 `https://github.com/JuliaBinaryWrappers/LibCURL_jll.jl.git#4b758d9`\n```\n\nOn 1.7 it says it has the old version, I guess that is because it picks it up from the stdlib project version.\n\n | [giordano]: Yes, we want to install in Julia v1.7 (or _any_ other versions) the version of the package for Julia v1.8. So using Julia v1.8 specifically isn't useful to see the issue",2,false,0,0,0,0,0,0,0,0,0
2942,"`Pkg.add(Pkg.Types.Context(;julia_version), [PackageSpec(...)])` failing since Julia v1.7",open,giordano,,binarybuilder,,10,2022-01-16T17:35:49.0,2023-03-20T18:25:45.0,1280,852,https://github.com/JuliaLang/Pkg.jl/issues/2942,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2942,"Julia v1.6:\n```\njulia> using Pkg\n\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.6.3""""), [PackageSpec(;name=""""libjulia_jll"""")])\nb040-befd59781bbf""""), version=Pkg.Types.VersionSpec(""""*""""))])\n   Resolving package versions...\n    Updating `/tmp/jl_aPeyH5/Project.toml`\n  [5ad3ddd2] + libjulia_jll v1.7.0+8\n    Updating `/tmp/jl_aPeyH5/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.4.0\n  [21216c6a] + Preferences v1.2.3\n  [5ad3ddd2] + libjulia_jll v1.7.0+8\n  [0dad84c5] + ArgTools\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions\n  [44cfe95a] + Pkg\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML\n  [a4e569a6] + Tar\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll\n  [a83860b7] + LibOSXUnwind_jll\n  [29816b5a] + LibSSH2_jll\n  [183b4373] + LibUV_jll\n  [745a5e78] + LibUnwind_jll\n  [c8ffd9c3] + MbedTLS_jll\n  [14a3606d] + MozillaCACerts_jll\n  [83775a58] + Zlib_jll\n  [8f36deef] + libLLVM_jll\n  [8e850ede] + nghttp2_jll\n  [3f19e933] + p7zip_jll\n```\n\nJulia v1.7:\n```\njulia> using Pkg\n\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.6.3""""), [PackageSpec(;name=""""libjulia_jll"""")])\n   Resolving package versions...\nERROR: KeyError: key UUID(""""a83860b7-747b-57cf-bf1f-3e79990d037f"""") not found\nStacktrace:\n  [1] getindex\n    @ ./dict.jl:481 [inlined]\n  [2] deps_graph(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, uuid_to_name::Dict{UUID, String}, reqs::Dict{UUID, Pkg.Versions.VersionSpec}, fixed::Dict{UUID, Pkg.Resolve.Fixed}, julia_version::VersionNumber)\n    @ Pkg.Operations /usr/share/julia/stdlib/v1.7/Pkg/src/Operations.jl:408\n  [3] resolve_versions!(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n    @ Pkg.Operations /usr/share/julia/stdlib/v1.7/Pkg/src/Operations.jl:334\n  [4] targeted_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n    @ Pkg.Operations /usr/share/julia/stdlib/v1.7/Pkg/src/Operations.jl:1154\n  [5] tiered_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n    @ Pkg.Operations /usr/share/julia/stdlib/v1.7/Pkg/src/Operations.jl:1125\n  [6] _resolve(io::Base.TTY, env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n    @ Pkg.Operations /usr/share/julia/stdlib/v1.7/Pkg/src/Operations.jl:1160\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Set{UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations /usr/share/julia/stdlib/v1.7/Pkg/src/Operations.jl:1176\n  [8] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /usr/share/julia/stdlib/v1.7/Pkg/src/API.jl:268\n  [9] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /usr/share/julia/stdlib/v1.7/Pkg/src/API.jl:221\n [10] top-level scope\n    @ REPL[9]:1\n```\n\nJulia master:\n```\njulia> using Pkg\n\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.6.3""""), [PackageSpec(;name=""""libjulia_jll"""")])\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\nERROR: AssertionError: proj_file !== nothing\nStacktrace:\n [1] deps_graph(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, uuid_to_name::Dict{UUID, String}, reqs::Dict{UUID, Pkg.Versions.VersionSpec}, fixed::Dict{UUID, Pkg.Resolve.Fixed}, julia_version::VersionNumber)\n   @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:432\n [2] resolve_versions!(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n   @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:346\n [3] targeted_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n   @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1197\n [4] tiered_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n   @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1168\n [5] _resolve(io::Base.TTY, env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n   @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1203\n [6] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Set{UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n   @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1219\n [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Pkg.API ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/API.jl:275\n [8] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n   @ Pkg.API ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/API.jl:228\n [9] top-level scope\n   @ REPL[3]:1\n```\n\nNo idea what the errors mean","[giordano]: Using the `julia_versions=v""""1.7""""` context works somewhere:\n\njulia v1.6:\n```\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.7""""), [PackageSpec(;name=""""libjulia_jll"""")])\n   Resolving package versions...\n    Updating `/tmp/jl_aPeyH5/Project.toml`\n  [5ad3ddd2] + libjulia_jll v1.6.0+0\n    Updating `/tmp/jl_aPeyH5/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.4.0\n  [21216c6a] + Preferences v1.2.3\n  [dfe201cf] + Objconv_jll v2.49.1+1\n  [5ad3ddd2] + libjulia_jll v1.6.0+0\n  [00992c89] + utf8proc_jll v2.6.1+0\n  [0dad84c5] + ArgTools\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions\n  [44cfe95a] + Pkg\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML\n  [a4e569a6] + Tar\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [e66e0078] + CompilerSupportLibraries_jll\n  [781609d7] + GMP_jll\n  [deac9b47] + LibCURL_jll\n  [e37daf67] + LibGit2_jll\n  [a83860b7] + LibOSXUnwind_jll v0.0.6+2\n  [29816b5a] + LibSSH2_jll\n  [183b4373] + LibUV_jll\n  [745a5e78] + LibUnwind_jll\n  [3a97d323] + MPFR_jll\n  [c8ffd9c3] + MbedTLS_jll\n  [14a3606d] + MozillaCACerts_jll\n  [4536629a] + OpenBLAS_jll\n  [05823500] + OpenLibm_jll\n  [efcefdf7] + PCRE2_jll\n  [bea87d4a] + SuiteSparse_jll\n  [83775a58] + Zlib_jll\n  [05ff407c] + dSFMT_jll\n  [8f36deef] + libLLVM_jll\n  [8e850ede] + nghttp2_jll\n  [3f19e933] + p7zip_jll\n```\n\nJulia v1.7:\n```\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.7""""), [PackageSpec(;name=""""libjulia_jll"""")])\n   Resolving package versions...\n    Updating `/tmp/jl_CgDN0W/Project.toml`\n  [5ad3ddd2] + libjulia_jll v1.7.0+8\n    Updating `/tmp/jl_CgDN0W/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.4.0\n  [21216c6a] + Preferences v1.2.3\n  [a83860b7] + LibOSXUnwind_jll v0.0.6+2\n  [5ad3ddd2] + libjulia_jll v1.7.0+8\n  [0dad84c5] + ArgTools\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions\n  [44cfe95a] + Pkg\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML\n  [a4e569a6] + Tar\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll\n  [29816b5a] + LibSSH2_jll\n  [183b4373] + LibUV_jll\n  [745a5e78] + LibUnwind_jll\n  [c8ffd9c3] + MbedTLS_jll\n  [14a3606d] + MozillaCACerts_jll\n  [83775a58] + Zlib_jll\n  [8f36deef] + libLLVM_jll\n  [8e850ede] + nghttp2_jll\n  [3f19e933] + p7zip_jll\n```\n\nJulia master:\n```\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.7""""), [PackageSpec(;name=""""libjulia_jll"""")])\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\n  Downloaded artifact: libjulia\n    Updating `/tmp/Project.toml`\n  [5ad3ddd2] + libjulia_jll v1.7.0+8\n    Updating `/tmp/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.4.0\n  [21216c6a] + Preferences v1.2.3\n  [5ad3ddd2] + libjulia_jll v1.7.0+8\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads v1.5.2\n  [7b1f6079] + FileWatching\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL v0.6.2\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.7.0\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML v1.0.0\n  [a4e569a6] + Tar v1.10.0\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll v7.73.0+4\n  [29816b5a] + LibSSH2_jll v1.9.1+2\n  [183b4373] + LibUV_jll v2.0.1+5\n  [745a5e78] + LibUnwind_jll v1.3.2+0\n  [c8ffd9c3] + MbedTLS_jll v2.24.0+2\n  [14a3606d] + MozillaCACerts_jll v2020.7.22\n  [83775a58] + Zlib_jll v1.2.12+1\n  [8e850ede] + nghttp2_jll v1.41.0+1\n  [3f19e933] + p7zip_jll v16.2.1+1\n``` | [barche]: On Mac with Julia 1.7.1 the last command fails for me too, but with a different error:\n\n```\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.7""""), [PackageSpec(;name=""""libjulia_jll"""")])\n    Updating registry at `~/tmp/depot_pkg/registries/General.toml`\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package libjulia_jll [5ad3ddd2]:\n libjulia_jll [5ad3ddd2] log:\n ├─possible versions are: 1.3.1-1.7.0 or uninstalled\n ├─restricted to versions * by an explicit requirement, leaving only versions 1.3.1-1.7.0\n ├─restricted by compatibility requirements with GMP_jll [781609d7] to versions: [1.3.1, 1.5.1-1.7.0] or uninstalled, leaving only versions: [1.3.1, 1.5.1-1.7.0]\n │ └─GMP_jll [781609d7] log:\n │   └─possible versions are: 6.2.1 or uninstalled\n ├─restricted by compatibility requirements with PCRE2_jll [efcefdf7] to versions: 1.5.4-1.7.0 or uninstalled, leaving only versions: 1.5.4-1.7.0\n │ └─PCRE2_jll [efcefdf7] log:\n │   └─possible versions are: 10.36.0 or uninstalled\n └─restricted by compatibility requirements with libLLVM_jll [8f36deef] to versions: 1.3.1 or uninstalled — no versions left\n   └─libLLVM_jll [8f36deef] log:\n     └─possible versions are: 12.0.1 or uninstalled\n``` | [giordano]: That's totally unrelated and addressed by https://github.com/JuliaRegistries/General/pull/52551 | [vchuravy]: ```\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.6.3""""), [PackageSpec(;name=""""libjulia_jll"""")])\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\nERROR: AssertionError: proj_file !== nothing\n```\n\nOn 1.8-dev means that is thinks it is a stdlib:\n```\n(stdlib_name, stdlib_version) = stdlibs_for_julia_version[uuid] = (""""LibOSXUnwind_jll"""", v""""0.0.6+1"""")\nuuid_is_stdlib = true\nis_unregistered_stdlib(uuid) = false\n``` | [KristofferC]: What happens is that it detects that `LibOSXUnwind_jll` is an stdlib on 1.6, tries to find its project file so it can read its version and dependencies. But it can't find that file on Julia 1.7 so it errors. We need to know the dependencies of an stdlib to add it so presumably that needs to also go into https://github.com/JuliaLang/Pkg.jl/blob/master/src/HistoricalStdlibs.jl?\n\nThe reason it works on 1.6 is that at that point `LibOSXUnwind_jll` was in fact an stdlib so the project file existed. I guess. | [staticfloat]: > We need to know the dependencies of an stdlib to add it so presumably that needs to also go into https://github.com/JuliaLang/Pkg.jl/blob/master/src/HistoricalStdlibs.jl?\n\nWe could, or we could register `LibOSXUnwind_jll` in the `General` registry, perhaps? | [giordano]: > We could, or we could register `LibOSXUnwind_jll` in the `General` registry, perhaps?\n\nIt's already: https://github.com/JuliaRegistries/General/tree/ab0e73d69d28bf7a656fd57b7a4d094d641ff49d/L/LibOSXUnwind_jll | [giordano]: More datapoints, with v1.7:\n```\njulia> Pkg.add(Pkg.Types.Context(;julia_version=nothing), [BinaryBuilderBase.get_addable_spec(""""LibOSXUnwind_jll"""", v""""0.0.6+1"""")])\n   Resolving package versions...\n    Updating `/tmp/jl_nlveah/Project.toml`\n  [a83860b7] + LibOSXUnwind_jll v0.0.6+1 `https://github.com/JuliaBinaryWrappers/LibOSXUnwind_jll.jl.git#6e33af9`\n    Updating `/tmp/jl_nlveah/Manifest.toml`\n  [34da2185] + Compat v2.2.1\n  [692b3bcd] + JLLWrappers v1.4.0\n  [21216c6a] + Preferences v1.2.3\n  [a83860b7] + LibOSXUnwind_jll v0.0.6+1 `https://github.com/JuliaBinaryWrappers/LibOSXUnwind_jll.jl.git#6e33af9`\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts v1.3.0\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [8bb1440f] + DelimitedFiles\n  [8ba89e20] + Distributed\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL v0.6.3\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [37e2e46d] + LinearAlgebra\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [a63ad114] + Mmap\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.5.7\n  [9e88b42a] + Serialization\n  [1a1011a3] + SharedArrays\n  [6462fe0b] + Sockets\n  [2f01184e] + SparseArrays\n  [10745b16] + Statistics\n  [fa267f1f] + TOML v1.0.3\n  [a4e569a6] + Tar v1.9.2\n  [8dfed614] + Test\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll v7.71.1+0\n  [29816b5a] + LibSSH2_jll v1.10.1+0\n  [c8ffd9c3] + MbedTLS_jll v2.28.0+0\n  [14a3606d] + MozillaCACerts_jll v2021.1.19+0\n  [83775a58] + Zlib_jll v1.2.12+2\n  [8e850b90] + libblastrampoline_jll v4.0.0+0\n  [8e850ede] + nghttp2_jll v1.41.0+2\n  [3f19e933] + p7zip_jll v16.2.1+2\n\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.6.0""""), [BinaryBuilderBase.get_addable_spec(""""LibOSXUnwind_jll"""", v""""0.0.6+1"""")])\nERROR: IOError: mkdir(""""/usr/share/julia/stdlib/v1.7/LibOSXUnwind_jll""""; mode=0o777): permission denied (EACCES)\nStacktrace:\n  [1] uv_error\n    @ ./libuv.jl:97 [inlined]\n  [2] mkdir(path::String; mode::UInt16)\n    @ Base.Filesystem ./file.jl:183\n  [3] mkpath(path::String; mode::UInt16)\n    @ Base.Filesystem ./file.jl:234\n  [4] mkpath\n    @ ./file.jl:229 [inlined]\n  [5] (::Pkg.Types.var""""#42#43""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String})(repo::GitRepo)\n    @ Pkg.Types /usr/share/julia/stdlib/v1.7/Pkg/src/Types.jl:732\n  [6] with(f::Pkg.Types.var""""#42#43""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String}, obj::GitRepo)\n    @ LibGit2 /usr/share/julia/stdlib/v1.7/LibGit2/src/types.jl:1150\n  [7] handle_repo_add!(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec)\n    @ Pkg.Types /usr/share/julia/stdlib/v1.7/Pkg/src/Types.jl:676\n  [8] handle_repos_add!(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.Types /usr/share/julia/stdlib/v1.7/Pkg/src/Types.jl:743\n  [9] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Platform, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /usr/share/julia/stdlib/v1.7/Pkg/src/API.jl:248\n [10] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /usr/share/julia/stdlib/v1.7/Pkg/src/API.jl:221\n [11] top-level scope\n    @ REPL[36]:1\n```\n[`BinaryBuilderBase.get_addable_spec`](https://juliapackaging.github.io/BinaryBuilderBase.jl/stable/#BinaryBuilderBase.get_addable_spec-Tuple{AbstractString,%20VersionNumber}) is a good solution when we don't specify the julia version, but the bug shows up when we use `julia_version=v""""1.6.0""""` | [giordano]: Uhm, this actually seems to work in master:\n```\njulia> using BinaryBuilderBase, Pkg\n\njulia> Pkg.add(Pkg.Types.Context(;julia_version=v""""1.6.0""""), [BinaryBuilderBase.get_addable_spec(""""LibOSXUnwind_jll"""", v""""0.0.6+1"""")])\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\n    Updating `/tmp/jl_JE0aOc/Project.toml`\n  [a83860b7] + LibOSXUnwind_jll v0.0.6+1 `https://github.com/JuliaBinaryWrappers/LibOSXUnwind_jll.jl.git#6e33af9`\n    Updating `/tmp/jl_JE0aOc/Manifest.toml`\n  [a83860b7] + LibOSXUnwind_jll v0.0.6+1 `https://github.com/JuliaBinaryWrappers/LibOSXUnwind_jll.jl.git#6e33af9`\n  [f43a241f] ↓ Downloads v1.6.0 ⇒ v1.4.0\n  [b27032c2] ↓ LibCURL v0.6.3 ⇒ v0.6.2\n  [44cfe95a] ↓ Pkg v1.8.0 ⇒ v1.5.0\n  [ea8e919c] ~ SHA v0.7.0 ⇒ \n  [a4e569a6] ↓ Tar v1.10.0 ⇒ v1.9.0\n  [deac9b47] ↓ LibCURL_jll v7.73.0+4 ⇒ v7.73.0+3\n  [29816b5a] ↓ LibSSH2_jll v1.9.1+2 ⇒ v1.9.1+0\n  [c8ffd9c3] ↓ MbedTLS_jll v2.24.0+2 ⇒ v2.24.0+1\n  [83775a58] ↓ Zlib_jll v1.2.12+1 ⇒ v1.2.12+0\n  [8e850ede] ↓ nghttp2_jll v1.41.0+1 ⇒ v1.41.0+0\n  [3f19e933] ↓ p7zip_jll v16.2.1+1 ⇒ v16.2.1+0\n```\nMaybe there is a fix that can be backported to v1.7? | [giordano]: Nevermind, that doesn't actually work because nothing is actually installed in practice, because of #2930",10,false,0,0,0,0,0,0,0,0,0
2938,Error `no method matching length(::Pkg.Versions.VersionSpec)` when passing context to `Pkg.add` if the version is a string,open,giordano,,binarybuilder,,4,2022-01-13T11:34:32.0,2023-03-20T18:25:44.0,1284,852,https://github.com/JuliaLang/Pkg.jl/issues/2938,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2938,"```julia\njulia> using Pkg\n\njulia> Pkg.add(Pkg.Types.Context(), [PackageSpec(;name=""""Example"""", version=""""0.5.3"""")])\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\nERROR: MethodError: no method matching length(::Pkg.Versions.VersionSpec)\nClosest candidates are:\n  length(::Union{Base.KeySet, Base.ValueIterator}) at ~/repo/julia/usr/share/julia/base/abstractdict.jl:58\n  length(::Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T, S}} where {T, S}) at ~/repo/julia/usr/share/julia/stdlib/v1.8/LinearAlgebra/src/adjtrans.jl:171\n  length(::LinRange) at ~/repo/julia/usr/share/julia/base/range.jl:755\n  ...\nStacktrace:\n  [1] union!(s::Set{Any}, itr::Pkg.Versions.VersionSpec)\n    @ Base ./abstractset.jl:99\n  [2] intersect!(s::Set{Any}, itr::Pkg.Versions.VersionSpec)\n    @ Base ./abstractset.jl:190\n  [3] _shrink(shrinker!::Function, itr::String, itrs::Tuple{Pkg.Versions.VersionSpec})\n    @ Base ./array.jl:2661\n  [4] intersect(itr::String, itrs::Pkg.Versions.VersionSpec)\n    @ Base ./array.jl:2665\n  [5] resolve_versions!(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n    @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:327\n  [6] targeted_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n    @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1187\n  [7] tiered_resolve(env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, julia_version::VersionNumber)\n    @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1158\n  [8] _resolve(io::Base.TTY, env::Pkg.Types.EnvCache, registries::Vector{Pkg.Registry.RegistryInstance}, pkgs::Vector{Pkg.Types.PackageSpec}, preserve::Pkg.Types.PreserveLevel, julia_version::VersionNumber)\n    @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1193\n  [9] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Set{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:1209\n [10] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/API.jl:274\n [11] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/API.jl:227\n [12] top-level scope\n    @ REPL[2]:1\n```\nIt works if the version is a `VersionNumber`, or if you don't pass the context as first argument to `Pkg.add`","[giordano]: BTW, this is a regression, it used to work in Julia v1.6:\n```julia\njulia> Pkg.add(Pkg.Types.Context(), [PackageSpec(;name=""""Example"""", version=""""0.5.3"""")])\n   Resolving package versions...\n    Updating `/tmp/jl_bo8zBW/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/tmp/jl_bo8zBW/Manifest.toml`\n  [7876af07] + Example v0.5.3\n```\nOf course I found also this bug while trying to upgrade BinaryBuilder to Julia v1.7 (https://github.com/JuliaPackaging/BinaryBuilderBase.jl/pull/129) | [KristofferC]: Well, it is not really a regression because calling `add` with a `Context` is using internals.\n\nLooking at the code you need to call `handle_package_input!` on the input `PackageSpec`.\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/c313966330e161d5fc8218d0144b80884b6d5657/src/API.jl#L155\n\nfor example.\n | [giordano]: Are you suggesting to fix a problem with the use of an internal function by using yet another internal function? :slightly_smiling_face:\n\nTo be honest, I'm happy to use `version::VersionNumber` everywhere and I opened the issue at least to document this behaviour (I bumped into this twice in one week, the second time I didn't remember what was the fix and I wasted again several minutes tracking the error down), but the fact that using `version::String` throws a totally unrelated error makes me think you should either not allow it in the first place or fix this behaviour internally. | [KristofferC]: > Are you suggesting to fix a problem with the use of an internal function by using yet another internal function?\n\nI don't really understand your point.  I just explained what you have to do if you want to call this internal function as things are right now. \n\nIt is possible that converting the string to a version number in the constructor would help.",4,false,0,0,0,0,0,0,0,0,0
2930,"`Pkg.add([PackageSpec(""GMP_jll"")]; julia_version=v""1.6"")` doesn't install anything",open,giordano,,binarybuilder,,9,2022-01-07T22:01:02.0,2023-03-20T18:25:43.0,1289,852,https://github.com/JuliaLang/Pkg.jl/issues/2930,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2930,"Trying to [make `BinaryBuilderBase` work with Julia nightly](https://github.com/JuliaPackaging/BinaryBuilderBase.jl/pull/129) I found that `Pkg.add([PackageSpec(""""GMP_jll"""")]; julia_version=v""""1.6"""")` does _nothing_:\n```\njulia> using Pkg, UUIDs\n\n(@v1.8) pkg> activate --temp\n  Activating new project at `/tmp/jl_KrcKAp`\n\njulia> Pkg.add([PackageSpec(""""GMP_jll"""")]; julia_version=v""""1.6"""")\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\n    Updating `/tmp/jl_KrcKAp/Project.toml`\n  [781609d7] + GMP_jll v6.2.0+5\n    Updating `/tmp/jl_KrcKAp/Manifest.toml`\n  [56f22d72] + Artifacts\n  [8f399da3] + Libdl\n  [781609d7] + GMP_jll v6.2.0+5\n```\nIf I use `Pkg.Operations.find_installed` to get the path where `v6.2.0+5` is installed I get\n```\njulia> Pkg.Operations.find_installed(""""GMP_jll"""", UUID(""""781609d7-10c4-51f6-84f2-b8444358ff6d""""), Base.SHA1(""""40388878122d491a2e55b0e730196098595d8a90""""))\n""""/home/mose/.julia/packages/GMP_jll/IA6Pi""""\n```\nbut this directory doesn't exist:\n```\nshell> ls $(Pkg.Operations.find_installed(""""GMP_jll"""", UUID(""""781609d7-10c4-51f6-84f2-b8444358ff6d""""), Base.SHA1(""""40388878122d491a2e55b0e730196098595d8a90"""")))\nls: cannot access '/home/mose/.julia/packages/GMP_jll/IA6Pi': No such file or directory\n\nshell> ls -l ~/.julia/packages/GMP_jll/\ntotal 4\ndrwxr-xr-x 3 mose mose 4096 Jan  7 19:32 i3hkK\n```\nThe only directory in `packages/GMP_jll` is `6.1.2+6`:\n```\njulia> Pkg.Operations.find_installed(""""GMP_jll"""", UUID(""""781609d7-10c4-51f6-84f2-b8444358ff6d""""), Base.SHA1(""""15abc5f976569a1c9d651aff02f7222ef305eb2a""""))\n""""/home/mose/.julia/packages/GMP_jll/i3hkK""""\n\nshell> ls -l $(Pkg.Operations.find_installed(""""GMP_jll"""", UUID(""""781609d7-10c4-51f6-84f2-b8444358ff6d""""), Base.SHA1(""""15abc5f976569a1c9d651aff02f7222ef305eb2a"""")))\ntotal 28\n-r--r--r-- 1 mose mose 8889 Jan  7 19:32 Artifacts.toml\n-r--r--r-- 1 mose mose 1545 Jan  7 19:32 LICENSE\n-r--r--r-- 1 mose mose  333 Jan  7 19:32 Project.toml\n-r--r--r-- 1 mose mose 3222 Jan  7 19:32 README.md\ndrwxr-xr-x 3 mose mose 4096 Jan  7 19:32 src\n```","[giordano]: For the record, it looks like in BinaryBuilder we're going to sidestep this issue by _not_ using `Pkg.add(; julia_version)`, but the fact that this doesn't work still stands. | [IanButterworth]: > by not `using Pkg.add(; julia_version)`\n\nGiven that exists for BB, if it's not needed perhaps it could be torn out? | [giordano]: It turns out that fixing this bug would still be useful to workaround #2942 | [fingolfin]: It sounds as to me as that it's not """"needed"""" in BB because it's broken, and BB works around it; so perhaps if it was fixed, BB would again want to use it? @giordano ? | [giordano]: I don't think the current implementation of [`BinaryBuilderBase.setup_dependencies`](https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/74fd093d3ab33f9410a64cd42b28662654a014fe/src/Prefix.jl#L535-L665) works around this bug, Elliot simply came up with a more straightforward way to install the packages, but, as shown by #2942, being able to install packages with `Pkg.add([PackageSpec(""""GMP_jll"""")]; julia_version=v""""1.6"""")` would still be useful in its own right. | [giordano]: To add a data point, `julia_version` may not be relevant.  Running this script in a clean depot:\n```julia\nusing  Pkg, UUIDs\n\nname = """"GMP_jll""""\nuuid = UUID(""""781609d7-10c4-51f6-84f2-b8444358ff6d"""")\ntree_hash = Base.SHA1(""""40388878122d491a2e55b0e730196098595d8a90"""")\n\nPkg.add([PackageSpec(; name, uuid, tree_hash)])\npkg_dir = Pkg.Operations.find_installed(name, uuid, tree_hash)\n\n@show readdir(pkg_dir)\n```\nI get\n```\n  Installing known registries into `/tmp/tmp.kqDfoYmeJH`\n    Updating registry at `/tmp/tmp.kqDfoYmeJH/registries/General.toml`\n   Resolving package versions...\n    Updating `/tmp/tmp.kqDfoYmeJH/environments/v1.7/Project.toml`\n  [781609d7] + GMP_jll\n    Updating `/tmp/tmp.kqDfoYmeJH/environments/v1.7/Manifest.toml`\n  [56f22d72] + Artifacts\n  [8f399da3] + Libdl\n  [781609d7] + GMP_jll\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds\nERROR: LoadError: IOError: readdir(""""/tmp/tmp.kqDfoYmeJH/packages/GMP_jll/IA6Pi""""): no such file or directory (ENOENT)\nStacktrace:\n [1] uv_error\n   @ ./libuv.jl:97 [inlined]\n [2] readdir(dir::String; join::Bool, sort::Bool)\n   @ Base.Filesystem ./file.jl:851\n [3] readdir(dir::String)\n   @ Base.Filesystem ./file.jl:846\n [4] top-level scope\n   @ show.jl:1047\nin expression starting at /tmp/foo.jl:10\n```\n\nThe same happens with\n```julia\nname = """"LibOSXUnwind_jll""""\nuuid = UUID(""""a83860b7-747b-57cf-bf1f-3e79990d037f"""")\ntree_hash = Base.SHA1(""""4ad86f1d058c211e8916ceddf2404ea75b002e47"""")\n```\nwhich is the problem reported in https://github.com/JuliaLang/Pkg.jl/issues/2942#issuecomment-1018606329 | [staticfloat]: I'm still not 100% certain this is the wrong behavior.  It depends on what `Pkg.add()` means.  From a manifest standpoint, this is the correct behavior.  If you were on Julia v1.6 and you did `Pkg.add(""""GMP_jll"""")`, the correct behavior would be to mark down that a `GMP_jll` stdlib has been added to the current project, and then do nothing afterwards.  If you were on Julia v1.5, the correct behavior would be to actually install something, because `GMP_jll` isn't an stdlib on that version.\n\nI think it's reasonable for BB to be required to jump through extra hoops in order to get stdlib JLLs.  The purpose of `Pkg.add(; julia_version)` was to emulate what would happen if you did a `Pkg.add()` on a different Julia version.  Since neither v1.6 nor v1.7 would install GMP_jll, that stays constant.  The issue is that, for BB, we _really actually want_ to get the bits that the old version has bundled within it.  But I think that's a reasonable thing for BB to need to do.\n\nThe extent of Pkg's responsibility here, IMO, is to know which versions of which stdlibs belong to which versions of Julia, so that it can write out the manifest properly.\n\nBB's responsibility is then to use that information to go and grab the necessary package versions and get those artifacts, using `Pkg.add(; julia_version=nothing)`.\n\nPinging @KristofferC to see if he agrees with my delineation of where Pkg's responsibility starts and ends. | [staticfloat]: As an example of how this gets worked around in BinaryBuilder:\n\n```julia\nusing Pkg, BinaryBuilderBase\n\nverbose = true\ndependencies = [PackageSpec(;name=""""GMP_jll"""")]\njulia_version = v""""1.6""""\nctx = Pkg.Types.Context(;julia_version)\nPkg.API.handle_package_input!.(dependencies)\nPkg.add(ctx, dependencies)\n\nfor dep in dependencies\n    dep.version = BinaryBuilderBase.stdlib_version(dep.uuid, julia_version)\n    Pkg.Operations.load_tree_hash!(ctx.registries, dep, nothing)\n    stdlib_pkgspec = BinaryBuilderBase.get_addable_spec(dep.name, dep.version; verbose)\n    Pkg.add(ctx, [stdlib_pkgspec]; julia_version=nothing)\n\n    run(`ls -la $(Pkg.Operations.find_installed(dep.name, dep.uuid, dep.tree_hash))`)\nend\n``` | [KristofferC]: > If I use Pkg.Operations.find_installed to get the path where v6.2.0+5 is installed I get\n\n> `julia> Pkg.Operations.find_installed(""""GMP_jll"""", UUID(""""781609d7-10c4-51f6-84f2-b8444358ff6d""""), \n Base.SHA1(""""40388878122d491a2e55b0e730196098595d8a90""""))`\n> `""""/home/mose/.julia/packages/GMP_jll/IA6Pi""""`\n\n> but this directory doesn't exist:\n\nThis is not surprising since the `find_installed` call there is just a computation based on the inputs. You could run that on any machine, with whatever is installed and you would get the same answer.",9,false,0,0,0,0,0,0,0,0,0
3398,`]add --preserve=all Foo` doesn't seem to preserve the version of `Foo`,open,ssfrr,,bug,,3,2023-03-03T14:04:53.0,2023-03-20T04:57:56.0,870,853,https://github.com/JuliaLang/Pkg.jl/issues/3398,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3398,"Here's a situation that happened to me earlier:\n\n1. I'm developing `PkgA`, which depends on `PkgB`, which depends on `PkgC` , and am in the `PkgA` environment\n2. I run `]add --preserve=all PkgC` (note `PkgC` is already in the Manifest because `PkgB` depends on it)\n3. What I'd like to happen is that `PkgC` just gets added to the `Project.toml` of `PkgA`. What actually happend is that `PkgC` was updated to the latest version before adding it, which then triggered precompilation of `PkgB` (which happens to be a long process I was trying to avoid).\n\nCurrently I think the solution is to manually add the package to `Project.toml` but that doesn't seem like the """"right way"""", and doesn't seem like `--preserve=all` is doing what I'd expect.\n\n```\njulia> versioninfo()\nJulia Version 1.7.3\nCommit 742b9abb4d (2022-05-06 12:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, skylake-avx512)\nEnvironment:\n  JULIA_PKG_USE_CLI_GIT = true\n```","[IanButterworth]: I looked into fixing this and couldn't see why it's happening | [ssfrr]: Thanks for checking it out. To clarify - is the issue that you can't reproduce it, or that it's not clear from the code why it's happening? | [IanButterworth]: The latter. I can't figure out why the added package isn't being treated like other packages from the manifest when it itself is in the manifest.",3,false,0,0,0,0,0,0,0,0,0
3411,`PkgId` method error when adding by URL and specifying the UUID,open,mortenpi,,,,2,2023-03-16T23:44:21.0,2023-03-17T09:33:05.0,856,856,https://github.com/JuliaLang/Pkg.jl/issues/3411,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3411,"Adding by URL and specifying the UUID leads to a `MethodError` with `Base.PkgId`:\n\n```\njulia> Pkg.add(PackageSpec(url=""""git@github.com:JuliaLang/Example.jl.git"""", uuid=""""7876af07-990d-54b4-ab0e-23690620f79a""""))\n    Updating git-repo `git@github.com:JuliaLang/Example.jl.git`\nERROR: MethodError: no method matching Base.PkgId(::Base.UUID, ::Nothing)\n\nClosest candidates are:\n  Base.PkgId(::Base.UUID, ::AbstractString)\n   @ Base pkgid.jl:7\n\nStacktrace:\n  [1] error_if_in_sysimage(pkg::Pkg.Types.PackageSpec)\n    @ Pkg.Types ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/Types.jl:570\n  [2] (::Pkg.Types.var""""#57#58""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String})(repo::LibGit2.GitRepo)\n    @ Pkg.Types ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/Types.jl:787\n  [3] with(f::Pkg.Types.var""""#57#58""""{Pkg.Types.Context, Pkg.Types.PackageSpec, String}, obj::LibGit2.GitRepo)\n    @ LibGit2 ~/julia/usr/share/julia/stdlib/v1.10/LibGit2/src/types.jl:1159\n  [4] handle_repo_add!(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec)\n    @ Pkg.Types ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/Types.jl:744\n  [5] handle_repos_add!(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.Types ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/Types.jl:814\n  [6] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:255\n  [7] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:156\n  [8] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:145\n  [9] #add#24\n    @ ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:143 [inlined]\n [10] add(pkg::Pkg.Types.PackageSpec)\n    @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:143\n [11] top-level scope\n    @ REPL[3]:1\n```\n\nTested with latest Julia master (`1.10.0-DEV.826`) and 1.8.","[KristofferC]: While the error message is bad, the input doesn't really make sense right? Or why are you specifying the UUID? | [mortenpi]: So.. what I was going to say is that I would expect Pkg to verify that the remote package and the UUID match, and refuse to add if it doesn't, because that is what `add` does for name/UUID pairs..\n\n```\njulia> Pkg.add(PackageSpec(name=""""Example"""", uuid=""""8dfed614-e22c-5e08-85e1-65c5234f0b41""""))\nERROR: Refusing to add package `Example [8dfed614]`.\nPackage `Example=8dfed614-e22c-5e08-85e1-65c5234f0b40` with the same name already exists as a direct dependency.\nTo remove the existing package, use `import Pkg; Pkg.rm(""""Example"""")`.\n```\n\nBut I now realize that this is not the case:\n\n```\njulia> Pkg.add(PackageSpec(name=""""Foobar"""", uuid=""""8dfed614-e22c-5e08-85e1-65c5234f0b40""""))\n   Resolving package versions...\n  No Changes to `/tmp/jl_s7Kgmp/Project.toml`\n  No Changes to `/tmp/jl_s7Kgmp/Manifest.toml`\n  0 dependencies successfully precompiled in 0 seconds\n  1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package\n\n(jl_s7Kgmp) pkg> st\nStatus `/tmp/jl_s7Kgmp/Project.toml`\n→ [8dfed614] Foobar\nInfo Packages marked with → are not downloaded, use `instantiate` to download\n```\n\nInstead, the environment seems to end up in some inconsistent state.. So now I am no longer exactly sure what should happen here, but I can see two possible actionable items:\n\n1. Pkg should verify the UUID if it is specified and it downloads a package from somewhere.\n2. Consider this a request to improve the error message. It should explicitly say that you shouldn't specify `uuid` and `url` together (and I guess some other combinations as well).",2,false,0,0,0,0,0,0,0,0,0
3366,`validate` errors should indicate the project that is invalid,open,felixcremer,,error handling,,0,2023-02-08T14:30:35.0,2023-03-14T13:26:50.0,893,859,https://github.com/JuliaLang/Pkg.jl/issues/3366,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3366,"I got the following error because I had a dependency dev'ed which had wrong compat entries.\n\n```julia\n(YAXArrays) pkg> resolve\nERROR: Compat `ArchGDAL` not listed in `deps` or `extras` section.\n```\nThis confused me, because I didn't find ArchGDAL in my package. I think it would have helped if the error message would have indicated also the project where the error was thrown. I would like to have something like this:\n```julia\n(YAXArrays) pkg> resolve\nERROR: In Project `YAXArrayBase`:  Compat `ArchGDAL` not listed in `deps` or `extras` section.\n```\n",,0,false,0,0,0,0,0,0,0,0,0
3405,Feature request: `]test --quiet`,open,miguelraz,,,,0,2023-03-13T22:41:36.0,2023-03-13T22:41:36.0,859,859,https://github.com/JuliaLang/Pkg.jl/issues/3405,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3405,"I don't have the bandwidth at the moment, but it would be super useful to have a flag so that \n`]test --quiet` or an equivalent would turn\n```\n\n(RandomWalkBVP) pkg> test\n     Testing RandomWalkBVP\n      Status `/tmp/jl_iBEm2S/Project.toml`\n  [41a02a25] Folds v0.2.8\n  [f67ccb44] HDF5 v0.16.14\n  [114ffcdd] RandomWalkBVP v0.1.0 `~/.julia/dev/RandomWalkBVP`\n  [bc48ee85] Tullio v0.3.5\n  [9a3f8284] Random `@stdlib/Random`\n  [8dfed614] Test `@stdlib/Test`\n      Status `/tmp/jl_iBEm2S/Manifest.toml`\n  [7d9f7c33] Accessors v0.1.28\n  [79e6a3ab] Adapt v3.6.1\n  [dce04be8] ArgCheck v2.3.0\n  [198e06fe] BangBang v0.3.37\n  [9718e550] Baselet v0.1.1\n  [d360d2e6] ChainRulesCore v1.15.7\n  [9e997f8a] ChangesOfVariables v0.1.6\n  [34da2185] Compat v4.6.1\n  [a33af91c] CompositionsBase v0.1.1\n  [187b0558] ConstructionBase v1.5.1\n  [9a962f9c] DataAPI v1.14.0\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [b552c78f] DiffRules v1.13.0\n  [ffbed154] DocStringExtensions v0.9.3\n  [e189563c] ExternalDocstrings v0.1.1\n  [41a02a25] Folds v0.2.8\n  [f67ccb44] HDF5 v0.16.14\n  [22cec73e] InitialValues v0.3.1\n  [3587e190] InverseFunctions v0.1.8\n  [92d709cd] IrrationalConstants v0.2.2\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [2ab3a3ac] LogExpFunctions v0.3.23\n  [1914dd2f] MacroTools v0.5.10\n  [128add7d] MicroCollections v0.1.3\n  [77ba4419] NaNMath v1.0.2\n  [bac558e1] OrderedCollections v1.4.1\n  [21216c6a] Preferences v1.3.0\n  [114ffcdd] RandomWalkBVP v0.1.0 `~/.julia/dev/RandomWalkBVP`\n  [42d2dcc6] Referenceables v0.1.2\n  [ae029012] Requires v1.3.0\n  [efcf1570] Setfield v1.1.1\n  [276daf66] SpecialFunctions v2.2.0\n  [171d559e] SplittablesBase v0.1.15\n  [90137ffa] StaticArrays v1.5.17\n  [1e83bf80] StaticArraysCore v1.4.0\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.10.0\n  [24d252fe] ThreadedScans v0.1.0\n  [28d57a85] Transducers v0.4.75\n  [bc48ee85] Tullio v0.3.5\n  [700de1a5] ZygoteRules v0.2.2\n  [0234f1f7] HDF5_jll v1.12.2+2\n  [458c3c95] OpenSSL_jll v1.1.20+0\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [0dad84c5] ArgTools v1.1.1 `@stdlib/ArgTools`\n  [56f22d72] Artifacts `@stdlib/Artifacts`\n  [2a0f44e3] Base64 `@stdlib/Base64`\n  [ade2ca70] Dates `@stdlib/Dates`\n  [8ba89e20] Distributed `@stdlib/Distributed`\n  [f43a241f] Downloads v1.6.0 `@stdlib/Downloads`\n  [7b1f6079] FileWatching `@stdlib/FileWatching`\n  [9fa8497b] Future `@stdlib/Future`\n  [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`\n  [b27032c2] LibCURL v0.6.3 `@stdlib/LibCURL`\n  [76f85450] LibGit2 `@stdlib/LibGit2`\n  [8f399da3] Libdl `@stdlib/Libdl`\n  [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`\n  [56ddb016] Logging `@stdlib/Logging`\n  [d6f4376e] Markdown `@stdlib/Markdown`\n  [a63ad114] Mmap `@stdlib/Mmap`\n  [ca575930] NetworkOptions v1.2.0 `@stdlib/NetworkOptions`\n  [44cfe95a] Pkg v1.8.0 `@stdlib/Pkg`\n  [de0858da] Printf `@stdlib/Printf`\n  [3fa0cd96] REPL `@stdlib/REPL`\n  [9a3f8284] Random `@stdlib/Random`\n  [ea8e919c] SHA v0.7.0 `@stdlib/SHA`\n  [9e88b42a] Serialization `@stdlib/Serialization`\n  [6462fe0b] Sockets `@stdlib/Sockets`\n  [2f01184e] SparseArrays `@stdlib/SparseArrays`\n  [10745b16] Statistics `@stdlib/Statistics`\n  [fa267f1f] TOML v1.0.0 `@stdlib/TOML`\n  [a4e569a6] Tar v1.10.1 `@stdlib/Tar`\n  [8dfed614] Test `@stdlib/Test`\n  [cf7118a7] UUIDs `@stdlib/UUIDs`\n  [4ec0a83e] Unicode `@stdlib/Unicode`\n  [e66e0078] CompilerSupportLibraries_jll v1.0.1+0 `@stdlib/CompilerSupportLibraries_jll`\n  [deac9b47] LibCURL_jll v7.84.0+0 `@stdlib/LibCURL_jll`\n  [29816b5a] LibSSH2_jll v1.10.2+0 `@stdlib/LibSSH2_jll`\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0 `@stdlib/MbedTLS_jll`\n  [14a3606d] MozillaCACerts_jll v2022.2.1 `@stdlib/MozillaCACerts_jll`\n  [4536629a] OpenBLAS_jll v0.3.20+0 `@stdlib/OpenBLAS_jll`\n  [05823500] OpenLibm_jll v0.8.1+0 `@stdlib/OpenLibm_jll`\n  [83775a58] Zlib_jll v1.2.12+3 `@stdlib/Zlib_jll`\n  [8e850b90] libblastrampoline_jll v5.1.1+0 `@stdlib/libblastrampoline_jll`\n  [8e850ede] nghttp2_jll v1.48.0+0 `@stdlib/nghttp2_jll`\n  [3f19e933] p7zip_jll v17.4.0+0 `@stdlib/p7zip_jll`\n     Testing Running tests...\nConstruction and basic functions: Test Failed at /home/mrg/.julia/dev/RandomWalkBVP/test/runtests.jl:29\n  Expression: sum(re.sol) ≈ 1 / 3\n   Evaluated: 0.5 ≈ 0.3333333333333333\nStacktrace:\n [1] macro expansion\n   @ ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]\n [2] macro expansion\n   @ ~/.julia/dev/RandomWalkBVP/test/runtests.jl:29 [inlined]\n [3] macro expansion\n   @ ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Test/src/Test.jl:1363 [inlined]\n [4] top-level scope\n   @ ~/.julia/dev/RandomWalkBVP/test/runtests.jl:12\nTest Summary:                    | Pass  Fail  Total  Time\nConstruction and basic functions |  108     1    109  1.3s\nERROR: LoadError: Some tests did not pass: 108 passed, 1 failed, 0 errored, 0 broken.\nin expression starting at /home/mrg/.julia/dev/RandomWalkBVP/test/runtests.jl:9\nERROR: Package RandomWalkBVP errored during testing\n```\n\ninto \n```\n(RandomWalkBVP) pkg> test --quiet\n     Testing RandomWalkBVP\nConstruction and basic functions: Test Failed at /home/mrg/.julia/dev/RandomWalkBVP/test/runtests.jl:29\n  Expression: sum(re.sol) ≈ 1 / 3\n   Evaluated: 0.5 ≈ 0.3333333333333333\nStacktrace:\n [1] macro expansion\n   @ ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]\n [2] macro expansion\n   @ ~/.julia/dev/RandomWalkBVP/test/runtests.jl:29 [inlined]\n [3] macro expansion\n   @ ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Test/src/Test.jl:1363 [inlined]\n [4] top-level scope\n   @ ~/.julia/dev/RandomWalkBVP/test/runtests.jl:12\nTest Summary:                    | Pass  Fail  Total  Time\nConstruction and basic functions |  108     1    109  1.3s\nERROR: LoadError: Some tests did not pass: 108 passed, 1 failed, 0 errored, 0 broken.\nin expression starting at /home/mrg/.julia/dev/RandomWalkBVP/test/runtests.jl:9\nERROR: Package RandomWalkBVP errored during testing\n```\n\nThe second doesn't require one to change focus and scroll down to see what actual test was ran.\nThis is a feature request, so do feel free to close it down if it's not on the priority list or to point me in the right way so that I may PR it later.",,0,false,0,0,0,0,0,0,0,0,0
3404,Pkg.dependencies() leading to method error,open,axsk,,bug,,1,2023-03-09T22:25:43.0,2023-03-09T22:30:46.0,863,863,https://github.com/JuliaLang/Pkg.jl/issues/3404,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3404,"I tried switching to Julia 1.9.0rc1 today. However I couldn't use Plots.jl because it is calling Pkg.dependencies(), and that in turn failed:\n\n```\njulia> Pkg.dependencies()\nERROR: MethodError: no method matching project_rel_path(::Pkg.Types.EnvCache, ::Nothing)\n\nClosest candidates are:\n  project_rel_path(::Pkg.Types.EnvCache, ::String)\n   @ Pkg /data/numerik/people/bzfsikor/julia/julia-1.9.0-rc1/share/julia/stdlib/v1.9/Pkg/src/Operations.jl:911\n\nStacktrace:\n  [1] package_info(env::Pkg.Types.EnvCache, pkg::Pkg.Types.PackageSpec, entry::Pkg.Types.PackageEntry)\n    @ Pkg.API /data/numerik/people/bzfsikor/julia/julia-1.9.0-rc1/share/julia/stdlib/v1.9/Pkg/src/API.jl:65\n  [2] package_info(env::Pkg.Types.EnvCache, pkg::Pkg.Types.PackageSpec)\n    @ Pkg.API /data/numerik/people/bzfsikor/julia/julia-1.9.0-rc1/share/julia/stdlib/v1.9/Pkg/src/API.jl:58\n  [3] #9\n    @ ./none:0 [inlined]\n  [4] iterate\n    @ ./generator.jl:47 [inlined]\n  [5] _all(f::Base.var""""#372#374"""", itr::Base.Generator{Vector{Pkg.Types.PackageSpec}, Pkg.API.var""""#9#10""""{Pkg.Types.EnvCache}}, #unused#::Colon)\n    @ Base ./reduce.jl:1292\n  [6] all\n    @ ./reduce.jl:1278 [inlined]\n  [7] Dict(kv::Base.Generator{Vector{Pkg.Types.PackageSpec}, Pkg.API.var""""#9#10""""{Pkg.Types.EnvCache}})\n    @ Base ./dict.jl:111\n  [8] dependencies\n    @ /data/numerik/people/bzfsikor/julia/julia-1.9.0-rc1/share/julia/stdlib/v1.9/Pkg/src/API.jl:85 [inlined]\n  [9] dependencies()\n    @ Pkg.API /data/numerik/people/bzfsikor/julia/julia-1.9.0-rc1/share/julia/stdlib/v1.9/Pkg/src/API.jl:82\n [10] top-level scope\n    @ REPL[1]:1\n ```\n \n I could track it down to the entry\n```\n [[deps.DelimitedFiles]]\ndeps = [""""Mmap""""]\nuuid = """"8bb1440f-4735-579b-a4ab-409b98df4dab""""\n```\nin the `Manifest.toml`\n\nAfter deleting the `Manifest.toml` and recreating it it worked fine with the entry being\n```\n[[deps.DelimitedFiles]]\ndeps = [""""Mmap""""]\ngit-tree-sha1 = """"9e2f36d3c96a820c678f2f1f1782582fcf685bae""""\nuuid = """"8bb1440f-4735-579b-a4ab-409b98df4dab""""\nversion = """"1.9.1""""\n```\n1.8.5 on the other hand had no problem with my old Manifest.\n\nNot sure if this is a bug or I just ended up with an ill-defined Manifest somehow, but I thought I'll post it here for reference (and others with similar problems). Feel free to close this.","[DilumAluthge]: Likely related to the de-stdlibification of DelimitedFiles. cc: @KristofferC \n\nIn general, a manifest generated on Julia 1.x is not going to be compatible with Julia 1.y for x != y. But we should print a nice message, instead of crashing with an unhelpful error message.",1,false,3,2,0,0,0,0,0,1,0
3345,Command to copy/fork environment,open,jariji,,,,1,2023-01-28T07:15:36.0,2023-03-08T22:01:06.0,904,864,https://github.com/JuliaLang/Pkg.jl/issues/3345,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3345,"I have a “main” environment that has a lot of the packages I use. Whenever I want to try something out, I go to a new directory and I want to use those packages plus a couple of other packages.\n\n- I don’t want to reinstall these main packages\n- I don’t want to mutate-in-place the main environment with the new packages\n- I want the project’s Project.toml and Manifest.toml to be complete, not relying on some external hidden state\n\n\nA solution is to copy/snapshot/fork the main environment into a new project, as described [here](https://discourse.julialang.org/t/workflow-for-forking-an-environment/93660/7) and [here](https://discourse.julialang.org/t/first-pluto-notebook-launches-are-slower-on-julia-1-9-beta-3/93429/89) and [here](https://discourse.julialang.org/t/first-pluto-notebook-launches-are-slower-on-julia-1-9-beta-3/93429/88).\n\nThe current workflow seems to be manually copying and activating the main environment tomls. For a common workflow like this, it would be nice to have a single command that can fork the environment into a new location.\n\n\n",[AbhinavMir]: Can we have some equivalent of a global install that's global but not globally referenced unless specified?,1,false,0,0,0,0,0,0,0,0,0
3396,_auto_gc_enabled doesn't work,open,AbhimanyuAryan,,,,0,2023-03-01T19:52:46.0,2023-03-01T19:53:42.0,871,871,https://github.com/JuliaLang/Pkg.jl/issues/3396,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3396,I have used `Pkg. _auto_gc_enabled[] = false` everywhere before `instantiate()` but it's still being called. I think it's buggy. Can anyone verify if this works? \n\n\nthere's this test: https://github.com/JuliaLang/Pkg.jl/blob/2931cf990b799099a12d1c9d820ae5761033c2e1/test/new.jl#L24\n\nHas anyone verified that removing this calls `Pkg.gc()`?,,0,false,0,0,0,0,0,0,0,0,0
3380,Autoname extensions,open,aplavin,,,,5,2023-02-17T19:49:34.0,2023-02-24T14:40:39.0,883,877,https://github.com/JuliaLang/Pkg.jl/issues/3380,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3380,"Basically everyone would follow the recommended naming scheme for extensions: extension triggered by `SomePkg` should be named `SomePkgExt`. Can this naming be done automatically to reduce repetition?\n\nCurrently, there are lots of unnecessary repetitions in the common case:\n- `Project.toml` `[extensions]`\n  - extension name `SomePkgExt`\n  - package name `= SomePkg`\n- Code\n  - file name `SomePkgExt.jl`\n  - module name `module SomePkgExt`\n\nMaybe, at least some of these could be removed?\nFor example, instead of `SomePkgExt = SomePkg` allow just `SomePkg` in `[extensions`]?\nAnd/or implicitly define `module SomePkgExt` in the corresponding file?","[fredrikekre]: I like that things are explicit, it also isn't more repetitive than the package itself. I think it is also nice if there is just one way to specify the extension since it is enough to learn one way.\n\nIn addition, this is something you set it up once and then don't have to bother with it again, and not something you have to type everytime you use an extension. | [aplavin]: I'm thinking about consistency, not just convenience of typing. Would be nice to have an """"official"""" naming scheme, suggested or even enforced by `Pkg`.\nThere are already some issues with naming extensions, see eg https://github.com/JuliaMath/ChangesOfVariables.jl/pull/13. Their names may seem not important at all, but turns out they are! For one, arbitrary names without a convention would prevent building sysimages. | [KristofferC]: > For one, arbitrary names without a convention would prevent building sysimages\n\nDue to some existing deficiencies. There is nothing inherently problematic about it. | [aplavin]: So, is it fine if different packages have extensions with the same name?\n\nDue to that sysimage issue, some packages started prepending their name to the extension, leading to very long and redundant names as a result.\nFor instance, these lines from precompilation output:\n```julia\n  ✓ LogExpFunctions → LogExpFunctionsInverseFunctionsExt\n  ✓ LogExpFunctions → LogExpFunctionsChainRulesCoreExt\n```\nwould really be better as \n```julia\n  ✓ LogExpFunctions → InverseFunctionsExt\n  ✓ LogExpFunctions → ChainRulesCoreExt\n```\nassuming extension names don't have to be distinct. | [aplavin]: Anyway, no matter what naming scheme is decided on, it would be nice to have it uniform and consistent across packages.",5,false,0,0,0,0,0,0,0,0,0
3369,`Pkg.add` should not update registry,open,jakobnissen,,,,19,2023-02-11T14:19:22.0,2023-02-20T22:00:48.0,890,880,https://github.com/JuliaLang/Pkg.jl/issues/3369,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3369,"Running `Pkg.add` should not automatically update the registry. Optionally add a warning when running `Pkg.add` if the registry is more than, say, 3 months old and Pkg is not in offline mode.\n\n## Background\n[A recent Discourse thread](https://discourse.julialang.org/t/first-pluto-notebook-launches-are-slower-on-julia-1-9-beta-3/93429) on the increased precompilation time with Julia 1.9 led to [some discussion on Slack](https://julialang.slack.com/archives/C03LD7K8HLN/p1676028682517259) about what can be done to reduce the amount of precompilation.\n\nI don't think the Slack discussion reached a consensus, but several good suggestions were brought up that deserve an issue here on Pkg. Notably, some of the proposed solutions are good ideas _regardless_ of whether Julia 1.9's precompilation woes will be solved elsewhere.\n\n## Motivation\nThe motivation is twofold: First, from a theoretical standpoint, adding a package and updating are conceptually different and orthogonal operations. You should be able to add a package without updating anything. Hence, the two operation should be separated.\n\nFrom a practical point of view, developers and experienced users of Julia often create environments and modify their environments many times per day, sometimes tens of times per day. With the current state where every `Pkg.add` operation updates automatically, these users are going to be served new releases of various packages (dependencies of dependencies) very often, each time triggering waiting time for fetching the registry and/or package precompilation. For most users, getting the very newest version of every package is completely unnecessary - certainly getting up-to-the-hour updates is not needed.\n\n## Possible objections\nQ: Wouldn't this mean lots of people would get stuck on months old packages?\nA: The registry would only get stale if they never choose to run `Pkg.update` for _any_ project. And if they never do so, it's probably safe to assume they are fine running an old environment. Furthermore, we should in general expect many users explicitly want to run years old environments that they choose not to upgrade or modify.","[IanButterworth]: The summary that \n\n> the current state where every Pkg.add operation updates automatically, these users are going to be served new releases of various packages (dependencies of dependencies) very often\n\nIsn't quite fair. Even if the registry is regularly updated, by default `Pkg.add` uses a tiered preserve strategy, where it tries to add the requested package while updating no existing package in the environment first, but if it cannot will go onto try the more permissive strategies (see https://pkgdocs.julialang.org/v1/api/#Pkg.add)\n\nIf `Pkg.add` has updated any existing dep, it should mean it couldn't add the package without doing that.\n\nThe exception is the build number bug detailed here https://github.com/JuliaLang/Pkg.jl/issues/1568#issuecomment-1425948204 | [jariji]: I wonder if there could be a smarter algorithm that figures out the optimal frequency for updating the registry. It could account for how often new versions are released for the currently installed packages and when the last time the registry was updated. There could be a user-tunable parameter for how sensitive the user is to having the newest version. | [fredrikekre]: If there is nothing new, then """"updating"""" the registry is a no-op essentially;\n```\njulia> @time Pkg.Registry.update()\n    Updating registry at `~/.julia/registries/General.toml`\n  0.054130 seconds (1.91 k allocations: 122.359 KiB)\n```\nand as Ian mentioned, other packages shouldn't be updated by `Pkg.add` anyway, so I doubt automatic registry updating contributes much to the problems mentioned in the OP. | [jakobnissen]: Suppose you with to add Pkg A, which is cached in your depot, and has a lot of dependencies. A new version of one of these dependencies are released. When you add it, does the new transitive dependency need to be downloaded? That would be a source of lots of unnecessary downloaded packages.\n\nEdit: when testing this situation on my own computer, indeed it does download new packages even when I only ask to add a package I already have - in my case, needlessly re-triggering precompilation of Plots which took 91 seconds. | [KristofferC]: Can you give a concrete example? It isn't clear to me what exact scenario you are describing. | [jakobnissen]: Sure. I'm at work and spin up a new environment for the day's analysis. I get some data that I decide I want to make a quick barplot of, so I `pkg> add Plots` to the environment - a package I use on a daily/weekly basis and have cached in my depot.\n\nHowever, since Plots has 175 transitive dependencies, if a new version of any of these packages have been pushed since I last made a plot, I will now have to download the registry, download this new package, and recompile Plots. Completely unnecessarily - I just want to make a barplot.\n\nTo me it feels unnecessary. I didn't ask for updates. If I did, I would have typed `pkg> up`. I just need to install a package I already have. Why not separate the two distinct operations of getting a new package and updating your packages? | [KristofferC]: You probably want https://github.com/JuliaLang/Pkg.jl/issues/1233 for cases like this which we should try get into 1.10. In short, it would allow you to share a big manifest among many projects (and thus use the same version of the packages). | [timholy]: I also agree that #1233 is desirable as Julia 1.10 material. Still, I think we can do better for 1.9. Here's the sequence I imagine @jakobnissen is describing:\n\n- I have a package, `Plots`, that depends on `PkgA` and `PkgB`. I use `Plots` a lot, and there's a compiled version on my hard drive somewhere.\n- I'm working on `DevPkg`, which happens to depends on `PkgA`. Now I decide to `DevPkg> add Plots`. Pkg, being the lovely citizen it is, agrees that since we're already depending on `PkgA`, let's use the same version that's in the manifest.\n- However, `DevPkg` does not (yet) depend on `PkgB`. So my `add` triggers a registry update, which discovers that there's a new release of `PkgB`. Thus it downloads the new `PkgB` and re-precompiles Plots.\n\nThere are overlapping ways to solve this. In this particular case, `Pkg.offline(true)` would presumably have done exactly what I wanted. However, there are two differences of note:\n- its persistence gives it different usage semantics: I have to remember to turn it on again if I want to add something """"truly"""" new (i.e., a package I've never installed before).\n- imagine a scenario in which I've never installed `Plots`, but I do have precompiled versions of `HeavyDependency` upon which `Plots` depends. To get `Plots`, I'm going to have to hit the network; but while updating the registry, I may also discover there's a new version of `HeavyDependency` or one of its dependencies. So rather than the relatively minimal task of installing and precompiling just `Plots`, now I'm precompiling the whole stack. This case cannot be handled with `offline` (I had to hit the network to get `Plots`) but is handled if we can suppress registry updates.\n\nTo me, the bottom line is that stuff is happening that I didn't ask for, and there's no way to shut it off. When I start with an analysis environment and then say `SomeProject>add Plots`, what I'm really saying is """"I will need plotting in this environment,"""" not """"please give me the latest version of every package I hadn't yet requested.""""\n\nI agree it would be problematic to change the default behavior here, but providing at least the option to `pkg> add -noregistry Plots` seems sensible and likely to be effective. | [KristofferC]: > I agree it would be problematic to change the default behavior here, but providing at least the option to pkg> add -noregistry Plots seems sensible and likely to be effective.\n\nWhat is `-noregistry` supposed to do? The equivalent of a temporary `Pkg.offline` for the duration of one operation? | [timholy]: Still allowed to download new package code. It just doesn't update the registry first (it uses the current version of the registry installed on my machine).\n\nHmm, would this be equivalent to `Pkg.UPDATED_REGISTRY_THIS_SESSION[] = true`, and that my perception that this still doesn't quite work properly is just because of the build-number bug? If so, then maybe the better solution is simply to document this option and then close this issue. | [aplavin]: Registry update isn't the whole story here. Even if I have an up-to-date registry and `]add Plots` in an environment, it makes sense to install `Plots` version from a week ago, if it's already stored and precompiled on my machine. It's relatively rare when the actual newest version is needed, and in those cases one can do `]up`. Still, this update shouldn't make all further heavy package installations to precompile effectively from scratch. | [KristofferC]: > Still allowed to download new package code. It just doesn't update the registry first (it uses the current version of the registry installed on my machine).\n\nArtificially holding the registry back seems like a bad solution to this because as soon as you somehow accidentally forget to hold it back and it updates you are pretty much out of luck because you cannot really go back. So this situation is kind of living on an unstable equilibrium. The registry is just information about what package version exists and it should never be bad to just get more information. It is up to us to form our queries so that we get the package versions we want.\n\nSo, what we actually want seems to be: Install packages such that we don't have to 1.) download them 2.) precompile them.\n\nSomething similar to a command run under `Pkg.offline` seems like it would get you quite far there. If it is already downloaded, it is likely also precompiled. You could also allow it to download packages if those packages are not available at all in order to avoid a complete failure in those cases. \n | [IanButterworth]: I like this proposal, and perhaps it could be spelled\n```\npkg> add --installed Plots\n```\ni.e. """"add the installed version of package Plots"""" | [visr]: I like this too, it's what I also proposed [on Discourse](https://discourse.julialang.org/t/first-pluto-notebook-launches-are-slower-on-julia-1-9-beta-3/93429/91).\n\nBeing greedy here, but why not make it the default? The tiered algorithm now only looks at preserving versions of packages already in the environment, but this doesn't help us when creating new environments. Could preserving both versions and installations be the new upper tier?\n\nWhat would be the downside to this? Some users may get some older packages sometimes, but once doing a Pkg.update somewhere will install the latest, making it available for all Pkg.add. In the most extreme case, if a user never runs Pkg.update and is never forced to install newer versions due to compat bounds, they would add versions that are as old as their julia install, when they installed the package in the depot for the first time. | [IanButterworth]: Just another idea if it were to be opt-in, to put the flag in the place the version specifier is usually and make it package specific\n```\npkg> add Plots@installed Flux\n```\nSo """"add the installed version of Plots, and Flux latest"""" | [timholy]: > The registry is just information about what package version exists and it should never be bad to just get more information. It is up to us to form our queries so that we get the package versions we want.\n\nAgreed that in principle it isn't bad to get more information, *if* you have good mechanisms that don't *force* you to exploit that new information. My point is that #1233 is a 1.10 solution; I'm trying to find something to dull the pain for 1.9 that also doesn't cause regrets later. Avoiding registry updates seemed to me to be a """"cheap"""" way of accomplishing that. If `pkg> add --installed Plots` is doable for 1.9, that sounds much better.\n\nBut if it isn't, what do you propose instead?\n\n> Even if I have an up-to-date registry and ]add Plots in an environment, it makes sense to install Plots version from a week ago, if it's already stored and precompiled on my machine.\n\nSure. I'm just trying to find something that often works that we can accomplish for 1.9. The boat has sailed on big, new features; we have to do something that isn't so ambitious that rushing it could cause regrets later. (Once we ship something in a release, we're stuck with it.) Rare registry updates will """"asymptotically"""" get the behavior you want, just not as fast as an optimal solution.\n\nBut again, I'm very happy to accept any reasonable solution to the problem. I just don't want to see it go unaddressed in 1.9. If there's a """"perfect"""" solution being designed for 1.10, I'm arguing that we *also* need a no-regrets bandaid for 1.9. | [KristofferC]: > Being greedy here, but why not make it the default? \n\nChanging defaults without any trial period is kind of iffy. And it also means there is this hidden state that goes into the default resolver procedure which can be tricky to debug and maybe confusing. Say two colleagues (or a teacher and a student) doing `add Foo` and get a bunch of different versions for all the dependencies. It just doesn't feel that great of a solution.\n\n\n\n | [visr]: My feeling is that there is enough tooling in place to mitigate those concerns. Running `up` will always ignore installs, there are compat bounds, `status` showing outdated packages, and manifest sharing that can be used when appropriate. We could even add something that would act similar to the current `add Example`, like `add Example@latest` (perhaps not the best name). | [gaurav-arya]: One weird idea I had is to allow writing e.g. `add @plots`, which would add all the packages in the named environment `@plots` (#3347). No env stacking or backrefs, just adding of packages, but at the same versions as are currently in `@plots`, and so as long as `@plots` has been precompiled this `add` would be fast. Then, the workflow would be to keep e.g. plotting utilities in an environment `@plots` and add them like this.\n\nProbably not the right solution here, and possibly superceded by #1233, but just wanted to float it as food for thought.",19,false,4,4,0,0,0,0,0,0,0
3074,Allow testing projects without a UUID,open,cossio,,,,2,2022-05-02T18:06:43.0,2023-02-20T14:10:39.0,1174,881,https://github.com/JuliaLang/Pkg.jl/issues/3074,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3074,"Currently if you try to `Pkg.test` a project without an UUID, it will throw this error:\n\n```\nERROR: trying to test unnamed project\n```\n\nEven if the project has a name.\n\nIs there any reason why the Project.toml needs to have an UUID if I want to test it?","[cossio]: Related: https://github.com/JuliaLang/Pkg.jl/issues/1982 | [AnHeuermann]: For me it would already be an improvement to make the error message more specific. I needed to search for a while until I noticed that the missing UUID was the reason for the error message.\nI created a Julia project that is not a package using DrWatson, see https://github.com/JuliaDynamics/DrWatson.jl/issues/67.\n\nSo for the missing UUID something like\n\n```\nERROR: trying to test unnamed project (missing UUID in Project.toml)\n```\n\nwould improve my experience.\n\n----------------\n\nAlso related to https://github.com/JuliaLang/Pkg.jl/issues/1253.",2,false,3,3,0,0,0,0,0,0,0
3377,Specifying override artifacts using a relative path,open,smartalecH,,,,0,2023-02-16T17:09:22.0,2023-02-16T17:10:29.0,884,884,https://github.com/JuliaLang/Pkg.jl/issues/3377,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3377,"Currently, an `overrides.toml` file requires that an artifact override be specified using an *absolute* path (understandably). It would be nice to be able to specify an arbitrary path *relative* to the location of the `overrides.toml` itself.\n\nThis may not seem necessary on the surface. But many large-scale infra stacks use their own build management systems that make working with absolute paths really painful (for good reason).\n",,0,false,0,0,0,0,0,0,0,0,0
1568,Feature request: support version numbers with build metadata,open,DilumAluthge,,feature request,,15,2019-12-29T00:28:36.0,2023-02-11T14:09:43.0,2030,890,https://github.com/JuliaLang/Pkg.jl/issues/1568,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1568,"Suppose I want to `Pkg.add` a specific version of a package. For example, suppose that I want to install version `0.5.3` of the `Example` package. I can do this as follows:\n```julia\njulia> import Pkg\n\njulia> Pkg.add(Pkg.PackageSpec(name = """"Example"""", version = """"0.5.3""""))\n   Cloning default registries into `~/.julia`\n   Cloning registry from """"https://github.com/JuliaRegistries/General.git""""\n     Added registry `General` to `~/.julia/registries/General`\n Resolving package versions...\n Installed Example ─ v0.5.3\n  Updating `~/.julia/environments/v1.4/Project.toml`\n  [7876af07] + Example v0.5.3\n  Updating `~/.julia/environments/v1.4/Manifest.toml`\n  [7876af07] + Example v0.5.3\n```\n\nI can also accomplish the same thing using the REPL mode:\n```julia\n(@v1.4) pkg> add Example@0.5.3\n   Cloning default registries into `~/.julia`\n   Cloning registry from """"https://github.com/JuliaRegistries/General.git""""\n     Added registry `General` to `~/.julia/registries/General`\n Resolving package versions...\n Installed Example ─ v0.5.3\n  Updating `~/.julia/environments/v1.4/Project.toml`\n  [7876af07] + Example v0.5.3\n  Updating `~/.julia/environments/v1.4/Manifest.toml`\n  [7876af07] + Example v0.5.3\n```\n\nBut this does not work with JLL packages. For example, suppose that I want to install version `2.23.0+1` of the `Git_jll` package. I tried this, but it gives me an error:\n```julia\njulia> import Pkg\n\njulia> Pkg.add(Pkg.PackageSpec(name = """"Git_jll"""", version = """"2.23.0+1""""))\nERROR: ArgumentError: invalid version range: """"2.23.0+1""""\nStacktrace:\n [1] Pkg.Types.VersionRange(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/versions.jl:114\n [2] VersionSpec at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/versions.jl:197 [inlined]\n [3] #Package#129 at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/API.jl:996 [inlined]\n [4] top-level scope at REPL[2]:1\n```\n\nI also tried the REPL mode, but it also gives an error:\n```julia\n(@v1.4) pkg> add Git_jll@2.23.0+1\nERROR: ArgumentError: invalid version range: """"2.23.0+1""""\nStacktrace:\n [1] Pkg.Types.VersionRange(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/versions.jl:114\n [2] Union{Pkg.Types.VersionRange, String, Pkg.REPLMode.Rev}(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/argument_parsers.jl:33\n [3] iterate at ./generator.jl:47 [inlined]\n [4] collect_to!(::Array{String,1}, ::Base.Generator{Array{String,1},Type{Union{Pkg.Types.VersionRange, String, Pkg.REPLMode.Rev}}}, ::Int64, ::Int64) at ./array.jl:710\n [5] collect_to_with_first!(::Array{String,1}, ::String, ::Base.Generator{Array{String,1},Type{Union{Pkg.Types.VersionRange, String, Pkg.REPLMode.Rev}}}, ::Int64) at ./array.jl:689\n [6] _collect(::Array{String,1}, ::Base.Generator{Array{String,1},Type{Union{Pkg.Types.VersionRange, String, Pkg.REPLMode.Rev}}}, ::Base.EltypeUnknown, ::Base.HasShape{1}) at ./array.jl:683\n [7] collect_similar at ./array.jl:607 [inlined]\n [8] map at ./abstractarray.jl:2072 [inlined]\n [9] parse_package(::Array{Pkg.REPLMode.QString,1}, ::Dict{Symbol,Any}; add_or_dev::Bool) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/argument_parsers.jl:10\n [10] (::Pkg.REPLMode.var""""#64#69"""")(::Array{Pkg.REPLMode.QString,1}, ::Dict{Symbol,Any}) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/command_declarations.jl:89\n [11] Pkg.REPLMode.Command(::Pkg.REPLMode.Statement) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/REPLMode.jl:365\n [12] iterate at ./generator.jl:47 [inlined]\n [13] _collect(::Array{Pkg.REPLMode.Statement,1}, ::Base.Generator{Array{Pkg.REPLMode.Statement,1},Type{Pkg.REPLMode.Command}}, ::Base.EltypeUnknown, ::Base.HasShape{1}) at ./array.jl:678\n [14] collect_similar at ./array.jl:607 [inlined]\n [15] map at ./abstractarray.jl:2072 [inlined]\n [16] do_cmd(::REPL.LineEditREPL, ::String; do_rethrow::Bool) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/REPLMode.jl:378\n [17] do_cmd at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/REPLMode.jl:376 [inlined]\n [18] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL,REPL.LineEdit.Prompt})(::REPL.LineEdit.MIState, ::Base.GenericIOBuffer{Array{UInt8,1}}, ::Bool) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/REPLMode/REPLMode.jl:542\n [19] #invokelatest#1 at ./essentials.jl:712 [inlined]\n [20] invokelatest at ./essentials.jl:711 [inlined]\n [21] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/REPL/src/LineEdit.jl:2354\n [22] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/REPL/src/REPL.jl:1055\n [23] run_repl(::REPL.AbstractREPL, ::Any) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/REPL/src/REPL.jl:206\n [24] (::Base.var""""#764#766""""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:383\n [25] #invokelatest#1 at ./essentials.jl:712 [inlined]\n [26] invokelatest at ./essentials.jl:711 [inlined]\n [27] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:367\n [28] exec_options(::Base.JLOptions) at ./client.jl:305\n [29] _start() at ./client.jl:484\n```\n\nSo, as far as I can tell, there is currently no way to `Pkg.add` a specific version of a JLL package.\n\ncc: @staticfloat @giordano","[giordano]: I can also confirm that `Project.toml` is not happy if you specify the build number in the compat section | [DilumAluthge]: > I can also confirm that `Project.toml` is not happy if you specify the build number in the compat section\n\nCorrect. Suppose you have a `Project.toml` file with the following contents:\n```toml\n[deps]\nGit_jll = """"f8c6e375-362e-5223-8a59-34ff63f689eb""""\n\n[compat]\nGit_jll = """"2.23.0+1""""\n```\n\nHere is the error you get if you start Julia with `julia --project` and then try to instantiate:\n```julia\nDMBP:foo dilum$ julia --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.4.0-DEV.660 (2019-12-23)\n _/ |\__'_|_|_|\__'_|  |  Commit 27eb582279 (5 days old master)\n|__/                   |\n\njulia> import Pkg\n\njulia> Pkg.instantiate()\nERROR: Could not parse compatibility version for dependency `Git_jll`\nStacktrace:\n [1] pkgerror(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/Types.jl:54\n [2] read_project_compat(::Dict{String,Any}, ::Pkg.Types.Project) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:66\n [3] Pkg.Types.Project(::Dict{String,Any}) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:121\n [4] read_project(::IOStream; path::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:140\n [5] #32 at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:144 [inlined]\n [6] open(::Pkg.Types.var""""#32#33""""{String}, ::String; kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./io.jl:298\n [7] open at ./io.jl:296 [inlined]\n [8] read_project(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:143\n [9] Pkg.Types.EnvCache(::Nothing) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/Types.jl:283\n [10] EnvCache at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/Types.jl:279 [inlined]\n [11] Pkg.Types.Context() at ./util.jl:736\n [12] #instantiate#114 at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/API.jl:741 [inlined]\n [13] instantiate() at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/API.jl:741\n [14] top-level scope at REPL[2]:1\ncaused by [exception 1]\ninvalid version specifier: 2.23.0+1\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] semver_spec(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/versions.jl:273\n [3] read_project_compat(::Dict{String,Any}, ::Pkg.Types.Project) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:64\n [4] Pkg.Types.Project(::Dict{String,Any}) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:121\n [5] read_project(::IOStream; path::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:140\n [6] #32 at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:144 [inlined]\n [7] open(::Pkg.Types.var""""#32#33""""{String}, ::String; kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./io.jl:298\n [8] open at ./io.jl:296 [inlined]\n [9] read_project(::String) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/project.jl:143\n [10] Pkg.Types.EnvCache(::Nothing) at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/Types.jl:283\n [11] EnvCache at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/Types.jl:279 [inlined]\n [12] Pkg.Types.Context() at ./util.jl:736\n [13] #instantiate#114 at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/API.jl:741 [inlined]\n [14] instantiate() at /Users/dilum/dev/forks-DilumAluthge/julia/usr/share/julia/stdlib/v1.4/Pkg/src/API.jl:741\n [15] top-level scope at REPL[2]:1\n``` | [fredrikekre]: Works if you pass a version number. | [JackDunnNZ]: Even though passing as a version number works, it seems like the version selected is simply the latest version of the same patch release. Here I request `0.3.7+2` but `0.3.7+4` is added:\n\n```\njulia> Pkg.status()\n    Status `/tmp/Project.toml`\n  (empty environment)\n\njulia> Pkg.add(PackageSpec(name=""""OpenBLAS_jll"""", version=v""""0.3.7+2""""))\n Resolving package versions...\n  Updating `/tmp/Project.toml`\n  [4536629a] + OpenBLAS_jll v0.3.7+4\n  Updating `/tmp/Manifest.toml`\n  [4536629a] + OpenBLAS_jll v0.3.7+4\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [b77e0a4c] + InteractiveUtils\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [44cfe95a] + Pkg\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n``` | [DilumAluthge]: > Even though passing as a version number works, it seems like the version selected is simply the latest version of the same patch release. Here I request `0.3.7+2` but `0.3.7+4` is added:\n\nThat’s not good. Seems like a bug to me. | [KristofferC]: > That’s not good. Seems like a bug to me.\n\nIf it is a bug, it is in the bot that makes PR for jll packages to General and produces these version numbers. Pkg doesn't support this type of version numbers. This was known to the people doing `_jll` stuff but the advantage of being able to do multiple builds and have the major, minor, patch version correspond to the library version was likely considered more important than the drawback of being able to select different build versions to install (you should always want the latest?).\n\nPkg could be made to accept these version numbers but that is a feature request. | [staticfloat]: > the advantage of being able to do multiple builds and have the major, minor, patch version correspond to the library version was likely considered more important than the drawback of being able to select different build versions to install (you should always want the latest?).\n\nThat's exactly what we said, yes.  We discussed the relative advantages of decoupling JLL versioning from the underlying source library, and we decided that being able to specify exactly which _source library_ to choose from was more important than which build; although it would of course be better to be able to choose both, it's much more important for us to be able to have `LibFoo v3.3.3` and `LibFoo v3.3.4` distinguishable, since the (vast) majority of our build-increment-only JLL package versions are build system improvements, turning on more features, adding more platforms, etc...  Very rarely is there a behavioral difference in a build-number-only bump. | [giordano]: > Works if you pass a version number.\n\nWhat am I missing?\n\n```julia\njulia> using Pkg\n\njulia> Pkg.add(PackageSpec(; name = """"SuiteSparse_jll"""", version = v""""5.4.0+2""""))\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Resolving package versions...\nDownloading artifact: OpenBLAS\n   Updating `~/.julia/environments/v1.4/Project.toml`\n  [bea87d4a] + SuiteSparse_jll v5.4.0+4\n   Updating `~/.julia/environments/v1.4/Manifest.toml`\n  [d00139f3] + METIS_jll v5.1.0+1\n  [4536629a] + OpenBLAS_jll v0.3.7+5\n  [bea87d4a] + SuiteSparse_jll v5.4.0+4\n```\n\nI'm not sure how that would work, I don't see the build number in the `PackageSpec`:\n```julia\njulia> dump(PackageSpec(; name = """"SuiteSparse_jll"""", version = v""""5.4.0+2""""))\nPkg.Types.PackageSpec\n  name: String """"SuiteSparse_jll""""\n  uuid: Nothing nothing\n  version: Pkg.Types.VersionSpec\n    ranges: Array{Pkg.Types.VersionRange}((1,))\n      1: Pkg.Types.VersionRange\n        lower: Pkg.Types.VersionBound\n          t: Tuple{UInt32,UInt32,UInt32}\n            1: UInt32 0x00000005\n            2: UInt32 0x00000004\n            3: UInt32 0x00000000\n          n: Int64 3\n        upper: Pkg.Types.VersionBound\n          t: Tuple{UInt32,UInt32,UInt32}\n            1: UInt32 0x00000005\n            2: UInt32 0x00000004\n            3: UInt32 0x00000000\n          n: Int64 3\n  tree_hash: Nothing nothing\n  repo: Pkg.Types.GitRepo\n    source: Nothing nothing\n    rev: Nothing nothing\n  path: Nothing nothing\n  pinned: Bool false\n  mode: Pkg.Types.PackageMode PKGMODE_PROJECT\n``` | [00vareladavid]: @giordano Although it doesn't error, I think the build number is still not respected | [DilumAluthge]: > @giordano Although it doesn't error, I think the build number is still not respected\n\nYeah, exactly. It will always install the latest build number. | [KristofferC]: You can probably add by commit sha as a workaround. | [giordano]: Yep,\n```julia\nPkg.add(PackageSpec(; name = """"SuiteSparse_jll"""", rev = """"202ebf9db961644ad225cb53549dedc8f1df9453""""))\n```\ndoes the trick | [j-fu]: .... while it does the trick it feels like a workaround.  Is there a plan to extend the dependency management to the binarybuildert tools (inlcuding the build numbers)? | [KristofferC]: It is indeed a workaround. This would only get solved by someone going through the codebase and add support for this, adding proper testing and performance checks. | [IanButterworth]: One way in which this can be especially painful with pkgimages is it can punch through the `preserve=PRESERVE_TIERED` default strategy of `Pkg.add`, even if the tiered approach is satisfied with `PRESERVE_ALL` jlls with new builds will be updated, causing a whole load of autoprecompilation\n```\nshell> cd ~/.julia/registries/General\n/home/ian/.julia/registries/General\n\nshell> git checkout ae8ec3b695efb04ddec4371b97477779b6c62549\nHEAD is now at ae8ec3b695 New version: OpenAPI v0.1.7 (#77093)\n\n(@v1.10) pkg> activate --temp\n  Activating new project at `/tmp/jl_bgg4u9`\n\n(jl_bgg4u9) pkg> add ImageMagick_jll@6.9.11\n    Updating registry at `~/.julia/registries/General`\n┌ Error: Some registries failed to update:\n│     — `~/.julia/registries/General` — registry detached\n└ @ Pkg.Registry ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.10/Pkg/src/Registry/Registry.jl:476\n   Resolving package versions...\n   Installed ImageMagick_jll ─ v6.9.11+3\n  Downloaded artifact: ImageMagick\n    Updating `/tmp/jl_bgg4u9/Project.toml`\n⌃ [c73af94c] + ImageMagick_jll v6.9.11+3\n    Updating `/tmp/jl_bgg4u9/Manifest.toml`\n  [692b3bcd] + JLLWrappers v1.4.1\n  [21216c6a] + Preferences v1.3.0\n  [61579ee1] + Ghostscript_jll v9.55.0+3\n⌃ [c73af94c] + ImageMagick_jll v6.9.11+3\n  [aacddb02] + JpegTurbo_jll v2.1.2+0\n  [88015f11] + LERC_jll v3.0.0+1\n  [89763e89] + Libtiff_jll v4.4.0+0\n  [d3a379c0] + LittleCMS_jll v2.12.0+0\n  [643b3616] + OpenJpeg_jll v2.4.0+0\n  [3161d3a3] + Zstd_jll v1.5.2+0\n  [b53b4c65] + libpng_jll v1.6.38+0\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching\n  [b77e0a4c] + InteractiveUtils\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.10.0\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML v1.0.3\n  [a4e569a6] + Tar v1.10.0\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll v7.84.0+0\n  [29816b5a] + LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] + MbedTLS_jll v2.28.0+0\n  [14a3606d] + MozillaCACerts_jll v2022.10.11\n  [83775a58] + Zlib_jll v1.2.13+0\n  [8e850ede] + nghttp2_jll v1.48.0+0\n  [3f19e933] + p7zip_jll v17.4.0+0\n        Info Packages marked with ⌃ have new versions available and may be upgradable.\nPrecompiling environment...\n  1 dependency successfully precompiled in 1 seconds. 13 already precompiled.\n\n(jl_bgg4u9) pkg> add Example\n   Resolving package versions...\n    Updating `/tmp/jl_bgg4u9/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/tmp/jl_bgg4u9/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\n(jl_bgg4u9) pkg> rm Example\n    Updating `/tmp/jl_bgg4u9/Project.toml`\n  [7876af07] - Example v0.5.3\n    Updating `/tmp/jl_bgg4u9/Manifest.toml`\n  [7876af07] - Example v0.5.3\n\nshell> git checkout 3dd229c080a140cf67146ceb3ed6dba8add22ddf\nPrevious HEAD position was ae8ec3b695 New version: OpenAPI v0.1.7 (#77093)\nHEAD is now at 3dd229c080 New version: ImageMagick_jll v6.9.11+4 (#77094)\n\n(jl_bgg4u9) pkg> add Example\n   Resolving package versions...\n   Installed ImageMagick_jll ─ v6.9.11+4\n  Downloaded artifact: ImageMagick\n    Updating `/tmp/jl_bgg4u9/Project.toml`\n  [7876af07] + Example v0.5.3\n⌃ [c73af94c] ↑ ImageMagick_jll v6.9.11+3 ⇒ v6.9.11+4\n    Updating `/tmp/jl_bgg4u9/Manifest.toml`\n  [7876af07] + Example v0.5.3\n⌃ [c73af94c] ↑ ImageMagick_jll v6.9.11+3 ⇒ v6.9.11+4\n        Info Packages marked with ⌃ have new versions available and may be upgradable.\nPrecompiling environment...\n  1 dependency successfully precompiled in 1 seconds. 14 already precompiled.\n```",15,false,0,0,0,0,0,0,0,0,0
3367,Potential feature: recommend project environment on unsatisfiable requirements in default env,open,nilshg,,,,0,2023-02-10T12:54:34.0,2023-02-10T12:55:16.0,891,891,https://github.com/JuliaLang/Pkg.jl/issues/3367,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3367,"An idea: to cut down on the amount of """"unsatisfiable requirements"""" questions from new users, could we add a nudge to use a project environment when people get version conflicts in their main environment?\n\nSomething like:\n\n```\nERROR: Unsatisfiable requirements detected \n\nYou are trying to add a package to your default environment. To reduce the number of \npotential package version conflicts it is recommended not to install all packages \ninto the default environment, but to work with project specific environments instead. \nRead more at https://pkgdocs.julialang.org/v1/environments/\n\nUnsatisfiable requirements detected for package XXX\n[...full tree output...]\n```\n\nThis message would only be shown when conflicts happen in the default environment (on the assumption that users that already created a different environment don't have to be told how to do it!)\n\nRefinements could be:\n\n* Only show it the first/first X times a conflict happens in the main environment\n* Only show it when there are more than [3?] packages in the default environment",,0,false,0,0,0,0,0,0,0,0,0
3365,tree_hash does not handle devices,open,maleadt,,,,0,2023-02-08T06:13:30.0,2023-02-08T06:13:30.0,893,893,https://github.com/JuliaLang/Pkg.jl/issues/3365,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3365,"The input to `tree_hash` doesn't seem to need to be a directory:\n\n```julia\njulia> Pkg.GitTools.tree_hash(""""/tmp/x"""")\n20-element Vector{UInt8}:\n...\n```\n\nBut passing it a device fails:\n\n```julia\njulia> Pkg.GitTools.tree_hash(""""/dev/null"""")\nERROR: IOError: readdir(""""/dev/null""""): not a directory (ENOTDIR)\nStacktrace:\n [1] uv_error\n   @ ./libuv.jl:97 [inlined]\n [2] readdir(dir::String; join::Bool, sort::Bool)\n   @ Base.Filesystem ./file.jl:865\n [3] tree_hash(::Type{SHA.SHA1_CTX}, root::String; debug_out::Nothing, indent::Int64)\n   @ Pkg.GitTools ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Pkg/src/GitTools.jl:277\n [4] #tree_hash#15\n   @ ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Pkg/src/GitTools.jl:326 [inlined]\n [5] tree_hash(root::String)\n   @ Pkg.GitTools ~/.julia/juliaup/julia-1.8.5+0.x64.linux.gnu/share/julia/stdlib/v1.8/Pkg/src/GitTools.jl:326\n [6] top-level scope\n   @ REPL[8]:1\n```\n\nRealistically, such files can be encountered when e.g. hashing a rootfs, or an overlay directory (where removed files are represented by a whiteout char device).",,0,false,0,0,0,0,0,0,0,0,0
3354,Add feature to run specific test files.,open,codetalker7,,,,5,2023-02-02T08:14:24.0,2023-02-02T21:54:56.0,899,898,https://github.com/JuliaLang/Pkg.jl/issues/3354,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3354,"For instance, frameworks like `jest` allow the user to run tests [which follow a particular pattern](https://jestjs.io/docs/cli#running-from-the-command-line). Currently, in Julia, only the following two methods exist for testing: \n\n- Use the `Test.jl` package and run tests manually in a Julia session.\n- Test a package from `pkg` mode: \n```julia\n(packageName) pkg> test\n```\n\nThere is no systematic way in `Pkg.jl` to run specific test files. Packages like [TestSetExtensions.jl](https://github.com/ssfrr/TestSetExtensions.jl) exist, but I think this should be part of Julia's core functionality.\n\nI can think of two possible solutions: \n\n- An interface to mention particular files to test; for example, suppose the `test/` directory contains files `a.jl` and `b.jl`. To run the tests in only these files, one might do: \n```julia\n(packageName) pkg> test a b\n```\n\n- To allow running tests whose names match against a pattern. For example, if I have a `@testset`\n```julia\n@testset """"myfunction()"""" begin\n    # some tests\nend\n```\nThen I should be able to do\n\n```julia\n(packageName) pkg> test """"myfunction()""""\n```\nThis will make testing much easier and convenient.","[fredrikekre]: The Pkg REPL can perhaps pass arguments after the package and pass that to `test_args` which `Pkg.test` support already.\n```\npkg> test Example -- a b\n``` | [codetalker7]: > \n\n@fredrikekre thanks for this. However, `Pkg.jl`'s documentation doesn't explain much about `test_args`; will it be a good idea to add a few examples to the API reference for this?\n\nAlso, regarding your idea: does the Pkg REPL already have this feature, or is this yet to be implemented? | [fredrikekre]: No this doesn't work right now, was just an idea for what can be done from Pkg.jl's side. Filtering based on those arguments would then be done by the test framework you are using. | [codetalker7]: > No this doesn't work right now, was just an idea for what can be done from Pkg.jl's side. Filtering based on those arguments would then be done by the test framework you are using.\n\nYes, I think that would be a good idea. If you can provide me a starting point for this, I can work on this feature and make a PR. | [fredrikekre]: Probably would start here: https://github.com/JuliaLang/Pkg.jl/blob/957b55a896d5cb496da134ea7bf3ee70de07ef2a/src/REPLMode/command_declarations.jl#L9 by defining a new function that splits on `--` and then calls `parse_package` on the left and some other parsing of the right part, then thread that into the API call somewhere down the line",5,false,0,0,0,0,0,0,0,0,0
3348,[docs] document indirect conditional loading,open,CarloLucibello,,,,2,2023-01-30T15:26:55.0,2023-01-30T16:31:13.0,901,901,https://github.com/JuliaLang/Pkg.jl/issues/3348,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3348,"Say that my `Plotting` package has a `ContourExt` extension:\n```\nname = """"Plotting""""\n\n[weakdeps]\nContour = """"d38c429a-6771-53c6-b99e-75d170b6e991""""\n\n[extensions]\nContourExt = """"Contour""""\n```\nbut then in my code I never import `Contour` directly but only some package `PkgUsingContour` that depends on `Contour`.\nSo I wonder if after\n```julia\nusing PkgUsingContour, Plotting\n```\nthe `ContourExt` extension is available. \nIn any case, this behavior could be documented more clearly in the docs. \n\n \n","[KristofferC]: Yes, no matter how the weak dependency is loaded, the extension will be loaded (at least if it is loaded from the same environment). | [CarloLucibello]: Very nice, that is the behavior I was hoping for. \nSince the term """"loaded package"""" is used in describing extensions, we could add a corresponding definition in the Glossary section?",2,false,0,0,0,0,0,0,0,0,0
3270,Prioritize full upgrade of direct dependencies over indirect dependencies,open,BioTurboNick,,,,2,2022-12-02T15:26:42.0,2023-01-27T20:41:31.0,960,904,https://github.com/JuliaLang/Pkg.jl/issues/3270,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3270,"Currently, the package version resolver collects all dependent packages and updates them in order as far as [compat] allows.\n\nHowever, this can lead to an issue where an incompatible indirect dependency may be updated earlier in the order than a direct dependency. Because the resolver treats all packages as equal at this stage, the direct dependency is left at an earlier version.\n\nThis creates surprising behavior for users which can be frustrating to resolve. The direct dependency appears updatable with a green caret in `st`. The cause of this behavior also isn't shown in `st --outdated`. Updating the package specifically can temporarily work, because the resolver forces the indirect dependency down to a mutually compatible version. However, if the user ever tries a global update again, the problem re-emerges because the indirect dependency is updated again, which forces the direct dependency to downgrade. Related: #3198, #3119, #3248, #3232\n\nUsers generally expect that all direct dependencies should be updated as far as possible. They don't care if an indirect dependency is held back, or else they'd take that dependency directly and specify a version.\n\nIt is not necessarily possible to avoid all order-of-operations-related restrictions. However, it should not be possible to create a situation where Pkg can flip-flop between these states easily.\n\nThus:\n* Pkg should attempt to maximally upgrade all direct dependencies and find the highest mutually compatible set of indirect dependencies.\n* Pkg operations should be stable - `update` should not revert a state created by `update packagename` or vice versa","[BioTurboNick]: One simple, but not necessarily efficient, solution would be to do the following:\n`update` could:\n1) Run the current update as normal\n2) For every green-caret direct dependency, internally run `update packagename` on it in order\n3) If one of the previous operations downgrades another direct dependency earlier in the order, emit error that package X and Y cannot both be updated, and the user needs to provide a compat entry for one of them to resolve the conflict.\n\nEDIT: One matter this doesn't help with is conflicting indirect dependencies. However, it does allow that issue to be overcome by taking the downgraded indirect dependency as a direct dependency. | [JeffreySarnoff]: bump",2,false,2,2,0,0,0,0,0,0,0
3175,Suggest how to resolve conflict,open,jariji,,,,2,2022-08-20T22:32:18.0,2023-01-25T09:22:13.0,1064,907,https://github.com/JuliaLang/Pkg.jl/issues/3175,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3175,"```jl\npkg> add AlgebraOfGraphics@0.6.11\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package Observables [510215fc]:\n Observables [510215fc] log:\n ├─possible versions are: 0.2.0-0.5.1 or uninstalled\n ├─restricted by compatibility requirements with GLMakie [e9467ef8] to versions: [0.2.0-0.4.0, 0.5.1]\n │ └─GLMakie [e9467ef8] log:\n │   ├─possible versions are: 0.0.1-0.6.13 or uninstalled\n │   ├─restricted to versions * by an explicit requirement, leaving only versions 0.0.1-0.6.13\n │   ├─restricted by compatibility requirements with Colors [5ae59095] to versions: 0.0.18-0.6.13 or uninstalled, leaving only versions: 0.0.18-0.6.13\n │   │ └─Colors [5ae59095] log:\n │   │   ├─possible versions are: 0.9.0-0.12.8 or uninstalled\n │   │   ├─restricted to versions * by an explicit requirement, leaving only versions 0.9.0-0.12.8\n │   │   ├─restricted by compatibility requirements with AlgebraOfGraphics [cbdf2221] to versions: 0.12.0-0.12.8\n │   │   │ └─AlgebraOfGraphics [cbdf2221] log:\n │   │   │   ├─possible versions are: 0.1.0-0.6.11 or uninstalled\n │   │   │   └─restricted to versions 0.6.11 by an explicit requirement, leaving only versions 0.6.11\n │   │   └─restricted by compatibility requirements with Reexport [189a3867] to versions: 0.12.6-0.12.8 or uninstalled, leaving only versions: 0.12.6-0.12.8\n │   │     └─Reexport [189a3867] log:\n │   │       ├─possible versions are: 0.2.0-1.2.2 or uninstalled\n │   │       ├─restricted to versions [0.2, 1] by PrettyTables [08abe8d2], leaving only versions 0.2.0-1.2.2\n │   │       │ └─PrettyTables [08abe8d2] log:\n │   │       │   ├─possible versions are: 1.3.1 or uninstalled\n │   │       │   └─PrettyTables [08abe8d2] is fixed to version 1.3.1\n │   │       └─restricted by compatibility requirements with SampleChainsDynamicHMC [6d9fd711] to versions: 1.0.0-1.2.2\n │   │         └─SampleChainsDynamicHMC [6d9fd711] log:\n │   │           ├─possible versions are: 0.1.0-0.3.5 or uninstalled\n │   │           └─restricted to versions * by an explicit requirement, leaving only versions 0.1.0-0.3.5\n │   └─restricted by compatibility requirements with Makie [ee78f7c6] to versions: [0.0.2-0.2.9, 0.6.6-0.6.13] or uninstalled, leaving only versions: [0.0.18-0.2.9, 0.6.6-0.6.13]\n │     └─Makie [ee78f7c6] log:\n │       ├─possible versions are: 0.9.0-0.17.13 or uninstalled\n │       └─restricted by compatibility requirements with AlgebraOfGraphics [cbdf2221] to versions: 0.17.6-0.17.13\n │         └─AlgebraOfGraphics [cbdf2221] log: see above\n ├─restricted by compatibility requirements with TableView [40c74d1a] to versions: 0.2.0-0.4.0\n │ └─TableView [40c74d1a] log:\n │   ├─possible versions are: 0.1.0-0.7.1 or uninstalled\n │   ├─restricted to versions * by an explicit requirement, leaving only versions 0.1.0-0.7.1\n │   └─restricted by compatibility requirements with FloatingTableView [197bc772] to versions: 0.6.0-0.7.1\n │     └─FloatingTableView [197bc772] log:\n │       ├─possible versions are: 0.1.0-0.2.0 or uninstalled\n │       └─restricted to versions * by an explicit requirement, leaving only versions 0.1.0-0.2.0\n └─restricted by compatibility requirements with Makie [ee78f7c6] to versions: 0.5.1 — no versions left\n   └─Makie [ee78f7c6] log: see above\n```\n\nI want to install a package but it gives me a mass of information which I find hard to process (sometimes it's much larger than this). I usually look through it for some packages I recognize and try randomly removing them to see if that helps. I usually have to guess a number of times. \n\nIs there a simple rule for what I should do?\n\nIt would be helpful if the resolver could suggest some commands using heuristics for what I can remove in order to get the package I want. Some heuristics might be: a package is not recently used, hasn't been upgraded lately, is behind the upstream version (I'm not sure which of these are possible/make sense). \n\n\nFor example it might say:\n\n```\nSuggestions (any of these should allow installing AlgebraOfGraphics@0.6.11):\n\n    rm GLMakie, Observables # least recently used\n\n    rm AbstractPlotting # most behind \n```","[KristofferC]: It's pretty hard to give advice like that. But even though the log might look intimidating, it is usually not too bad to find the root cause, for example here we have:\n\n```\n Observables [510215fc] log:\n ├─possible versions are: 0.2.0-0.5.1 or uninstalled\n ├─restricted by compatibility requirements with TableView [40c74d1a] to versions: 0.2.0-0.4.0\n └─restricted by compatibility requirements with Makie [ee78f7c6] to versions: 0.5.1 — no versions left\n```\n\nwhich is clear because the intersection between 0.2.0-0.4.0 and 0.5.1 is empty. | [jkrumbiegel]: Part of the issue is that the log is quite verbose, so it's not easy to scan the relationships quickly.\nI've tried editing out parts that do not seem strictly necessary to me and end up with this, which to me seems much easier to read.\n\n```julia\nERROR: Unsatisfiable requirements detected for package Observables:\n Observables\n ├─has possible versions: 0.2.0-0.5.1\n ├─GLMakie requires: [0.2.0-0.4.0, 0.5.1]\n │   ├─has possible versions: 0.0.1-0.6.13\n │   ├─Colors requires: 0.0.18-0.6.13, leaving: 0.0.18-0.6.13\n │   │   ├─has possible versions: 0.9.0-0.12.8\n │   │   ├─AlgebraOfGraphics requires: 0.12.0-0.12.8\n │   │   │   ├─has possible versions: 0.1.0-0.6.11\n │   │   │   └─restricted to versions 0.6.11 explicitly, leaving: 0.6.11\n │   │   └─Reexport requires: 0.12.6-0.12.8, leaving: 0.12.6-0.12.8\n │   │       ├─has possible versions: 0.2.0-1.2.2\n │   │       ├─restricted to versions [0.2, 1] by PrettyTables, leaving: 0.2.0-1.2.2\n │   │       │   ├─has possible versions: 1.3.1\n │   │       │   └─PrettyTables is fixed to version 1.3.1\n │   │       └─SampleChainsDynamicHMC requires: 1.0.0-1.2.2\n │   │           └─has possible versions: 0.1.0-0.3.5\n │   └─Makie requires: [0.0.2-0.2.9, 0.6.6-0.6.13], leaving: [0.0.18-0.2.9, 0.6.6-0.6.13]\n │       ├─has possible versions: 0.9.0-0.17.13\n │       └─AlgebraOfGraphics requires: 0.17.6-0.17.13\n │         └─see above\n ├─TableView requires: 0.2.0-0.4.0\n │   ├─has possible versions: 0.1.0-0.7.1\n │   └─FloatingTableView requires: 0.6.0-0.7.1\n │       └─has possible versions: 0.1.0-0.2.0\n └─Makie requires: 0.5.1 — no versions left\n   └─see above\n\nAlgebraOfGraphics [cbdf2221], Colors [5ae59095], FloatingTableView [197bc772],\nGLMakie [e9467ef8], Makie [ee78f7c6], Observables [510215fc], PrettyTables [08abe8d2],\nReexport [189a3867], SampleChainsDynamicHMC [6d9fd711], TableView [40c74d1a]\n```\n\nIt seems like some lines mentioning restrictions are missing the `leaving ...` part, but that's from the original so either that's on purpose or a bug. I would find it more consistent if every line noting a restriction mentioned the remaining possible versions, so it filters downwards.",2,false,0,0,0,0,0,0,0,0,0
3337,Auto-Install with wrong package name does not hit the Suggestion Error message,open,felixcremer,,,,0,2023-01-25T07:46:25.0,2023-01-25T07:52:32.0,907,907,https://github.com/JuliaLang/Pkg.jl/issues/3337,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3337,"When I make a typo in an `using PackageName` it suggests to install it via `Pkg.add` which will then fail, because the package name has been misspelled. It would be nice to directly get the Suggestions for nearby package names which we get from a normal installation.\n\n```julia\njulia> using EXample\nERROR: ArgumentError: Package EXamle not found in current path.\n- Run `import Pkg; Pkg.add(""""EXample"""")` to install the EXample package.\nStacktrace:\n [1] macro expansion\n   @ ./loading.jl:1537 [inlined]\n [2] macro expansion\n   @ ./lock.jl:267 [inlined]\n [3] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1518\n\njulia> import Pkg; Pkg.add(""""EXample"""")\nERROR: The following package names could not be resolved:\n * EXample (not found in project, manifest or registry)\n   Suggestions: Example SMCExamples SIIPExamples ArviZExampleData DashTextareaAutocomplete TrajectoryGamesExamples ExactOptimalTransport ExpectationMaximizationPCA\nStacktrace:\n  [1] pkgerror(msg::String)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Types.jl:68\n  [2] ensure_resolved(ctx::Pkg.Types.Context, manifest::Pkg.Types.Manifest, pkgs::Vector{Pkg.Types.PackageSpec}; registry::Bool)\n    @ Pkg.Types ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Types.jl:989\n  [3] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:264\n  [4] kwcall(::NamedTuple{(:io,), Tuple{Base.TTY}}, ::typeof(Pkg.API.add), ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:226\n  [5] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:156\n  [6] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:145\n  [7] #add#25\n    @ ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:144 [inlined]\n  [8] add\n    @ ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:144 [inlined]\n  [9] #add#24\n    @ ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:143 [inlined]\n [10] add(pkg::String)\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:143\n [11] top-level scope\n    @ REPL[5]:1\n",,0,false,0,0,0,0,0,0,0,0,0
3335,`ArgumentError: invalid base 10 digit` when fixing package with exotic version suffix,open,topolarity,,,,2,2023-01-25T00:12:33.0,2023-01-25T01:37:29.0,907,907,https://github.com/JuliaLang/Pkg.jl/issues/3335,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3335,"I was trying to `pkg> fix Binutils_jll@2.38.0+4` on my machine but this seems to be impossible due to this error.\n\nThe best I could do was pin `Binutils_jll@2.38.0` which gives me version `Binutils_jll@2.38.0+3`.\n\nMWE:\n```terminal\n(@v1.9) pkg> pin FakePkg@0.1.2+3\n```\n\nOutput:\n```julia\nERROR: ArgumentError: invalid base 10 digit '+' in """"2+3""""\nStacktrace:\n  [1] tryparse_internal(#unused#::Type{Int64}, s::SubString{String}, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    @ Base ./parse.jl:137\n  [2] parse(::Type{Int64}, s::SubString{String}; base::Nothing)\n    @ Base ./parse.jl:241\n  [3] parse\n    @ ./parse.jl:240 [inlined]\n  [4] Pkg.Versions.VersionBound(s::SubString{String})\n    @ Pkg.Versions ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Versions.jl:112\n  [5] Pkg.Versions.VersionRange(s::String)\n    @ Pkg.Versions ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Versions.jl:146\n  [6] VersionSpec\n    @ ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/Versions.jl:229 [inlined]\n  [7] handle_package_input!(pkg::Pkg.Types.PackageSpec)\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:2040\n  [8] foreach\n    @ ./abstractarray.jl:3067 [inlined]\n  [9] pin(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:155\n [10] pin(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/API.jl:145\n [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/REPLMode/REPLMode.jl:412\n [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/REPLMode/REPLMode.jl:390\n [13] do_cmd\n    @ ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/REPLMode/REPLMode.jl:380 [inlined]\n [14] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/Pkg/src/REPLMode/REPLMode.jl:557\n [15] #invokelatest#2\n    @ ./essentials.jl:816 [inlined]\n [16] invokelatest\n    @ ./essentials.jl:813 [inlined]\n [17] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/REPL/src/LineEdit.jl:2644\n [18] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL ~/.julia/juliaup/julia-1.9.0-beta3+0.x64.linux.gnu/share/julia/stdlib/v1.9/REPL/src/REPL.jl:1293\n [19] (::REPL.var""""#62#68""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ./task.jl:514\n```","[IanButterworth]: Unfortunately Pkg doesn't handle the build part of version numbers, so they will always be updated to latest build and cannot be pinned. | [topolarity]: Would it be possible to make this a useful error message explaining the limitation, rather than an error + backtrace?",2,false,0,0,0,0,0,0,0,0,0
3326,Projects with symlinked `Project.toml`s are broken,open,chriselrod,,,,2,2023-01-18T20:35:18.0,2023-01-18T20:45:01.0,913,913,https://github.com/JuliaLang/Pkg.jl/issues/3326,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3326,"Because instantiating the project follows the symlink and creates/instantiates the `Manifest.toml` in the directory of the pointed to `Project.toml`.\nHowever, trying to `using` any package in that project checks the project directory itself, which doesn't have a `Manifest.toml` due to it having been created elsewhere.\n\nE.g.:\n[tests.tar.gz](https://github.com/JuliaLang/Pkg.jl/files/10450550/tests.tar.gz)\n\n```julia\n(myproj) pkg> instantiate\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/Documents/progwork/julia/tests/myproj/Project.toml`\n  [615f187c] + IfElse v0.1.1\n    Updating `~/Documents/progwork/julia/tests/myproj/Manifest.toml`\n  [615f187c] + IfElse v0.1.1\n\n(myproj) pkg> st\nStatus `~/Documents/progwork/julia/tests/myproj/Project.toml`\n  [615f187c] IfElse v0.1.1\n\njulia> using IfElse\nERROR: ArgumentError: Package IfElse [615f187c-cbe4-4ef1-ba3b-2fcf58d6d173] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\nStacktrace:\n [1] _require(pkg::Base.PkgId, env::String)\n   @ Base ./loading.jl:1685\n [2] _require_prelocked(uuidkey::Base.PkgId, env::String)\n   @ Base ./loading.jl:1571\n [3] macro expansion\n   @ ./loading.jl:1559 [inlined]\n [4] macro expansion\n   @ ./lock.jl:267 [inlined]\n [5] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1522\n\njulia> Base.active_project()\n""""/home/chriselrod/Documents/progwork/julia/tests/myprojlink/Project.toml""""\n\nshell> ll myprojlink/\ntotal 4.0K\nlrwxrwxrwx. 1 chriselrod chriselrod 22 Jan 18 15:19 Project.toml -> ../myproj/Project.toml\n```\n\nI attached the sample directory illustrating the problem.\n\n`myproj` contains a `Project.toml`.\n`myprojlink` contains a symlink to this `Project.toml`\n\nI activate the `myprojlink` project. The active project is `myprojlink`.\n\nI instantiate the project. The `Manifest.toml` gets created in `myproj`, the location of the actual `Project.toml`. That is, it follows the link.\n\nI `using IfElse`. This throws an error, because there is no `Manifest.toml` inside the active project. \nIt unhelpfully suggests I try instantiating the project.\n\n\nFor the example to illustrate the problem, you can't have `IfElse.jl` in your main environment/it can't be findable otherwise. Otherwise it'll load from that Project+Manifest instead of the one we're testing.\nI used `IfElse` as the example because (a) I figured people were unlikely to have it in their main environment and (b) it is one of the most lightweight packages.\n\n\nI think `Pkg` should be consistent in following or not following the symlink with respect to creating and reading the `Manifest.toml`.\nIt is the inconsistency that caused the problem.\n\nWhy does this example matter?\nSome package managers (e.g. [straight.el](https://github.com/radian-software/straight.el)) clone repos in one directory, and then sym link the files to another directory for building.\nThis doesn't work if you want to have Julia dependencies without also shipping a `Manifest.toml` to be copied over. https://github.com/non-Jedi/eglot-jl/pull/37","[KristofferC]: If the Project and Manifest files are created correctly, then this seems to be more an issue with the package loading code in Julia and not the package manager itself. | [chriselrod]: Should I file this bug with Julia?\n\nI'd say all the files were created correctly, assuming sym linking is considered valid (which I don't see why it shouldn't be).",2,false,0,0,0,0,0,0,0,0,0
3316,"JET.jl gets lots of error using `Pkg.activate`, `Pkg.instantiate` and `Pkg.status`",open,lgeissbauer-btig,,,,2,2023-01-16T10:13:28.0,2023-01-18T08:41:58.0,916,914,https://github.com/JuliaLang/Pkg.jl/issues/3316,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3316,"@aviatesk \n\n```\njulia> import Pkg\n\njulia> function f()\n\n       Pkg.activate(@__DIR__)\n       Pkg.instantiate()\n       Pkg.status(io=stderr)\n       println(stderr, """"julia = """", VERSION)\n       end\nf (generic function with 1 method)\n\njulia> JET.@report_call f()\n═════ 190 possible errors found ═════\n┌ @ REPL[10]:3 Pkg.activate(""""C:\\GitHub\\scripts\\Script"""")\n│┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1701 Pkg.API.:(var""""#activate#282"""")(false, false, Pkg.API.stderr_f(), #self#, path)\n││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1711 fullpath = Pkg.API._activate_dep(path)\n│││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1688 ctx = Pkg.API.Context()\n││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Types.jl:383 EnvCache()\n│││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Types.jl:343 #self#(Pkg.Types.nothing)\n││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Types.jl:364 manifest = read_manifest(manifest_file)\n│││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\manifest.jl:213 Manifest(raw, f_or_io)\n││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\manifest.jl:194 Pkg.Types.validate_manifest(julia_version, manifest_format, stage1, other)\n│││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\manifest.jl:117 Core.kwcall(NamedTuple{(:isext,)}(tuple(true)), Pkg.Types.normalize_deps, name, info.uuid, info.weakdeps, stage1)\n││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\manifest.jl:90 Pkg.Types.:(var""""#normalize_deps#38"""")(_9, _3, name, uuid, deps, manifest)\n│││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\manifest.jl:104 Pkg.Types.length(infos)\n││││││││││││ no matching method found `length(::Nothing)` (1/2 union split): Pkg.Types.length(infos::Union{Nothing, Vector{Pkg.Types.Stage1}})\n│││││││││││└───────────────────────────────────────────────────────────────────\n│││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\manifest.jl:106 infos[1]\n││││││││││││ no matching method found `getindex(::Nothing, ::Int64)` (1/2 union split): (infos::Union{Nothing, Vector{Pkg.Types.Stage1}})[1]\n│││││││││││└───────────────────────────────────────────────────────────────────\n││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Types.jl:383 Pkg.Registry.reachable_registries()\n│││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:401 Pkg.Registry.:(var""""#reachable_registries#25"""")(DEPOT_PATH, #self#)\n││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:431 Pkg.Registry.RegistryInstance(candidate)\n│││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:325  = Pkg.Registry.uncompress_registry(Pkg.Registry.joinpath(Pkg.Registry.dirname(path), compressed_file))\n││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:258 Pkg.Registry.open(#19, Base.cmd_gen(tuple(tuple(Pkg.Registry.exe7z()), tuple(x), tuple(tar_gz), tuple(-so))))\n│││││││││┌ @ process.jl:414 Base.:(var""""#open#769"""")(tuple(pairs(NamedTuple()), #self#, f, cmds), args...)\n││││││││││┌ @ process.jl:415  = open(tuple(cmds), args...)\n│││││││││││┌ @ process.jl:383 #self#(cmds, devnull)\n││││││││││││┌ @ process.jl:383 Base.:(var""""#open#768"""")(write, read, #self#, cmds, stdio)\n│││││││││││││┌ @ process.jl:393 processes = Base._spawn(cmds, Base.SpawnIO[stdio, out, stderr])\n││││││││││││││┌ @ process.jl:138 pp = Base.setup_stdios(#759, stdios)\n│││││││││││││││┌ @ process.jl:227 Base.close_stdio(open_io[i])\n││││││││││││││││┌ @ process.jl:316 close(stdio)\n│││││││││││││││││ no matching method found `close(::RawFD)`: close(stdio::RawFD)\n││││││││││││││││└──────────────────\n││││││││││┌ @ process.jl:427  = f(P)\n│││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:259 Core.kwcall(NamedTuple{(:buf,)}(tuple(getfield(#self#, :buf))), Pkg.Registry.Tar.read_tarball, #20, #21, tar)\n││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:342 Tar.:(var""""#read_tarball#45"""")(_9, _9, _3, callback, predicate, tar)\n│││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:354 hdr = Core.kwcall(NamedTuple{(:globals, :buf, :tee)}(tuple(globals, buf, skeleton)), Tar.read_header, tar)\n││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:418 Tar.:(var""""#read_header#48"""")(_8, _8, _8, _3, io)\n│││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:424 hdr = Core.kwcall(NamedTuple{(:buf, :tee)}(tuple(buf, tee)), Tar.read_standard_header, io)    \n││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:579 Tar.:(var""""#read_standard_header#58"""")(_7, _7, _3, io)\n│││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:599 Tar.match(r""""^(.*?)\s*\[header block data\]""""s, typeassert(Tar.convert(Union{SubString{String}, String}, err.msg), Union{SubString{String}, String})).captures\n││││││││││││││││││┌ @ Base.jl:37 Base.getfield(x, f)\n│││││││││││││││││││ type Nothing has no field captures\n││││││││││││││││││└──────────────\n│││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:407  = Tar.position(tar)\n││││││││││││││ no matching method found `position(::Base.Process)`:  = Tar.position(tar::Base.Process)\n│││││││││││││└──────────────────────────────────────────────────────────────────\n│││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Tar\src\extract.jl:410 Tar.position(tar)\n││││││││││││││ no matching method found `position(::Base.Process)`: Tar.position(tar::Base.Process)\n│││││││││││││└──────────────────────────────────────────────────────────────────\n│││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:340 reg = Pkg.Registry.RegistryInstance(path, typeassert(d[""""name""""], Pkg.Registry.String), Pkg.Registry.UUID(typeassert(d[""""uuid""""], Pkg.Registry.String)), typeassert(Pkg.Registry.get(d, """"repo"""", Pkg.Registry.nothing), Union{Nothing, String}), typeassert(Pkg.Registry.get(d, """"description"""", Pkg.Registry.nothing), Union{Nothing, String}), pkgs, tree_info, in_memory_registry, Dict{String, Base.UUID}())\n││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\registry_instance.jl:270 convert(fieldtype(Pkg.Registry.RegistryInstance, 9), name_to_uuids)\n│││││││││┌ @ abstractdict.jl:570 T(x)\n││││││││││┌ @ dict.jl:84 h[k] = v\n│││││││││││┌ @ dict.jl:370 v = convert(V, v0)\n││││││││││││ no matching method found `convert(::Type{Vector{Base.UUID}}, ::Base.UUID)`: v = convert(V::Type{Vector{Base.UUID}}, v0::Base.UUID)\n│││││││││││└───────────────\n││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1734 Pkg.API.PREV_ENV_PATH[] = Base.active_project()\n│││┌ @ refvalue.jl:57 b.x = x\n││││┌ @ Base.jl:38 convert(Base.fieldtype(Base.typeof(x), f), v)\n│││││ no matching method found `convert(::Type{String}, ::Nothing)`: convert(Base.fieldtype(Base.typeof(x::Base.RefValue{String})::Type{Base.RefValue{String}}, f::Symbol)::Type{String}, v::Nothing)\n││││└──────────────\n┌ @ REPL[10]:4 Pkg.instantiate()\n│┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1542 Pkg.API.:(var""""#instantiate#276"""")(pairs(NamedTuple()), #self#)\n││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1542 Pkg.API.instantiate(Pkg.API.Context())\n│││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1543 Pkg.API.HostPlatform()\n││││┌ @ binaryplatforms.jl:981 Base.BinaryPlatforms.host_triplet()\n│││││┌ @ binaryplatforms.jl:959 libstdcxx_version = detect_libstdcxx_version()\n││││││┌ @ binaryplatforms.jl:868 #self#(30)\n│││││││┌ @ binaryplatforms.jl:880 Core.kwcall(NamedTuple{(:throw_error,)}(tuple(false)), dlsym, hdl, string(""""GLIBCXX_3.4."""", minor_version))\n││││││││ no matching method found `kwcall(::NamedTuple{(:throw_error,), Tuple{Bool}}, ::typeof(Base.Libc.Libdl.dlsym), ::Nothing, ::String)` (1/2 union split): Core.kwcall(NamedTuple{(:throw_error,)}(tuple(false)::Tuple{Bool})::NamedTuple{(:throw_error,), Tuple{Bool}}, dlsym, hdl::Union{Nothing, Ptr{Nothing}}, string(""""GLIBCXX_3.4."""", minor_version)::String)\n│││││││└──────────────────────────\n│││││││┌ @ binaryplatforms.jl:880 Core.kwcall(NamedTuple{(:throw_error,)}(tuple(false)), dlsym, hdl, string(""""GLIBCXX_3.4."""", minor_version))\n││││││││ no matching method found `kwcall(::NamedTuple{(:throw_error,), Tuple{Bool}}, ::typeof(Base.Libc.Libdl.dlsym), ::Nothing, ::String)` (1/2 union split): Core.kwcall(NamedTuple{(:throw_error,)}(tuple(false)::Tuple{Bool})::NamedTuple{(:throw_error,), Tuple{Bool}}, dlsym, hdl::Union{Nothing, Ptr{Nothing}}, string(""""GLIBCXX_3.4."""", minor_version::Int64)::String)::Union{Nothing, Ptr{Nothing}}\n│││││││└──────────────────────────\n││││┌ @ binaryplatforms.jl:981 Base.BinaryPlatforms.parse(Platform, Base.BinaryPlatforms.host_triplet())\n│││││┌ @ binaryplatforms.jl:671 Base.BinaryPlatforms.:(var""""#parse#29"""")(false, #self#, _2, triplet)\n││││││┌ @ binaryplatforms.jl:718 arch = get_field(m, Base.BinaryPlatforms.arch_mapping)\n│││││││┌ @ binaryplatforms.jl:708 lastindex(m[k])\n││││││││ no matching method found `lastindex(::Nothing)` (1/2 union split): lastindex((m::RegexMatch)[k::String]::Union{Nothing, SubString{String}})\n│││││││└──────────────────────────\n│││││││┌ @ binaryplatforms.jl:708 m[k][11 Base.BinaryPlatforms.:(:) lastindex(m[k])]\n││││││││ no matching method found `getindex(::Nothing, ::UnitRange{Int64})` (1/2 union split): ((m::RegexMatch)[k::String]::Union{Nothing, SubString{String}})[(11 Base.BinaryPlatforms.:(:) lastindex((m::RegexMatch)[k::String]::Union{Nothing, SubString{String}})::Int64)::UnitRange{Int64}]\n│││││││└──────────────────────────\n││││││┌ @ binaryplatforms.jl:732 split_tags(m[""""tags""""])\n│││││││┌ @ binaryplatforms.jl:726 tag_fields = Core.kwcall(NamedTuple{(:keepempty,)}(tuple(false)), Base.BinaryPlatforms.split, tagstr, """"-"""")\n││││││││ no matching method found `kwcall(::NamedTuple{(:keepempty,), Tuple{Bool}}, ::typeof(split), ::Nothing, ::String)`: tag_fields = Core.kwcall(NamedTuple{(:keepempty,)}(tuple(false)::Tuple{Bool})::NamedTuple{(:keepempty,), Tuple{Bool}}, Base.BinaryPlatforms.split, tagstr::Nothing, """"-"""")\n│││││││└──────────────────────────\n││││││┌ @ binaryplatforms.jl:744 os_version = extract_os_version(""""macos"""", r"""".*darwin([\d\.]+)"""")\n│││││││┌ @ binaryplatforms.jl:736 m_osvn = Base.BinaryPlatforms.match(pattern, getfield(#self#, :m)[os_name])\n││││││││ no matching method found `match(::Regex, ::Nothing)` (1/2 union split): m_osvn = Base.BinaryPlatforms.match(pattern::Regex, (getfield(#self#::Base.BinaryPlatforms.var""""#extract_os_version#37""""{RegexMatch}, :m)::RegexMatch)[os_name::String]::Union{Nothing, SubString{String}})\n│││││││└──────────────────────────\n│││││││┌ @ binaryplatforms.jl:738 Base.BinaryPlatforms.VersionNumber(m_osvn.captures[1])\n││││││││ no matching method found `VersionNumber(::Nothing)` (1/2 union split): Base.BinaryPlatforms.VersionNumber(((m_osvn::RegexMatch).captures::Vector{Union{Nothing, SubString{String}}})[1]::Union{Nothing, SubString{String}})\n│││││││└──────────────────────────\n│││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1543 Pkg.API.:(var""""#instantiate#277"""")(Pkg.API.nothing, true, false, Pkg.API.HostPlatform(), true, true, pairs(NamedTuple()), #self#, ctx)\n││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1543 Pkg.API.:(var""""#instantiate#277"""")(_12, _12, _12, _12, _12, _12, kwargs..., _3, ctx)\n│││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\API.jl:1547 Pkg.Registry.download_default_registries(ctx.io)\n││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:98 Pkg.Registry.:(var""""#download_default_registries#39"""")(true, Pkg.Registry.depots1(), #self#, io)│││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:105 Pkg.Registry.pkg_server_registry_urls()\n││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:86 server_registry_info = Pkg.Registry.pkg_server_registry_info()\n│││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:66 f()\n││││││││││┌ @ error.jl:291 getfield(#self#, Symbol(""""#91#92""""))(tuple(pairs(NamedTuple()), #self#), args...)\n│││││││││││┌ @ error.jl:296 getfield(#91#92, :f)(args...)\n││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:64 Core.kwcall(NamedTuple{(:verbose,)}(tuple(false)), Pkg.Registry.download, string(getfield(#self#, :server), """"/registries""""), getfield(#self#, :tmp_path))\n│││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:252 Pkg.PlatformEngines.:(var""""#download#15"""")(_10, _10, _10, _10, _3, url, dest)\n││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:261 auth_header = Core.kwcall(NamedTuple{(:verbose,)}(tuple(verbose)), Pkg.PlatformEngines.get_auth_header, url)\n│││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:110 Pkg.PlatformEngines.:(var""""#get_auth_header#10"""")(_6, _3, url)\n││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:111 server_dir = Pkg.PlatformEngines.get_server_dir(url)\n│││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:50 #self#(url, Pkg.PlatformEngines.pkg_server())\n││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:59 Pkg.PlatformEngines.String(m[1])\n│││││││││││││││││││ no matching method found `String(::Nothing)` (1/2 union split): Pkg.PlatformEngines.String((m::RegexMatch)[1]::Union{Nothing, SubString{String}})\n││││││││││││││││││└─────────────────────────────────────────────────────────────────────────\n││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:163 Core.kwcall(NamedTuple{(:auth_header, :verbose)}(tuple(refresh_auth, verbose)), Pkg.PlatformEngines.download, refresh_url, tmp)\n│││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:252 Pkg.PlatformEngines.:(var""""#download#15"""")(_10, _10, _10, _10, _3, url, dest)\n││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:266 Pkg.PlatformEngines.get_metadata_headers(url)\n│││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:224 Pkg.PlatformEngines.push!(headers, """"Julia-Pkg-Server"""" Pkg.PlatformEngines.:(=>) server)\n││││││││││││││││││││┌ @ array.jl:1060 itemT = convert(T, item)\n│││││││││││││││││││││┌ @ pair.jl:63 convert(B, x[2])\n││││││││││││││││││││││ no matching method found `convert(::Type{String}, ::Nothing)`: convert(B::Type{String}, (x::Pair{String, Nothing})[2]::Nothing)\n│││││││││││││││││││││└──────────────\n│││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:243 words = Core.kwcall(NamedTuple{(:keepempty,)}(tuple(false)), Pkg.PlatformEngines.split, m.captures[1], _)\n││││││││││││││││││││ no matching method found `kwcall(::NamedTuple{(:keepempty,), Tuple{Bool}}, ::typeof(split), ::Nothing, ::Char)` (1/2 union split): words = Core.kwcall(NamedTuple{(:keepempty,)}(tuple(false)::Tuple{Bool})::NamedTuple{(:keepempty,), Tuple{Bool}}, Pkg.PlatformEngines.split, ((m::RegexMatch).captures::Vector{Union{Nothing, SubString{String}}})[1]::Union{Nothing, SubString{String}}, _)\n│││││││││││││││││││└──────────────────────────────────────────────────────────────────────────\n││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:285  = Core.kwcall(NamedTuple{(:headers, :progress)}(tuple(headers, progress)), Pkg.PlatformEngines.Downloads.download, url, dest)\n│││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:221 Downloads.:(var""""#download#2"""")(_13, _13, _13, _13, _13, _13, _13, _3, url, output) \n││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:232 Downloads.arg_write(#3, output)\n│││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\ArgTools\src\ArgTools.jl:103 Core.kwcall(NamedTuple{(:write,)}(tuple(true)), ArgTools.open_nolock, f, arg)     \n││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\ArgTools\src\ArgTools.jl:35 ArgTools.:(var""""#open_nolock#1"""")(tuple(kws..., _3), args...)\n│││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\ArgTools\src\ArgTools.jl:35 Core.kwcall(tuple(merge(merge(Base.NamedTuple(), kws), NamedTuple{(:lock,)}(tuple(false))), ArgTools.open), args...)\n││││││││││││││││││││││││┌ @ io.jl:392 Base.:(var""""#open#408"""")(tuple(kwargs..., _3, f), args...)\n│││││││││││││││││││││││││┌ @ io.jl:395  = f(io)\n││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:233 Core.kwcall(NamedTuple{(:output, :method, :headers, :timeout, :progress, :verbose, :debug, :downloader)}(tuple(output, getfield(#self#, :method), getfield(#self#, :headers), getfield(#self#, :timeout), getfield(#self#, :progress), getfield(#self#, :verbose), getfield(#self#, :debug), getfield(#self#, :downloader))), request, getfield(#self#, :url))\n│││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:295 Downloads.:(var""""#request#5"""")(_15, _15, _15, _15, _15, _15, _15, _15, _15, \n_15, _3, url)\n││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:327 Downloads.arg_read(#7, input)\n│││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\ArgTools\src\ArgTools.jl:76 f(arg)\n││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:328 Downloads.arg_write(#8, getfield(#self#, :output))\n│││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\ArgTools\src\ArgTools.jl:134 f(arg)\n││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:329 Downloads.with_handle(#9, Downloads.Easy())\n│││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Curl.jl:90  = f(handle)\n││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:331 Downloads.set_url(easy, getfield(#self#, :url))\n│││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Easy.jl:109 Downloads.Curl.verify_host(url, """"ssl"""")\n││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\NetworkOptions\src\verify_host.jl:60 NetworkOptions.env_host_pattern_match(""""JULIA_ALWAYS_VERIFY_HOSTS"""", host)\n│││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\NetworkOptions\src\verify_host.jl:83 NetworkOptions.occursin(NetworkOptions.env_host_pattern_regex(var), host)\n││││││││││││││││││││││││││││││││││││││ no matching method found `occursin(::Nothing, ::SubString{String})` (1/2 union split): NetworkOptions.occursin(NetworkOptions.env_host_pattern_regex(var::String)::Union{Nothing, Regex}, host::SubString{String})\n│││││││││││││││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────────────\n││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Downloads.jl:364 Downloads.add_handle(getfield(getfield(#self#, :downloader), :contents).multi, easy)\n│││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:45 Downloads.Curl.lock(#25, multi.lock)\n││││││││││││││││││││││││││││││││││││┌ @ lock.jl:229  = f()\n│││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:50 Downloads.Curl.init!(getfield(#self#, :multi))\n││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:18 Downloads.Curl.add_callbacks(multi)\n│││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:209 socket_cb = $(Expr(:cfunction, Ptr{Nothing}, :($(QuoteNode(Downloads.Curl.socket_callback))), Int32, svec(Ptr{Nothing}, Base.Libc.WindowsRawSocket, Int32, Ptr{Nothing}, Ptr{Nothing}), :(:ccall)))\n││││││││││││││││││││││││││││││││││││││││┌ @ task.jl:518 task = Base.Task(#54)\n│││││││││││││││││││││││││││││││││││││││││┌ @ task.jl:5 #self#(f, 0)\n││││││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:184 Downloads.Curl.lock(#55, getfield(#self#, :multi).lock)   \n│││││││││││││││││││││││││││││││││││││││││││┌ @ lock.jl:229  = f()\n││││││││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:185 getfield(#self#, :watcher).writable\n│││││││││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\FileWatching\src\FileWatching.jl:293 fdw.mask.writable\n││││││││││││││││││││││││││││││││││││││││││││││┌ @ Base.jl:37 Base.getfield(x, f)\n│││││││││││││││││││││││││││││││││││││││││││││││ type Bool has no field writable\n││││││││││││││││││││││││││││││││││││││││││││││└──────────────\n││││││││││││││││││││││││││││││││││││││││││││││┌ @ Base.jl:37 Base.getfield(x, f)\n│││││││││││││││││││││││││││││││││││││││││││││││ type FileWatching._FDWatcher has no field writable\n││││││││││││││││││││││││││││││││││││││││││││││└──────────────\n││││││││││││││││││││││││││││││││││││││││┌ @ task.jl:518 task = Base.Task(#57)\n│││││││││││││││││││││││││││││││││││││││││┌ @ task.jl:5 #self#(f, 0)\n││││││││││││││││││││││││││││││││││││││││││┌ @ logging.jl:349 tuple(Downloads.Curl.err, 1000)\n│││││││││││││││││││││││││││││││││││││││││││ `Downloads.Curl.err` is not defined\n││││││││││││││││││││││││││││││││││││││││││└──────────────────\n│││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:111 Pkg.Registry.download_registries(io, registries, depot)\n││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:168 Core.kwcall(NamedTuple{(:stale_age,)}(tuple(10)), mkpidlock, #48, Pkg.Registry.joinpath(regdir, """".pid""""))\n│││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\FileWatching\src\pidfile.jl:77 FileWatching.Pidfile.:(var""""#mkpidlock#6"""")(kwopts..., _3, f, at)\n││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\FileWatching\src\pidfile.jl:77 Core.kwcall(merge(Base.NamedTuple(), kwopts), mkpidlock, f, at, FileWatching.Pidfile.getpid())\n│││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\FileWatching\src\pidfile.jl:79 FileWatching.Pidfile.:(var""""#mkpidlock#7"""")(kwopts..., _3, f, at, pid)\n││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\FileWatching\src\pidfile.jl:82  = f()\n│││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:183 Pkg.Registry.download_verify(url, Pkg.Registry.nothing, tmp)\n││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:318 Pkg.PlatformEngines.:(var""""#download_verify#20"""")(false, false, false, #self#, url, hash, dest)\n│││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:351 f()\n││││││││││││││││┌ @ error.jl:291 getfield(#self#, Symbol(""""#91#92""""))(tuple(pairs(NamedTuple()), #self#), args...)\n│││││││││││││││││┌ @ error.jl:308 getfield(#91#92, :f)(args...)\n││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:349 Core.kwcall(NamedTuple{(:verbose,)}(tuple(_2)), Pkg.PlatformEngines.download, getfield(#self#, :url), getfield(#self#, :dest))\n││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\PlatformEngines.jl:272 bar = Core.kwcall(NamedTuple{(:header, :color)}(tuple(""""Downloading"""", Pkg.PlatformEngines.Base.info_color())), Pkg.PlatformEngines.MiniProgressBar)\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\MiniProgressBars.jl:7 Pkg.MiniProgressBars.:(var""""#MiniProgressBar#1"""")(_15, _15, _15, _15, _15, _15, _15, _15, _15, _15, _15, _3)\n││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\MiniProgressBars.jl:7 MiniProgressBar(max, header, color, width, current, prev, has_shown, time_shown, percentage, always_reprint, indent)\n│││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\MiniProgressBars.jl:8 convert(fieldtype(MiniProgressBar, 3), color)\n││││││││││││││││││││││││││││ no matching method found `convert(::Type{Symbol}, ::Int64)`: convert(fieldtype(MiniProgressBar, 3)::Type{Symbol}, color::Int64)\n│││││││││││││││││││││││││││└─────────────────────────────────────────────────────────────────────────\n│││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:199 Pkg.Registry.mktempdir(#50)\n││││││││││││││┌ @ file.jl:756 #self#(fn, tempdir())\n│││││││││││││││┌ @ file.jl:756 Base.Filesystem.:(var""""#mktempdir#24"""")(Base.Filesystem.temp_prefix, #self#, fn, parent)\n││││││││││││││││┌ @ file.jl:760  = fn(tmpdir)\n│││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:211 Pkg.Registry.pkgerror(string(""""A symlinked registry was requested but `path` was not set and `url` was set to `"""", getfield(#self#, :url), """"`.\nSet only `path` and `linked = true` to use registry symlinking.\n""""))\n││││││││││││││││││ `Pkg.Registry.pkgerror` is not defined\n│││││││││││││││││└────────────────────────────────────────────────────────────────────────────\n│││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\Registry\Registry.jl:235 repo = Core.kwcall(NamedTuple{(:header,)}(tuple(string(""""registry from """", Pkg.Registry.repr(getfield(#self#, :reg).url)))), Core.kwcall(NamedTuple{(:delays, :check)}(tuple(Pkg.Registry.fill(1.0, 5), #51)), Pkg.Registry.retry, Pkg.GitTools.clone), getfield(#self#, :io), getfield(#self#, :reg).url, tmp)\n││││││││││││││││││┌ @ error.jl:291 getfield(_3, Symbol(""""#91#92""""))(tuple(kwargs..., _3), args...)\n│││││││││││││││││││┌ @ error.jl:296 Core.kwcall(tuple(merge(Base.NamedTuple(), kwargs), getfield(#91#92, :f)), args...)\n││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\GitTools.jl:88 Pkg.GitTools.:(var""""#clone#3"""")(_10, _10, kwargs..., _3, io, url, source_path)\n│││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\GitTools.jl:90 url = Pkg.GitTools.normalize_url(url)\n││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\GitTools.jl:58 Pkg.GitTools.lowercase(host)\n│││││││││││││││││││││││ no matching method found `lowercase(::Nothing)` (1/2 union split): Pkg.GitTools.lowercase(host)\n││││││││││││││││││││││└──────────────────────────────────────────────────────────────────\n││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\GitTools.jl:63 Pkg.GitTools.lowercase(host)\n│││││││││││││││││││││││ no matching method found `lowercase(::Nothing)` (1/2 union split): Pkg.GitTools.lowercase(host::Union{Nothing, SubString{String}})\n││││││││││││││││││││││└──────────────────────────────────────────────────────────────────\n│││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Pkg\src\GitTools.jl:115  = Core.kwcall(merge(NamedTuple{(:callbacks, :credentials)}(tuple(callbacks, credentials)), kwargs), LibGit2.clone, url, source_path)\n││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\LibGit2.jl:556 LibGit2.:(var""""#clone#120"""")(_11, _11, _11, _11, _11, _3, repo_url, repo_path)       \n│││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\LibGit2.jl:564 LibGit2.credentials_cb()\n││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:513 $(Expr(:cfunction, Ptr{Nothing}, :($(QuoteNode(LibGit2.credentials_callback))), Int32, svec(Ptr{Ptr{Nothing}}, Cstring, Cstring, UInt32, Any), :(:ccall)))\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:281 m[:scheme]\n││││││││││││││││││││││││││ no matching method found `getindex(::Nothing, ::Symbol)` (1/2 union split): m[:scheme]\n│││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:282 m[:user]\n││││││││││││││││││││││││││ no matching method found `getindex(::Nothing, ::Symbol)` (1/2 union split): m[:user]\n│││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:283 m[:host]\n││││││││││││││││││││││││││ no matching method found `getindex(::Nothing, ::Symbol)` (1/2 union split): m[:host]\n│││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:283 p.host = m[:host]\n││││││││││││││││││││││││││┌ @ Base.jl:38 convert(Base.fieldtype(Base.typeof(x), f), v)\n│││││││││││││││││││││││││││ no matching method found `convert(::Type{String}, ::Nothing)`: convert(Base.fieldtype(Base.typeof(x::LibGit2.CredentialPayload)::Type{LibGit2.CredentialPayload}, f::Symbol)::Type{String}, v::Nothing)\n││││││││││││││││││││││││││└──────────────\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:307 LibGit2.haskey(p.cache, cred_id)\n││││││││││││││││││││││││││ no matching method found `haskey(::Nothing, ::String)` (1/2 union split): LibGit2.haskey((p::LibGit2.CredentialPayload).cache::Union{Nothing, LibGit2.CachedCredentials}, cred_id)\n│││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:309 p.cache[cred_id]\n││││││││││││││││││││││││││ no matching method found `getindex(::Nothing, ::String)` (1/2 union split): ((p::LibGit2.CredentialPayload).cache::Union{Nothing, LibGit2.CachedCredentials})[cred_id::String]\n│││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:323 err = LibGit2.authenticate_ssh(libgit2credptr, p, username_ptr)\n││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:124 response = Core.kwcall(NamedTuple{(:default,)}(tuple(cred.user)), Base.prompt, string(""""Username for '"""", url, """"'""""))\n│││││││││││││││││││││││││││┌ @ util.jl:385 Base.:(var""""#prompt#969"""")(_6, _3, message)\n││││││││││││││││││││││││││││┌ @ util.jl:385 Core.kwcall(NamedTuple{(:default,)}(tuple(default)), Base.prompt, stdin, stdout, message)\n│││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:213 VSCodeServer.IJuliaCore.:(var""""#prompt#2"""")(_8, _3, input, output, message)\n││││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:215 VSCodeServer.IJuliaCore.readprompt(message VSCodeServer.IJuliaCore.:* """": """")\n│││││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:188 VSCodeServer.IJuliaCore.:(var""""#readprompt#1"""")(false, #self#, prompt)\n││││││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:193 VSCodeServer.IJuliaCore.raw_input[]\n│││││││││││││││││││││││││││││││││ `VSCodeServer.IJuliaCore.raw_input` is not defined\n...\n```","[KristofferC]: I think it would be good to filter this a bit. For example:\n\n```\n│││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\LibGit2\src\callbacks.jl:307 LibGit2.haskey(p.cache, cred_id)\n││││││││││││││││││││││││││ no matching method found `haskey(::Nothing, ::String)` (1/2 union split): LibGit2.haskey((p::LibGit2.CredentialPayload).cache::Union{Nothing, LibGit2.CachedCredentials}, cred_id)\n│││││││││││││││││││││││││└────────────────────────────────────────────────────────────────────────\n```\n\n```\n│││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:213 VSCodeServer.IJuliaCore.:(var""""#prompt#2"""")(_8, _3, input, output, message)\n││││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:215 VSCodeServer.IJuliaCore.readprompt(message VSCodeServer.IJuliaCore.:* """": """")\n│││││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:188 VSCodeServer.IJuliaCore.:(var""""#readprompt#1"""")(false, #self#, prompt)\n││││││││││││││││││││││││││││││││┌ @ c:\Users\lgeissbauer\.vscode\extensions\julialang.language-julia-1.40.1\scripts\packages\IJuliaCore\src\stdio.jl:193 VSCodeServer.IJuliaCore.raw_input[]\n│││││││││││││││││││││││││││││││││ `VSCodeServer.IJuliaCore.raw_input` is not defined\n```\n\n```\n│││││││││││││││││││││││││││││││││││││││││││┌ @ lock.jl:229  = f()\n││││││││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\Downloads\src\Curl\Multi.jl:185 getfield(#self#, :watcher).writable\n│││││││││││││││││││││││││││││││││││││││││││││┌ @ C:\workdir\usr\share\julia\stdlib\v1.10\FileWatching\src\FileWatching.jl:293 fdw.mask.writable\n││││││││││││││││││││││││││││││││││││││││││││││┌ @ Base.jl:37 Base.getfield(x, f)\n│││││││││││││││││││││││││││││││││││││││││││││││ type Bool has no field writable\n││││││││││││││││││││││││││││││││││││││││││││││└──────────────\n```\n\netc doesn't seem to have anything to do with Pkg. | [aviatesk]: This would cut off reports that are found within """"non-`Pkg`"""" module context:\n```julia\njulia> struct ParentMod; mod::Module; end\n\njulia> function JET.match_module(mod::ParentMod, @nospecialize(report::JET.InferenceErrorReport))\n           return parentmodule(JET.linfomod(last(report.vst).linfo)) === mod.mod\n       end\n\njulia> report_call(; target_modules=(ParentMod(Pkg),)) do\n           Pkg.activate(@__DIR__)\n           Pkg.instantiate()\n           Pkg.status(io=stderr)\n           println(stderr, """"julia = """", VERSION)\n       end\n═════ 102 possible errors found ═════\n[...]\n```",2,false,0,0,0,0,0,0,0,0,0
3305,[Feature Request] Add an Option to Copy an Existing `Project.toml` to Initialize an Environment,open,RoyiAvital,,,,2,2023-01-10T13:39:05.0,2023-01-16T13:35:28.0,922,916,https://github.com/JuliaLang/Pkg.jl/issues/3305,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3305,As a continuation to the chat on Slack:\n\n![image](https://user-images.githubusercontent.com/7347975/211565930-ad41b118-00ff-44be-a858-18679baf3980.png)\n\nIt would be great to be able to set the initial `Project.toml` of a new environment (Specifically the `--temp` environment) from an existing environment or a path to a file.,"[timholy]: Relatedly, this might be a way to avoid the issues discussed in https://discourse.julialang.org/t/10-15-minute-ttfp-with-plots-jl-please-help/92636: provide an option to initialize a Manifest with the versions used in your default (or other) environment. | [KristofferC]: > provide an option to initialize a Manifest with the versions used in your default (or other) environment.\n\nRelated to this, there is currently some work going on where multiple projects are able to share one """"mega manifest"""" (so that all the projects share dependency versions).",2,false,0,0,0,0,0,0,0,0,0
3297,Feature request: more flexibility for Project extras and targets,open,MarkNahabedian,,,,1,2023-01-03T16:53:52.0,2023-01-11T01:25:54.0,928,921,https://github.com/JuliaLang/Pkg.jl/issues/3297,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3297,"I find it an undue nuisance to have to maintain a separate environment to build documentation.  It would be helpful if one could use the extras/targets mechanism in `Project.toml` to describe and set up that environment.\n\nI searched Pkg.jl to see how `extras` and `targets` are used and found that they are only used for the `test` and `build` operations.  It would be nice if this mechanism were generalized to support arbitrary targets.\n\nMaybe `Pkg.activate` could take a `target` keyword argument that would use the """"environment"""" for the specified target.  `Pkg.add`, etc would manipulate the `extras` and `targets` of the project as necessary, rather than `deps`, if a target is specified.\n\nBecause this mechanism must be available before one can access code that is not part of the julia release, I feel it should be provided in Pkg.jl itself.\n\n\nI fear ths might be a big change.  That an environment is represented soley by a file path seems to go pretty deep.\n\nThis work might involve refactoring how envirnments are represented and operated on, perhaps making them first class objects.  It seems that any code that wants to customize an environment needs to create a temporary directory and manipulate the Project.toml and Manifest.toml files within it.  Not only does Pkg.jl do this itself (see Pkg.Operations.sandbox) but other packages like Pluto (see Pluto.activate_notebook_environment)) need to do it as well.\n\n\nIn the mean time, to build docs for my projects, I'm experimenting with Pkg.Operations.sandbox and Pkg.Operations.gen_target_project, but there seems to be a lot of setup I need to do to make that work, and I've not identified it all yet.\n","[MarkNahabedian]: Also see """"subprojects"""" proposal https://github.com/JuliaLang/Pkg.jl/issues/1233.",1,false,9,9,0,0,0,0,0,0,0
3300,`instantiate` triggers `build` on deps but not the active package,open,IanButterworth,,,,6,2023-01-05T16:11:15.0,2023-01-06T16:08:14.0,926,925,https://github.com/JuliaLang/Pkg.jl/issues/3300,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3300,"If you check out a package, activate it, then call `Pkg.instantiate` it installs and builds the deps, then autoprecompiles the deps and the package itself. Notably the package itself doesn't get `build` called on it, so you can end up in an error state unless your package does some check that it was actually built.\n\nMeaning that on scripts that run in the package itself you have to call \n```\nusing Pkg\nPkg.instantiate(allow_autoprecomp = false)\nPkg.build()\nPkg.precompile()\n```\n\nThis is also the reason CI testing needs\n```\njulia-buildpkg\njulia-runtest\n```\neven though the latter calls `Pkg.instantiate` etc..\n\nIt would be good to understand whether this is intentional design, and if so what motivates it.\n\n","[fredrikekre]: I believe it is intentional, `build` is only triggered the first time a package is installed to disk so since the package itself is already cloned `build` does not run. If `instantiate` would trigger `build` it would have to *always* do it, since it is not possible to tell if a package is built or not. | [IanButterworth]: Ok that makes sense, thanks.\n\nThe docs in this section are problematic then if the cloned repo requires build\nhttps://pkgdocs.julialang.org/dev/environments/#Using-someone-else's-project\n\nI'm not sure how to modify the example though\n\nThis won't work because the packages might be missing that are needed by build\n```\n(@v1.8) pkg> activate Example.jl\n\n(Example) pkg> build\n\n(Example) pkg> instantiate\n```\n\nOtherwise you'd need to do this and hit precompilation twice (or disable autoprecomp which is awkward)\n```\n(@v1.8) pkg> activate Example.jl\n\n(Example) pkg> instantiate\n\n(Example) pkg> build\n\n(Example) pkg> precompile\n```\n\nNow that scratchspaces are used for build logs, perhaps we can just detect if the root environment has been built? | [fredrikekre]: The docs are correct if """"someone else's project"""" is just a project and not a package though, but the repo name suggest it might be a package.. | [IanButterworth]: True, that needs changing.\n\nThe build scratchspace log path is based on the tree hash, so feasibly `Pkg.instantiate` could detect if the env is a package with a `build.jl` and auto-build it if there's no build log for it? Would there be an issue with that? | [fredrikekre]: > The build scratchspace log path is based on the tree hash\n\nNot for `dev`d packages I think, then you hit https://github.com/JuliaLang/Pkg.jl/blob/a8ae3c58078f8815718d3edc3842edf3a36adefa/src/Operations.jl#L1084 | [IanButterworth]: ok, so that's even simpler. It's not like developers are calling `instantiate` a lot during development, so it's a one off check in a clean dev-ed/activated package",6,false,0,0,0,0,0,0,0,0,0
3301,"""Missing source file for ..."" error during precompilation",open,timholy,,,,1,2023-01-06T11:56:42.0,2023-01-06T12:16:11.0,926,926,https://github.com/JuliaLang/Pkg.jl/issues/3301,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3301,"https://github.com/JuliaImages/ImageView.jl/actions/runs/3841921340/jobs/6542696058#step:6:389\n\nVery puzzling. Didn't happen on any other platforms other than macOS + nightly. But the tests continued, and then failed for (presumably unrelated) reasons.",[KristofferC]: There are two Observables getting installed:\n\n```\n  [510215fc] Observables v0.5.4\n  [a223df75] Observables v0.8.3\n```\n\nI guess it is related to that.,1,false,0,0,0,0,0,0,0,0,0
3292,Registry updates from package server does not do incremental updates,open,LilithHafner,,performance; registries; network,,1,2022-12-28T15:21:30.0,2022-12-28T15:36:22.0,934,934,https://github.com/JuliaLang/Pkg.jl/issues/3292,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3292,"I updated my local registry this morning and tracked the network traffic of the Julia process the OS-level. I ran this: \n```julia\n(@v1.8) pkg> activate --temp\n  Activating new project at `/var/folders/hc/fn82kz1j5vl8w7lwd4l079y80000gn/T/jl_3Zj1Lx`\n\n(jl_3Zj1Lx) pkg> up\n[...]\n```\nAnd recorded 16.2 MB downloaded. It had been less than 24 hours since the previous registry update. The [diff](https://github.com/JuliaRegistries/General/compare/a57dd5364ab601e6a6bd4c275a35c9c8deff1e8e..f22e6f4c22794daa9c739fd28dde9ed699e61012) from the past 24 hours has 221 additions and 13 deletions.\n\nFor context, the 1000 most commonly downloaded packages have a total uncompressed size (including only .jl files) of 172 MB and compressed size of 34 MB. It seems ridiculous that a no-op operation uses network resources equivalent to downloading about 500 packages.\n\nThe compressed size of the General registry (as per `git clone --depth 1` & `tar -zcvf`) is 16.9 MB. It appears I downloaded the entire registry when I only needed a few kilobytes.","[KristofferC]: You can swap to using `git`  for the registry if you want to get incremental updates. When using the package server we indeed currently ship the whole thing on every update.\n\nAlthough the `General.tar.gz` is currently 5.4MB, not 16MB.",1,false,0,0,0,0,0,0,0,0,0
2741,Installation of Julia packages for fully offline environments,open,lpanichi,,enhancement,,6,2021-09-24T09:32:14.0,2022-12-28T14:23:56.0,1395,935,https://github.com/JuliaLang/Pkg.jl/issues/2741,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2741,"It could be nice to have a simple way of installing a package for fully offline environments.\nPython has wheels archives and it's ok but you often have to manually download several archives, libraries should be shipped with all their depandancies.\n\nBesides, because the need of offline installation arise usually in constrained environments, the installation directory of these packages should be configurable and default on the directory of the portable version of julia used.\n","[jakobnissen]: Have you seen `Pkg.offline(true)`? | [lpanichi]: I have found the functionnality you are talking about in [the code ](https://github.com/JuliaLang/Pkg.jl/blob/2029bee7e94140aa0614f7ec4077042c419a2fe9/src/Pkg.jl#L441)\nBut not in the documentation.\n\nAnyway, setting `Pkg.offline(true)` doesn't solve everything it seems.\n\nI'm on windows with `julia 1.6.3` so to solve the problem of having the `.julia` in the root directory of my user (I have no rights in this dir), I used JULIA_DEPOT_PATH before starting julia's CLI.\n\nThe problem is that I don't know of this will behave when using julia with vscode but I guess this is not urgent right now.\n\nThe second problem is to be able to install a package such as Julia [DataFrames](https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/index.md) from sources.\n\n\nSo I downloaded the sources as a zip archive but I see no simple way of installing the package from theses sources.\nCould it be possible to install this package with `add` ? Right now I have\n\n```\n(v1.6) pkg> add C:\Users\libs\julia\DataFrames.jl-main\nERROR: Did not find a git repository at `C:\Users\libs\julia\DataFrames.jl-main`\n```\n | [KristofferC]: >  Could it be possible to install this package with add ? Right now I have\n\nUse `dev`. | [lpanichi]: Thanks for your help.\nI did succeed in installing all the required packages to use DataFrames by manually dowloading them from git.\nI also had to manually install the registry in my julia dir.\nI did not use the `Pkg.offline` command.\n\nIf I may give some feedback, it could be nice to have a list of all missing dependancies of a package and the required version. Right now the `dev` command only gives one of the missing package and not all the missing tree.\n\nIl could also be useful to pass a directory to the `dev` command containing several git archives of julia packages and julia would install as many packages as possible from this directory.\n\nFinally, regarding JULIA_DEPOT_PATH, I believe this can be set in the `setting.json` of vscode using the external terminal path parameter so it's not a real problem.\n\nFeel free to close this issue and thanks again for your help.\n | [zxm403089989]: > Thanks for your help. I did succeed in installing all the required packages to use DataFrames by manually dowloading them from git. I also had to manually install the registry in my julia dir. I did not use the `Pkg.offline` command.\n> \n> If I may give some feedback, it could be nice to have a list of all missing dependancies of a package and the required version. Right now the `dev` command only gives one of the missing package and not all the missing tree.\n> \n> Il could also be useful to pass a directory to the `dev` command containing several git archives of julia packages and julia would install as many packages as possible from this directory.\n> \n> Finally, regarding JULIA_DEPOT_PATH, I believe this can be set in the `setting.json` of vscode using the external terminal path parameter so it's not a real problem.\n> \n> Feel free to close this issue and thanks again for your help.\n\nHi do you solve this problem? I am also trying to install some packages offline. However, it seems even with local git clone, Pkg still need network to finish installing process, otherwise it throws errors. | [LilithHafner]: The total size of all .jl files in the 1000 most commonly downloaded packages is about 172MB, so predownloading and doing offline package mangagement seems like quite a reasonable option.",6,false,4,4,0,0,0,0,0,0,0
3268,Add `pkg> bump patch/minor/major` to bump the active env version,open,IanButterworth,,,,2,2022-11-30T17:47:57.0,2022-12-20T14:47:21.0,962,943,https://github.com/JuliaLang/Pkg.jl/issues/3268,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3268,"I think a `pkg> bump patch/minor/major` would be helpful in the repl, with patch as default to increment the version of the active package.\n\nAlso a `Pkg.bump(type::Symbol = :patch)` would be useful in automated actions.\n\nDoing something like\n```\nfunction bump(type::Symbol = :patch)\n    type in (:patch, :minor, :major) || error(""""Bump type :$type not recognized"""")\n\tenv = Pkg.Types.Context().env\n    isnothing(env.project.version) && error(""""The active environment does not have a version set"""")\n\tif type == :patch\n\t    env.project.version = Base.nextpatch(env.project.version)\n    elseif type == :minor\n\t    env.project.version = Base.nextminor(env.project.version)\n    elseif type == :major\n\t    env.project.version = Base.nextmajor(env.project.version)\n    end\n\tPkg.Types.write_project(env)\nend\n```","[fredrikekre]: When would you use this? Developing and changing code is something you normally do from an editor, and wouldn't it be most natural to update the version number from that editor environment too? | [IanButterworth]: I'm mostly interested for the purposes of automation, so more `Pkg.bump`.\nFor instance patch bumping an automated PR. Currently one has to write a few lines of code to do so.\n\nBut I thought it might also be useful in the repl given that `cargo bump` exists.",2,false,0,0,0,0,0,0,0,0,0
3279,`IOError: FDWatcher: bad file descriptor` running `Pkg.update()`,open,glm729,,,,0,2022-12-14T22:02:12.0,2022-12-14T22:02:12.0,948,948,https://github.com/JuliaLang/Pkg.jl/issues/3279,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3279,"When running `Pkg.update()` or running `up` in the REPL mode, there is a short pause then an error is thrown: `Unhandled Task ERROR: IOError: FDWatcher: bad file descriptor (EBADF)`.  After a longer wait, a warning is given stating that registry data could not be downloaded.  Below is the printed error message in the REPL.  The error when running `julia -e 'using Pkg; Pkg.update()'` is identical.\n\nThis may be because I am running behind a VPN on my work machine, but I have not had this occur until today.  For about a month, both at work and at home, the registry info is extremely slow to download (~30 minutes), but I am not sure if that is related.  Currently, I cannot update at all.\n\nWhen I just tried it again, I got different errors -- no `IOError`, but two different connection errors when downloading registry data.  Console output for those is also below.  The `IOError` occurred multiple times, so I am not sure why it is no longer happening.\n\nIt looks like this is just a fault with my own shonky network, feel free to close if so!\n\n\n-----\n\n\nInstall method: Precompiled binary, directory placed at `/usr/local/share/julia-1.8.3`, binary linked to `/usr/local/share/bin/julia`\n\n\nVersion info:\n\n```\nJulia Version 1.8.3\nCommit 0434deb161e (2022-11-14 20:14 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 12 × 12th Gen Intel(R) Core(TM) i7-1255U\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, goldmont)\n  Threads: 12 on 12 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = 12\n```\n\n(I set `JULIA_NUM_THREADS=$(nproc)` in my bash profile -- please correct me if this is not a good idea!)\n\n\n-----\n\n\n<details>\n<summary>Console output (IOError)</summary>\n\n```\n(@v1.8) pkg> up\nUnhandled Task ERROR: IOError: FDWatcher: bad file descriptor (EBADF)\nStacktrace:\n [1] try_yieldto(undo::typeof(Base.ensure_rescheduled))\n   @ Base ./task.jl:871\n [2] wait()\n   @ Base ./task.jl:931\n [3] wait(c::Base.GenericCondition{Base.Threads.SpinLock})\n   @ Base ./condition.jl:124\n [4] _wait(fdw::FileWatching._FDWatcher, mask::FileWatching.FDEvent)\n   @ FileWatching /usr/local/share/julia-1.8.3/share/julia/stdlib/v1.8/FileWatching/src/FileWatching.jl:535\n [5] wait(fdw::FileWatching.FDWatcher)\n   @ FileWatching /usr/local/share/julia-1.8.3/share/julia/stdlib/v1.8/FileWatching/src/FileWatching.jl:563\n [6] macro expansion\n   @ /usr/local/share/julia-1.8.3/share/julia/stdlib/v1.8/Downloads/src/Curl/Multi.jl:166 [inlined]\n [7] (::Downloads.Curl.var""""#40#46""""{Int32, FileWatching.FDWatcher, Downloads.Curl.Multi})()\n   @ Downloads.Curl ./task.jl:484\n┌ Warning: could not download https://pkg.julialang.org/registries\n│   exception = HTTP/2 301 (Failed to connect to au.pkg.julialang.org port 443 after 15210 ms: Connection timed out) while requesting https://pkg.julialang.org/registries\n└ @ Pkg.Registry /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/usr/share/julia/stdlib/v1.8/Pkg/src/Registry/Registry.jl:68\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n  No Changes to `~/.julia/environments/v1.8/Manifest.toml`\n```\n</details>\n\n\n<details>\n<summary>Console output (error 301)</summary>\n\n```\n(@v1.8) pkg> up\n┌ Warning: could not download https://pkg.julialang.org/registries\n│   exception = HTTP/2 301 (Failed to connect to au.pkg.julialang.org port 443 after 15220 ms: Connection timed out) while requesting https://pkg.julialang.org/registries\n└ @ Pkg.Registry /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/usr/share/julia/stdlib/v1.8/Pkg/src/Registry/Registry.jl:68\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n  No Changes to `~/.julia/environments/v1.8/Manifest.toml`\n```\n</details>\n\n\n<details>\n<summary>Console output (error 502)</summary>\n\n```\n(@v1.8) pkg> up\n┌ Warning: could not download https://pkg.julialang.org/registries\n│   exception = HTTP/2 502 while requesting https://pkg.julialang.org/registries\n└ @ Pkg.Registry /cache/build/default-amdci5-6/julialang/julia-release-1-dot-8/usr/share/julia/stdlib/v1.8/Pkg/src/Registry/Registry.jl:68\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n  No Changes to `~/.julia/environments/v1.8/Manifest.toml`\n```\n</details>\n",,0,false,0,0,0,0,0,0,0,0,0
3267,"Experimental status of Pkg.dependencies(), Pkg.project()",open,mkitti,,,,0,2022-11-30T08:12:54.0,2022-11-30T08:12:54.0,963,963,https://github.com/JuliaLang/Pkg.jl/issues/3267,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3267,[`Pkg.dependencies`](https://pkgdocs.julialang.org/dev/api/#Pkg.dependencies) and [`Pkg.project`](https://pkgdocs.julialang.org/dev/api/#Pkg.project) are currently marked as experimental since Julia 1.4.\n\nCould you clarify the status of the APIs and if they are expected to be used?\n\nOne application we were considering was in Plots.jl:\nhttps://github.com/JuliaPlots/Plots.jl/pull/4566\n\nThere we wanted to check if a package was installed before set the default backend via Preferences.jl.,,0,false,2,2,0,0,0,0,0,0,0
378,Source of packages should be recorded in the manifest,open,KristofferC,,,,1,2018-06-13T14:21:50.0,2022-11-21T10:42:05.0,2594,972,https://github.com/JuliaLang/Pkg.jl/issues/378,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/378,"Otherwise, we need the same registries that the manifest was created from and that is not recorded.",[greimel]: Having this would be really helpful for people that don't want to clutter `General` but also don't want to destroy reproducibility when sharing code. It's really easy to forget that a package from my private registry has been used and then my students or collaborators (not necessarily aware of package registries) get frustrated and cannot use my code.\n\n(In order to avoid that I keep copy-pasting functionality across my teaching notebooks.),1,false,12,12,0,0,0,0,0,0,0
3259,Feature request: add search function to search for available packages.,open,Mouli04,,,,0,2022-11-12T06:51:50.0,2022-11-12T06:51:50.0,981,981,https://github.com/JuliaLang/Pkg.jl/issues/3259,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3259,Add a search function to search for available packages. which returns the names of the packages with similar names and a short description of those packages.,,0,false,1,1,0,0,0,0,0,0,0
3245,"When `add`'ing a package, also automatically add its subpackages",open,Keno,,,,7,2022-10-28T20:41:45.0,2022-11-10T20:21:55.0,995,982,https://github.com/JuliaLang/Pkg.jl/issues/3245,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3245,"I have a package that that is internally organized as a collection of sub-packages. Now, when `dev`, this package, everything works great and the package can find its dependencies. However, when I `add MyPackage.jl#main`, I get:\n```\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package MySubPackage [72c5b8b4]:\n MySubPackage [72c5b8b4] log:\n ├─MySubPackage [72c5b8b4] has no known versions!\n └─restricted to versions * by MyPackage [9075980a] — no versions left\n   └─MyPackage [9075980a] log:\n     ├─possible versions are: 0.1.0 or uninstalled\n     └─MyPackage [9075980a] is fixed to version 0.1.0\n```\n\nI'm assuming there's some sort of magic that makes this work for `dev`. It would be nice if that logic was extended to `add`, so this could just work.","[Keno]: A related issue is if you `dev` first and then `add`, the manifest will keep the paths pointed to the `dev` version, which is very surprising behavior. | [KristofferC]: >  the manifest will keep the paths pointed to the dev version, which is very surprising behavior.\n\nWell, untracking a bunch of package directories just because you freed some package could also be argued to be surprising. | [Keno]: I suppose, but here `Pkg` is kind of maintaining the illusion that these packages are managed as a unit, because it automatically added the sub-packages to the manifest by filesystem path when I `dev`'ed the main package, so I do think it's surprising that it wouldn't manage them as a unit here. | [KristofferC]: >  but here Pkg is kind of maintaining the illusion that these packages are managed as a unit, because it automatically added the sub-packages to the manifest by filesystem path when I dev'ed the main package\n\nYeah, this """"search"""" was added as a workaround for https://github.com/JuliaLang/Pkg.jl/issues/1005. From Pkg's p.o.v they are just completely independent packages though. But something can probably be done better. | [oscardssmith]: One especially problematic part of this is that it is impossible to add an ssh version of a subpackage. | [KristofferC]: Why is that impossible? | [oscardssmith]: it's not. Never mind.",7,false,0,0,0,0,0,0,0,0,0
3249,Inconsistent error handling for CLI-git/libgit2,open,laggvar,,bug,,0,2022-11-02T21:01:42.0,2022-11-03T10:52:44.0,990,990,https://github.com/JuliaLang/Pkg.jl/issues/3249,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3249,"I have a private registry that I can only reach while being at the office or using VPN from home.\n\nWhen I'm not connected through VPN and want to add a package from the general registry, all registries will be updated. In case Pkg uses libgit2, it will notice that the private registry is not reachable and just skip it. But if Pkg uses CLI git, it appears `Pkg.add` just stops when it cannot connect to my private registry. So essentially, I need to connect to my private network through VPN just to add a public package. Easy to work around, but quite annoying. \n",,0,false,0,0,0,0,0,0,0,0,0
3233,Trying to fix broken manifests is really frustrating,open,Keno,,,,5,2022-10-22T00:41:09.0,2022-10-25T21:33:16.0,1002,998,https://github.com/JuliaLang/Pkg.jl/issues/3233,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3233,"For example, when I have a broken Manifest with two broken local path references, it won't let me fix one, because the other is broken, and it won't let me fix the other because the first is broken. It works fine if I try to fix both simulatenously, but there isn't really a good syntax for it (I ended up doing `dev PackageThatDependsOnMTK ModelingToolkit` and then using `add` afterwards, which worked). I feel like the UX here could be improved, either by allowing some of these operations if the manifest was already broken before or otherwise by having some way to do more of these transactions atomically.\n\n```\n(CedarSim) pkg> dev PackageThatDependsOnMTK\n   Resolving package versions...\nERROR: expected package `ModelingToolkit [961ee093]` to exist at path `/home/oscardssmith/.julia/dev/ModelingToolkit`\n\n(CedarSim) pkg> add ModelingToolkit#master\n    Updating git-repo `https://github.com/SciML/ModelingToolkit.jl.git`\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\nERROR: expected package `PackageThatDependsOnMTK [32805668]` to exist at path `/home/keno/.julia/.julia/dev/PackageThatDependsOnMTK`\n```\n\nThis isn't the only situation, but one I happened on encounter tonight. It regularly happens to me that I don't know how to fix a broken manifest, because every command I try on it errors.","[KristofferC]: > It works fine if I try to fix both simulatenously, but there isn't really a good syntax for it \n\n```\npkg> free PkgA PkgB\n```\n\nor\n\n```\npkg> dev path/PkgA path/PkgB\n```\n\nmaybe? \n\n\n | [Keno]: `free` doesn't work in this case, because it doesn't know what versions to pick. `dev` with appropriate versions worked (and then I could do `add` afterwards), but it was still frustrating. | [oscardssmith]: I've run into this also before. It's incredibly annoying. | [KristofferC]: > free doesn't work in this case, because it doesn't know what versions to pick\n\nI don't understand this, it would do a normal resolve presumably? Or is it non registered?\n\nIf you have a manifest where a bunch of stuff is pointing at garbage paths there isn't really that much you can do that makes sense except repointing those paths to new local paths which is what `dev` does. Is the issue that you need to do all of them in one shot? \n\n> It's incredibly annoying\n\nWhat is? | [Keno]: > Or is it non registered?\n\nIt is not.\n\n> Is the issue that you need to do all of them in one shot?\n\nYes\n",5,false,0,0,0,0,0,0,0,0,0
3240,Pkg can confusingly load env in secondary DEPOT_PATH by default,open,jakobnissen,,,,1,2022-10-25T14:04:56.0,2022-10-25T14:12:09.0,999,999,https://github.com/JuliaLang/Pkg.jl/issues/3240,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3240,"I experienced this problem which I think was needlessly confusing, but I'm not sure what specific change I'm suggesting to address it. The circumstance was:\n* My `DEPOT_PATH` was `[""""/home/people/jakni/.julia"""", """"/services/tools/julia/1.8.2/depot""""]`, where I have read/write access to the former path and read-only access to the latter\n* After upgrading from Julia 1.7 to Julia 1.8, the default Julia environment is `@v1.8`\n* The `@v1.8` environment exists in the latter depot, but I did not manually create it in the former, and therefore it did not exist\n\nWhen attempting to add packages, `Pkg` would fail with a """"Permission denied"""" error, as it operated in the read-only depot. I then checked `DEPOT_PATH` and confirmed that indeed _another_ path was supposed to take priority over the read-only path, yet for some reason, it didn't.\n\nPossible solutions:\n* Automatically create the default `@v1.8` environment in the primary depot path. such that the default environment is always in the primary path\n* When activating an environment starting with `@`, warn if this is not from your primary depot path",[jakobnissen]: Might be a duplicate of https://github.com/JuliaLang/julia/issues/45167,1,false,0,0,0,0,0,0,0,0,0
3227,deving multiple packages doesn't parse correctly when comma separated,open,anandijain,,,,0,2022-10-15T02:28:04.0,2022-10-15T02:28:04.0,1009,1009,https://github.com/JuliaLang/Pkg.jl/issues/3227,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3227,"```julia\n(MySciML) pkg> dev ModelingToolkit, SciMLBase, DifferentialEquations, OrdinaryDiffEq\nERROR: Unable to parse `ModelingToolkit,` as a package.\n\n(MySciML) pkg> dev ModelingToolkit SciMLBase DifferentialEquations OrdinaryDiffEq\n     Cloning git-repo `https://github.com/SciML/DifferentialEquations.jl.git\n```",,0,false,0,0,0,0,0,0,0,0,0
3226,Feat: implement retries for package and artifact downloading,open,Octogonapus,,,,2,2022-10-14T18:08:09.0,2022-10-14T18:13:54.0,1009,1009,https://github.com/JuliaLang/Pkg.jl/issues/3226,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3226,"This is a feature request for the implementation of a retry mechanism for downloading packages and artifacts. Sometimes GitHub returns a 5xx error, or silently returns incorrect data, so a retry mechanism would be helpful. As it stands, a temporary error like this one can fail a build:\n```julia\nERROR: Unable to automatically download/install artifact 'MariaDB_Connector_C' from sources listed in '/home/runner/.julia/packages/MariaDB_Connector_C_jll/TtzWz/Artifacts.toml'.\nSources attempted:\n- https://github.com/JuliaBinaryWrappers/MariaDB_Connector_C_jll.jl/releases/download/MariaDB_Connector_C-v3.1.12+0/MariaDB_Connector_C.v3.1.12.x86_64-linux-gnu.tar.gz\n    Error: HTTP/2 503 while requesting https://github.com/JuliaBinaryWrappers/MariaDB_Connector_C_jll.jl/releases/download/MariaDB_Connector_C-v3.1.12+0/MariaDB_Connector_C.v3.1.12.x86_64-linux-gnu.tar.gz\n```","[DilumAluthge]: You can take whatever Pkg function you are calling (`Pkg.instantiate()`, `Pkg.update()`, etc.) and wrap it in the [retry](https://docs.julialang.org/en/v1/base/base/#Base.retry) function from Base Julia. | [Octogonapus]: Indeed I could, though I disagree that the burden should be shifted to the user for such high-level functions like `Pkg.instantiate()` and `Pkg.update()`.",2,false,0,0,0,0,0,0,0,0,0
2451,Pkg.pin resolves,open,fredrikekre,,,,3,2021-03-25T12:59:14.0,2022-10-08T06:44:48.0,1578,1016,https://github.com/JuliaLang/Pkg.jl/issues/2451,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2451,"```\npkg> st\nStatus `/tmp/Project.toml`\n  [713c75ef] Franklin v0.6.12\n  [16fef848] LiveServer v0.3.6\n\npkg> pin Franklin\n  Resolving package versions...\nUpdating `/tmp/Project.toml`\n  [713c75ef] ↓ Franklin v0.6.12 ⇒ v0.6.12 ⚲\nUpdating `~/dev/TME061/build-tools/Manifest.toml`\n  [713c75ef] ↓ Franklin v0.6.12 ⇒ v0.6.12 ⚲\n  [c8ffd9c3] ↑ MbedTLS_jll v2.16.0+1 ⇒ v2.16.0+2\n  ```\n  \n<details> \n<summary>Project.toml</summary>\n\n```toml\n[deps]\nFranklin = """"713c75ef-9fc9-4b05-94a9-213340da978e""""\nLiveServer = """"16fef848-5104-11e9-1b77-fb7a48bbb589""""\n\n[compat]\nFranklin = """"=0.6.12""""\n```\n\n</details>\n<details> \n<summary>Manifest.toml</summary>\n\n```toml\n# This file is machine-generated - editing it directly is not advised\n\n[[Base64]]\nuuid = """"2a0f44e3-6c83-55bd-87e4-b1978d98bd5f""""\n\n[[Crayons]]\ngit-tree-sha1 = """"cb7a62895da739fe5bb43f1a26d4292baf4b3dc0""""\nuuid = """"a8cc5b0e-0ffa-5ad4-8c14-923d3ee1735f""""\nversion = """"4.0.1""""\n\n[[Dates]]\ndeps = [""""Printf""""]\nuuid = """"ade2ca70-3891-5945-98fb-dc099432e06a""""\n\n[[DelimitedFiles]]\ndeps = [""""Mmap""""]\nuuid = """"8bb1440f-4735-579b-a4ab-409b98df4dab""""\n\n[[Distributed]]\ndeps = [""""Random"""", """"Serialization"""", """"Sockets""""]\nuuid = """"8ba89e20-285c-5b6f-9357-94700520ee1b""""\n\n[[DocStringExtensions]]\ndeps = [""""LibGit2"""", """"Markdown"""", """"Pkg"""", """"Test""""]\ngit-tree-sha1 = """"88bb0edb352b16608036faadcc071adda068582a""""\nuuid = """"ffbed154-4ef7-542d-bbb7-c09d3a79fcae""""\nversion = """"0.8.1""""\n\n[[Documenter]]\ndeps = [""""Base64"""", """"Dates"""", """"DocStringExtensions"""", """"InteractiveUtils"""", """"JSON"""", """"LibGit2"""", """"Logging"""", """"Markdown"""", """"REPL"""", """"Test"""", """"Unicode""""]\ngit-tree-sha1 = """"bc99c157ff2957c058a1067061d16c2c83d1ec42""""\nuuid = """"e30172f5-a6a5-5a46-863b-614d45cd2de4""""\nversion = """"0.24.9""""\n\n[[FileWatching]]\nuuid = """"7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee""""\n\n[[Franklin]]\ndeps = [""""Dates"""", """"DelimitedFiles"""", """"DocStringExtensions"""", """"FranklinTemplates"""", """"HTTP"""", """"Literate"""", """"LiveServer"""", """"Logging"""", """"Markdown"""", """"NodeJS"""", """"OrderedCollections"""", """"Pkg"""", """"Random""""]\ngit-tree-sha1 = """"066688cff2bb17e3db1388fd8366dcece65e0c3b""""\nuuid = """"713c75ef-9fc9-4b05-94a9-213340da978e""""\nversion = """"0.6.12""""\n\n[[FranklinTemplates]]\ngit-tree-sha1 = """"cda889ef006e9419823c70ebaefbc57812a8addf""""\nuuid = """"3a985190-f512-4703-8d38-2a7944ed5916""""\nversion = """"0.5.7""""\n\n[[HTTP]]\ndeps = [""""Base64"""", """"Dates"""", """"IniFile"""", """"MbedTLS"""", """"Sockets""""]\ngit-tree-sha1 = """"fe31f4ff144392ad8176f5c7c03cca6ba320271c""""\nuuid = """"cd3eb016-35fb-5094-929b-558a96fad6f3""""\nversion = """"0.8.14""""\n\n[[IniFile]]\ndeps = [""""Test""""]\ngit-tree-sha1 = """"098e4d2c533924c921f9f9847274f2ad89e018b8""""\nuuid = """"83e8ac13-25f8-5344-8a64-a9f2b223428f""""\nversion = """"0.5.0""""\n\n[[InteractiveUtils]]\ndeps = [""""Markdown""""]\nuuid = """"b77e0a4c-d291-57a0-90e8-8db25a27a240""""\n\n[[JSON]]\ndeps = [""""Dates"""", """"Mmap"""", """"Parsers"""", """"Unicode""""]\ngit-tree-sha1 = """"b34d7cef7b337321e97d22242c3c2b91f476748e""""\nuuid = """"682c06a0-de6a-54ab-a142-c8b1cf79cde6""""\nversion = """"0.21.0""""\n\n[[LibGit2]]\ndeps = [""""Printf""""]\nuuid = """"76f85450-5226-5b5a-8eaa-529ad045b433""""\n\n[[Libdl]]\nuuid = """"8f399da3-3557-5675-b5ff-fb832c97cbdb""""\n\n[[Literate]]\ndeps = [""""Base64"""", """"JSON"""", """"REPL""""]\ngit-tree-sha1 = """"ac48e6b189a3e993788e1776485625bcbed3504d""""\nuuid = """"98b081ad-f1c9-55d3-8b20-4c87d4299306""""\nversion = """"2.3.1""""\n\n[[LiveServer]]\ndeps = [""""Crayons"""", """"Documenter"""", """"FileWatching"""", """"HTTP"""", """"Pkg"""", """"Sockets"""", """"Test""""]\ngit-tree-sha1 = """"9b78352e4b8fca8ad5233b1e6bcfb99720ee488f""""\nuuid = """"16fef848-5104-11e9-1b77-fb7a48bbb589""""\nversion = """"0.3.6""""\n\n[[Logging]]\nuuid = """"56ddb016-857b-54e1-b83d-db4d58db5568""""\n\n[[Markdown]]\ndeps = [""""Base64""""]\nuuid = """"d6f4376e-aef5-505a-96c1-9c027394607a""""\n\n[[MbedTLS]]\ndeps = [""""Dates"""", """"MbedTLS_jll"""", """"Random"""", """"Sockets""""]\ngit-tree-sha1 = """"426a6978b03a97ceb7ead77775a1da066343ec6e""""\nuuid = """"739be429-bea8-5141-9913-cc70e7f3736d""""\nversion = """"1.0.2""""\n\n[[MbedTLS_jll]]\ndeps = [""""Libdl"""", """"Pkg""""]\ngit-tree-sha1 = """"066a4467008745eed36dad973ceb66405785a621""""\nuuid = """"c8ffd9c3-330d-5841-b78e-0817d7145fa1""""\nversion = """"2.16.0+1""""\n\n[[Mmap]]\nuuid = """"a63ad114-7e13-5084-954f-fe012c677804""""\n\n[[NodeJS]]\ndeps = [""""Pkg""""]\ngit-tree-sha1 = """"350ac618f41958e6e0f6b0d2005ae4547eb1b503""""\nuuid = """"2bd173c7-0d6d-553b-b6af-13a54713934c""""\nversion = """"1.1.1""""\n\n[[OrderedCollections]]\ndeps = [""""Random"""", """"Serialization"""", """"Test""""]\ngit-tree-sha1 = """"c4c13474d23c60d20a67b217f1d7f22a40edf8f1""""\nuuid = """"bac558e1-5e72-5ebc-8fee-abe8a469f55d""""\nversion = """"1.1.0""""\n\n[[Parsers]]\ndeps = [""""Dates"""", """"Test""""]\ngit-tree-sha1 = """"75d07cb840c300084634b4991761886d0d762724""""\nuuid = """"69de0a69-1ddd-5017-9359-2bf0b02dc9f0""""\nversion = """"1.0.1""""\n\n[[Pkg]]\ndeps = [""""Dates"""", """"LibGit2"""", """"Libdl"""", """"Logging"""", """"Markdown"""", """"Printf"""", """"REPL"""", """"Random"""", """"SHA"""", """"UUIDs""""]\nuuid = """"44cfe95a-1eb2-52ea-b672-e2afdf69b78f""""\n\n[[Printf]]\ndeps = [""""Unicode""""]\nuuid = """"de0858da-6303-5e67-8744-51eddeeeb8d7""""\n\n[[REPL]]\ndeps = [""""InteractiveUtils"""", """"Markdown"""", """"Sockets""""]\nuuid = """"3fa0cd96-eef1-5676-8a61-b3b8758bbffb""""\n\n[[Random]]\ndeps = [""""Serialization""""]\nuuid = """"9a3f8284-a2c9-5f02-9a11-845980a1fd5c""""\n\n[[SHA]]\nuuid = """"ea8e919c-243c-51af-8825-aaa63cd721ce""""\n\n[[Serialization]]\nuuid = """"9e88b42a-f829-5b0c-bbe9-9e923198166b""""\n\n[[Sockets]]\nuuid = """"6462fe0b-24de-5631-8697-dd941f90decc""""\n\n[[Test]]\ndeps = [""""Distributed"""", """"InteractiveUtils"""", """"Logging"""", """"Random""""]\nuuid = """"8dfed614-e22c-5e08-85e1-65c5234f0b40""""\n\n[[UUIDs]]\ndeps = [""""Random"""", """"SHA""""]\nuuid = """"cf7118a7-6976-5b1a-9a39-7adc72f591a4""""\n\n[[Unicode]]\nuuid = """"4ec0a83e-493e-50e2-b9ac-8f72acf5a8f5""""\n\n```\n\n</details>","[KristofferC]: ```\n  [c8ffd9c3] ↑ MbedTLS_jll v2.16.0+1 ⇒ v2.16.0+2\n```\n\nI think the reason for this is that `jll`s uses build number and Pkg can't see that there is a difference between `v2.16.0+1` and `v2.16.0+2` so even with the tiered resolver, the first tier (which is supposed to try to keep every version the same) it updates it.\n\nThis is a side point regarding if a resolve is needed or not. | [fredrikekre]: Right, it happens for regular versions too. | [Seelengrab]: ![screenshot_2022-10-08_08-40-16_809820432](https://user-images.githubusercontent.com/11753998/194693794-2a62d1af-f00b-4259-b021-99e7f21b6b74.png)\n\nSince JLLs are kind of prevalent, it seems bad that we run any updating code at all for what should be a totally local operation, no? Does `]pin` need to try to instantiate/resolve itself?\n\n<details>\n<summary>State after the `]pin`</summary>\n\n```\n(@v1.9) pkg> st\nStatus `~/.julia/environments/v1.9/Project.toml`\n  [6e4b80f9] BenchmarkTools v1.3.1\n  [f68482b8] Cthulhu v2.7.3\n  [31a5f54b] Debugger v0.7.6\n⌃ [c3a54625] JET v0.6.5 ⚲\n  [70703baa] JuliaSyntax v0.2.0\n  [2b0e0bc5] LanguageServer v4.3.1\n  [b4c46c6c] LinuxPerf v0.3.3\n  [16fef848] LiveServer v1.0.3\n⌃ [e4faabce] PProf v2.2.0\n  [14b8a8f1] PkgTemplates v0.7.29\n  [c46f51b8] ProfileView v1.5.2\n  [295af30f] Revise v3.4.0\n⌃ [90137ffa] StaticArrays v1.5.8\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n```\n\n</details>",3,false,0,0,0,0,0,0,0,0,0
3222,Opaque error message when specifically requested version doesn't exist,open,BioTurboNick,,,,0,2022-10-07T12:15:57.0,2022-10-07T12:15:57.0,1017,1017,https://github.com/JuliaLang/Pkg.jl/issues/3222,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3222,"If you try to add a package version that doesn't exist, you end up with an `unsatisfiable requirement` error, which suggests a compat issue. Rather, Pkg should just tell the user that the version doesn't exist in the registry.\n\n```\n(@v1.8) pkg> add Plots@v1.35.50\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package Plots [91a5bcdd]:\n Plots [91a5bcdd] log:\n ├─possible versions are: 0.12.1-1.35.2 or uninstalled\n └─restricted to versions 1.35.50 by an explicit requirement — no versions left\n```",,0,false,1,1,0,0,0,0,0,0,0
3181,deps_graph looks at current paths for stdlibs of different version,open,gbaraldi,,,,2,2022-08-26T18:50:36.0,2022-09-25T11:44:30.0,1058,1029,https://github.com/JuliaLang/Pkg.jl/issues/3181,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3181,"This was found in https://github.com/JuliaPackaging/BinaryBuilderBase.jl/pull/260#issuecomment-1226586115. \nBut basically when `deps_graph` receives a julia version it tries to look for the paths of the stdlibs, which was fine until DelimitedFiles was removed. Since DelimitedFiles was still a stdlib in 1.5 it does try to find it, but since it looks at the host julia stdlibs it doesn't find it. Leading to the error.\nTo reproduce this just add BinaryBuilderBase and run the functions in the gist below in a recent master build. \nIt also has the output of some printf debugging\nhttps://gist.github.com/gbaraldi/0908d3c4603b49754cdb590c642fb6cd",[KristofferC]: https://github.com/JuliaLang/Pkg.jl/issues/3170 | [giordano]: I just realised this and #3170 are probably related to #2942?,2,false,0,0,0,0,0,0,0,0,0
3210,Detect and warn about changes to package directory during testing,open,maleadt,,feature request,,0,2022-09-22T18:41:15.0,2022-09-22T18:41:15.0,1031,1031,https://github.com/JuliaLang/Pkg.jl/issues/3210,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3210,"Some recent work over at PkgEval.jl started using a layered depot, with packages installed system-wide in a read-only directory. This resulted in many test failures due to packages assuming they can write to their package directory (e.g. writing temporary files to `@__DIR__` instead of `mktempdir()`). I will probably work around this by copying the package that's being tested to a writable depot directory (i.e. `~/.julia/packages`).\n\nSince it would nonetheless be good to avoid this pattern in packages, @KristofferC suggested that Pkg could warn about this during testing, by computing the package directory's tree hash before and after testing, and letting the user know if there's a mismatch. (It cannot use the treehash from the registry, because packages that have an old-style `deps/build.jl` obviously need to be able to write to the package directory during installation)",,0,false,1,1,0,0,0,0,0,0,0
770,Julep: interlocked changes across the package ecosystem,open,timholy,,,,11,2018-09-21T10:32:19.0,2022-09-21T18:04:03.0,2494,1032,https://github.com/JuliaLang/Pkg.jl/issues/770,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/770,"At quite a few points in my development experience I've made changes in one package that have ripple effects across many others. I remember one case involving colors and/or images where just the sequence of making a change in one package, waiting for tests to finish, merging and tagging, getting the tag merged to metadata (me """"abusing"""" my METADATA merge privileges and doing it ASAP, without waiting for someone to review it), and then going on to the next package literally took an entire weekend doing little else, even though I already had local branches queued for all of the changes.\n\nThe latest (much smaller) version of this just happened with OrderedCollections/DataStructures, https://github.com/JuliaCollections/OrderedCollections.jl/issues/10.\n\nIt would be lovely to have some way of easily expressing a transient dependency on not-yet-merged branches in other packages, without having any more customization than necessary that later needs to be backed out. My main suggestion for this would be to add a top-level file like `PreferredBranch.toml` with contents\n```\nColorTypes = """"teh/fix_283""""\nColors = """"teh/newct""""\nImageCore = """"teh/newct""""\n...\n```\nand list the specific branch that CI should check out in each package. This would have two impacts:\n\n- As the changes are being submitted package-by-package, the developer can copy the previous `PreferredBranch.toml` file to the next project, adding the relevant line about the right branch for the just-submitted PR in the previous package.\n- When it's time to merge and tag things, the developer somehow submits the final `PreferredBranch.toml` file to attobot, which does everything (merging the PRs and submitting the METADATA tags) all at once; after merging to METADATA attobot also submits and merges a PR to delete `PreferredBranch.toml` from each package.\n","[StefanKarpinski]: This seems like it might be a case for a """"development registry"""" where you can play around with versions until you get it right and everything works and then upstream the lot of them all at once. Would that work? One can also work on branches of a registry and tweak things until they're right. We can consider versions on branches not to be """"written in stone"""" until they're merged into master.\n\nRelatedly, I've been thinking about tooling to allow orgs to have their own registries where they can implement their own CI policies and include whatever upstream dependencies they """"allow"""", pulling those from the General registry. Then people submit versions to the org registry for tagging and the org registry can implement whatever CI policies that they care to. Testing, coding, compatibility standards, etc. If an org registry is trusted, then General can just pull versions from the org registry automatically. | [timholy]: Yes, a development registry sounds like it would work well, and is better in the sense that it leverages existing infrastructure.\n\nThe org-specific registry also sounds pretty cool. A fair amount of work to configure initially, perhaps, but for a big org with lots of activity I can easily see it being worthwhile. | [Cody-G]: I've only recently transitioned to Julia 0.7 so I may be unaware of some of the available development tools, but I've been finding it cumbersome to do CI with a development registry.  Say that package A depends on package B, and B depends on C.  If I've made a set of local changes to all 3 packages and want to push the changes and let Travis run tests, it seems I need to take this sequence of actions:\n\n1. Push update of C to Github, get Travis tests passing\n2. Push a commit to my development registry that updates `Versions.toml` for package C\n3. Push update of B to Github, get Travis tests passing\n4. Push a commit to my development registry that updates `Versions.toml` for package B\n5. Push update of A to Github, get Travis tests passing\n6. Push a commit to my development registry that updates `Versions.toml` for package A\n7. If desired make a PR to merge my development registry with its (non-development) counterpart\n\nwhereas before Pkg3 the sequence was simply\n\n1. Push update of C to Github, get Travis tests passing\n2. Push update of B to Github, get Travis tests passing\n3. Push update of A to Github, get Travis tests passing\n\nAre there any tools to make this easier with Pkg3?  Is my workflow in need of revision?  Or is the thought that it's worth this extra development labor since it gives package users a more stable experience?\n\nIn cases like this I'm already feeling tempted to just combine A, B, and C into one package (when they're my own packages) to avoid this extra work. Usually I think of that as worse development practice, but I wonder if others are feeling the same temptation.\n\nI'm hoping that someone will say """"You're doing it wrong."""" rather than """"Don't be lazy."""" :) | [StefanKarpinski]: You should be able to check in a Manifest.toml file that uses non-registered versions of dependencies and it should just work. There's no requirement that versions in manifests are registered anywhere. | [Cody-G]: >You should be able to check in a Manifest.toml file that uses non-registered versions of dependencies and it should just work. There's no requirement that versions in manifests are registered anywhere.\n\nI just want to make sure I understand:  Are you suggesting that I check a Manifest.toml into each of the repos for packages A, B, and C in my example? I think I understand how that would allow me to develop freely without worrying about updating versions, but then when it's time to make my updated packages available to others through a registry I think I would need more commits *removing* Manifest.toml from each package?  Or are you suggesting to avoid using a registry altogether?  In our case that doesn't seem ideal. | [StefanKarpinski]: There's no need to remove the `Manifest.toml` file when registering. It's ignored when your package is used as a dependency anyway. It only applies when your package is the primary application (e.g. when running tests). Committing a manifest file tracks a full set of dependencies that worked. | [Cody-G]: > It's ignored when your package is used as a dependency anyway. It only applies when your package is the primary application (e.g. when running tests).\n\nAh!  I didn't understand this.  Somewhere I read that `Manifest.toml` isn't/shouldn't be committed, and I assumed this was because it could cause conflicts with a registry.  Thanks! | [timholy]: Committing the Manifest isn't working for me. I suspect the problem is due to my `script` section in the `.travis.yml` file:\n\n```yml\nscript:\n  - if [[ -a .git/shallow ]]; then git fetch --unshallow; fi\n  - julia -e 'using Pkg, LibGit2;\n              user_regs = joinpath(DEPOT_PATH[1],""""registries"""");\n              mkpath(user_regs);\n              all_registries = Dict(""""General"""" => """"https://github.com/JuliaRegistries/General.git"""",\n                            """"HolyLabRegistry"""" => """"git@github.com:HolyLab/HolyLabRegistry.git"""");\n              Base.shred!(LibGit2.CachedCredentials()) do creds\n                for (reg, url) in all_registries\n                  path = joinpath(user_regs, reg);\n                  LibGit2.with(Pkg.GitTools.clone(url, path; header = """"registry $reg from $(repr(url))"""", credentials = creds)) do repo end\n                end\n              end'\n- julia -e 'using Pkg; Pkg.build(); Pkg.test(""""RegisterMismatch""""; coverage=false)'\n```\n\nIn the Travis build log, there's a section\n```\n...  # a bunch of public packages, finishing with...\n Installed Colors ──────────────────── v0.9.5\n Installed FFTW ────────────────────── v0.2.4\n   Cloning [3bd9afcd-55df-531a-9b34-dc642dce7b95] RFFT from git@github.com:HolyLab/RFFT.jl.git\n[ Info: Installed RFFT ────────────────────── v0.0.0\n   Cloning [67712758-55e7-5c3c-8e85-dda1d7758434] RegisterCore from git@github.com:HolyLab/RegisterCore.jl.git\n[ Info: Installed RegisterCore ────────────── v0.1.0\n   Cloning [46a7138f-0d70-54e1-8ada-fb8296f91f24] CenterIndexedArrays from git@github.com:HolyLab/CenterIndexedArrays.jl.git\n[ Info: Installed CenterIndexedArrays ─────── v0.1.0\n   Cloning [abb2e897-52bf-5d28-a379-6ca321e3b878] RegisterMismatchCommon from git@github.com:HolyLab/RegisterMismatchCommon.jl.git\n[ Info: Installed RegisterMismatchCommon ──── v0.1.0\n```\n\nUnfortunately it doesn't specify the `git-tree-sha1` used for these packages. However, from the fact that it errors, I suspect it's ignoring the `git-tree-sha1` in the `Manifest.toml` that I committed. | [KristofferC]: I'll close this as a dup of https://github.com/JuliaLang/Pkg.jl/issues/770 since they seem fairly similar. | [StefanKarpinski]: This is _very_ similar to #770. | [KristofferC]: 😢 I always do this",11,false,0,0,0,0,0,0,0,0,0
1717,pkg> fsck,open,fredrikekre,,,,1,2020-03-14T11:24:26.0,2022-09-21T12:19:02.0,1954,1033,https://github.com/JuliaLang/Pkg.jl/issues/1717,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1717,"Came up on slack, see https://github.com/JuliaLang/Pkg.jl/issues/1198#issuecomment-529224374",[KristofferC]: Ref https://github.com/KristofferC/PkgFsck.jl,1,false,4,4,0,0,0,0,0,0,0
3119,Pkg.update downgrades the packages,open,vtjnash,,,,3,2022-06-27T18:21:31.0,2022-09-12T14:34:00.0,1118,1042,https://github.com/JuliaLang/Pkg.jl/issues/3119,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3119,"Why can't these packages be upgraded, and instead causes other packages to get downgraded?\n[Manifest.toml.txt](https://github.com/JuliaLang/Pkg.jl/files/9007147/Manifest.toml.txt)\n[Project.toml.txt](https://github.com/JuliaLang/Pkg.jl/files/9007148/Project.toml.txt)\n```\n(@v1.8) pkg> up VectorizationBase\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Installed SpecialFunctions ─ v2.1.6\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [276daf66] ↑ SpecialFunctions v1.8.6 ⇒ v2.1.6\n\n(@v1.8) pkg> status --outdated\nStatus `~/.julia/environments/v1.8/Project.toml`\n⌅ [1520ce14] AbstractTrees v0.3.4 (<v0.4.2): CombinedParsers, FileTrees, FlameGraphs, FoldingTrees, LeftChildRightSiblingTrees, OnlineStats, OnlineStatsBase, Tries\n⌅ [cd3eb016] HTTP v0.9.17 (<v1.0.5): Coverage, Dash, GR, RemoteFiles\n⌃ [2b0e0bc5] LanguageServer v4.1.0 (<v4.2.0)\n⌃ [bdcacae8] LoopVectorization v0.12.110 (<v0.12.119)\n⌅ [a4795742] NLPModels v0.18.5 (<v0.19.0): SolverTools\n⌃ [3d5dd08c] VectorizationBase v0.21.33 (<v0.21.37)\n\n(@v1.8) pkg> status VectorizationBase\nStatus `~/.julia/environments/v1.8/Project.toml`\n⌃ [3d5dd08c] VectorizationBase v0.21.33\nInfo Packages marked with ⌃ have new versions available\n\n(@v1.8) pkg> up\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n    Updating git-repo `https://github.com/Hop-developers/Hop.jl.git`\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n⌃ [276daf66] ↓ SpecialFunctions v2.1.6 ⇒ v1.8.6\n        Info Packages marked with ⌃ have new versions available\n```","[KristofferC]: ```\n(UpProb) pkg> up VectorizationBase\n    Updating registry at `~/.julia/registries/General.toml`\nERROR: expected package `Pidfile [fa939f87]` to exist at path `/home/vtjnash/.julia/dev/Pidfile`\n```\n\nWould be good if you could provide a manifest that does not have absolute paths in it. | [vtjnash]: Okay, I updated the files at the top to remove those and that `up/down` behavior still seems to reproduce | [BioTurboNick]: What does `status --outdated -m` show?",3,false,0,0,0,0,0,0,0,0,0
3197,The interactive compat editor should allow to edit mulitple entries,open,ufechner7,,,,0,2022-09-09T16:16:27.0,2022-09-09T16:16:27.0,1044,1044,https://github.com/JuliaLang/Pkg.jl/issues/3197,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3197,Tested on Julia 1.8.1 on Linux:\n\n- go to the folder of project\n- start julia with **julia --project**\n- press ] to enter the package manager\n- type **compat**\n- select end edit the first entry\n- press enter\n\nExpected result:\n- I can choose a new entry to edit\n\nWhat happens:\nI leave the interactive compat editor.\n\nI think this should be changed.,,0,false,0,0,0,0,0,0,0,0,0
3194,Artifact selection hooks should not read the output TOML dictionary from `stdout`,open,DilumAluthge,,artifacts,,3,2022-09-06T14:00:30.0,2022-09-07T07:53:15.0,1048,1047,https://github.com/JuliaLang/Pkg.jl/issues/3194,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3194,"Currently, artifact selection hooks expect that the hook will print the resultant TOML dictionary to `stdout`.\n\nUnfortunately, this means that if you have any other output being printed to `stdout`, the artifact selection hooks break. Some examples of this include:\n1. You have a custom sysimage, and in that custom sysimage there are some `__init__()` functions that print various output to `stdout`.\n2. You've enabled a debug mode in your packages, and this debug mode prints various debugging statements to `stdout`.\n\nInstead of having artifact selection hook output printed to `stdout`, I would recommend an interface of the following:\n1. Before we run the artifact selection hook, we `touch` a temporary file, e.g. `/tmp/mytempdir/myfile.toml`, and we set `ENV[""""JULIA_PKG_ARTIFACT_SELECTION_HOOK_OUTPUT""""] = """"/tmp/mytempdir/myfile.toml""""`.\n2. When the hook runs, it writes its TOML dictionary out to the `ENV[""""JULIA_PKG_ARTIFACT_SELECTION_HOOK_OUTPUT""""]` file.\n3. After the hook has run, Pkg reads the TOML dictionary in from the `ENV[""""JULIA_PKG_ARTIFACT_SELECTION_HOOK_OUTPUT""""]` file.\n\nThe design mirrors the `GITHUB_ENV` file that GitHub Actions uses for passing output between steps.","[KristofferC]: Sounds like a good idea to me | [fredrikekre]: Can this be done without breaking all existing releases? I don't think so?\n\nEdit: I suppose packages must print to both for a while and in Pkg we use the file output if it is non-empty, otherwise stdout? Then over time the new system will take over. | [KristofferC]: \n> You've enabled a debug mode in your packages, and this debug mode prints various debugging statements to stdout.\n\nMost of these stuff should probably print to stderr though.",3,false,2,2,0,0,0,0,0,0,0
3150,upgradable marker sometimes inaccurate,open,rapus95,,,,12,2022-07-30T13:12:32.0,2022-09-06T01:06:47.0,1086,1048,https://github.com/JuliaLang/Pkg.jl/issues/3150,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3150,"marker shows that there is a new version to update to, but it still doesn't update. \n```julia\n(@testing) pkg> st\nStatus `C:\Users\Aaron\.julia\environments\testing\Project.toml`\n  [cbdf2221] AlgebraOfGraphics v0.6.9\n⌃ [e9467ef8] GLMakie v0.6.9\nInfo Packages marked with ⌃ have new versions available\n\n(@testing) pkg> up GLMakie\n    Updating registry at `C:\Users\Aaron\.julia\registries\General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  No Changes to `C:\Users\Aaron\.julia\environments\testing\Project.toml`\n  No Changes to `C:\Users\Aaron\.julia\environments\testing\Manifest.toml`\n\n(@testing) pkg> up\n    Updating registry at `C:\Users\Aaron\.julia\registries\General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  No Changes to `C:\Users\Aaron\.julia\environments\testing\Project.toml`\n  No Changes to `C:\Users\Aaron\.julia\environments\testing\Manifest.toml`\n```","[rapus95]: ```julia\njulia> versioninfo()\nJulia Version 1.8.0-rc3\nCommit 33f19bcbd2 (2022-07-13 19:10 UTC)\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: 12 × AMD Ryzen 5 3600 6-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)\n  Threads: 1 on 12 virtual cores\n``` | [IanButterworth]: See https://discourse.julialang.org/t/julia-1-8-how-do-i-upgrade-packages-with-new-versions-available/84573/2\n\nI think we need to figure out how to explain that succinctly in the tip that shows up | [IanButterworth]: Perhaps we could do:\n\n```\n(@testing) pkg> up GLMakie\n    Updating registry at `C:\Users\Aaron\.julia\registries\General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  No Changes to `C:\Users\Aaron\.julia\environments\testing\Project.toml`\n  No Changes to `C:\Users\Aaron\.julia\environments\testing\Manifest.toml`\n\n    Info: There is a newer version of GLMakie available, but updating it would \n          require downgrading more packages than would be upgraded. \n          To force installation use `pkg> add GLMakie@0.7.0`\n```\n\nBut only in `update` when the package is specified. | [rapus95]: @IanButterworth sadly that's not all. It's even impossible to upgrade:\n```julia\n(@testing) pkg> st\nStatus `C:\Users\Aaron\.julia\environments\testing\Project.toml`\n  [cbdf2221] AlgebraOfGraphics v0.6.9\n⌃ [e9467ef8] GLMakie v0.6.9\nInfo Packages marked with ⌃ have new versions available\n\n(@testing) pkg> add GLMakie@0.6.12\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package AlgebraOfGraphics [cbdf2221]:\n AlgebraOfGraphics [cbdf2221] log:\n ├─possible versions are: 0.1.0-0.6.9 or uninstalled\n ├─restricted to versions * by an explicit requirement, leaving only versions 0.1.0-0.6.9\n ├─restricted by compatibility requirements with Observables [510215fc] to versions: 0.4.0-0.6.9 or uninstalled, leaving only versions: 0.4.0-0.6.9\n │ └─Observables [510215fc] log:\n │   ├─possible versions are: 0.2.0-0.5.1 or uninstalled\n │   └─restricted by compatibility requirements with GLMakie [e9467ef8] to versions: 0.5.1\n │     └─GLMakie [e9467ef8] log:\n │       ├─possible versions are: 0.0.1-0.6.12 or uninstalled\n │       └─restricted to versions 0.6.12 by an explicit requirement, leaving only versions 0.6.12\n ├─restricted by compatibility requirements with GeometryBasics [5c1252a2] to versions: [0.1.0-0.1.2, 0.5.3-0.6.9] or uninstalled, leaving only versions: 0.5.3-0.6.9\n │ └─GeometryBasics [5c1252a2] log:\n │   ├─possible versions are: 0.1.0-0.4.2 or uninstalled\n │   ├─restricted by compatibility requirements with GLMakie [e9467ef8] to versions: 0.4.1-0.4.2\n │   │ └─GLMakie [e9467ef8] log: see above\n │   └─restricted by compatibility requirements with Makie [ee78f7c6] to versions: 0.4.2\n │     └─Makie [ee78f7c6] log:\n │       ├─possible versions are: 0.9.0-0.17.12 or uninstalled\n │       └─restricted by compatibility requirements with GLMakie [e9467ef8] to versions: 0.17.12\n │         └─GLMakie [e9467ef8] log: see above\n ├─restricted by compatibility requirements with Makie [ee78f7c6] to versions: [0.1.0-0.3.1, 0.6.7-0.6.9] or uninstalled, leaving only versions: 0.6.7-0.6.9\n │ └─Makie [ee78f7c6] log: see above\n └─restricted by compatibility requirements with GridLayoutBase [3955a311] to versions: 0.1.0-0.3.1 or uninstalled — no versions left\n   └─GridLayoutBase [3955a311] log:\n     ├─possible versions are: 0.1.0-0.9.0 or uninstalled\n     ├─restricted by compatibility requirements with Observables [510215fc] to versions: 0.7.5-0.9.0 or uninstalled\n     │ └─Observables [510215fc] log: see above\n     └─restricted by compatibility requirements with Makie [ee78f7c6] to versions: 0.9.0\n       └─Makie [ee78f7c6] log: see above\n``` | [IanButterworth]: What's the output of `st --outdated`? | [rapus95]: @IanButterworth \n```julia\n(@testing) pkg> st --outdated\nStatus `C:\Users\Aaron\.julia\environments\testing\Project.toml`\n⌃ [e9467ef8] GLMakie v0.6.9 (<v0.6.12)\n``` | [IanButterworth]: Looks like a bug. Are you able to share the Project.toml? | [KristofferC]: Is there any package in the environment that is upper bounding GLMakie to that version? If not, then the upgradable marker is shown. | [rapus95]: @IanButterworth it's already an MWE, this is the entire project.toml:\n```\n[deps]\nAlgebraOfGraphics = """"cbdf2221-f076-402e-a563-3d30da359d67""""\nGLMakie = """"e9467ef8-e4e7-5192-8a1a-b1aee30e663a""""\n```\n[Project.txt](https://github.com/JuliaLang/Pkg.jl/files/9228798/Project.txt)\n[Manifest.txt](https://github.com/JuliaLang/Pkg.jl/files/9228812/Manifest.txt)\nit didn't let me upload .toml files -.-\n\n@KristofferC there are no explicit bounds. According to the report I made above, the only thing upper-bounding GLMakie is the existence of AlgebraOfGraphics because there's no version of it that's compatible to the newer versions of GLMakie. But in that case there should be the yellow marker which says that it's constrained by some other package I guess. | [IanButterworth]: FYI, the conflict appears to be fixed with the release of AlgebraOfGraphics 0.6.10\n\nBut I do think there's a bug here\n\n```\n(jl_9jYE5C) pkg> add AlgebraOfGraphics@0.6.9 GLMakie\n...\n\n(jl_9jYE5C) pkg> pin AlgebraOfGraphics\n...\n\n(jl_9jYE5C) pkg> st\nStatus `/private/var/folders/_6/1yf6sj0950vcg4t91m9ltb5w0000gn/T/jl_9jYE5C/Project.toml`\n⌃ [cbdf2221] AlgebraOfGraphics v0.6.9 ⚲\n⌃ [e9467ef8] GLMakie v0.6.9\nInfo Packages marked with ⌃ have new versions available\n\n(jl_9jYE5C) pkg> st --outdated\nStatus `/private/var/folders/_6/1yf6sj0950vcg4t91m9ltb5w0000gn/T/jl_9jYE5C/Project.toml`\n⌃ [cbdf2221] AlgebraOfGraphics v0.6.9 ⚲ (<v0.6.10)\n⌃ [e9467ef8] GLMakie v0.6.9 (<v0.6.12)(jl_9jYE5C) pkg> add AlgebraOfGraphics@0.6.9 GLMakie\n\n(jl_9jYE5C) pkg> add GLMakie@0.6.12\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package GridLayoutBase [3955a311]:\n GridLayoutBase [3955a311] log:\n ├─possible versions are: 0.1.0-0.9.0 or uninstalled\n ├─restricted by compatibility requirements with AlgebraOfGraphics [cbdf2221] to versions: 0.6.0-0.7.10\n │ └─AlgebraOfGraphics [cbdf2221] log:\n │   ├─possible versions are: 0.1.0-0.6.10 or uninstalled\n │   └─restricted to versions 0.6.9 by an explicit requirement, leaving only versions 0.6.9\n ├─restricted by compatibility requirements with Observables [510215fc] to versions: 0.7.5-0.9.0 or uninstalled, leaving only versions: 0.7.5-0.7.10\n │ └─Observables [510215fc] log:\n │   ├─possible versions are: 0.2.0-0.5.1 or uninstalled\n │   └─restricted by compatibility requirements with GLMakie [e9467ef8] to versions: 0.5.1\n │     └─GLMakie [e9467ef8] log:\n │       ├─possible versions are: 0.0.1-0.6.12 or uninstalled\n │       └─restricted to versions 0.6.12 by an explicit requirement, leaving only versions 0.6.12\n └─restricted by compatibility requirements with Makie [ee78f7c6] to versions: 0.9.0 — no versions left\n   └─Makie [ee78f7c6] log:\n     ├─possible versions are: 0.9.0-0.17.12 or uninstalled\n     └─restricted by compatibility requirements with GLMakie [e9467ef8] to versions: 0.17.12\n       └─GLMakie [e9467ef8] log: see above\n```\n\n@KristofferC IIUC in this case GLMakie should have a `⌅`, I believe?\n | [rapus95]: yes, that MWE is fixed because the new one is compatible to the current Makie version. But the general problem persists. And yes I'd also say that it should get the yellow marker. | [vancleve]: I'm seeing this too, though I have a ton of packages in my default Project.toml",12,false,0,0,0,0,0,0,0,0,0
3187,Feature Request: Add branch by PR number,open,ianatol,,,,1,2022-08-31T00:13:38.0,2022-08-31T06:08:01.0,1054,1054,https://github.com/JuliaLang/Pkg.jl/issues/3187,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3187,It would be nice if we could do `] add SomePackage#4800` and have that pick up the branch corresponding to PR #4800 in that repo \n,"[KristofferC]: Similar matchers as in https://github.com/JuliaLang/Pkg.jl/blob/a657e5941c610fd3ce0405f6b419e4a88dc054ca/src/REPLMode/argument_parsers.jl#L13-L15 could be added.\n\nThere is a bit of an ambiguity between a numeric branch name and a PR number with this syntax, but maybe that is ok. You can always use the API interface if you need to add a branch with a number name.",1,false,0,0,0,0,0,0,0,0,0
1962,Applications: what are they?,open,StefanKarpinski,,,,28,2020-08-15T14:45:37.0,2022-08-12T18:58:13.0,1800,1072,https://github.com/JuliaLang/Pkg.jl/issues/1962,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1962,I want to start an official discussion of what makes a project an application here.,"[Roger-luo]: I think this is a bit related to what I was working on. CLIs can be one kind of the applications, since in principal they can be built in a standalone environment using PackageCompiler as an app, and then installed to `.julia/bin`, but CLIs doesn't have to contain a `bin` folder in the project folder, since that can be generated. It'd be nice if Pkg can manage this use case (either install or uninstall)\n | [KristofferC]: Posting this discussion here: https://discourse.julialang.org/t/julia-bin-as-a-standard-location-for-scripts/45993.\n\nSome quick thoughts/ideas. The exact name of stuff are not that important.\n\n1. An application is a Julia project (note, not a package) that comes with `bin/foo_1.jl`, `bin/foo_2.jl` files that all defines a `main(args::Vector{String})` function.\n2. The project file should list all the """"entry points"""" like `apps = [""""foo_1"""", """"foo_2""""]`. These are the names of how a user would run the app (`./foo_1`) and correspond to the file in `bin`. Each app can therefore define multiple """"executables"""".\n2. An application is required to have a Manifest file. The resolver is in fact unused when it comes to installing applications.\n3. Because of point 2, an application does not have any compat info in the registry.\n4. An application is installed with `app add App`.\n5. Similar functions like `app status` `app rm` are available.\n6. The currently active project is irrelevant for apps since they are self-contained and run in their own process.\n7. Upon installation, the app is put into `apps/$slug`  (or maybe we should just keep using the `packages` directory) and for each entry in `apps` a wrapper file is put into `.julia/bin` that will run the app. For example `.julia/bin/foo_1` will start julia and pass the arguments to `apps/$slug/bin/foo_1.jl`. People are recommended to add `.julia/bin` to their PATH (perhaps Pkg should have some convenience tool to add that to `.bashrc` etc.)\n8. You cannot depend on an app.\n\n\nQustions:\n\n1. What happens with name collisions in `.julia/bin`?\n2. How do you """"dev"""" an app? Just clone it and then you manually run `julia bin/foo_1.jl`?\n2. How do we GC?\n3. What julia version is used to run all the apps? Perhaps just `julia` by default overridable by an env and an explicit argument to the app? \n4. Should there be some way to pass standard julia arguments to the app (like `--optimize`, and `--check-bounds`). \n5. How should Julia compat be handled if there is only one manifest. Maybe that is too strict and we should in fact resolve dependencies to the app? | [aviks]: I've been thinking about this for a while, so herewith some comments. I agree with most of https://github.com/JuliaLang/Pkg.jl/issues/1962#issuecomment-686447390 except:\n\n* I think saying that Apps have frozen dependencies and cannot participate in version resolution is too restrictive. Many apps run user code, which might have dependencies of their own. For example, consider an image editor that runs plugins. A simpler but more concrete example is GameZero, which behaves as an app in that it has a command line game runner. But the game it runs is a julia code, with it's own set of dependencies. This is a hard problem, and I'm not sure what a good solution is -- but I think it is important that apps can fit into another _environment_ somehow. \n* Somewhat related, should there be a way of running an app from the REPL, as opposed to only via a shell wrapper. Basically should there be a shortcur for `include(""""project/bin/main.jl""""); main()`? How does that relate to environments? How do you pass parameters in this case?\n\nSome other random comments\n\n* I think the wrapper in `.julia/bin` should use the path to julia that was used to install the app. Different versions of julia maybe used by setting an environment variable (Maybe called `JULIA` which is used in some contexts) \n* For clarity, I think apps should be able to be registered in the registry. | [KristofferC]: >  For example, consider an image editor that runs plugins. A simpler but more concrete example is GameZero, which behaves as an app in that it has a command line game runner. But the game it runs is a julia code, with it's own set of dependencies. \n\nMaybe there should be a library version of `GameZero` then like `GameZeroLib` and an eventual `GameZero` application. I think that running apps from the terminal but at the same time have them be bound to some external environment will be very confusing. Like, if we do things correctly, you aren't even supposed to know that you are running Julia code. | [fredrikekre]: I was actually thinking about this this morning, funny coincidence. This is what I had in mind, and what I sketched up now:\n```\n$ cat MyApp/bin/myapp.jl \nprintln(""""""""""""Welcome.\n    This is myapp running with $(LOAD_PATH[1])\n    as the environment with the following version of Example.jl:\n    $(read(pipeline(`pkg st`, `grep Example`), String))"""""""""""")\n\n$ julia -e 'Applications; Applications.install(""""MyApp"""")'\n[ Info: Installed `foo` to /home/fredrik/.julia/bin\n[ Info: Installed `myapp` to /home/fredrik/.julia/bin\n\n$ myapp\nWelcome.\nThis is myapp running with /home/fredrik/.julia/scratchspaces/043fa9b4-a959-4035-b28b-58282c1da903/c8bb88aa-bf07-49d0-bccd-10f9f1c5c30c/0.1.0\nas the environment with the following version of Example.jl:\n  [7876af07] Example v0.5.1\n```\nwhereas in the regular env\n```\n$ pkg st | grep Example\n  [7876af07] Example v0.5.3\n```\n\nEdit: version 2:\n```\n$ myapp\nWelcome.\nThis is myapp running with /home/fredrik/.julia/packages/MyApp/qaAkC\nas the environment with the following version of Example.jl:\n  [7876af07] Example v0.5.1\n``` | [ffevotte]: I entirely agree with Kristoffer's comment above.\n\nSome thoughts about the remaining questions:\n\n<br/>\n\n> * How do you """"dev"""" an app? Just clone it and then you manually run `julia bin/foo_1.jl`?\n\nI'd say yes, just clone it. Then with the minimal interface defined above:\n```\njulia -L bin/foo_1.jl -e 'main(ARGS)' -- arg1 arg2 arg3\n```\nOr possibly \n```\njulia bin/foo_1.jl -- arg1 arg2 arg3\n```\nif the scripts in `bin` additionally automatically run `main(ARGS)` when they are [run as the main script](https://docs.julialang.org/en/v1/manual/faq/#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?)\n\n<br/>\n\n> * Should there be some way to pass standard julia arguments to the app (like --optimize, and --check-bounds).\n\nI think this would be useful. Perhaps via environment variables?\nSuch a feature would also be a way to support sysimages without too much effort from `Pkg`'s side.\n\nA related question is whether there would be a way for the app itself to control which command-line arguments are used for the Julia process that runs it. Apps could perhaps declare a preferred (poossibly overrideable) set of arguments in `Project.toml`\n\n<br/>\n\n> * What julia version is used to run all the apps? Perhaps just julia by default overridable by an env and an explicit argument to the app?\n\nI don't have any sensible answer to propose here, but just wanted to mention that this question is very important if we want to allow """"executables"""" to support custom sysimages.\n\nI guess what makes this particularly difficult is that some users delete older julia versions when they install a newer one. Others don't but update a set of symlinks in their PATH so that older versions remain accessible, but under an other name...\n\nMaybe a minimal way to handle julia upgrades would be to provide a way for users to re-generate all wrappers in `~/.julia/bin` (or at least check whether apps and their dependencies are still compatible with the newly installed julia version). | [Roger-luo]: I recently have been building some CLIs which I think are also """"Applications"""". I agree with most of the comments above, but the current solution I'm using now is a bit different from what @KristofferC described, which might be interesting to consider. \n\n> An application is a Julia project (note, not a package) that comes with bin/foo_1.jl, bin/foo_2.jl files that all defines a main(args::Vector{String}) function.\n\nIn my case, the CLI projects are generated by the DSL [Comonicon](https://github.com/Roger-luo/Comonicon.jl), it generates an entry function `command_main` in the package's module, and then generates two scripts in `.julia/bin`. This allows Julia to precompile the `command_main(::Vector{String})` function so for simple CLIs we can have almost zero extra start-up time.\n\n1. `command_name.jl` this file simply `using XXX; XXX.command_main()`\n2. `command_name` this is shell script, it basically configs how one should call Julia compiler with some optimization options, a glance of how it may look like\n\n```sh\n#!/bin/sh\nJULIA_PROJECT=/Users/roger/julia_code/IonCLI /Applications/Julia-1.5.app/Contents/Resources/julia/bin/julia \\n    -J/Users/roger/julia_code/IonCLI/deps/lib/libion.dylib \\n    --compile=min \\n    -O2 \\n    --startup-file=no \\n    -- /Users/roger/.julia/bin/ion.jl $@\n```\n\nI guess potentially, I can also generate an entry file in `bin/command_name.jl`, but would be nice if I don't need to.\n\n> perhaps Pkg should have some convenience tool to add that to .bashrc etc\n\nI implemented this in Comonicon: https://github.com/Roger-luo/Comonicon.jl/blob/master/src/tools/build.jl#L559 in case if someone wants it.\nBut I find it's hard to cover all kinds of shells.\n\nRegarding environments, I'm currently using the package environment directly with a committed `Manifest.toml`, I find this works pretty well in general (except https://github.com/JuliaLang/PackageCompiler.jl/issues/438, but it's not related)\n\n\n> Should there be some way to pass standard julia arguments to the app (like --optimize, and --check-bounds).\n\nI think allowing developers to config in `Project.toml` would be nice (tho environment variables can always be a low priority choice), since it will make building system image easier in the CI and more consistent on users' device (so users don't need to set up environment variables themselves) e.g I'm currently using a custom config file `Comonicon.toml`: https://github.com/Roger-luo/IonCLI.jl/blob/master/Comonicon.toml  It'd be nice if this can be included in `Project.toml` which makes the folder more compact. \n\n\n> How do you """"dev"""" an app? Just clone it and then you manually run julia bin/foo_1.jl?\n\nI think this currently works for me. but note in my case if I want to generate the entries in `bin` I need to run `build` before installation etc.\n\n> What julia version is used to run all the apps? Perhaps just julia by default overridable by an env and an explicit argument to the app?\n\nI'm using the julia when the user install the application/package. so at least we can make sure this julia executable is compatible (guaranteed by Pkg) and can run/build the application.\n\n> What happens with name collisions in .julia/bin?\n\nI think in rust, application names are registered so at least in the same registry you can't have two same application names. | [KristofferC]: >  >How do you """"dev"""" an app? Just clone it and then you manually run julia bin/foo_1.jl?\n> I'd say yes, just clone it.\n\nI thought about this some more and I don't think this is """"correct"""". Firstly, we should have a """"manifest"""" file that lists all the applications that are installed. This should be a TOML file and should contain all data that is necessary to reproduce the same set of applications on another machine. It could look something like\n\n```\n[[MyApp]]\nexecutables = [""""app_1"""", """"app_2""""]\ngit-tree-sha1 = """"abcd-1232.""""\nversion = """"0.1.0""""\n\n[[OtherApp]]\nexecutables = [""""ls"""", """"cat""""]\npath = """"/home/kc/juliapps/OtherApps\nversion = """"1.1.0""""\n\n[[PkgEval]]\nexecutables = [""""pkgeval""""]\ngit-tree-sha1 = """"abcd-1232...""""\nrepo-url = """"...""""\nrepo-rev = """"master""""\nversion = """"1.1.0""""\n```\n\nso in this case, running `app_1` would load it from something like `.julia/apps/$SLUG/bin/app_1.jl` but in the `OtherApp` case it loads it from the given path. Note hos this pretty much exactly replicated how code loading work for the Manifest.\n\nWe could then have something like `""""instantiate""""` that takes this TOML file as an input and produces the correct wrappers in `.julia/bin` so that you can actually run things by just `app_1` (assuming PATH is set). You could also then just send this file to another machine and get the same set of """"apps"""" installed.\n\nThere would then be a set of Pkg commands that manages this file. For example:\n\n```\npkg> app add RipGrepJL\nAdding RipGrepJL....\n\npkg> app status\nRipGrepJL @ 1.0.0 -> ripgrep\nOtherApp @ 1.1.0 [""""home/kc/juliapps/OtherApps""""]  -> ls, cat\nMyApp @ 0.1.0 -> app_1, \n\npkg> app rm MyApp\n...\n\npkg> app dev home/kc/juliapps/CoolApp2\n```\n\nPkg always makes sure that the stuff in `.julia/bin` are updated. | [KristofferC]: > This allows Julia to precompile the command_main(::Vector{String}) function so for simple CLIs we can have almost zero extra start-up time.\n\nYes, I agree that the application needs to support precompilation so it should probably be something like `import App; App.app1()` to run `app1` in the application `App` instead of just executing `bin/app1.jl`. This is similar to what PackageCompiler is doing.\n\n> I think allowing developers to config in Project.toml would be nice\n\nDo you mean that apps want to set custom julia argument options themselves. Maybe that should be in the project file then. Users could override them with something like:\n\n```\n./myapp --julia-args --check-bounds=no -O 3\n```\n\nwhere everything after `--julia-args` are passed as julia arguments.\n\n> I think in rust, application names are registered so at least in the same registry you can't have two same application names.\n\nBut we also want to be able to just add an application by url á la `pkg> app add https://...`.\n\n | [Roger-luo]: > I thought about this some more and I don't think this is """"correct"""". Firstly, we should have a """"manifest"""" file that lists all the applications that are installed. This should be a TOML file and should contain all data that is necessary to reproduce the same set of applications on another machine. It could look something like\n\n@KristofferC does this mean per environment `bin` folder?\n\nI feel the `bin` folder might be nice to have for per environment too, this could resolve part of the name conflict problem.\n\n> Do you mean that apps want to set custom julia argument options themselves. Maybe that should be in the project file then. Users could override them with something like\n\nOne potential issue is that if the application is itself a CLI application, these extra options might not be necessary and can make the already complicated CLI more complicated.\n\n> But we also want to be able to just add an application by url á la pkg> app add https://....\n\nIf it's not a registered package, maybe user should take their own risk? if we have per environment `bin` then maybe what they could do is just use a new environment.\nThis is also consistent with the behavior of packages I think? But then on terminal side, we need to setup some shell environments that activates certain Julia environment via `JULIA_PROJECT`.\n\n\n\n | [tkf]: Here's my take on how to define an application:\n\n* An application is specified by just TOML file(s). Say `Application.toml` and `Manifest.toml`.  It does not contain any Julia code by itself.\n* An application can have multiple entry points.  When they are installed as CLIs (e.g., via `pkg> app add MyApp`), they are mapped to executables.\n* Each application entry point is implemented as a function _in a package_ listed in the `Manifest.toml` file of the application.\n* The signature of the function is something like `f(args::Vector{String}) -> code::Int`.  In particular, the function itself does _not_ call `exit`.\n\nThe format of `Application.toml` is something like this\n\n```toml\nname = """"MyApp""""\nuuid = """"...""""\nauthors = [""""...""""]\nversion = """"X.Y.Z""""\n\n[executable.app_1]\npackage_name = """"MyPackage""""\npackage_uuid = """"u-u-i-d""""\nentry_point = """"app_1""""  # i.e., `MyPackage.app_1(::Vector{String})` exists\n\n[executable.app_2]\npackage_name = """"MyPackage""""\npackage_uuid = """"u-u-i-d""""\nentry_point = """"app_2""""\n```\n\nI think it's nice to decouple how an application is specified and how it is implemented.  For example, with this approach we can also derive in-REPL Pkg-like """"CLI"""" from the above interface (i.e., just install MyPackage and call `MyPackage.app_1([""""arg1"""", """"arg2""""])` via `cli> app_1 arg1 arg2`).  It also makes it easy to use a different mechanism to invoke an application (e.g., https://github.com/tkf/JuliaCLI.jl).  Composing other applications (e.g., provide them through subcommands with pre-/post-processing) is easy this way.  I think it also addresses some of the points @KristofferC raised:\n\n> 2\. How do you """"dev"""" an app?\n\nIf we enforce that an application has no code, we can just dev a package that implements the application.\n\n> 5\. Should there be some way to pass standard julia arguments to the app (like `--optimize`, and `--check-bounds`).\n\nIf the entry point is easy to import as a function, you can just call it with `julia` (as already mentioned https://github.com/JuliaLang/Pkg.jl/issues/1962#issuecomment-686707220).\n | [KristofferC]: > It does not contain any Julia code by itself.\n> Each application entry point is implemented as a function in a package listed in the Manifest.toml file of the application.\n\nI don't really understand this. It seems odd to me that a set of entry points can go into different packages and that they are in packages listed in the manifest and not the Project.toml/Application.toml. What if I don't want to register a package, the code my app executes might be only for the app and is not reusable as a library?\n\nI think each application should have an associated module that can be individually precompiled and where app code can be put. Depending on the entry point you might want to load a different set of dependencies. So an app with multiple entry points would be structured something like\n\n```\nApplication.toml\nManifest.toml\nsrc/App1.jl\nsrc/App2.jl\n```\n\n```toml\n# Application.toml\nname = """"MyApp""""\nuuid = """"...""""\nauthors = [""""...""""]\nversion = """"X.Y.Z""""\n\n[executable.App1]\n# metadata\n\n[executable.App2]\n# metadata\n\n[deps]\nDepA = """"...""""\nDepB = """"...""""\nDepC = """"...""""\n...\n\n\n\n```\n\n```jl\n# src/App1.jl\nmodule App1\nusing DepA\nusing DepB\n\nmain(args::Vector{String}) = ...\n\nend # module\n```\n\n```jl\n# src/App2.jl\nmodule App1\nusing DepA\nusing DepC\n\nmain(args::Vector{String}) = ...\n\nend  # module\n```\n\nThe user facing entry points would be `./app1` and `./app2`. Calling these will precompile the corresponding module and run the main function in that module. | [tkf]: > the code my app executes might be only for the app and is not reusable as a library?\n\nMy point is that code is usually reusable. If the entry-point function does not call `exit`, I think the majority of """"CLI"""" is actually totally usable as a library. Even if not, I think providing different ways to invoke the entry points (via Pkg.jl-like REPL, worker pools like JuliaCLI.jl, as sub-commands, etc.) is an important feature. I think distributing a concrete Manifest.toml for an app is a good idea. But, if the app code is not loadable outside a fixed Manifest.toml distributed with the app, being able to put any code in an app promotes Julia programmers to write non-reusable code (e.g., if the code cannot be loaded in REPL and it's hard to auto-create Pkg.jl-like UI).\n\nThat said, what I'm proposing is doable by suggesting\n\n```julia\n# src/App1.jl\nmodule App1\nusing MyPackage\nmain(args) = exit(MyPackage.app_1(args))\nend # module\n```\n\nas the best practice. I just thought that it's nice to encode the best practice as the default behavior.\n | [KristofferC]: > My point is that code is usually reusable. If the entry-point function does not call exit, I think the majority of """"CLI"""" is actually totally usable as a library. \n\nMaybe, maybe not. If the user wants to not deal with the overhead of writing library like code that should be totally fine. Forcing all application code into a library might very well mean that nice tools don't get made because the author doesn't think the code makes sense in a library (and maybe it doesn't). One should be allowed to write cool and interesting applications that are not meant to be used as libraries without having to register some dummy library package. | [tkf]: > register some dummy library package\n\nSince Manifest.toml file can contain URL and relative path, I don't think that's necessary.\n\n> Forcing all application code into a library might very well mean that nice tools don't get made\n\nDo you mind elaborating on this? Frankly, I don't understand why categorizing a certain set of files as """"library"""" instead of """"application"""" suddenly makes it hard to write exactly the same chunk of Julia code.  This is especially so when you don't have to register the package.\n | [KristofferC]: > Since Manifest.toml file can contain URL and relative path, I don't think that's necessary.\n\nThat's a good point and then the difference between library and application code becomes moot.\n\nBut then I don't see what you object with to e.g. the layout in https://github.com/JuliaLang/Pkg.jl/issues/1962#issuecomment-686932729.\n\nInstead of \n\n```\nsrc/App1.jl\nsrc/App2.jl\n```\n\nyou want it to be\n\n```\nApp1l/src/App1.jl\nApp2/src/App1.jl\n```\n\nand each """"app"""" runs `App1/src/App1.jl:main(args)` so that someone can do `dev/Apps/App1` and run the main function manually? That's a good idea then but it won't work immediately since `dev/Apps/App1` doesn't have a project file. The reason I want to have a separate module for each entry point is that they can then be precompiled separately and only use the dependencies it needs. | [Roger-luo]: Just one related thought on this, if there is a registry for applications, then we can consider provide an option to compile the entire application as standalone executable on registry side, and even Julia itself can be one of the application on this registry. Thus should make download of a lot Julia toolchain become easier and user don't need to wait for precompile/compile locally. | [tkf]: > But then I don't see what you object with to e.g. the layout in [#1962 (comment)](https://github.com/JuliaLang/Pkg.jl/issues/1962#issuecomment-686932729).\n\nThe main point I wanted to emphasize was that having a package-compatible directory structure reduces the things Julia programmers have to learn and also infrastructures such as Pkg.jl have to implement.  If the code lives in a separate directory or a URL, Julia programmers don't have to learn anything for knowing how to `dev` the code.  Likewise, nothing has to be implemented in Pkg.jl for supporting `add`ing for `dev`ing the application _implementations_ (i.e., the packages; installing executables is another story, of course).  This is also why I think we can maximize the """"accidental reusability"""" of the application code as it's just a package.\n\n> it won't work immediately since `dev/Apps/App1` doesn't have a project file\n\nActually, I want\n\n```\nApplication.toml or Project.toml?\nManifest.toml\nApp1/Project.toml\nApp1/src/App1.jl\nApp2/Project.toml\nApp2/src/App2.jl\n```\n\nso that `App1` and `App2` are just normal packages that can be `add`ed and `dev`ed.  Of course, creating `App1/src/App1.jl`, `App2/src/App2.jl`, corresponding `Project.toml`, etc. by hand is very tedious.  I think this is a disadvantage of a package-based approach.  But I think that's already more or less solved since we have PkgTemplates.jl.\n\nI think it resembles the move from `[extras]`/`[targets]` to `test/Project.toml`.  Just like test-only dependencies are recorded in `test/Project.toml`, it's straight forward to record a separate set of dependencies in `App1/Project.toml` and `App2/Project.toml`.  Since the project is a minimal component in Julia's code organization, I think that reusing the concept of projects everywhere is a nice simple approach.\n | [KristofferC]: > The main point I wanted to emphasize was that having a package-compatible directory structure reduces the things Julia programmers have to learn and also infrastructures such as Pkg.jl have to implement. \n\nOk, that is a valid point that I can agree with. In fact, PackageCompiler.jl apps are structured in exactly that way.\n\nI'm not sure what it means to have multiple project files but one manifest file. How would the resolution process for that work? What happens to `compat` in the project files etc? What is in those project files?\n\n\n | [KristofferC]: > we can consider provide an option to compile the entire application as standalone executable on registry side, and even Julia itself can be one of the application on this registry.\n\nIt would be cool but also require a significant amount of infrastructure and work. You would need buildbots for the different architectures, automatic hosting, a download page for apps etc. | [tkf]: > I'm not sure what it means to have multiple project files but one manifest file. How would the resolution process for that work? What happens to `compat` in the project files etc? What is in those project files?\n\nHmm..., I thought it'd already work out-of-the-box.  I'm thinking that the top-level `/Manifest.toml` has entries like\n\n```toml\n[[App1]]\ndeps = [""""Compat""""]\npath = """"App1""""  # relative path\nuuid = """"945464c1-6d4c-46d5-ac5e-fb453f79302f""""\n\n[[App2]]\ndeps = [""""JSON""""]\npath = """"App2""""  # relative path\nuuid = """"32a02d8f-a56a-4e64-b0fa-04f84568876c""""\n```\n\nand `/App1/Project.toml` is something like\n\n```toml\nname = """"App1""""\nuuid = """"945464c1-6d4c-46d5-ac5e-fb453f79302f""""\n\n[deps]\nCompat = """"34da2185-b29b-5c13-b0c7-acf172513d20""""\n\n[compat]\nCompat = """"2.0, 3.0""""\n```\n\nI thought `compat` of `/App1/Project.toml` and `/App2/Project.toml` are considered when I run Pkg commands like `up` and `resolve` on `/Manifest.toml`.  Am I misunderstanding how Pkg works? Or are there other concerns I am missing?\n\nFor more advanced usages like using `/Manifest.toml` when `/App1/Project.toml` is activated, I imagine that the sub-projects feature #1233 can be repurposed.\n | [Roger-luo]: I guess this is something related: so I'm providing standalone binaries via PackageCompiler and GitHub Actions for CLIs made by Comonicon. This is done automatically, but it can still be cumbersome to install these applications. Since they are standalone, I might expect that users may not have a valid julia compiler locally, thus I provide a shell script for a one-click installation experience: https://github.com/Roger-luo/IonCLI.jl/blob/master/setup , so users can install an application like this directly via\n\n```\nbash -ci """"$(curl -fsSL https://raw.githubusercontent.com/Roger-luo/IonCLI.jl/master/setup)""""\n```\n\nso I notice there is https://sh.rustup.rs in rust community, I'm thinking if we could have something like `julialang.sh` (this domain is not claimed yet) as a short domain for applications registered in the registry, then users can install using installers via something like `https://julialang.sh/<app name>` | [mauro3]: It seems to me that what is being discussed here does not square with """"Application"""" as defined in the glossary: """"Application: a project which provides standalone functionality not intended to be reused by other Julia projects. For example a web application or a commmand-line utility, or *simulation/analytics code accompanying a scientific paper.*"""" (emphasis mine)  As for simulation/analytics code, I don't need any command-line tool installed.  So, maybe there is a need to add another term to the glossary, something like to """"a-bunch-of-scripts"""". So a project could be a Package, an Application, or a-bunch-of-scripts.\n\nAs far as I can tell, most of what's discussed here does not apply to a-bunch-of-scripts projects. | [Roger-luo]: what does a-bunch-of-scripts projects look like typically here? is it still a Julia project? or just a folder of scripts? | [kescobo]: > what does a-bunch-of-scripts projects look like typically here? is it still a Julia project? or just a folder of scripts?\n\nI don't know if it's typical, but I recently [made this](https://github.com/Klepac-Ceraj-Lab/ResonanceMicrobiome), which has a julia package structure, but also a `notebooks/` directory that has analysis code where I do `using ResonanceMicrobiome`. But I wouldn't call this an application (which I think is @mauro3 's point?), and I don't think I'd need the functionality being discussed here for that project. | [mauro3]: Yes, something like this.  Although mine look a lot less fancy than @kescobo's ;-)  But the Project.toml & Manifest.toml are essential to keep track of the deps, so it's a project.\n\nEdit: this https://github.com/luraess/julia-parallel-course-EGU21 would be a good example as well.  It's not for a paper but a course with a bunch of scripts which the students can then run. | [simonbyrne]: I kicked off a related discussion on discourse:\nhttps://discourse.julialang.org/t/tooling-for-julia-command-line-scripts/73915?u=simonbyrne\nBut had a few more thoughts as to specifically what exactly an """"application"""" might be, and how this could work:\n\n1. An application is a project with one or more """"endpoints"""": these could include:\n\n   - a script (.jl) file which handles command line arguments via `ARGS` (i.e.. the simplest possible application could be a `Package.toml` and a single script)\n   - a function `main(ARGS)`-style function contained in a module\n   - a dynamic library (e.g. as created by [`PackageCompiler.create_library`](https://julialang.github.io/PackageCompiler.jl/stable/refs.html#PackageCompiler.create_library)\n   - other files that are either:\n      - stored in the package\n      - stored in an associated artifact\n      - generated in an associated [scratch space](https://github.com/JuliaPackaging/Scratch.jl)\n \n   Note that this definition could include things like libraries or executable products in _jll packages, so the application mechanism could encompass functionality like that of [`ygg`](https://github.com/fredrikekre/ygg).\n\n2. Installing a package would consist of a process like:\n    a. instantiating a package environment in some directory (e.g. `~/.julia/apps/tree-hash/`)\n    b. resolving the endpoints: there could be various user-configurable options for how to do this, e.g. \n      - whether or not to build a system image\n      - whether to compile `main(ARGS)`-style endpoints as executables, or use a simple shell shim script\n      - what command line args to pass to julia\n\n    c. (optionally) symlink these into `~/.julia/bin` (or some other directory). Again, there could be various options here such as:\n      - link only a subset of endpoints\n      - rename endpoints (e.g. to support having multiple versions of a package installed at a time)\n\nI'm sure there are lots of things I'm missing here (e.g. would this approach work on Windows? how to handle things like header files for libraries?), but I would be keen to hear other people's suggestions. | [simonbyrne]: I've put together a minimal prototype of my idea here: https://github.com/simonbyrne/PkgApp.jl",28,false,11,11,0,0,0,0,0,0,0
3170,Make custom `julia_version` work again,open,KristofferC,staticfloat; KristofferC,,1.9,0,2022-08-11T19:25:45.0,2022-08-11T19:25:45.0,1073,1073,https://github.com/JuliaLang/Pkg.jl/issues/3170,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3170,Movin out DelmitedFiles from Julia made the custom `julia_version` code path no longer work since it tries to look up the Project file from the local installation. A discussed solution was to let Pkg accept a path to a custom registry that descirbes the dependencies of the stdlibs over the different Julia versions (but we still need to know what stdlib version was installed for each julia version).,,0,false,0,0,0,0,0,0,0,0,0
3164,FR: Make different version upgrades distinguishable,open,prbzrg,,,,0,2022-08-07T22:18:49.0,2022-08-07T22:18:49.0,1077,1077,https://github.com/JuliaLang/Pkg.jl/issues/3164,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3164,Something like:\n1.2.3 --> 1.2.4 --------- italic font\n1.2.3 --> 1.3.1 --------- normal font\n1.2.3 --> 2.0.1 --------- bold font\nor have different shades of a colour for them.\n,,0,false,1,1,0,0,0,0,0,0,0
3152,[Feature request] introduce an upgradability marker for packages that constrain updating of other packages,open,rapus95,,,,2,2022-07-31T12:21:19.0,2022-07-31T21:06:51.0,1085,1084,https://github.com/JuliaLang/Pkg.jl/issues/3152,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3152,"This is the complement to the yellow marker (which says “there's a new version, but we cannot use it due to dependencies”) and shall mean “this package prevents us from updating dependencies”. I'd propose a warm color for it. Maybe even red.\nIt helps by directly showing which packages need a new compat info (open PR/issue on their repo) or need to be disabled if I need the new version of another package.","[IanButterworth]: This already exists. It's a bug in  #3150 that it's not showing | [IanButterworth]: Sorry, I misread this suggestion. I'll reopen for discussion. \n\nMy view though is that there isn't much more the proposed marker would add, and I think adding another marker type might get close to making the information too complex. \n\nIf there's a package being held back, one can use --outdated to find out why. That singular example might benefit slightly from the suggested marker, but often there are many packages being held back in various ways, so I don't think a single new marker type can communicate useful information. For that the user needs to use --outdated",2,false,0,0,0,0,0,0,0,0,0
2743,1.7.0-rc1: clean up bad registry tarball on EOF exception,open,johnnychen94,,,,1,2021-09-25T03:26:04.0,2022-07-30T15:47:24.0,1394,1085,https://github.com/JuliaLang/Pkg.jl/issues/2743,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2743,"I'm not sure how to reproduce it, but with some bad network conditions, I get a bad `General.tar.gz` file in `~/.julia/registries` and then hit the following error in Julia 1.7.0-rc1:\n\n```julia\njulia> versioninfo()\nJulia Version 1.7.0-rc1\nCommit 9eade6195e (2021-09-12 06:45 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.6.0)\n  CPU: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 8\n\n(@v1.7) pkg> up\nERROR: Unexpected end of data : General.tar\nERROR: EOFError: read end of file\nStacktrace:\n  [1] read_data(tar::Base.Process, file::IOBuffer; size::Int64, buf::Vector{UInt8}, tee::Base.DevNull)\n    @ Tar /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Tar/src/extract.jl:706\n  [2] #12\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:201 [inlined]\n  [3] read_tarball(callback::Pkg.Registry.var""""#12#15""""{Base.Process, IOBuffer, Vector{UInt8}, Dict{String, String}}, predicate::Pkg.Registry.var""""#13#16"""", tar::Base.Process; buf::Vector{UInt8}, skeleton::Base.DevNull)\n    @ Tar /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Tar/src/extract.jl:399\n  [4] #11\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:199 [inlined]\n  [5] open(::Pkg.Registry.var""""#11#14""""{IOBuffer, Vector{UInt8}, Dict{String, String}}, ::Cmd; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Base ./process.jl:395\n  [6] open\n    @ ./process.jl:393 [inlined]\n  [7] uncompress_registry(tar_gz::String)\n    @ Pkg.Registry /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:198\n  [8] Pkg.Registry.RegistryInstance(path::String)\n    @ Pkg.Registry /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:266\n  [9] reachable_registries(; depots::Vector{String})\n    @ Pkg.Registry /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:373\n [10] reachable_registries\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:345 [inlined]\n [11] download_default_registries(io::Base.TTY; only_if_empty::Bool)\n    @ Pkg.Registry /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/Registry.jl:101\n [12] download_default_registries\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/Registry/Registry.jl:101 [inlined]\n [13] up(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/API.jl:144\n [14] up(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/API.jl:144\n [15] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:407\n [16] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:385\n [17] do_cmd\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:376 [inlined]\n [18] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:549\n [19] #invokelatest#2\n    @ ./essentials.jl:716 [inlined]\n [20] invokelatest\n    @ ./essentials.jl:714 [inlined]\n [21] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493\n [22] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1230\n [23] (::REPL.var""""#49#54""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ./task.jl:411\n```\n\nMy understanding is that we need some exception handling in https://github.com/JuliaLang/Pkg.jl/blob/13b7861518dcfceebfc01566c329a2b2faa62623/src/Registry/registry_instance.jl#L368-L373 to clean up the bad registry tarball.","[Vaibhavdixit02]: I hit this as well\n\n```\npkg> registry status\nERROR: Unexpected end of data : General.tar\nERROR: EOFError: read end of file\nStacktrace:\n  [1] read_data(tar::Base.Process, file::IOBuffer; size::Int64, buf::Vector{UInt8}, tee::Base.DevNull)\n    @ Tar /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Tar/src/extract.jl:706\n  [2] #12\n    @ /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:201 [inlined]\n  [3] read_tarball(callback::Pkg.Registry.var""""#12#15""""{Base.Process, IOBuffer, Vector{UInt8}, Dict{String, String}}, predicate::Pkg.Registry.var""""#13#16"""", tar::Base.Process; buf::Vector{UInt8}, skeleton::Base.DevNull)\n    @ Tar /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Tar/src/extract.jl:399\n  [4] #11\n    @ /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:199 [inlined]\n  [5] open(::Pkg.Registry.var""""#11#14""""{IOBuffer, Vector{UInt8}, Dict{String, String}}, ::Cmd; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Base ./process.jl:395\n  [6] open\n    @ ./process.jl:393 [inlined]\n  [7] uncompress_registry(tar_gz::String)\n    @ Pkg.Registry /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:198\n  [8] Pkg.Registry.RegistryInstance(path::String)\n    @ Pkg.Registry /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:266\n  [9] reachable_registries(; depots::Vector{String})\n    @ Pkg.Registry /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:373\n [10] reachable_registries\n    @ /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/registry_instance.jl:345 [inlined]\n [11] status(io::Base.TTY) (repeats 2 times)\n    @ Pkg.Registry /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/Registry/Registry.jl:470\n [12] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:404\n [13] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:385\n [14] do_cmd\n    @ /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:376 [inlined]\n [15] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/Pkg/src/REPLMode/REPLMode.jl:549\n [16] #invokelatest#2\n    @ ./essentials.jl:716 [inlined]\n [17] invokelatest\n    @ ./essentials.jl:714 [inlined]\n [18] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493\n [19] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1230\n [20] (::REPL.var""""#49#54""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ./task.jl:423\n```\n\n```\njulia> versioninfo()\nJulia Version 1.7.0\nCommit 3bf9d17731 (2021-11-30 12:12 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.5.0)\n  CPU: Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, icelake-client)\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = 8\n  ```",1,false,0,0,0,0,0,0,0,0,0
3138,Pkg.add() and `add` slightly different results,open,cormullion,,,,4,2022-07-19T10:50:36.0,2022-07-26T08:20:56.0,1097,1090,https://github.com/JuliaLang/Pkg.jl/issues/3138,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3138,"Sorry if this a FAQ - are `Pkg.add()` and `add` do different things?\n\nHere, `Pkg.add()` adds a """"#master"""" at the end, whereas `add` doesn't.\n\n```julia\n    (@MiniFB) pkg> add https://github.com/oheil/Luxor.jl#multi_drawing\n        Updating git-repo `https://github.com/oheil/Luxor.jl`\n       Resolving package versions...\n        Updating `~/.julia/environments/MiniFB/Project.toml`\n      [ae8d54c2] ~ Luxor v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing#master` ⇒ v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing`\n        Updating `~/.julia/environments/MiniFB/Manifest.toml`\n🔴      [ae8d54c2] ~ Luxor v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing#master` ⇒ v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing`\n    Precompiling project...\n      ✓ Luxor\n      1 dependency successfully precompiled in 4 seconds. 82 already precompiled.\n      1 dependency precompiled but a different version is currently loaded. Restart julia to access the new version\n    \n    (@MiniFB) pkg> st\n    Status `~/.julia/environments/MiniFB/Project.toml`\n      [5ae59095] Colors v0.12.8\n      [ae8d54c2] Luxor v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing`\n      [cc649173] MiniFB v0.1.1\n    \n    julia> Pkg.add(path=""""https://github.com/oheil/Luxor.jl#multi_drawing"""")\n        Updating git-repo `https://github.com/oheil/Luxor.jl#multi_drawing`\n       Resolving package versions...\n        Updating `~/.julia/environments/MiniFB/Project.toml`\n      [ae8d54c2] ~ Luxor v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing` ⇒ v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing#master`\n        Updating `~/.julia/environments/MiniFB/Manifest.toml`\n🔴      [ae8d54c2] ~ Luxor v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing` ⇒ v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing#master`\n    Precompiling project...\n      ✓ Luxor\n      1 dependency successfully precompiled in 3 seconds. 82 already precompiled.\n      1 dependency precompiled but a different version is currently loaded. Restart julia to access the new version\n    \n    (@MiniFB) pkg> st\n    Status `~/.julia/environments/MiniFB/Project.toml`\n      [5ae59095] Colors v0.12.8\n      [ae8d54c2] Luxor v3.5.0 `https://github.com/oheil/Luxor.jl#multi_drawing#master`\n      [cc649173] MiniFB v0.1.1\n```\n","[fredrikekre]: > `Pkg.add(path=""""https://github.com/oheil/Luxor.jl#multi_drawing"""")`\n\nThis is spelled `Pkg.add(url = """"https://github.com/oheil/Luxor.jl"""", rev = """"multi_drawing"""")`. It is at least hinted to here: https://pkgdocs.julialang.org/v1/api/#Package-API-Reference. The Pkg REPL is meant for interactive use, so it tries to be a bit more """"clever"""" compared to the API, which you have to tell exactly what you mean. | [cormullion]: Ah, OK, thanks! I was just automating some manual typing, and translated it carelessly... Feel free to close this if you want. | [giordano]: Perhaps `Pkg.add(path=""""https://github.com/oheil/Luxor.jl#multi_drawing"""")` should error instead of just ignoring part of the (malformed) input? | [fredrikekre]: Problem is that it is a a valid URL though.\n\nEdit: Although from Wikipedia:\n\n>  [...] Clients are not supposed to send URI fragments to servers when they retrieve a document [...]\n\n`curl` drops it silently, `git` errors.",4,false,0,0,0,0,0,0,0,0,0
3137,Document compressed registries?,open,tpgillam,,,,0,2022-07-18T16:40:26.0,2022-07-18T16:40:26.0,1097,1097,https://github.com/JuliaLang/Pkg.jl/issues/3137,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3137,"There might be more than one issue, and maybe not all of them should be solved within `Pkg`.\n\n**Observation / issue 1**: Using Julia 1.7.2. Despite a new version of a package being merged to the general registry, over an hour afterwards my Julia session wasn't able to find the new version. Initially this was confusing to me.\n\nA little digging later, I discovered that the general registry had been downloaded as a tarball, rather than as a clone of the git repo. I eventually found [an entry in the changelog](https://docs.julialang.org/en/v1/NEWS/#Package-Manager) which alluded to this, but I couldn't find any information about it. e.g., it would be useful to know if there is some expected delay in whatever process generates these tarballs. And, if so, maybe advise people that they can switch the registry to cloning from git, if they want it more up-to-date.\n\n**Issue 2**: From the `Pkg.jl` documentation, I couldn't find any reference to """"compressed registries"""" — possibly it would be useful to have something added?\n\n---\n\nI am presuming that """"Issue 1"""" is expected behaviour, even if surprising (?) — in which case this is really just a documentation problem.",,0,false,3,3,0,0,0,0,0,0,0
1982,Allow named non-package project,open,fredrikekre,,,,5,2020-08-24T10:39:01.0,2022-07-18T14:00:59.0,1791,1098,https://github.com/JuliaLang/Pkg.jl/issues/1982,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1982,"```\n$ cat Project.toml \nname=""""MyProject""""\nuuid=""""81de396f-a148-4a69-b217-b58614fed4bb""""\n\n$ jlpkg resolve\nPkgError: expected the file `src/MyProject.jl` to exist for package `MyProject` at `/tmp/tmp.N0Z4kqJFBs`\n```","[Roger-luo]: I second this, another use case for me is when I install a CLI project (a package that generates a CLI to `.julia/bin`) I want to have an isolated project environment generated instead of mutating the package Project.toml that may have no permission for the CLI. | [fredrikekre]: Why do you need it to be """"named"""" for that application? | [Roger-luo]: I think I just copied the package environment then mutate on that? So there's a name in it. Or yeah you are right, I may not need the name but only a deps field. | [mauro3]: Would this also allow for `Pkg.test()` to work without having a `src/MyProj.jl`?\n\n(Is there an work-around apart from creating a minimal `src/MyProj.jl`?) | [Datseris]: > Would this also allow for Pkg.test() to work without having a src/MyProj.jl?\n\nOh that would be wonderful and would also solve https://github.com/JuliaDynamics/DrWatson.jl/issues/67",5,false,11,11,0,0,0,0,0,0,0
3115,Make usage tips take form of current mode (REPL or API),open,IanButterworth,,,,0,2022-06-23T16:20:13.0,2022-06-23T16:27:52.0,1122,1122,https://github.com/JuliaLang/Pkg.jl/issues/3115,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3115,"Quoting @KristofferC in https://github.com/JuliaLang/Pkg.jl/pull/3099#pullrequestreview-996200799 because it's a good idea that we should keep track of\n\n> I think we should show the hints using REPL mode or API mode depending on how the command was called. If the REPL mode was used we could store that in Context and then look at that field when printing suggestions. That's for another time of course.\n\n___\n\nI've also been thinking in REPL mode warnings and soft errors should be formatted the same as Pkg REPL mode, so instead of\n\n```\n(@1.9) pkg> instantiate\n┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.7.3). Unexpected behavior may occur.\n└ @ ~/Documents/GitHub/MyProject.jl/Manifest.toml:0\nPrecompiling project...\n```\n\ndo something like\n```\n(@1.9) pkg> instantiate\n     Warning The active manifest file has dependencies that were resolved with a different julia version (1.7.3). \n             Unexpected behavior may occur.\n             Active manifest: ~/Documents/GitHub/MyProject.jl/Manifest.toml\nPrecompiling project...\n```\nbut keep them as logs in API mode, in case users are depending on them being served through logging infrastructure.",,0,false,0,0,0,0,0,0,0,0,0
2584,`ctrl-c` during registry updates leads to corruption,open,ericphanson,,,,10,2021-06-01T18:29:32.0,2022-06-15T18:05:33.0,1509,1130,https://github.com/JuliaLang/Pkg.jl/issues/2584,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2584,"I didn't see any issue for this but let me know if it's a duplicate. (This is usually fixed fine by `rm`ing and `add`ing the registry, but many users don't know that).","[fredrikekre]: During git clone then? Otherwise it is just a file move. | [ericphanson]: When I've seen it on my machine, it might've been during git clone yeah. (I get very annoyed by Pkg server registry delays so I usually switch to the git version). I'm not sure about the other cases I've heard about. | [StefanKarpinski]: I'm not sure if there's much we can do about this when the registry is transferred via git: the `git` CLI program is likely to be ctrl-C resilient, but libgit2 is unlikely to be. Now that we do this by downloading a compressed tarball and reading it directly, this should be much better since we unconditionally do that everywhere. | [ericphanson]: > I'm not sure if there's much we can do about this\n\nI was imagining a try-catch around the problematic libgit operations to try to safely handle interrupts or print a warning or something. But if we are moving off git and the new way doesn't have this problem then probably it's not worth it. | [KristofferC]: > But if we are moving off git and the new way doesn't have this problem then probably it's not worth it.\n\nWell, the reason you are using git:\n\n> (I get very annoyed by Pkg server registry delays so I usually switch to the git version)\n\nwill still be there so it doesn't seem like anything with the registry being uncompressed or not will have an effect here. | [ericphanson]: Yeah... was hoping that one could get solved too 😄. But if there is not much hope there and git will continue to be the path for active developers who want their new versions asap then maybe continuing to support/develop the git mode is the way to go. | [ericphanson]: @josephsdavid just ran into this with our private registry (we don't have a package server), so I'll bump this :). | [josephsdavid]: > @josephsdavid just ran into this with our private registry (we don't have a package server), so I'll bump this :).\n\nThis may be a problem exists between keyboard and chair scenario 😅😅 remains unclear! | [KristofferC]: For git repos we clone it to a tmp directory:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/423343402943074825392faa8b04a6d353204689/src/Registry/Registry.jl#L224\n\nand then move it in place:\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/423343402943074825392faa8b04a6d353204689/src/Registry/Registry.jl#L250.\n\nIf the temp dir and the final destination is on different drives then I guess the move will have to copy things file by file and interrupting it could leave an incomplete registry. So perhaps the `mv` should be in a try-catch and have the directory removed if it fails? | [ericphanson]: Sorry, apparently I assumed it was this issue too soon- @josephsdavid can probably say more but apparently it was an unrelated issue, something about some crazy interaction between git worktrees and Pkg, and not related to interrupts. (IMO it would be good to have a separate issue for that @josephsdavid but I know you already spent a few hours on this so idk if you have the time to try to reproduce what happened).",10,false,0,0,0,0,0,0,0,0,0
3098,Problem with the resolver when bumping stdlib version,open,KristofferC,,resolver,,2,2022-06-03T09:38:53.0,2022-06-13T20:01:52.0,1143,1132,https://github.com/JuliaLang/Pkg.jl/issues/3098,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3098,"In the upcoming 1.6 it is possible to hit the following error (https://s3.amazonaws.com/julialang-reports/nanosoldier/pkgeval/by_hash/9561ec5_vs_aafae8a/PATHSolver.primary.log)\n\n```\nPkgEval failed: MethodError: no method matching isless(::Int64, ::Nothing)\nClosest candidates are:\n  isless(::Any, !Matched::Missing) at missing.jl:88\n  isless(!Matched::Missing, ::Any) at missing.jl:87\n  isless(::Real, !Matched::AbstractFloat) at operators.jl:168\n  ...\nStacktrace:\n  [1] <(x::Int64, y::Nothing)\n    @ Base ./operators.jl:279\n  [2] >(x::Nothing, y::Int64)\n    @ Base ./operators.jl:305\n  [3] greedysolver(graph::Pkg.Resolve.Graph)\n    @ Pkg.Resolve /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/Resolve/Resolve.jl:293\n  [4] resolve(graph::Pkg.Resolve.Graph)\n    @ Pkg.Resolve /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/Resolve/Resolve.jl:63\n```\n\nThis can be reprod by just trying to add PATHSolver on the https://github.com/JuliaLang/julia/pull/45319 branch.\n\nThe issue comes from the bump in the stdlib version in https://github.com/JuliaLang/julia/pull/45319/commits/2ccbfe697b732626144b4d59dd75966a0e220e18#diff-3e1bbf7143d0e3a025448928aadf9cf29dbe3975ccdac85125e62843049d9089R3 together with the compat of DataDeps at https://github.com/JuliaRegistries/General/blob/08ac670477f95639640b8881be8548ef7cfdfd69/D/DataDeps/Compat.toml#L33 since changing any of these makes the issue goes away.\n\nHowever, this indicates there is some issue with the resolver I think since it should either have caught this in an assertion (if the input is inconsistent) or returned a resolved result.\n\n@carlobaldassi, maybe you could look at this?","[carlobaldassi]: Sure, I'll look into it as soon as I can | [KristofferC]: To repro this, you need a registry before https://github.com/JuliaRegistries/General/pull/61849",2,false,0,0,0,0,0,0,0,0,0
3102,Julia 1.6.3 - zstd - hash mismatch,open,ifelsefi,,,,1,2022-06-06T19:50:55.0,2022-06-09T21:14:05.0,1139,1136,https://github.com/JuliaLang/Pkg.jl/issues/3102,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3102,"Hi\n\nI am getting hash issue trying to add zstd.  This is on CentOS 7.9 server.\n\n```\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.3 (2021-09-23)\n _/ |\__'_|_|_|\__'_|  |\n|__/                   |\n\n\n(v1.6) pkg> st\n      Status `/nfs/users/admin/.julia_new/environments/v1.6/Project.toml` (empty project)\n\n(v1.6) pkg> add Arrow\n  Installing known registries into `/nfs/users/admin/.julia_new`\n\n\n       Added registry `General` to `/nfs/users/admin/.julia_new/registries/General`\n   Resolving package versions...\n   Installed ArrowTypes ────────────────── v1.2.1\n   Installed BitIntegers ───────────────── v0.2.6\n   Installed CodecZstd ─────────────────── v0.7.2\n   Installed Zstd_jll ──────────────────── v1.5.2+0\n   Installed InlineStrings ─────────────── v1.1.2\n   Installed CodecLz4 ──────────────────── v0.4.0\n   Installed Compat ────────────────────── v3.45.0\n   Installed SentinelArrays ────────────── v1.3.13\n   Installed Lz4_jll ───────────────────── v1.9.3+0\n   Installed Arrow ─────────────────────── v2.3.0\n   Installed ExprTools ─────────────────── v0.1.8\n   Installed RecipesBase ───────────────── v1.2.1\n   Installed OrderedCollections ────────── v1.4.1\n   Installed DataAPI ───────────────────── v1.10.0\n   Installed TranscodingStreams ────────── v0.9.6\n   Installed JLLWrappers ───────────────── v1.4.1\n   Installed IteratorInterfaceExtensions ─ v1.0.0\n   Installed DataValueInterfaces ───────── v1.0.0\n   Installed Tables ────────────────────── v1.7.0\n   Installed PooledArrays ──────────────── v1.4.2\n   Installed Parsers ───────────────────── v2.3.1\n   Installed CEnum ─────────────────────── v0.4.2\n   Installed Mocking ───────────────────── v0.7.3\n   Installed TableTraits ───────────────── v1.0.1\n   Installed Preferences ───────────────── v1.3.0\n   Installed TimeZones ─────────────────── v1.7.3\n Downloading artifact: Zstd\n┌ Error: Tree Hash Mismatch!\n│   Expected git-tree-sha1:   d22cde7583df1d5f71160a8e4676955a66a91f33\n│   Calculated git-tree-sha1: 963087c2d2f8b2470029113562bafddaf8ea7397\n  Downloaded artifact: Zstd\n  Downloaded artifact: Zstd\nERROR: Unable to automatically install 'Zstd' from '/nfs/users/admin/.julia_new/packages/Zstd_jll/qVDWi/Artifacts.toml'\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:33\n  [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n    @ Pkg.Artifacts /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:445\n  [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n    @ Pkg.Artifacts /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:510\n  [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY)\n    @ Pkg.Operations /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:709\n  [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY)\n    @ Pkg.Operations /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:686\n  [6] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Vector{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1241\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Iterators.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:204\n  [8] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:80\n  [9] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:78\n [10] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:408\n [11] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386\n [12] do_cmd\n    @ /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]\n [13] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550\n [14] #invokelatest#2\n    @ ./essentials.jl:708 [inlined]\n [15] invokelatest\n    @ ./essentials.jl:706 [inlined]\n [16] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441\n [17] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL /software/centos7/julia/1.6.3/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126\n [18] (::REPL.var""""#44#49""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ./task.jl:411\n\n```\n\nWe are using Julia Package sever and no firewall blocking downloads.","[staticfloat]: On my linux machine, on a completely fresh depot, I can install it no problem:\n\n```\n$ mkdir -p /tmp.pkg_test && cd /tmp/pkg_test\n$ JULIA_DEPOT_PATH=. julia-1.6.3 -e 'import Pkg; Pkg.add(""""Zstd_jll"""")'\n...\n  6 dependencies successfully precompiled in 2 seconds\n```\n\nAnd you can see the artifact installed locally, with the correct hash:\n```\n$ ls artifacts/\nd22cde7583df1d5f71160a8e4676955a66a91f33\n```\n\nWhere did you get your Julia install?  Does it work with the official binaries from https://julialang.org?",1,false,0,0,0,0,0,0,0,0,0
2922,Interrupting Pkg.test sometimes orphans the test sandbox process,open,IanButterworth,,bug,,1,2022-01-05T19:03:49.0,2022-06-05T02:06:28.0,1291,1141,https://github.com/JuliaLang/Pkg.jl/issues/2922,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2922,"`^C`-ing a `Pkg.test` run doesn't seem to reliably interrupt the child session, leaving it orphaned and running even when you close julia\n\nObserved on ubuntu\n\n","[IanButterworth]: This just happened to me interrupting Pkg tests on master, though it's reliable interrupting other test suites like `Dates`\n\n```\nVersion 1.9.0-DEV.706 (2022-06-02)\nCommit bd8dbc388c (2 days old master)\n```\n\n",1,false,2,2,0,0,0,0,0,0,0
3092,"Add function Pkg.create_project(project_name="""", packages=[])",open,ufechner7,,,,1,2022-05-25T09:44:03.0,2022-05-25T10:32:30.0,1152,1152,https://github.com/JuliaLang/Pkg.jl/issues/3092,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3092,"**Feature request**\n\nIt should be easier to create new user projects. Currently you need to do:\n```\nmkdir new_project\ncd new_project\njulia --project="""".""""\nusing Pkg\npkg""""add LinearAlgebra""""\nprg""""add StaticArrays""""\n```\nThis is just an example.\nAfter this new feature is implemented you should be able to do:\n```\njulia\nusing Pkg\nPkg.create_project(""""new_project"""", [""""LinearAlgebra"""",""""StaticArrays""""])\n```\nThis would make it easier to explain to new students how to create a user project.\nPerhaps even an interactive dialog could be started if the parameters are missing.","[KristofferC]: ```\nshell> mkdir NewProj\n\n(@v1.8) pkg> activate NewProj\n  Activating new project at `~/JuliaTests/NewProj`\n\n(NewProj) pkg> add LinearAlgebra StaticArrays\n```\n\n> This would make it easier to explain to new students how to create a user project.\n\nInstead of having a """"magic"""" command that does this, I think it is more instructive for students to see these three steps.\n\n- The first one shows that a project is just a folder.\n- The second one shows that you activate a project by just activating the folder.\n- The third one adds packages to the activated project.\n\nIf you have `Pkg.create_project(""""new_project"""", [""""LinearAlgebra"""",""""StaticArrays""""])` who knows what is going on?\n",1,false,0,0,0,0,0,0,0,0,0
2738,"Improve the ""empty intersection"" error message",open,Octogonapus,,,,5,2021-09-22T19:12:18.0,2022-05-22T03:44:43.0,1396,1155,https://github.com/JuliaLang/Pkg.jl/issues/2738,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2738,"When adding a specific version of a package that's incompatible with your project's compat bounds, you will get this error message:\n```\n(dev) pkg> add FileIO@1.11\n   Resolving package versions...\nERROR: empty intersection between FileIO@1.11.1 and project compatibility 1.5.0\n```\n\nIt states the minimum information I need to know, but it would be more helpful if it also told me why my project compatibility is `1.5.0`. Is it because of a dependency's compatibility? Is it because I specified that in my project's compat section? In this particular instance, it was because of the latter reason, so I think a more helpful error message would look like:\n\n```\n(dev) pkg> add FileIO@1.11\n   Resolving package versions...\nERROR: empty intersection between FileIO@1.11.1 and project compatibility 1.5.0\n Project log:\n ├─possible versions are: 1.5.0 or uninstalled\n ├─source: explicit project compatibility requirement\n     @ /path/to/Project.toml:25\n ├─restricted to versions 1.11.1 by an explicit requirement (`add FileIO@1.11`) - no versions left\n └─source: `add FileIO@1.11`\n     @ REPL[1]:1\n```\n\nThis error message tells me why my project compatibility is `1.5.0`. It's because I wrote `FileIO=""""=1.5.0""""` in my `Project.toml` file on line `25`. The error message could state something similar if a dependency is bounding the compatibility, similar to the resolver errors.","[KristofferC]: > Is it because I specified that in my project's compat section?\n\nAlways this. | [Octogonapus]: @IanButterworth and I talked offline and we agree that at least printing the compat entry line in the error message would be a big improvement. We feel that just stating `project compatibility 1.5.0`  doesn't tell the user that it specifically means the `[compat]` entry. | [DilumAluthge]: In addition, we could change the text `project compatibility` to `project compatibility (e.g. [compat] entry)`. | [KristofferC]: > project compatibility (e.g. [compat] entry)\n\nNot really `e.g.` here because it is only that. | [moble]: > > Is it because I specified that in my project's compat section?\n> \n> Always this.\n\nIt seems like it's not *always* this.  I had a confounding problem when I was working on a package (let's call it package `B`) which depended on another (let's call it `A`, of which I am the developer).  I realized that I needed to change `A` to get `B` working, so I just `dev`ed `A` in `B`, worked on `A` until `B` worked, and made a new release of `A`.  After the change made it into the general registry, I altered `Project.toml` in `B` to restrict to that version of `A` (or greater), and tried to update.  But I got the error\n\n    ERROR: empty intersection between A@1.0.0 and project compatibility 1.1.0-1\n\nIt took me much too long to remember that I had `dev`ed `A`.  My brute-force solution was just to delete `Manifest.toml`, and update.",5,false,2,2,0,0,0,0,0,0,0
3063,Interactive compat editor: io objects do not have a handle field,open,vtjnash,,,,2,2022-04-20T14:10:32.0,2022-05-18T17:27:25.0,1187,1158,https://github.com/JuliaLang/Pkg.jl/issues/3063,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3063,"This needs to be removed: https://github.com/JuliaLang/Pkg.jl/blob/7676431149332ae400a805632082b12263c20269/src/API.jl#L1742\n\nAlso, don't randomly ccall methods which don't apply to your memory type.\n\n(yes, it is not ideal that the only wrapper for this functionality now is in `REPL.Terminals.raw!`, but why is this reimplementing yet another REPL. It looks like I see at least 4 unique REPL-like implementations used in this package.)","[IanButterworth]: It seems like `REPL.Terminals.raw!` isn't a drop-in replacement\n```\nERROR: MethodError: no method matching raw!(::Base.TTY, ::Bool)\nClosest candidates are:\n  raw!(::REPL.Terminals.TTYTerminal, ::Bool) at ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/REPL/src/Terminals.jl:137\n  raw!(::REPL.Terminals.TextTerminal, ::Bool) at ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/REPL/src/Terminals.jl:89\n```\n\nIf there isn't a drop-in, one option would be to build the functionality into the core pkg repl mode, but that may be a lot of work.\n\nThe simplest option could be to remove this interactive `pkg> compat` menu, given that 1.8 isn't out yet. That would still leave the `pkg> compat Foo 1.3` format and the `pkg> status --compat` list, which is still a gain. | [IanButterworth]: bump.\nIf the interactive compat menu can't be easily fixed (@vtjnash: advice would be appreciated above) then we might want to go ahead and remove it for 1.8, or leave it in and at some point rework it into the existing REPL",2,false,0,0,0,0,0,0,0,0,0
3084,Behavior of no-arg activate with julia --project changed with julia v1.6,open,stemann,,,,1,2022-05-16T11:57:55.0,2022-05-16T12:14:02.0,1161,1161,https://github.com/JuliaLang/Pkg.jl/issues/3084,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3084,"Did the behavior of no-arg `Pkg.activate()` change with Julia v1.6, such that it activates the default env.?\n\nIn other words - does the docs need updating, cf. https://pkgdocs.julialang.org/v1/api/#Pkg.activate ?\n\nOn Julia v1.5, `julia --project --eval 'using Pkg; Pkg.activate()`, the local project is activated:\n```\n$ docker run -it --rm julia:1.5 bash -c """"julia --eval 'using InteractiveUtils; versioninfo(); using Pkg; Pkg.activate(); Pkg.generate(\""""Foo\"""")'; cd Foo; julia --project --eval 'using Pkg; Pkg.activate(); Pkg.activate(\"""".\"""")'""""\nJulia Version 1.5.4\nCommit 69fcb5745b (2021-03-11 19:13 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_GPG = 3673DF529D9049477F76B37566E3C7DC03D6E495\n  JULIA_VERSION = 1.5.4\n  JULIA_PATH = /usr/local/julia\n Activating environment at `~/.julia/environments/v1.5/Project.toml`\n Generating  project Foo:\n    Foo/Project.toml\n    Foo/src/Foo.jl\n Activating environment at `/Foo/Project.toml`\n Activating environment at `/Foo/Project.toml`\n```\n\nOn Julia v1.6-v1.7, `julia --project --eval 'using Pkg; Pkg.activate()`, activates the default env.:\nv1.6\n```\n$ docker run -it --rm julia:1.6 bash -c """"julia --eval 'using InteractiveUtils; versioninfo(); using Pkg; Pkg.activate(); Pkg.generate(\""""Foo\"""")'; cd Foo; julia --project --eval 'using Pkg; Pkg.activate(); Pkg.activate(\"""".\"""")'""""\nJulia Version 1.6.6\nCommit b8708f954a (2022-03-28 07:17 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_GPG = 3673DF529D9049477F76B37566E3C7DC03D6E495\n  JULIA_VERSION = 1.6.6\n  JULIA_PATH = /usr/local/julia\n  Activating environment at `~/.julia/environments/v1.6/Project.toml`\n  Generating  project Foo:\n    Foo/Project.toml\n    Foo/src/Foo.jl\n  Activating environment at `~/.julia/environments/v1.6/Project.toml`\n  Activating environment at `/Foo/Project.toml`\n```\nv1.7\n```\n$ docker run -it --rm julia:1.7 bash -c """"julia --eval 'using InteractiveUtils; versioninfo(); using Pkg; Pkg.activate(); Pkg.generate(\""""Foo\"""")'; cd Foo; julia --project --eval 'using Pkg; Pkg.activate(); Pkg.activate(\"""".\"""")'""""\nJulia Version 1.7.2\nCommit bf53498635 (2022-02-06 15:21 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_GPG = 3673DF529D9049477F76B37566E3C7DC03D6E495\n  JULIA_VERSION = 1.7.2\n  JULIA_PATH = /usr/local/julia\n  Activating project at `~/.julia/environments/v1.7`\n  Generating  project Foo:\n    Foo/Project.toml\n    Foo/src/Foo.jl\n  Activating project at `~/.julia/environments/v1.7`\n  Activating project at `/Foo`\n```\n","[KristofferC]: My guess is this got changed based on https://github.com/JuliaLang/julia/pull/36434. If the docs are out of date, then they do need updating, indeed.",1,false,0,0,0,0,0,0,0,0,0
3083,Missing package add prompt needs more tests,open,IanButterworth,,,,0,2022-05-11T16:24:23.0,2022-05-11T16:24:23.0,1165,1165,https://github.com/JuliaLang/Pkg.jl/issues/3083,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3083,As is shown by the issue fixed by https://github.com/JuliaLang/Pkg.jl/pull/3082 the missing package add prompt needs more extensive tests,,0,false,0,0,0,0,0,0,0,0,0
2607,API request: installable versions from package name,open,fonsp,,,,5,2021-06-09T11:03:36.0,2022-05-10T14:34:57.0,1502,1167,https://github.com/JuliaLang/Pkg.jl/issues/2607,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2607,"I could not find a way to do the following, without using internal API:\n\n> Which versions (if any?) of a package (by name) can be installed from a reachable registry?\n\nUse cases in https://github.com/fonsp/Pluto.jl/pull/844 include (screenshots attached):\n- [autocomplete all available packages when typing `using Plo<TAB>`](https://user-images.githubusercontent.com/6933510/121342763-434b2000-c922-11eb-8c8d-7e7a447b5581.png)\n- [show that a package name is not found in the registry](https://user-images.githubusercontent.com/6933510/121342888-65dd3900-c922-11eb-956b-05a629b491c3.png)\n- [show which version will be installed]() (though this also requires https://github.com/JuliaLang/Pkg.jl/issues/11)\n- show whether a package has a more recent version than the one installed\n\n# Current implementation\n\nI use internal API to find all registries, then internal `Pkg.Types.read_registry` to parse it, and then internal API to iterate and query the entries matching a package name.\n\n# Difference with https://github.com/JuliaLang/Pkg.jl/issues/11\n\nIssue #11 should respect _compatibility bounds_ of a given environment, which is one step further than this issue.","[KristofferC]: The API (while still internal) should be better in 1.7. It would be something like:\n\n```jl\nusing UUIDs\n\nregistry = Pkg.Registry.RegistryInstance(""""/home/kc/.julia/registries/General"""")\n\nuuids_with_name = Pkg.Registry.uuids_from_name(registry, """"Pluto"""")\n\nd = Dict{UUID, Set{VersionNumber}}()\nfor uuid in uuids_with_name\n   pkg_info = Pkg.Registry.registry_info(registry[uuid])\n   d[uuid] = keys(pkg_info.version_info)\nend\n```\nwhich here gives you a dictionary mapping each package with the name """"Pluto"""" (remember, a registry can have multiple packages with the same name) to its set of versions.\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/89746e96bd0b239a2b729788e6873529657bbcb2/src/Registry/registry_instance.jl#L42-L56\n\nis useful to look at.\n\n | [fonsp]: Are any changes in the past year useful here? This is still a big future-proof-problem for Pluto | [KristofferC]: Does\n\n```jl\nusing UUIDs, Pkg\n\nregistries = Pkg.Registry.reachable_registries()\n\nd = Dict{UUID, Set{VersionNumber}}()\n\nfor registry in registries\n    uuids_with_name = Pkg.Registry.uuids_from_name(registry, """"Pluto"""")\n    for uuid in uuids_with_name\n        pkg_info = Pkg.Registry.registry_info(registry[uuid])\n        d[uuid] = keys(pkg_info.version_info)\n    end\nend\n```\n\nwork for you? | [fonsp]: Yes perfect! Do you think we can make `reachable_registries`, `uuids_from_name` and `registry_info` public API? | [KristofferC]: Not really, but you can use the https://github.com/GunnarFarneback/RegistryInstances.jl package:\n\n> The whole purpose of RegistryInstances is to provide the RegistryInstance abstraction without relying on Pkg internals. \n\n",5,false,0,0,0,0,0,0,0,0,0
3006,Trouble Installing Packages,open,eaylee123,,,,0,2022-02-26T13:05:49.0,2022-05-03T14:41:17.0,1240,1174,https://github.com/JuliaLang/Pkg.jl/issues/3006,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3006,"Hi,\n\nStruggling to get packages installed for Julia in VSC on a windows 10 machine.\nIt works fine for me in Linux so not sure where the issue lies. Have included the error message below:\n\nUsing Pkg\nPkg.add(""""CSV"""")\n\n\n```\nGitError(Code:ERROR, Class:Index, invalid data in index - incorrect header signature)\nStacktrace:\n  [1] macro expansion\n    @ C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\LibGit2\src\error.jl:110 [inlined]\n  [2] diff_tree(repo::LibGit2.GitRepo, tree::LibGit2.GitTree, pathspecs::String; cached::Bool)\n    @ LibGit2 C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\LibGit2\src\diff.jl:34\n  [3] isdiff(repo::LibGit2.GitRepo, treeish::String, paths::String; cached::Bool)\n    @ LibGit2 C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\LibGit2\src\LibGit2.jl:160\n  [4] #isdirty#103\n    @ C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\LibGit2\src\LibGit2.jl:135 [inlined]\n  [5] isdirty (repeats 2 times)\n    @ C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\LibGit2\src\LibGit2.jl:135 [inlined]\n  [6] (::Pkg.Registry.var""""#58#62""""{Base.TTY, Pkg.Registry.RegistryInstance})(repo::LibGit2.GitRepo)\n    @ Pkg.Registry C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\Registry\Registry.jl:404\n  [7] with(f::Pkg.Registry.var""""#58#62""""{Base.TTY, Pkg.Registry.RegistryInstance}, obj::LibGit2.GitRepo)\n    @ LibGit2 C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\LibGit2\src\types.jl:1150\n  [8] update(regs::Vector{Pkg.Registry.RegistrySpec}; io::Base.TTY, force::Bool)\n    @ Pkg.Registry C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\Registry\Registry.jl:403\n  [9] update_registries(ctx::Pkg.Types.Context; force::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.Operations C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\Operations.jl:1072\n [10] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\API.jl:252\n [11] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\API.jl:149\n [12] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\API.jl:144\n [13] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\REPLMode\REPLMode.jl:407\n [14] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\REPLMode\REPLMode.jl:385\n [15] do_cmd\n    @ C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\REPLMode\REPLMode.jl:376 [inlined]\n [16] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\Pkg\src\REPLMode\REPLMode.jl:549\n [17] #invokelatest#2\n    @ .\essentials.jl:716 [inlined]\n [18] invokelatest\n    @ .\essentials.jl:714 [inlined]\n [19] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\REPL\src\LineEdit.jl:2493\n [20] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL C:\Users\lloyd\AppData\Local\Programs\Julia-1.7.2\share\julia\stdlib\v1.7\REPL\src\REPL.jl:1232\n [21] (::REPL.var""""#49#54""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL .\task.jl:423\n```",,0,false,0,0,0,0,0,0,0,0,0
3077,"Updating JuliaRegistry on fresh install of 1.6.6 with `ENV[""JULIA_PKG_USE_CLI_GIT""]=true` => failed unlink prompts",open,BioTurboNick,,,,0,2022-05-03T14:12:13.0,2022-05-03T14:18:00.0,1174,1174,https://github.com/JuliaLang/Pkg.jl/issues/3077,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3077,"I installed 1.6.6 on a system that has had 1.7 and 1.8 versions active. Windows 11. When I tried to run the update command in Pkg, I got a long string of prompts about a failed unlinked file:\n\n""""Unlink of file '.git/objects/pack/pack-bb81ba51f27aecf91eb38a1d96e3c95822a2bd55.pack' failed. Should I try again? (y/n)""""\n\nNot sure how many they are so I didn't try to get to the end; at least 20.\n\nSetting `ENV[""""JULIA_PKG_USE_CLI_GIT""""]=false` allowed it to proceed. I had to set that to true for my SSH key to be found and used correctly.",,0,false,0,0,0,0,0,0,0,0,0
2677,Use WSL style NTFS extended attributes to store permissions of extracted artifacts on Windows,open,davidanthoff,,windows,,1,2021-07-26T23:06:13.0,2022-05-03T12:56:04.0,1454,1174,https://github.com/JuliaLang/Pkg.jl/issues/2677,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2677,"The idea would be to follow https://docs.microsoft.com/en-us/windows/wsl/file-permissions#wsl-metadata-on-windows-files to store unix file permissions instead of changing ACLs of extracted files on Windows. The functions to interact with these extended attributes are https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwqueryeafile and https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwseteafile.\n\n@staticfloat, @StefanKarpinski, giordano had a brief chat about this on Slack, and I'm just opening this issue to keep a record of the links we dug out.","[staticfloat]: Okay, had a talk with @vtjnash about this, and we're on board with trying this out.\n\nThe concrete steps forward are:\n\n- [ ] Write the EA utility functions in libuv to read/write WSL2 permissions strings, use those in `uv_fs__chmod()` and `uv_fs__stat()` instead of the ACL code.\n- [ ] Create Julia branch that uses that libuv code, so `chmod()` and `stat()` use EAs instead of ACLs\n- [ ] See if our `access(X_OK)` code can detect whether `~/.julia` inherits an executable permission, and if it does not, surface a warning to the user that they may need to do something like `icacls .julia /grant ${USER}:(OI)(CI)F /T`.",1,false,0,0,0,0,0,0,0,0,0
2789,Can't specify a prerelease tag in the `compat` sectiion of a Project.toml File,open,MarkNahabedian,,feature request,,0,2021-10-21T15:16:16.0,2022-05-03T12:54:01.0,1368,1174,https://github.com/JuliaLang/Pkg.jl/issues/2789,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2789,"This is in Julia 1.6.0.\n\n```\nversioninfo()\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: Intel(R) Core(TM) i5-4300U CPU @ 1.90GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, haswell)\n```\n\nI first raised this issue in a [Julia Discourse topic](https://discourse.julialang.org/t/specify-a-prerelease-version-in-project-toml-compat-section/69938/1) but got no response.  Perhaps I should have picked a better title.\n\n# TLDR:\n\nOne can't specify a prerelease tag in the `compat` sectiion of a `Project.toml` file.  Version strings lik `1.2.3-dev` in the `compat` section fail to parse.\n\n# Motivation\n\nI have some changes to registered Julia packages that have not yet been incorporated into the registered versions.  For example, I have some [small changes](https://github.com/MarkNahabedian/NativeSVG.jl) to [NativeSVG.jl](https://github.com/BenLauwens/NativeSVG.jl) that make it more flexible.\n\nTo distinguish my version of NativeSVG.jl from version numbers in the main stream, I put\n\n```\nversion = """"0.1.0-naha""""\n```\n\nin the `Project.toml` file.\n\nI have other projects that depend on my changes to `NativeSVG`, but if I specify that dependency in the `compat` section of that `Project.toml` file I get an error.\n\nI would up having to [removethe prerelease tag](https://github.com/MarkNahabedian/NativeSVG.jl/commit/fd2b601d513e89979f24b06177c4567e285cb687) to avoid the error.\n\nThis is not ideal.\n\n\n# Analasys\n\n\n```\nvn = VersionNumber(""""0.1.0-naha"""")\nv""""0.1.0-naha""""\n```\n\nis a valid VersionNumber with a prerelease tag:\n\n```\nvn.prerelease\n(""""naha"""",)\n```\n\nbut it does not parse as a `VersionSpec`:\n\n```\nPkg.Types.VersionSpec(""""0.1.0-naha"""")\nERROR: ArgumentError: invalid base 10 digit 'n' in """"naha""""\nStacktrace:\n [1] tryparse_internal(#unused#::Type{Int64}, s::SubString{String}, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n   @ Base .\parse.jl:137\n [2] parse(::Type{Int64}, s::SubString{String}; base::Nothing)\n   @ Base .\parse.jl:241\n [3] parse\n   @ .\parse.jl:241 [inlined]\n [4] Pkg.Types.VersionBound(s::SubString{String})\n   @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\versions.jl:99\n [5] Pkg.Types.VersionRange(s::String)\n   @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\versions.jl:146\n [6] Pkg.Types.VersionSpec(s::String)\n   @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\versions.jl:227\n [7] top-level scope\n   @ none:1\n```\n\nThis is not the error I get when Julia tries to parse my """"offending"""" `compat` entry.  That error was\n\n```\nPkg.add(; url=""""https://github.com/MarkNahabedian/ShaperOriginDesignLib"""")\n    Updating git-repo `https://github.com/MarkNahabedian/ShaperOriginDesignLib`\nERROR: Could not parse compatibility version for dependency `NativeSVG`\nStacktrace:\n  [1] pkgerror(msg::String)\n    @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\Types.jl:55\n  [2] read_project_compat(raw::Dict{String, Any}, project::Pkg.Types.Project)\n    @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\project.jl:66\n  [3] Pkg.Types.Project(raw::Dict{String, Any})\n    @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\project.jl:121\n  [4] read_project(f_or_io::String)\n    @ Pkg.Types C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Pkg\src\project.jl:136\n```\n\nI believe this error is because my version string doesn't match the regular expressions at the end of `Julia-1.6.0/share/julia/stdlib/v1.6/Pkg/src/versions.jl`.\n\nNote that these regular expressions do not incorporate the regular expression `Base.VERSION_REGEX` (used to parse a VersionNumber).  It seems to me poor practtice that there are two different definitions of the syntax of a version number which could diverge under future development.\n\nNote that a `VersionSpec` can be constructed from such a `VersionNumber` though:\n\n```\nPkg.Types.VersionSpec(VersionNumber(""""0.1.0-naha""""))\nVersionSpec(""""0.1.0"""")\n```\n\nthough the prerelease tag is lost in the process.\n\nI don't know what the formal specification is meant to be, but I infer or observe that\n\n - one should be able to determine if a `VersionNumber` falls within a `VersionRange`;\n\n - a `VersionSpec` represents a set of `VersionRange`s;\n\n\n[SemVer](https://semver.org/) provides a BNF.\n\nIt appears that Julia's `VersionNumber` corresponds to the `<valid semver>` nonterminal in that BNF.\n\nI don't see anything in the BNF that corresponds to `VersionRange`.\n\nThe problem with the `VersionRange` syntax implemented in JUlia is that `-` can either separate the two extrema of a `VersionRange` or introduce the prerelease identifier of a `VersionNumber`.\n\nThe colon character `:` is not a terminal in the SemVer BNF.  Perhaps it should be used to separate the extrema of a `VersionRange`.  This is consistent with the use of `:` as Julia's range operator.\n\nAlternatively, one might want to specify open or closed ends of a `VersionRange`.  In that case, perhaps the separators `<`, `=<`, `<=` and `=<=` might be a way to specify that.\n\nThis would be an incompatible change.\n",,0,false,0,0,0,0,0,0,0,0,0
2728,CACHEDIR.TAG,open,fredrikekre,,speculative,,2,2021-09-14T18:47:00.0,2022-05-02T15:26:34.0,1404,1174,https://github.com/JuliaLang/Pkg.jl/issues/2728,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2728,"Should Pkg put a `CACHEDIR.TAG` file in e.g. `.julia/packages`, `.julia/registries`, `.julia/clones` etc? See https://bford.info/cachedir/. It seems like this proposal hasn't gained that much traction, but it is supported by e.g. GNU `tar` (see the `--exclude-caches` flag) and [`borg`](https://borgbackup.readthedocs.io) (same flag).",[fredrikekre]: cargo does this since some days ago: https://github.com/rust-lang/cargo/pull/10553 | [KristofferC]: Should be fairly easy to add this and it seems like it is getting traction so why not.,2,false,0,0,0,0,0,0,0,0,0
3060,Interrupting add resulting in unending download error logs,open,IanButterworth,,,,1,2022-04-18T02:21:57.0,2022-04-19T22:58:48.0,1189,1187,https://github.com/JuliaLang/Pkg.jl/issues/3060,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3060,"I just hit this on master, where I `ctrl-C`'d. The logs were unending and I had to kill the process.\n\nIt may be a Downloads.jl issue?\n\n```\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n^C┌ Error: curl_multi_socket_action: 8\n└ @ Downloads.Curl ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/Downloads/src/Curl/utils.jl:57\n┌ Error: curl_multi_socket_action: 8\n└ @ Downloads.Curl ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/Downloads/src/Curl/utils.jl:57\n┌ Error: curl_multi_socket_action: 8\n└ @ Downloads.Curl ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/Downloads/src/Curl/utils.jl:57\n┌ Error: curl_multi_socket_action: 8\n└ @ Downloads.Curl ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/Downloads/src/Curl/utils.jl:57\n┌ Error: curl_multi_socket_action: 8\n└ @ Downloads.Curl ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/Downloads/src/Curl/utils.jl:57\n┌ Error: curl_multi_socket_action: 8\n└ @ Downloads.Curl ~/Documents/GitHub/julia/usr/share/julia/stdlib/v1.9/Downloads/src/Curl/utils.jl:57\n```","[DilumAluthge]: The issue of having millions of log messages will be fixed by https://github.com/JuliaLang/Downloads.jl/pull/190.\n\nThat doesn't fix the underlying issue, of course. @StefanKarpinski @staticfloat",1,false,0,0,0,0,0,0,0,0,0
3054,Prompt to install package should purge input buffer before reading from it,open,mbauman,,,,1,2022-04-08T18:56:34.0,2022-04-13T19:36:02.0,1198,1193,https://github.com/JuliaLang/Pkg.jl/issues/3054,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3054,"This just happened to me.  Note the newlines (that I entered when my system stalled) and the following REPL prompts (that immediately appeared after installing):\n\n```\njulia> using Foo\n\n\n │ Package Foo not found, but a package named Foo is available from a registry. \n │ Install package?\n │   (@v1.7) pkg> add Foo \n └ (y/n) [y]: n\n\n\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n   Installed Foo ─ v0.3.2\n    Updating `~/.julia/environments/v1.7/Project.toml`\n  [a1216acd] + Foo v0.3.2\n    Updating `~/.julia/environments/v1.7/Manifest.toml`\n  [a1216acd] + Foo v0.3.2\n  [4722fa14] + Bar v1.1.1\n  [d3707c4a] + Baz_jll v1.55.1+0\nPrecompiling project...\n  1 dependency successfully precompiled in 6 seconds (33 already precompiled)\n\njulia> \n\njulia> n\nERROR: UndefVarError: n not defined\n```\n\nThis happened on Julia v1.7.1; I've not tested 1.8 or master.","[IanButterworth]: @DilumAluthge this seems like a simple fix. It doesn't need to wait for me to have time to fix it, so I unassigned myself",1,false,0,0,0,0,0,0,0,0,0
2424,Missing rules for [extras],open,bkamins,,,,1,2021-03-06T10:13:21.0,2022-04-05T11:40:14.0,1597,1202,https://github.com/JuliaLang/Pkg.jl/issues/2424,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2424,"In https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/toml-files.md there is no information on `[extras]` and `[targets]` parts of Project.toml.\n\nIn particular I was not clear in https://github.com/JuliaData/DataFrames.jl/pull/2646 if you can add `[compat]` entries to packages listed in `[extras]`. They are only described in https://julialang.github.io/Pkg.jl/dev/api/#Pkg.test where no mention of `[compat]` is made.\n\nI am aware of https://julialang.github.io/Pkg.jl/dev/creating-packages/#Test-specific-dependencies-in-Julia-1.0-and-1.1 but normally packages like DataFrames.jl are, in particular, tested against Julia LTS which is 1.0.5 now. Maybe this is a place to add `[compat]` information (as in the future it will be easier to maintain it when the information will be removed).","[sairus7]: Bump.\nI've run into the same issue, don't even know how to add packages into `extras` section. So I just `add` package and then manually move its UUID from deps into extras. And its not clear, which is recommended way vs test-specific project.",1,false,3,3,0,0,0,0,0,0,0
3014,LocalPreferences.toml are added upon `pkg> up`,open,charleskawczynski,staticfloat; vchuravy,,,11,2022-03-03T18:43:03.0,2022-03-28T16:20:44.0,1234,1209,https://github.com/JuliaLang/Pkg.jl/issues/3014,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3014,"LocalPreferences.toml are added upon `pkg> up`, and they shouldn't.\n\nI'm not sure about the best or most compact / reproducible way to report this is. But, until I (intentionally or accidentally) delete `ck/pkg_issue`, this can be reproduced with:\n\n```\ngit clone https://github.com/CliMA/TurbulenceConvection.jl\ncd TurbulenceConvection.jl\ngit checkout ck/pkg_issue\njulia --project\n] up\n```\n\n`LocalPreferences.toml` now exists in `TurbulenceConvection.jl/`.","[staticfloat]: The issue is that `CPUSummary` recently added a thing that unconditionally sets a preference: https://github.com/JuliaSIMD/CPUSummary.jl/blob/main/src/CPUSummary.jl#L19 | [DilumAluthge]: Even so, that preference is being set when `Pkg.test` is run, right? That's why `LocalPreferences.toml` is being created at `test/LocalPreferences.toml`.\n\nSo it still seems to me that the `LocalPreferences.toml` file should be created in a temporary directory. | [KristofferC]: Yeah, I don't see why | [staticfloat]: It happens at precompile time; that's a top-level statement that is calling `set_preferences!()`, so it's not happening at test time, it's happening during the precompilation phase, probably while we're instantiating.  Do we instantiate the test environment in a temporary directory, or do we only run the tests in a temporary directory? | [DilumAluthge]: I was under the impression that we resolve the test environment in the temporary directory, but it seems I may be mistaken about that? | [charleskawczynski]: I don't know if it's related, but I'm often also seeing the Project.toml getting modified upon `pkg> up`, the order of the compat and deps are switched, and this entry often pops up:\n\n```toml\n[extras]\nCPUSummary = """"2a0fbf3d-bb9c-48f3-b0a9-814d99fd7ab9""""\n``` | [goerz]: Is this something that can be fixed within `Pkg`, or is this a bug that should be reported to `CPUSummary`?\n\nI hope this can be fixed soon. It's pretty irritating to have my `test/Project.toml` rewritten every time I run the tests. | [vchuravy]: cc: @chriselrod | [chriselrod]: CPUSummary depends on Preferences.jl.\n\nIt tries to check if `using Hwloc; Hwloc.gettopology()` works and doesn't segfault Julia:\nhttps://github.com/JuliaSIMD/CPUSummary.jl/blob/91846c77aed015cf2ba2fe738197e5b6aa64eb04/src/CPUSummary.jl#L14-L20\nThe problem is, this check always returns `false`, even though it works when I try it in the REPL.\nThere was a recent PR that tried to fix/improve things, but it did not work:\nhttps://github.com/JuliaSIMD/CPUSummary.jl/pull/7\n\nIf `LocalPreferences.toml` and adding it to the extras is too annoying, perhaps the best solution moving forward is to give up on Hwloc and just hard code support for all CPUs I want to/care about supporting.\nOctavian.jl is the only library really using that information anyway.\nAnd basically no one is using Hwloc with it now anyway -- as the check always returns that it does not work.\n\nOlder versions (CPUSummary <= v""""0.1.8"""") always used Hwloc, and this basically always worked, except that it causes Julia to crash when running under wine. | [DilumAluthge]: I don't think that this is an issue with CPUSummary.\n\nI think the issue here is that Pkg should be instantiating in a temporary directory.\n | [chriselrod]: > I don't think that this is an issue with CPUSummary.\n\nCPUSummary sets a preference if Hwloc fails. The fact the test doesn't work, and it always reports that Hwloc doesn't work when almost every time things would've been fine if I just `using Hwloc` (as v <= 0.1.8 did), and thus that it always sets a preference, means that there is at least a problem in CPUSummary contributing to what @goerz is complaining about.\n\nhttps://github.com/JuliaSIMD/CPUSummary.jl/commit/1eb0f66a2cadd556a77bb0a61fceb6403760ddc0",11,false,0,0,0,0,0,0,0,0,0
3043,Error 400 Bad Request on redirection when using proxy,open,RemiLacroix-IDRIS,,,,0,2022-03-28T14:50:45.0,2022-03-28T14:50:45.0,1210,1210,https://github.com/JuliaLang/Pkg.jl/issues/3043,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3043,"Hello,\n\nWe are facing an issue with Julia 1.7.2 that we cannot seem to fix on our side.\n\nDownloading packages fails with errror `HTTP/1.1 400 Bad Request (status 302; Received HTTP code 400 from proxy after CONNECT)`.\n\nI used https://github.com/giordano/DebugArtifacts.jl to try debugging and I can easily reproduce the problem:\n```\njulia> using DebugArtifacts\n\njulia> debug_artifact(""""ZeroMQ"""")\n[ Info: Platform: Linux x86_64 {cxxstring_abi=cxx11, julia_version=1.7.2, libc=glibc, libgfortran_version=5.0.0, libstdcxx_version=3.4.25}\nJulia Version 1.7.2\nCommit bf53498635 (2022-02-06 15:21 UTC)\nPlatform Info:\n  OS: Linux (x86_64-redhat-linux)\n  CPU: Intel(R) Xeon(R) Gold 6248 CPU @ 2.50GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, cascadelake)\n\n[ Info: Downloading Artifacts.toml https://raw.githubusercontent.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/master/Artifacts.toml to /tmp/jl_UfyIki/Artifacts.toml...\n[ Info: Extracting artifact info for platform x86_64-linux-gnu-libgfortran5-cxx11-libstdcxx25-julia_version+1.7.2...\n[ Info: Found meta object with git-tree-sha1 ffb84b2e0ea7ff86dbe323c7a4f82dc896d87d7f, attempting download https://github.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/releases/download/ZeroMQ-v4.3.2+4/ZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz...\nERROR: HTTP/1.1 400 Bad Request (status 302; Received HTTP code 400 from proxy after CONNECT) while requesting https://github.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/releases/download/ZeroMQ-v4.3.2+4/ZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz\nStacktrace:\n  [1] (::Downloads.var""""#9#18""""{IOStream, Base.DevNull, Nothing, Vector{Pair{String, String}}, Float64, Downloads.var""""#24#27""""{Pkg.PlatformEngines.var""""#15#17""""{Base.TTY}}, Bool, Bool, String, Int64, Bool, Bool})(easy::Downloads.Curl.Easy)\n    @ Downloads /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Downloads.jl:369\n  [2] with_handle(f::Downloads.var""""#9#18""""{IOStream, Base.DevNull, Nothing, Vector{Pair{String, String}}, Float64, Downloads.var""""#24#27""""{Pkg.PlatformEngines.var""""#15#17""""{Base.TTY}}, Bool, Bool, String, Int64, Bool, Bool}, handle::Downloads.Curl.Easy)\n    @ Downloads.Curl /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Curl/Curl.jl:64\n  [3] #8\n    @ /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Downloads.jl:311 [inlined]                                                                                              \n  [4] arg_write(f::Downloads.var""""#8#17""""{Base.DevNull, Nothing, Vector{Pair{String, String}}, Float64, Downloads.var""""#24#27""""{Pkg.PlatformEngines.var""""#15#17""""{Base.TTY}}, Bool, Bool, String, Int64, Bool, Bool}, arg::IOStream)\n    @ ArgTools /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/ArgTools/src/ArgTools.jl:112\n  [5] #7\n    @ /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Downloads.jl:310 [inlined]                                                                                              \n  [6] arg_read(f::Downloads.var""""#7#16""""{IOStream, Nothing, Vector{Pair{String, String}}, Float64, Downloads.var""""#24#27""""{Pkg.PlatformEngines.var""""#15#17""""{Base.TTY}}, Bool, Bool, String, Int64, Bool, Bool}, arg::Base.DevNull)\n    @ ArgTools /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/ArgTools/src/ArgTools.jl:61\n  [7] request(url::String; input::Nothing, output::IOStream, method::Nothing, headers::Vector{Pair{String, String}}, timeout::Float64, progress::Pkg.PlatformEngines.var""""#15#17""""{Base.TTY}, verbose::Bool, throw::Bool, downloader::Nothing)\n    @ Downloads /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Downloads.jl:309\n  [8] #3\n    @ /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Downloads.jl:222 [inlined]\n  [9] open(f::Downloads.var""""#3#4""""{Nothing, Vector{Pair{String, String}}, Float64, Pkg.PlatformEngines.var""""#15#17""""{Base.TTY}, Bool, Nothing, String}, args::String; kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:write,), Tuple{Bool}}})\n    @ Base ./io.jl:330\n [10] arg_write(f::Function, arg::String)\n    @ ArgTools /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/ArgTools/src/ArgTools.jl:86\n [11] #download#2\n    @ /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Downloads/src/Downloads.jl:221 [inlined]\n [12] download(url::String, dest::String; verbose::Bool, headers::Vector{Pair{String, String}}, auth_header::Nothing, io::Base.TTY)\n    @ Pkg.PlatformEngines /.../julia/1.7.2/gcc-8.4.1-cm7wsviyfhc6wxkwmx6dpkkabzqxaer4/share/julia/stdlib/v1.7/Pkg/src/PlatformEngines.jl:282\n [13] (::DebugArtifacts.var""""#3#4""""{String, Base.BinaryPlatforms.Platform, String})(tmp_dir::String)\n    @ DebugArtifacts ~/.julia/packages/DebugArtifacts/2VJet/src/DebugArtifacts.jl:67\n [14] mktempdir(fn::DebugArtifacts.var""""#3#4""""{String, Base.BinaryPlatforms.Platform, String}, parent::String; prefix::String)\n    @ Base.Filesystem ./file.jl:750\n [15] mktempdir (repeats 2 times)\n    @ ./file.jl:748 [inlined]\n [16] debug_artifact(artifact_name::String, platform::Base.BinaryPlatforms.Platform)\n    @ DebugArtifacts ~/.julia/packages/DebugArtifacts/2VJet/src/DebugArtifacts.jl:55\n [17] debug_artifact(artifact_name::String)\n    @ DebugArtifacts ~/.julia/packages/DebugArtifacts/2VJet/src/DebugArtifacts.jl:43\n [18] top-level scope\n    @ REPL[2]:1\n```\n\nInterestingly enough, the problem only seems to occur when there is a redirection, for example `https://raw.githubusercontent.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/master/Artifacts.toml` works but not `https://github.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/releases/download/ZeroMQ-v4.3.2+4/ZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz`.\n\nDownloading from the same URL with wget or curl works fine:\n```\n$ wget -O /dev/null https://github.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/releases/download/ZeroMQ-v4.3.2+4/ZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz\n--2022-03-28 16:49:22--  https://github.com/JuliaBinaryWrappers/ZeroMQ_jll.jl/releases/download/ZeroMQ-v4.3.2+4/ZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz\nResolving proxy (proxy)... XXX.XXX.14.21, XXX.XXX.14.20, XXX.XXX.14.18, ...\nConnecting to proxy (proxy)|XXX.XXX.14.21|:3128... connected.\nProxy request sent, awaiting response... 302 Found\nLocation: https://objects.githubusercontent.com/github-production-release-asset-2e65be/214035989/bb04eb80-a885-11ea-89b6-70f9574c1bda?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220328%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20220328T144922Z&X-Amz-Expires=300&X-Amz-Signature=f11d01c970947f64d2d36be1d3521ef68713be0ed133c5235c1c6513f45c2d7c&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=214035989&response-content-disposition=attachment%3B%20filename%3DZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz&response-content-type=application%2Foctet-stream [following]\n--2022-03-28 16:49:22--  https://objects.githubusercontent.com/github-production-release-asset-2e65be/214035989/bb04eb80-a885-11ea-89b6-70f9574c1bda?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220328%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20220328T144922Z&X-Amz-Expires=300&X-Amz-Signature=f11d01c970947f64d2d36be1d3521ef68713be0ed133c5235c1c6513f45c2d7c&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=214035989&response-content-disposition=attachment%3B%20filename%3DZeroMQ.v4.3.2.x86_64-linux-gnu-cxx11.tar.gz&response-content-type=application%2Foctet-stream\nConnecting to proxy (proxy)|XXX.XXX.14.21|:3128... connected.\nProxy request sent, awaiting response... 200 OK\nLength: 336779 (329K) [application/octet-stream]\nSaving to: ‘/dev/null’\n\n/dev/null                       100%[=======================================================>] 328,89K  --.-KB/s    in 0,004s  \n\n2022-03-28 16:49:22 (83,7 MB/s) - ‘/dev/null’ saved [336779/336779]\n```\n\nDo you have any idea of what would cause such behavior?\n\nBest regards,\nRémi",,0,false,5,5,0,0,0,0,0,0,0
3032,"Feature Request: Given a `Project.toml`, generate a `Manifest.toml` without actually instantiating the project",open,thazhemadam,,,,1,2022-03-18T06:34:14.0,2022-03-18T12:33:51.0,1220,1220,https://github.com/JuliaLang/Pkg.jl/issues/3032,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3032,"Sometimes, given just a `Project.toml`, you want to generate a corresponding `Manifest.toml` without actually instantiating the project, i.e., installing all the packages and downloading the respective artifacts (if any).\n\nIt would be nice if there was an interface that allowed this functionality.\n",[thazhemadam]: This seems related - https://github.com/JuliaLang/Pkg.jl/pull/2504.\n,1,false,0,0,0,0,0,0,0,0,0
3026,Feature request: `Pkg.precompile(; throw_error = true)`,open,DilumAluthge,,,,0,2022-03-11T15:09:22.0,2022-03-11T15:09:22.0,1227,1227,https://github.com/JuliaLang/Pkg.jl/issues/3026,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3026,"Currently, if I do `julia -e 'import Pkg; Pkg.precompile()'`, if one or more of the packages in my manifest fails to precompile, the Julia process will still exit with exit code zero.\n\nI'd like to have the ability to do something like `Pkg.precompile(; throw_error = true)`, in which case if one or more of the packages in my manifest fails to precompile, the `Pkg.precompile` function will throw an exception, and thus the Julia process will exit with nonzero exit code.",,0,false,0,0,0,0,0,0,0,0,0
3019,Proposal: warn (at least) on activation of a project made with a different Julia version,open,sylvaticus,,,,1,2022-03-08T09:10:06.0,2022-03-08T11:59:58.0,1230,1230,https://github.com/JuliaLang/Pkg.jl/issues/3019,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3019,"Making an issue here as suggested on the [discourse thread](https://discourse.julialang.org/t/julia-shoudnt-silently-activate-a-project-associated-to-a-previous-julia-version/77480).\n\nThe idea is that now Manifest holds the information on the Julia version itself but """"ignores"""" this information if activating the environment from another Julia version.\nWhile it is true that it does issue a warning in instantiating it, sometimes you don't need to instantiate.\nFor example, I did start a new environment in Julia 1.7, add DataFrames and then activated it from Julia 1.8 beta, I had no warning. Yes, the package I were using were the same, but Julia wasn't, and I think this breaks the promise of replicability of Manifest.toml. \n\nAn option could always be added to `activate` NOT to warn/error in such cases (eg `strict = false`)...\n",[KristofferC]: One issue is when running with `--project=...` in that case no Pkg code is run. So to also catch that you would need to implement this in Base.,1,false,0,0,0,0,0,0,0,0,0
3012,Julia v1.8.0-beta1 shows outdated packages but does not update them,open,ranocha,,,,11,2022-03-02T12:56:09.0,2022-03-04T12:16:06.0,1236,1234,https://github.com/JuliaLang/Pkg.jl/issues/3012,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3012,"Here's what I get:\n```julia\njulia> versioninfo()\nJulia Version 1.8.0-beta1\nCommit 7b711ce699 (2022-02-23 15:09 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 12 × Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, skylake)\n  Threads: 1 on 12 virtual cores\nEnvironment:\n  LD_LIBRARY_PATH = :/usr/local/lib\n  JULIA_NUM_THREADS = 1\n  JULIA_EDITOR = code\n\njulia> using Pkg; Pkg.activate(temp=true)\n  Activating new project at `/tmp/jl_mf0QGH`\n\njulia> Pkg.add([""""Trixi"""", """"LoopVectorization""""])\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n    Updating `/tmp/jl_mf0QGH/Project.toml`\n⌃ [bdcacae8] + LoopVectorization v0.12.101\n  [a7f1ee26] + Trixi v0.4.23\n    Updating `/tmp/jl_mf0QGH/Manifest.toml`\n  [621f4979] + AbstractFFTs v1.1.0\n  [79e6a3ab] + Adapt v3.3.3\n  [dce04be8] + ArgCheck v2.3.0\n⌅ [4fba245c] + ArrayInterface v3.2.2\n  [4c555306] + ArrayLayouts v0.7.10\n  [b99e7846] + BinaryProvider v0.5.10\n  [62783981] + BitTwiddlingConvenienceFunctions v0.1.3\n⌅ [d43a6710] + CBinding v0.9.4\n  [2a0fbf3d] + CPUSummary v0.1.8\n  [d360d2e6] + ChainRulesCore v1.13.0\n  [9e997f8a] + ChangesOfVariables v0.1.2\n  [fb6a15b2] + CloseOpenIntervals v0.1.5\n  [da1fd8a2] + CodeTracking v1.0.7\n  [35d6a980] + ColorSchemes v3.17.1\n  [3da002f7] + ColorTypes v0.11.0\n  [5ae59095] + Colors v0.12.8\n  [38540f10] + CommonSolve v0.2.0\n  [bbf7d656] + CommonSubexpressions v0.3.0\n  [34da2185] + Compat v3.41.0\n  [187b0558] + ConstructionBase v1.3.0\n  [587fd27a] + CovarianceEstimation v0.2.7\n  [717857b8] + DSP v0.7.5\n  [9a962f9c] + DataAPI v1.9.0\n  [864edb3b] + DataStructures v0.18.11\n  [e2d170a0] + DataValueInterfaces v1.0.0\n  [163ba53b] + DiffResults v1.0.3\n  [b552c78f] + DiffRules v1.10.0\n  [ffbed154] + DocStringExtensions v0.8.6\n  [da5c29d0] + EllipsisNotation v1.3.0\n  [e2ba6199] + ExprTools v0.1.8\n  [7a1cc6ca] + FFTW v1.4.6\n  [442a2c76] + FastGaussQuadrature v0.4.9\n  [057dd010] + FastTransforms v0.13.6\n  [1a297f60] + FillArrays v0.13.0\n  [53c48c17] + FixedPointNumbers v0.8.4\n  [f6369f11] + ForwardDiff v0.10.25\n  [5c1252a2] + GeometryBasics v0.4.1\n  [f67ccb44] + HDF5 v0.16.2\n  [3e5b6fbb] + HostCPUFeatures v0.1.6\n  [0e44f5e4] + Hwloc v2.0.0\n  [615f187c] + IfElse v0.1.1\n  [3587e190] + InverseFunctions v0.1.2\n  [92d709cd] + IrrationalConstants v0.1.1\n  [c8e1da08] + IterTools v1.4.0\n  [82899510] + IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] + JLLWrappers v1.4.1\n  [2c470bb0] + Kronecker v0.5.1\n  [10f19ff3] + LayoutPointers v0.1.5\n  [7a12625a] + LinearMaps v3.5.1\n  [2ab3a3ac] + LogExpFunctions v0.3.6\n⌃ [bdcacae8] + LoopVectorization v0.12.101\n  [da04e1cc] + MPI v0.19.2\n  [1914dd2f] + MacroTools v0.5.9\n  [d125e4d3] + ManualMemory v0.1.8\n  [e1d29d7a] + Missings v1.0.2\n  [46d2c3a1] + MuladdMacro v0.2.2\n  [d8a4904e] + MutableArithmetics v1.0.0\n⌅ [77ba4419] + NaNMath v0.3.7\n  [356022a1] + NamedDims v0.2.46\n  [7aca2e03] + NodesAndModes v0.7.1\n  [6fd5a793] + Octavian v0.3.12\n  [6fe1bfb0] + OffsetArrays v1.10.8\n  [bac558e1] + OrderedCollections v1.4.1\n  [7d669430] + P4est v0.3.0\n  [995b91a9] + PlotUtils v1.1.3\n⌃ [f517fe37] + Polyester v0.6.4\n  [1d0040c9] + PolyesterWeave v0.1.4\n  [c74db56a] + PolynomialBases v0.4.11\n  [f27b6e38] + Polynomials v3.0.0\n  [21216c6a] + Preferences v1.2.4\n  [3cdcf5f2] + RecipesBase v1.2.1\n  [731186ca] + RecursiveArrayTools v2.24.2\n  [189a3867] + Reexport v1.2.2\n  [ae029012] + Requires v1.3.0\n  [3cdde19b] + SIMDDualNumbers v0.1.0\n  [94e857df] + SIMDTypes v0.1.0\n  [476501e8] + SLEEFPirates v0.6.30\n  [0bca4576] + SciMLBase v1.26.3\n  [efcf1570] + Setfield v0.8.2\n  [a2af1166] + SortingAlgorithms v1.0.1\n  [276daf66] + SpecialFunctions v2.1.4\n  [472ebc20] + StartUpDG v0.12.6\n⌅ [aedffcd0] + Static v0.4.1\n  [90137ffa] + StaticArrays v1.4.1\n  [82ae8749] + StatsAPI v1.2.1\n  [2913bbd2] + StatsBase v0.33.16\n  [d1fa6d79] + StrideArrays v0.1.15\n  [7792a7ef] + StrideArraysCore v0.2.12\n  [09ab397b] + StructArrays v0.6.5\n  [9f78cca6] + SummationByPartsOperators v0.5.13\n  [3783bdb8] + TableTraits v1.0.1\n  [bd369af6] + Tables v1.6.1\n⌅ [8290d209] + ThreadingUtilities v0.4.7\n  [a759f4b9] + TimerOutputs v0.5.15\n  [c751599d] + ToeplitzMatrices v0.7.0\n  [a2a6695c] + TreeViews v0.3.0\n  [f7e6ffb2] + Triangulate v2.1.2\n  [981d1d27] + TriplotBase v0.1.0\n  [808ab39a] + TriplotRecipes v0.1.0\n  [a7f1ee26] + Trixi v0.4.23\n  [3a884ed6] + UnPack v1.0.2\n  [9602ed7d] + Unrolled v0.1.3\n  [3d5dd08c] + VectorizationBase v0.21.24\n  [33b4df10] + VectorizedRNG v0.2.14\n  [700de1a5] + ZygoteRules v0.2.2\n  [5ae413db] + EarCut_jll v2.2.3+0\n  [f5851436] + FFTW_jll v3.3.10+0\n  [34b6f7d7] + FastTransforms_jll v0.5.4+0\n  [0234f1f7] + HDF5_jll v1.12.1+0\n  [e33a78d0] + Hwloc_jll v2.7.0+0\n  [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2\n  [856f044c] + MKL_jll v2022.0.0+0\n  [7cb0a576] + MPICH_jll v4.0.1+0\n  [9237b28f] + MicrosoftMPI_jll v10.1.3+2\n  [fe0851c0] + OpenMPI_jll v4.1.2+0\n  [458c3c95] + OpenSSL_jll v1.1.13+0\n  [efe28fd5] + OpenSpecFun_jll v0.5.5+0\n  [6b5a15aa] + P4est_jll v2.8.0+0\n  [5639c1d2] + Triangle_jll v1.6.1+0\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [8bb1440f] + DelimitedFiles\n  [8ba89e20] + Distributed\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching\n  [9fa8497b] + Future\n  [b77e0a4c] + InteractiveUtils\n  [4af54fe1] + LazyArtifacts\n  [b27032c2] + LibCURL v0.6.3\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [37e2e46d] + LinearAlgebra\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [a63ad114] + Mmap\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.8.0\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\n  [1a1011a3] + SharedArrays\n  [6462fe0b] + Sockets\n  [2f01184e] + SparseArrays\n  [10745b16] + Statistics\n  [fa267f1f] + TOML v1.0.0\n  [a4e569a6] + Tar v1.10.0\n  [8dfed614] + Test\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [e66e0078] + CompilerSupportLibraries_jll v0.5.0+0\n  [781609d7] + GMP_jll v6.2.1+1\n  [deac9b47] + LibCURL_jll v7.81.0+0\n  [29816b5a] + LibSSH2_jll v1.10.2+0\n  [3a97d323] + MPFR_jll v4.1.1+1\n  [c8ffd9c3] + MbedTLS_jll v2.28.0+0\n  [14a3606d] + MozillaCACerts_jll v2022.2.1\n  [4536629a] + OpenBLAS_jll v0.3.17+2\n  [05823500] + OpenLibm_jll v0.8.1+0\n  [83775a58] + Zlib_jll v1.2.12+1\n  [8e850b90] + libblastrampoline_jll v5.0.1+0\n  [8e850ede] + nghttp2_jll v1.41.0+1\n  [3f19e933] + p7zip_jll v16.2.1+1\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`\n\njulia> Pkg.status()\nStatus `/tmp/jl_mf0QGH/Project.toml`\n⌃ [bdcacae8] LoopVectorization v0.12.101\n  [a7f1ee26] Trixi v0.4.23\nInfo Packages marked with ⌃ have new versions available\n\njulia> Pkg.update()\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `/tmp/jl_mf0QGH/Project.toml`\n  No Changes to `/tmp/jl_mf0QGH/Manifest.toml`\n\njulia> Pkg.status()\nStatus `/tmp/jl_mf0QGH/Project.toml`\n⌃ [bdcacae8] LoopVectorization v0.12.101\n  [a7f1ee26] Trixi v0.4.23\nInfo Packages marked with ⌃ have new versions available\n\njulia> Pkg.update(""""LoopVectorization"""")\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `/tmp/jl_mf0QGH/Project.toml`\n  No Changes to `/tmp/jl_mf0QGH/Manifest.toml`\n\njulia> Pkg.status()\nStatus `/tmp/jl_mf0QGH/Project.toml`\n⌃ [bdcacae8] LoopVectorization v0.12.101\n  [a7f1ee26] Trixi v0.4.23\nInfo Packages marked with ⌃ have new versions available\n```\n\nThe output of `Pkg.status()` shows that there is a newer version of LoopVectorization.jl but it does not update it. \n\nIf I activate a new environment and install only LoopVectorization.jl, everything is fine:\n```julia\njulia> Pkg.activate(temp=true)\n  Activating new project at `/tmp/jl_xsHKgI`\n\njulia> Pkg.add(""""LoopVectorization"""")\n   Resolving package versions...\n    Updating `/tmp/jl_xsHKgI/Project.toml`\n  [bdcacae8] + LoopVectorization v0.12.102\n    Updating `/tmp/jl_xsHKgI/Manifest.toml`\n  [79e6a3ab] + Adapt v3.3.3\n⌅ [4fba245c] + ArrayInterface v3.2.2\n  [62783981] + BitTwiddlingConvenienceFunctions v0.1.3\n  [2a0fbf3d] + CPUSummary v0.1.8\n  [d360d2e6] + ChainRulesCore v1.13.0\n  [9e997f8a] + ChangesOfVariables v0.1.2\n  [fb6a15b2] + CloseOpenIntervals v0.1.5\n  [bbf7d656] + CommonSubexpressions v0.3.0\n  [34da2185] + Compat v3.41.0\n  [163ba53b] + DiffResults v1.0.3\n  [b552c78f] + DiffRules v1.10.0\n  [ffbed154] + DocStringExtensions v0.8.6\n  [f6369f11] + ForwardDiff v0.10.25\n  [3e5b6fbb] + HostCPUFeatures v0.1.6\n  [0e44f5e4] + Hwloc v2.0.0\n  [615f187c] + IfElse v0.1.1\n  [3587e190] + InverseFunctions v0.1.2\n  [92d709cd] + IrrationalConstants v0.1.1\n  [692b3bcd] + JLLWrappers v1.4.1\n  [10f19ff3] + LayoutPointers v0.1.5\n  [2ab3a3ac] + LogExpFunctions v0.3.6\n  [bdcacae8] + LoopVectorization v0.12.102\n  [1914dd2f] + MacroTools v0.5.9\n  [d125e4d3] + ManualMemory v0.1.8\n⌅ [77ba4419] + NaNMath v0.3.7\n  [6fe1bfb0] + OffsetArrays v1.10.8\n  [1d0040c9] + PolyesterWeave v0.1.4\n  [21216c6a] + Preferences v1.2.4\n  [ae029012] + Requires v1.3.0\n  [3cdde19b] + SIMDDualNumbers v0.1.0\n  [94e857df] + SIMDTypes v0.1.0\n  [476501e8] + SLEEFPirates v0.6.30\n  [276daf66] + SpecialFunctions v2.1.4\n⌅ [aedffcd0] + Static v0.4.1\n  [90137ffa] + StaticArrays v1.4.1\n  [8290d209] + ThreadingUtilities v0.5.0\n  [3a884ed6] + UnPack v1.0.2\n  [3d5dd08c] + VectorizationBase v0.21.24\n  [e33a78d0] + Hwloc_jll v2.7.0+0\n  [efe28fd5] + OpenSpecFun_jll v0.5.5+0\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [8bb1440f] + DelimitedFiles\n  [8ba89e20] + Distributed\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL v0.6.3\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [37e2e46d] + LinearAlgebra\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [a63ad114] + Mmap\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.8.0\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\n  [1a1011a3] + SharedArrays\n  [6462fe0b] + Sockets\n  [2f01184e] + SparseArrays\n  [10745b16] + Statistics\n  [fa267f1f] + TOML v1.0.0\n  [a4e569a6] + Tar v1.10.0\n  [8dfed614] + Test\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [e66e0078] + CompilerSupportLibraries_jll v0.5.0+0\n  [deac9b47] + LibCURL_jll v7.81.0+0\n  [29816b5a] + LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] + MbedTLS_jll v2.28.0+0\n  [14a3606d] + MozillaCACerts_jll v2022.2.1\n  [4536629a] + OpenBLAS_jll v0.3.17+2\n  [05823500] + OpenLibm_jll v0.8.1+0\n  [83775a58] + Zlib_jll v1.2.12+1\n  [8e850b90] + libblastrampoline_jll v5.0.1+0\n  [8e850ede] + nghttp2_jll v1.41.0+1\n  [3f19e933] + p7zip_jll v16.2.1+1\n        Info Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated`\n\njulia> Pkg.status()\nStatus `/tmp/jl_xsHKgI/Project.toml`\n  [bdcacae8] LoopVectorization v0.12.102\n```\n","[KristofferC]: Just because there is nothing holding back a package doesn't mean that `up` will update it. That is because updating the package might cause other packages to downgrade. My guess is that if you write `pkg> add LoopVectorization@0.12.102` in the original environment, it will happily install, but some other package will downgrade because of it.\n\nIn those cases, if you specifically want a version of some package you either need to add it by version (like shown above) or use the `[compat]` entry in the project file.\n\n\n | [ranocha]: Right, `pkg> add LoopVectorization@0.12.102` downgrades other packages. Maybe it would be good to add a note to the info line\n```\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`\n```\nFor me, it was at least a bit confusing to see that Pkg tells me there are new versions but refuses to `update` them easily. Maybe something along the lines of\n\n```\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`. Note that not all packages with new versions (⌃) will be updated if this would downgrade other dependencies.\n``` | [IanButterworth]: I wonder if what's needed is something like\n```\npkg> up\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `/tmp/jl_mf0QGH/Project.toml`\n  No Changes to `/tmp/jl_mf0QGH/Manifest.toml`\n\npkg> up LoopVectorization\n    Updating registry at `~/.julia/registries/General.toml`\n  No Changes to `/tmp/jl_mf0QGH/Project.toml`\n  No Changes to `/tmp/jl_mf0QGH/Manifest.toml`\n Info There is a newer version of LoopVectorization available, but at a cost of downgrading an unbalanced number of packages.\n      Use `pkg> add LoopVectorization@0.12.102` to force installation.\n``` \n\ni.e. the extra info is only given when an explicit package `up` is requested | [ranocha]: That would be even better :+1: | [DilumAluthge]: > I wonder if what's needed is something like\n> \n> ```\n> pkg> up\n>     Updating registry at `~/.julia/registries/General.toml`\n>   No Changes to `/tmp/jl_mf0QGH/Project.toml`\n>   No Changes to `/tmp/jl_mf0QGH/Manifest.toml`\n> \n> pkg> up LoopVectorization\n>     Updating registry at `~/.julia/registries/General.toml`\n>   No Changes to `/tmp/jl_mf0QGH/Project.toml`\n>   No Changes to `/tmp/jl_mf0QGH/Manifest.toml`\n>  Info There is a newer version of LoopVectorization available, but at a cost of downgrading an unbalanced number of packages.\n>       Use `pkg> add LoopVectorization@0.12.102` to force installation.\n> ```\n> \n> i.e. the extra info is only given when an explicit package `up` is requested\n\nI disagree with this. If this change is made, then:\n1. User does `] up`.\n2. User assumes that all of their direct dependencies are at the latest version.\n3. User is surprised when this assumption is false.\n\nWe routinely see users on Discourse that assume that doing `] up` will update all of their direct dependencies are at the latest version.\n\nI think that if `] up` results in one or more direct dependencies that are not at the latest version, we should always print a warning, regardless of the specific reason why the dependency is not at the latest version. | [ranocha]: I have been using Julia for many years. I know that I will not necessarily get the newest versions of all direct dependencies - since upgrading some of them may downgrade other packages. However, the new sign indicating that a direct dependency can be upgraded confused me quite a bit. So I agree with @DilumAluthge - it will probably avoid confusion if such warnings are shown. Another related option might be to introduce a third symbol indicating packages that have new versions that could be installed (so not `⌅` with its current meaning) but will not be installed since that would downgrade other packages. | [timholy]: Can you make a specific suggestion for what that symbol would be? (It's often quite hard to come up with candidates.)\n\nAnd what would ⌅ now do? You can *always* install the latest version of a package in isolation, it's only incompatibilities with other packages that prevent it. So I'm not sure what this new category really means. | [ranocha]: That's the problem - I also do not really have a good suggestion, sorry. \n1. One option may be to also use ⌅ for packages with newer versions that will not be installed by `] up` because other packages would be downgraded. That would be totally fine in my opinion. In this case, it would be good to add a warning as described by @DilumAluthge [above](https://github.com/JuliaLang/Pkg.jl/issues/3012#issuecomment-1058418975)\n2. Another option may be to use \n   - ⌅ for packages with newer versions that will not be installed by `] up` because other packages would be downgraded, i.e., a *soft* reason for keeping an old version (""""I do not want to do this"""")\n   - ⌆ for packages with newer versions that will not be installed by `] up` because of version conflicts etc. (basically the current meaning of ⌅?), i.e., a *hard* reason for keeping an old version (""""I really cannot do this"""")\n | [timholy]: How about my second point? I don't understand what the new symbol means that's actually different from `⌅`? What is a """"version conflict""""? Do you mean just with Julia itself? That's the only """"hard"""" conflict there is; all other version numbers are negotiable. | [KristofferC]: I think a good compromise is that after `up` and there are packages that are still not at the latest version to show something (but maybe a bit terser) as in https://github.com/JuliaLang/Pkg.jl/issues/3012#issuecomment-1056951812. | [ranocha]: > How about my second point? I don't understand what the new symbol means that's actually different from `⌅`? What is a """"version conflict""""? Do you mean just with Julia itself? That's the only """"hard"""" conflict there is; all other version numbers are negotiable.\n\nMy first guess after reading the (not really concrete) statement\n\n> those with ⌅ cannot be upgraded\n\nwas that there are probably some version conflicts preventing an upgrade because of explicit compat bounds of the project or other dependencies, e.g.,\n- `Project.toml` restricts package A to version v0.3 but v0.4 is available\n- `Project.toml` requires packages A and B; package A restricts package B to v0.3 but v0.4 is available\n\nIn the end, my point is that\n\n> Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded.\n\nsounds to me like those package with ⌃ can be upgraded (with `] up`). Any additional hint that this is not the case would be helpful, I think. (At least it would have prevented me from opening this issue and wasting your time - sorry for that and thanks to everybody implementing great stuff in Julia :slightly_smiling_face:).",11,false,0,0,0,0,0,0,0,0,0
3005,Docs for `up` is wrong,open,KristofferC,,,,0,2022-02-25T08:34:25.0,2022-02-25T08:34:59.0,1241,1241,https://github.com/JuliaLang/Pkg.jl/issues/3005,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/3005,"From the docs\n\n> If no positional argument is given, update all packages in the manifest if `mode` is `PKGMODE_MANIFEST` and packages in both manifest and project if `mode` is `PKGMODE_PROJECT`.\n\nThis doesn't really make sense because packages in the project is also in the manifest. And `up -m` also updates packages that are in the project:\n\n```jl\n(jl_xPuOsW) pkg> up -m\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `/tmp/jl_xPuOsW/Project.toml`\n  [91a5bcdd] ↑ Plots v1.25.3 ⇒ v1.25.11\n    Updating `/tmp/jl_xPuOsW/Manifest.toml`\n  [28b8d3ca] ↑ GR v0.62.1 ⇒ v0.64.0\n...\n```\n\n-------------\n\nFrom the REPL doc on `up`:\n\n> Update `pkg` within the constraints of the indicated version\nspecifications. These specifications are of the form `@1`, `@1.2` or `@1.2.3`, allowing\nany version with a prefix that matches, or ranges thereof, such as `@1.2-3.4.5`.\n\n```jl\n(jl_C8ktCX) pkg> up Plots@1.25.3\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `/tmp/jl_C8ktCX/Project.toml`\n  [91a5bcdd] ↑ Plots v1.25.3 ⇒ v1.25.11\n...\n```\n\n`@` does nothing.\n\nIt is also a bit strange that the docs for the API mode and REPL mode are so different.",,0,false,0,0,0,0,0,0,0,0,0
2981,Documentation for `Pkg.resolve` is very terse. Ok for this PR?,open,reumle,,,,1,2022-02-12T14:27:00.0,2022-02-12T14:56:43.0,1254,1254,https://github.com/JuliaLang/Pkg.jl/issues/2981,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2981,"Here it is. \n```\nPkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n```\n\nI suggest to add this, which is 90% a quote of another part of Pkg's documentation. It would then read:\n```\nPkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n\nUsually runs automatically when you add a package to your environment, eg with `Pkg.add(NAME_OF_PACKAGE_I_NEED )`\nNote that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To synchronize the Manifest, use the REPL command resolve.\n```\nHappy to do a small PR with this if considered correct.\n",[fredrikekre]: Feel free to open a PR. It is usually easier to discuss the wording at the PR itself.,1,false,0,0,0,0,0,0,0,0,0
2978,Add warning in case of a single registry thats not the General registry,open,laborg,,registries; display and printing; error handling,,1,2022-02-09T08:07:34.0,2022-02-09T18:59:57.0,1257,1256,https://github.com/JuliaLang/Pkg.jl/issues/2978,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2978,"Hi, \n\nWhen using a local registry without having installed any package from the General registry first, adding packages will fail with `Cannot find name corresponding to UUID`, as reported here: https://github.com/GunnarFarneback/LocalRegistry.jl/issues/46 \n\nIt would be great to show a special warning if a package can't be found and there is only one registry available which isn't the General registry: `Cannot find name for corresponding UUID; You might need to add the """"General"""" registry with ]registry add General`\n\n",[laborg]: From Slack:\n> [Gunnar Farnebäck]  I'm not sure exactly one registry is an interesting case. It should be fine to suggest adding General whenever a package can't be found and General is not installed.\n\n> [Kristoffer Carlsson] Yes,1,false,0,0,0,0,0,0,0,0,0
2977,Inspecting nested exceptions from download errors,open,staticfloat,,,,0,2022-02-08T23:20:49.0,2022-02-08T23:20:58.0,1257,1257,https://github.com/JuliaLang/Pkg.jl/issues/2977,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2977,"@vtjnash and I recently debugged an issue on Windows that boiled down to two things:\n\n- `Tar.jl` was failing to extract a file because it exceeded the maximum path length on Windows.\n- This caused `7zip` (whose output we were piping to `Tar`) to exit uncleanly, and because [we didn't wait for it to fully finish](https://github.com/JuliaLang/julia/pull/44078), we ended up throwing an exception upon [trying to `unlink()` the tarball after a failed extraction](https://github.com/JuliaLang/Pkg.jl/blob/c991ce0a31b784133e061816d21f7d2556a182e7/src/PlatformEngines.jl#L521).\n\nI'm quite enthused by the recent improvements to error logging, but in this case, we got a bit of a false flag; the fundamental issue was a `SystemError` being thrown by `Tar`, but since that error then caused a second error within a `finally` block, when we [print out the error for the user](https://github.com/JuliaLang/Pkg.jl/blob/8951735530483d34d60544b80b6775c4063bffa2/src/Artifacts.jl#L462), we only print a summary of the most recent error.  I think this is the right thing to do normally, (since I don't want to see a full stack trace in general) but I think it would be really nice if we could somehow persist the full exception object for later inspection.\n\nMost exceptions in the Julia world are treated as something that should either break execution, or be handled and completely ignored.  We don't really have that many exceptions that could live in the grey area of """"something went wrong, but I will try to continue"""".  In this case, I feel some way of inspecting what went wrong is important.  Perhaps a `Vector{Exception}` that gets cleared out every time you invoke a new Pkg operation, but which can be inspected to see what happened within the last time you invoked a Pkg operation.  Doing so would feel very ad-hoc, but I'm not sure what the fully general case for this is.",,0,false,0,0,0,0,0,0,0,0,0
2958,a suggestion/bug to pkg install,open,yanyu2015,,,,0,2022-01-12T05:06:47.0,2022-01-26T15:07:52.0,1285,1271,https://github.com/JuliaLang/Pkg.jl/issues/2958,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2958,"my julia version is 1.7，system is win 10\nsometimes some pkgs(for example, `MKL` `fileIO` ), it doesn't install successfully.So we need to remove it and reinstall, however, when using pkg it may report error as：\n```\n[ Info: Precompiling MKL [33e6dc65-8f57-5167-99aa-e5a354878fb2]\nERROR: LoadError: InitError: could not load library """"C:\Users\xuanQS\.julia\artifacts\28c8373199bf79bd94ce76e3f45eeaef6d9c1c47\bin\mkl_core.1.dll""""\nThe specified module could not be found\n```\n[this link](https://stackoverflow.com/questions/63230504/loaderror-initerror-while-precompiling-in-new-environment) provides a solution.\nso can the julia official do this solution automatically？It may solve lots of problems with failed package installs.\n\n\n",,0,false,0,0,0,0,0,0,0,0,0
2779,Unable to add private registry,open,fcdimitr,,,,7,2021-10-17T15:34:56.0,2022-01-14T14:28:53.0,1371,1283,https://github.com/JuliaLang/Pkg.jl/issues/2779,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2779,"We are unable to add a private GitHub registry, specifically,\n\n```julia\nregistry add git@github.com:user/PrivateRegistry.git\n```\n\nfails with the following trace.\n\n```\n Cloning registry from “git@github.com:user/PrivateRegistry.git”\nERROR: BoundsError: attempt to access 1024-element Vector{UInt8} at index [0x0000000000000001:0x00007ff934e138e0]\nStacktrace:\n [1] throw_boundserror(A::Vector{UInt8}, I::Tuple{UnitRange{UInt64}})\n  @ Base ./abstractarray.jl:651\n [2] checkbounds\n  @ ./abstractarray.jl:616 [inlined]\n [3] _getindex\n  @ ./multidimensional.jl:831 [inlined]\n [4] getindex\n  @ ./abstractarray.jl:1170 [inlined]\n [5] ssh_knownhost_check\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/LibGit2/src/callbacks.jl:436 [inlined]\n [6] certificate_callback(cert_p::Ptr{LibGit2.CertHostKey}, valid::Int32, host_p::Ptr{Int8}, data_p::Ptr{Nothing})\n  @ LibGit2 /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/LibGit2/src/callbacks.jl:401\n [7] macro expansion\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/LibGit2/src/error.jl:108 [inlined]\n [8] clone(repo_url::SubString{String}, repo_path::String, clone_opts::LibGit2.CloneOptions)\n  @ LibGit2 /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/LibGit2/src/repository.jl:459\n [9] clone(repo_url::SubString{String}, repo_path::String; branch::String, isbare::Bool, remote_cb::Ptr{Nothing}, credentials::LibGit2.CachedCredentials, callbacks::Dict{Symbol, Tuple{Ptr{Nothing}, Any}})\n  @ LibGit2 /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/LibGit2/src/LibGit2.jl:583\n [10] clone(ctx::Pkg.Types.Context, url::String, source_path::String; header::String, credentials::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n  @ Pkg.GitTools /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/GitTools.jl:109\n [11] (::Pkg.Types.var”#82#85""""{Pkg.Types.Context, String, Pkg.Types.RegistrySpec})(tmp::String)\n  @ Pkg.Types /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:1048\n [12] mktempdir(fn::Pkg.Types.var”#82#85""""{Pkg.Types.Context, String, Pkg.Types.RegistrySpec}, parent::String; prefix::String)\n  @ Base.Filesystem ./file.jl:729\n [13] mktempdir (repeats 2 times)\n  @ ./file.jl:727 [inlined]\n [14] clone_or_cp_registries(ctx::Pkg.Types.Context, regs::Vector{Pkg.Types.RegistrySpec}, depot::String)\n  @ Pkg.Types /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:1027\n [15] clone_or_cp_registries\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:1020 [inlined]\n [16] #add#6\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Registry.jl:32 [inlined]\n [17] add\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Registry.jl:28 [inlined]\n [18] #add#5\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Registry.jl:26 [inlined]\n [19] add(regs::Vector{Pkg.Types.RegistrySpec})\n  @ Pkg.Registry /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/Registry.jl:26\n [20] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n  @ Pkg.REPLMode /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:408\n [21] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n  @ Pkg.REPLMode /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386\n [22] do_cmd\n  @ /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]\n [23] (::Pkg.REPLMode.var”#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n  @ Pkg.REPLMode /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550\n [24] #invokelatest#2\n  @ ./essentials.jl:708 [inlined]\n [25] invokelatest\n  @ ./essentials.jl:706 [inlined]\n [26] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n  @ REPL.LineEdit /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441\n [27] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n  @ REPL /private/tmp/julia-20210929-79571-nlx62p/julia-1.6.3/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126\n [28] (::REPL.var”#44#49""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n  @ REPL ./task.jl:411\n```\nWe have verified that the command\n\n```\ngit clone git@github.com:user/PrivateRegistry.git\n```\n\nworks on the command line.\n\nI am also attaching the output of `versioninfo()`\n\n```julia\nJulia Version 1.6.3\nCommit ae8452a9e0 (2021-09-23 17:34 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.6.0)\n  CPU: Intel(R) Core(TM) i5-4288U CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, haswell)\n```\n\nThe registry has worked on a different machine with the following setup\n\n```julia\nJulia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i7-4558U CPU @ 2.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, haswell)\n```\n\nAny ideas?\n\nMany thanks in advance!","[KristofferC]: > ERROR: BoundsError: attempt to access 1024-element Vector{UInt8} at index [0x0000000000000001:0x00007ff934e138e0]\n\nSomething is going wrong here, looking at\n\nhttps://github.com/JuliaLang/julia/blob/7b76c7e50a4eda78a556d4677900c854fbbcfc8d/stdlib/LibGit2/src/callbacks.jl#L436\n\nand\n\n```\njulia> 0x00007ff934e138e0 |> Int\n140708310759648\n```\n\nIt seems to think the certificate length is very long.\n\nLooking at git blame, @StefanKarpinski has a lot of modifications to this code in https://github.com/JuliaLang/julia/pull/39324 and https://github.com/JuliaLang/julia/pull/38506 but I am not sure if the problematic code originated there.\n\nIf you are able to do some debugging, I would follow the code up from the stacktrace and try to figure out where this incorrect length gets set.\n | [kabeero]: same problem on macOS / homebrew Julia 1.6.3\n\nfails with ssh, e.g: `registry add git@gitlab...` but `registry add https://gitlab...` works\n | [asparagii]: As a temporary workaround, you can set the environment variable `JULIA_PKG_USE_CLI_GIT=true`, as suggested here: https://github.com/JuliaLang/Pkg.jl/issues/2937#issuecomment-1010145013\n\nThis way Pkg will use the alternative pathway to clone repositories, which should work correctly. | [StefanKarpinski]: Are you using an official build of Julia? | [DilumAluthge]: Can you provide the exact steps that you followed when you installed Julia? | [kabeero]: julia 1.6.3, 1.7+ built from git or using homebrew show the same behavior described above with public / private key-pairs (generated with ssh-keygen, added to ssh-agent with ssh-add)\n\n`JULIA_PKG_USE_CLI_GIT=true` does remedy this problem, I might recompile Pkg.jl with this permanently enabled\n\n---\n\nadditionally it seems there is another ssh issue with CA-signed public certificates... again \n`JULIA_PKG_USE_CLI_GIT=true` fixes this issue but seems like a workaround / hack\n```\n(@v1.7) pkg> registry add git@private.com:MyJuliaRegistry/Custom.git\n     Cloning registry from """"git@private.com:MyJuliaRegistry/Custom.git""""\nERROR: type CertHostKey has no field data\nStacktrace:\n  [1] getproperty\n    @ ./Base.jl:42 [inlined]\n  [2] ssh_knownhost_check(files::Vector{String}, host::String, cert::LibGit2.CertHostKey)\n    @ LibGit2 /usr/local/Cellar/julia/1.7.1_2/share/julia/stdlib/v1.7/LibGit2/src/callbacks.jl:436\n  [3] certificate_callback(cert_p::Ptr{LibGit2.CertHostKey}, valid::Int32, host_p::Ptr{Int8}, data_p::Ptr{Nothing})\n    @ LibGit2 /usr/local/Cellar/julia/1.7.1_2/share/julia/stdlib/v1.7/LibGit2/src/callbacks.jl:401\n  [4] macro expansion\n    @ /usr/local/Cellar/julia/1.7.1_2/share/julia/stdlib/v1.7/LibGit2/src/error.jl:108 [inlined]\n  [5] clone(repo_url::SubString{String}, repo_path::String, clone_opts::LibGit2.CloneOptions)\n    @ LibGit2 /usr/local/Cellar/julia/1.7.1_2/share/julia/stdlib/v1.7/LibGit2/src/repository.jl:459\n  [6] clone(repo_url::SubString{String}, repo_path::String; branch::String, isbare::Bool, remote_cb::Ptr{Nothing}, credentials::LibGit2.CachedCredentials, callbacks::Dict{Symbol, Tuple{Ptr{Nothing}, Any}})\n    @ LibGit2 /usr/local/Cellar/julia/1.7.1_2/share/julia/stdlib/v1.7/LibGit2/src/LibGit2.jl:583\n  [7] clone(io::Base.TTY, url::String, source_path::String; header::String, credentials::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n  ...\n``` | [KristofferC]: The `CertHostKey` does have a `data` field:\n\nhttps://github.com/JuliaLang/julia/blob/3f024fd0ab9e68b37d29fee6f2a9ab19819102c5/stdlib/LibGit2/src/callbacks.jl#L370\n\nSo something is perhaps strange with your setup?",7,false,0,0,0,0,0,0,0,0,0
2935,Wrong remote URL used when package already added from fork,open,fredrikekre,,,,0,2022-01-10T13:04:19.0,2022-01-10T13:04:19.0,1287,1287,https://github.com/JuliaLang/Pkg.jl/issues/2935,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2935,```\n$ cd $(mktemp -d)\n\n$ export JULIA_LOAD_PATH=${PWD}/Project.toml JULIA_DEPOT_PATH=${PWD}\n\n$ pkg add 'https://github.com/fredrikekre/LanguageServer.jl.git'#fe/rootUri &> /dev/null \n\n$ pkg add LanguageServer#master\n    Updating git-repo `https://github.com/fredrikekre/LanguageServer.jl.git`\nPkgError: could not find project file in package at `https://github.com/fredrikekre/LanguageServer.jl.git` maybe `subdir` needs to be specified\n```,,0,false,0,0,0,0,0,0,0,0,0
2664,Don't download artifact when overwritten via Overrides.toml,open,carstenbauer,,,,1,2021-07-06T15:51:17.0,2022-01-04T08:20:42.0,1474,1293,https://github.com/JuliaLang/Pkg.jl/issues/2664,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2664,"Came up over at MKL.jl [here](https://github.com/JuliaLinearAlgebra/MKL.jl/issues/82).\n\nCurrently, if you use `Overrides.toml` to point Julia to a custom artifact Pkg will still eagerly download the original artifact and then just not use it afterwards.\n\n**Example: `IntelOpenMP_jll`:**\n\n`Overrides.toml`\n```toml\n[1d5cc7b8-4909-519e-a0f8-d0f5ad9712d0]\nIntelOpenMP = """"/path/to/my/custom/artifact/"""" # contains lib/libiomp5.so and  lib/libiompstubs5.so\n```\nPkg still downloads the original artifact:\n```Julia\n(@v1.8) pkg> add IntelOpenMP_jll\n   Resolving package versions...\n  Downloaded artifact: IntelOpenMP\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds (9 already precompiled)\n```\n\n```\n➜  bauerc@ln-0001 .julia/artifacts  ls\n947793e42b663bacd09f00d96aa96a47095f3b1c  Overrides.toml\n➜  bauerc@ln-0001 .julia/artifacts  cd 947793e42b663bacd09f00d96aa96a47095f3b1c/lib/; ls\nlibiomp5.so  libiompstubs5.so\n```\n\nBut doesn't use it (that's desired of course 😄):\n```\njulia> IntelOpenMP_jll.libiomp_path\n""""/path/to/my/custom/artifact/lib/libiomp5.so""""\n```\n\n\n**Doesn't happen for `lazy` artifacts**\n\nIf an artifact is marked as `lazy = true` the unnecessary download of the original artifact doesn't happen, as desired. For example, `MKL_jll.jl` is [lazy](https://github.com/JuliaBinaryWrappers/MKL_jll.jl/blob/19da215d915da456e2ac4995c5d3f077f040ebdb/Artifacts.toml#L4).\n\n**Desired behaviour:**\nIMO, if an artifact is overwritten in an `Overrides.toml`, the original artifact should not be downloaded. Is there something we can do about this?","[mkitti]: I have encountered interest in this feature downstream. This would make the option to use conda-forge dependencies easier, for example, which may be necessary in cases where cross-compilation is not available or when interop is paramount.\n\nI thought Artifacts was moving from to Julia proper and out of Pkg.jl. Is this is the right place to have this issue?",1,false,5,5,0,0,0,0,0,0,0
2771,Make Pkg relocatable.,open,KristofferC,,,,1,2021-10-14T12:04:12.0,2022-01-03T00:23:26.0,1375,1294,https://github.com/JuliaLang/Pkg.jl/issues/2771,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2771,"Trying to use Pkg from e.g. app errors with\n\n```\njulia> Pkg.add(""""Test"""")\n    Updating registry at `~/.julia/registries/General`\nERROR: IOError: readdir(""""MyAppCompiled/share/julia/stdlib/v1.6""""): no such file or directory (ENOENT)\nStacktrace:\n  [1] uv_error\n    @ ./libuv.jl:97 [inlined]\n  [2] readdir(dir::String; join::Bool, sort::Bool)\n    @ Base.Filesystem ./file.jl:830\n  [3] readdir\n    @ ./file.jl:825 [inlined]\n  [4] load_stdlib()\n    @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:365\n  [5] stdlibs\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:378 [inlined]\n  [6] stdlib_resolve!(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:831\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Iterators.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:192\n  [8] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:80\n  [9] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:78\n [10] #add#23\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:76 [inlined]\n [11] add\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:76 [inlined]\n [12] #add#22\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:75 [inlined]\n [13] add(pkg::String)\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:75\n [14] top-level scope\n    @ REPL[11]:1\n```\n\nWe should probably not assume that a bunch of files are available during runtime.","[DilumAluthge]: Maybe, at sysimage creation time, we should compute `Pkg.Types.stdlibs()` and store the result somewhere in the sysimage?",1,false,2,2,0,0,0,0,0,0,0
2902,Feature request: sort packages by installation time,open,rafael-guerra-www,,,,0,2021-12-29T23:10:30.0,2021-12-29T23:11:23.0,1298,1298,https://github.com/JuliaLang/Pkg.jl/issues/2902,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2902,"Feature request: sort packages by installation time, e.g.:\npkg> st -t\n\nSo that the last package installed appears at the bottom of the list.",,0,false,0,0,0,0,0,0,0,0,0
2894,Non standard SSH port ignored in git URL for package add with Pkg.setprotocol!,open,markNZed,,,,0,2021-12-14T14:59:20.0,2021-12-14T14:59:20.0,1314,1314,https://github.com/JuliaLang/Pkg.jl/issues/2894,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2894,"I was experimenting with a Julia package hosted in a private git repo using SSH. I used `Pkg.setprotocol!(domain = """"domain"""", protocol = """"ssh"""")` to specify the protocol and saw messages like the following where the port has become part of the path:\n\n```\n(@v1.7) pkg> add user@domain:2222/git-server/repos/ARTime.git\n     Cloning git-repo `ssh://user@domain/2222/git-server/repos/ARTime.git`\n```\n\nI was able to do what I needed with:\n\n```\n(@v1.7) pkg> add ssh://user@domain:2222/git-server/repos/ARTime.git\n```\n\nI thought there may be an issue with ports and Pkg.setprotocol! so I created this issue. It may also just be my lack of understanding of Pkg...\n",,0,false,0,0,0,0,0,0,0,0,0
2888,Improve docs around overriding artifacts and specific libraries,open,odow,,,,0,2021-12-09T19:45:03.0,2021-12-09T19:45:03.0,1318,1318,https://github.com/JuliaLang/Pkg.jl/issues/2888,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2888,"I'm writing docs for JuMP on how to replace JLL solvers with custom ones: https://github.com/jump-dev/JuMP.jl/pull/2824\n\nSpurred by this discussion on Slack:\n```\nOscar Dowson Yesterday at 5:58 PM\nIs it possible to override a single file within an artifact? For example, if I have a JLL, can I override the location of libfoo but keep the default foo executable? I'm writing some documentation for JuMP: https://github.com/jump-dev/JuMP.jl/pull/2823\n\nKristoffer Carlsson  13 hours ago\nI don't think so\n\nOscar Dowson  13 hours ago\nOkay. I can see why it would be difficult. In which case, the docs are clear enough.\n\nStefan Karpinski  5 hours ago\nI think that @staticfloat had a plan for this involving preferences, but I’m not sure if it ever got implemented\n\nElliot Saba:horse:  4 hours ago\nYes, JLLWrappers allows for this\n\nElliot Saba:horse:  4 hours ago\nhttps://github.com/JuliaPackaging/JLLWrappers.jl/pull/27\n\nElliot Saba:horse:  4 hours ago\nNo real docs so far, because it won't work (yet) for any stdlibs\n\nOscar Dowson  39 minutes ago\nAwesome! Works a treat. I'll draft some docs for JuMP. Would you want docs for it? If so, where? The JLLWrappers README?\n\nStefan Karpinski  31 minutes ago\nI feel like having some docs in Pkg for what to do when you need to use system libraries rather than artifacts would be good\n```\n\nI'll have a go at improving the current Pkg docs. Opening this issue to remind me.",,0,false,0,0,0,0,0,0,0,0,0
2873,Auto-install prompt fails without explanation if no registries are available,open,PallHaraldsson,,,,1,2021-12-02T22:31:50.0,2021-12-08T03:35:28.0,1325,1320,https://github.com/JuliaLang/Pkg.jl/issues/2873,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2873,"A.\nThe new auto-install prompt is great, but you do not get it if you do not already have a .julia folder, when it's maybe most needed (i.e. for newbies). I guess that may be an oversight and easily fixed. Maybe then we'll see it in Julia 1.7.1?\n\nB.\nI'm not sure if the auto-install uses the same default as with pkg> add\n\nDoes anyone know, and if it doesn't preserve versions, or at least prevent downgrades, then I think that should be the default. Doing otherwise seems too implicit. I would even argue for a new default for pkg> add ...","[IanButterworth]: > A. The new auto-install prompt is great, but you do not get it if you do not already have a .julia folder,\n\nYeah. There's been some discussion about what best to do. \nOptions are:\n\n1. Auto setup the depot and install the default registries. What https://github.com/JuliaLang/Pkg.jl/pull/2862 did, but was considered too presumptive\n2. Prompt to offer to set up the default registries.\n3. Warn that the registries need installing. What Pkg master does (although it's not on julia master yet) via https://github.com/JuliaLang/Pkg.jl/pull/2865 but there's questions about the right suggestion to make\n4. What currently happens  in 1.7.0; the user is told to try `import Pkg; Pkg.add(""""Foo"""")`\n\nFor people who specifically don't want a registry installed, an env var could be exposed to suppress 1-3.\n\n> B. I'm not sure if the auto-install uses the same default as with pkg> add\n\nIt does the default for `Pkg.add` which I believe is the same as the default for `pkg> add` i.e. tiered.\nPerhaps that could be forked off into a different issue rather than discussed here?",1,false,0,0,0,0,0,0,0,0,0
2836,Adding package already in Manifest,open,jonas-schulze,,,,3,2021-11-09T18:28:56.0,2021-12-03T16:36:56.0,1348,1324,https://github.com/JuliaLang/Pkg.jl/issues/2836,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2836,"Adding a package via `--preserve=all` doesn't seem to respect packages that already are in the Manifest, even though it should preserve all existing dependencies. Note that [`DrWatson`](https://github.com/JuliaDynamics/DrWatson.jl/blob/v2.0.5/Project.toml#L8) depends on `FileIO`:\n\n```\npkg> st\n...\n  [634d3b9d] DrWatson v2.0.5\n...\n\npkg> add --preserve=all FileIO\n  Installing known registries into `~/.julia`\n       Added registry `General` to `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `~/playground/Project.toml`\n  [5789e2e9] + FileIO v1.11.2\n    Updating `~/playground/Manifest.toml`\n  [5789e2e9] ↑ FileIO v1.10.1 ⇒ v1.11.2\nPrecompiling project...\n  2 dependencies successfully precompiled in 11 seconds (31 already precompiled)\n```\n\n```\njulia> versioninfo()\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake-avx512)\nEnvironment:\n  JULIA_PROJECT = @.\n```","[jonas-schulze]: It would be nice if this specific `add` would be possible offline, even without updating the registry. | [fredrikekre]: Probably there is an assumption that the package you try to add is completely unrestricted regardless of the preservation level.\n\n> It would be nice if this specific add would be possible offline, even without updating the registry.\n\nDoesn't it? | [jonas-schulze]: > Probably there is an assumption that the package you try to add is completely unrestricted regardless of the preservation level.\n\nDo you mean within `Pkg` or within (one of) the packages requiring `FileIO` in this example? For the case of `DrWatson`, it only requires `v1.0.6` (see their [Project.toml](https://github.com/JuliaDynamics/DrWatson.jl/blob/master/Project.toml)). I was expecting `--preserve=all` to cover everything already in the manifest (due to the docs saying """"including recursive dependencies"""").\n\n\n\n>> It would be nice if this specific add would be possible offline, even without updating the registry.\n>\n> Doesn't it?\n\nI was just checking that again and it appears to be working when the registry is up-to-date. How do I simulate a very out-of-date registry -- would the `Updating registry ...` step fail?\n\n```julia\n(@v1.6) pkg> activate --temp\n  Activating new environment at `/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Project.toml`\n\n(jl_XcT2sc) pkg> add FileIO@1.10.1\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Project.toml`\n  [5789e2e9] + FileIO v1.10.1\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Manifest.toml`\n  [5789e2e9] + FileIO v1.10.1\n  [ae029012] + Requires v1.1.3\n  [0dad84c5] + ArgTools\n  [56f22d72] + Artifacts\n  [2a0f44e3] + Base64\n  [ade2ca70] + Dates\n  [f43a241f] + Downloads\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [ca575930] + NetworkOptions\n  [44cfe95a] + Pkg\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [9a3f8284] + Random\n  [ea8e919c] + SHA\n  [9e88b42a] + Serialization\n  [6462fe0b] + Sockets\n  [fa267f1f] + TOML\n  [a4e569a6] + Tar\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [deac9b47] + LibCURL_jll\n  [29816b5a] + LibSSH2_jll\n  [c8ffd9c3] + MbedTLS_jll\n  [14a3606d] + MozillaCACerts_jll\n  [83775a58] + Zlib_jll\n  [8e850ede] + nghttp2_jll\n  [3f19e933] + p7zip_jll\n\n(jl_XcT2sc) pkg> add DrWatson\n   Resolving package versions...\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Project.toml`\n  [634d3b9d] + DrWatson v2.7.5\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Manifest.toml`\n  [34da2185] + Compat v3.40.0\n  [864edb3b] + DataStructures v0.18.10\n  [634d3b9d] + DrWatson v2.7.5\n  [033835bb] + JLD2 v0.4.15\n  [1914dd2f] + MacroTools v0.5.9\n  [bac558e1] + OrderedCollections v1.4.1\n  [189a3867] + Reexport v1.2.2\n  [6c6a2e73] + Scratch v1.1.0\n  [3bb67fe8] + TranscodingStreams v0.9.6\n  [3a884ed6] + UnPack v1.0.2\n  [8bb1440f] + DelimitedFiles\n  [8ba89e20] + Distributed\n  [37e2e46d] + LinearAlgebra\n  [a63ad114] + Mmap\n  [1a1011a3] + SharedArrays\n  [2f01184e] + SparseArrays\n  [10745b16] + Statistics\n  [8dfed614] + Test\n\n(jl_XcT2sc) pkg> rm FileIO\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Project.toml`\n  [5789e2e9] - FileIO v1.10.1\n  No Changes to `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Manifest.toml`\n\n(jl_XcT2sc) pkg> # cut the cord\nERROR: Could not determine command\n\n(jl_XcT2sc) pkg> add --preserve=all FileIO\n   Resolving package versions...\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Project.toml`\n  [5789e2e9] + FileIO v1.11.2\n    Updating `/private/var/folders/2s/ywy1l_n55076vhx98_wrr5fr0000gn/T/jl_XcT2sc/Manifest.toml`\n  [5789e2e9] ↑ FileIO v1.10.1 ⇒ v1.11.2\n\njulia> versioninfo()\nJulia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 4\n  JULIA_PROJECT = @.\n  JULIA_PKG_PRECOMPILE_AUTO = 0\n```",3,false,0,0,0,0,0,0,0,0,0
2838,Provide nicer API for dependency listing,open,adigitoleo,,,,1,2021-11-10T00:05:00.0,2021-11-25T07:51:48.0,1348,1333,https://github.com/JuliaLang/Pkg.jl/issues/2838,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2838,"Currently I found two ways to list (direct) dependencies of a project using Pkg.\n\nIf the project is active, then `Pkg.project().dependencies` does the job, however to list dependencies of a project in general, we need to use a longwinded incantation (example for HTTP package):\n\n```\njulia> Pkg.dependencies()[Pkg.project().dependencies[""""HTTP""""]].dependencies\nDict{String, Base.UUID} with 5 entries:\n  """"Dates""""   => UUID(""""ade2ca70-3891-5945-98fb-dc099432e06a"""")\n  """"Base64""""  => UUID(""""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"""")\n  """"Sockets"""" => UUID(""""6462fe0b-24de-5631-8697-dd941f90decc"""")\n  """"IniFile"""" => UUID(""""83e8ac13-25f8-5344-8a64-a9f2b223428f"""")\n  """"MbedTLS"""" => UUID(""""739be429-bea8-5141-9913-cc70e7f3736d"""")\n```\n\nI wonder if there is some interest in adding a shortcut for this? Maybe just as simple as:\n\n```\ndependencies(s::AbstractString) = dependencies()[Pkg.project().dependencies[s]].dependencies\n```\n\nOr is this API expected to change soon anyway?","[adigitoleo]: A version that works regardless of whether `package` is the active project or not.\n\n```\n""""""""""""Get a dictionary of dependencies of a package and their UUIDs.""""""""""""\nfunction dependencies(package::AbstractString)\n    if package == Pkg.project().name\n        return Pkg.project().dependencies\n    end\n    return Pkg.dependencies()[Pkg.project().dependencies[package]].dependencies\nend\n```\n\nI'd open a  PR but I've never written a test before, I guess the way to test this would be to parse this package's TOML and compare outputs?\n\nAlso, it doesn't tell you the dependency versions, which could be a nice thing to have. I'm not actually aware of a way to get pakage versions from within a Julia session without parsing Project.toml files...",1,false,2,0,0,0,0,0,2,0,0
2792,Add line on which registry a package is being auto installed from,open,logankilpatrick,,,,7,2021-10-23T19:05:44.0,2021-11-18T11:24:49.0,1365,1340,https://github.com/JuliaLang/Pkg.jl/issues/2792,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2792,"With 1.7's new auto package installation, it would be very helpful (I think) to see which registry the auto package installation suggestion is coming from. I see a future where if there are more complicated registries, this could be increasingly important.\n\n```Julia\njulia> using Flux\n │ Package Flux not found, but a package named Flux is available from \n │ the General registry. \n │ Install package?\n │   (@v1.7) pkg> add Flux \n └ (y/n) [y]: \n```","[logankilpatrick]: Happy to take a stable at implementing this if folks think it would be helpful. Just need some guidance on where to branch from initially. | [IanButterworth]: It's a nice idea. That would be more insight than `pkg> add Flux` currently gives, which just goes ahead if a singular result is found in a registry.\nBut perhaps because we're already waiting on user input, it's not a bad idea to add the extra info?\n\nAs an aside, in the case where Flux appears in multiple registries, I believe the `pkg> add` process in both cases would prompt the user for their choice, but I'm not sure (I've never come across that in practice)\n | [logankilpatrick]: > As an aside, in the case where Flux appears in multiple registries, I believe the pkg> add process in both cases would prompt the user for their choice, but I'm not sure (I've never come across that in practice)\n\nDoes it say which registry the package would come from if two registries have the same package name? Looking at: https://github.com/JuliaLang/Pkg.jl/blob/a230dcf5f3546bd464e575e7752d6259a3221bd5/src/REPLMode/REPLMode.jl#L665 it does not appear it does. In the wild, this could be applicable as companies might operate their own internal fork of Julia packages. I am not sure if that is directly applicable here but was my initial thought.\n\nIf I want to tackle this, where would I branch from to play around? | [logankilpatrick]: I will further note that this could also be helpful if you somehow acquire a junk package registry. In the case where you are """"hacked"""" and your general Julia registry is replaced (or supplemented), it could be nice to see where the Pkg manager is trying to install from. Again, not sure that is directly applicable here but was just one of the thoughts I had. | [IanButterworth]: I'm talking about what happens inside `pkg> add` not the prompt. i.e. after the user selects `y`.\n\n> If I want to tackle this, where would I branch from to play around?\n\nUse julia master and follow https://github.com/JuliaLang/Pkg.jl#using-the-development-version-of-pkgjl | [KristofferC]: >  In the case where you are """"hacked"""" and your general Julia registry is replaced (or supplemented)\n\nIf someone can do this you have already lost so that doesn't seem like a very plausible threat model.\n\n>  it could be nice to see where the Pkg manager is trying to install from\n\nPresumably, most installs are going to be via `pkg> add` which does do not show anything about what registry a package comes from. However, instead of showing the registry, wouldn't showing the URL of the repo of the package be more informative? | [GunnarFarneback]: > In the wild, this could be applicable as companies might operate their own internal fork of Julia packages. I am not sure if that is directly applicable here but was my initial thought.\n\nI'll comment on this since I have some experience with it. At one point when the YAML package had some new features we needed on master but wasn't making a new release for a long time, I made an internal fork of it but I changed both the name and the UUID. Not changing the name had been technically possible but would have been a major pain because we would for all future have to live with the collision between our internal registry and General, always having to spell out from which registry to get it. It's bad enough to have an obsolete package we will never get rid of from the registry and a repository we can't really remove from our git server without losing traceability for the packages and other code that once used it. (Before forking we tried to depend on the master branch of the YAML package, but that turned out to be too brittle in practice.)\n",7,false,0,0,0,0,0,0,0,0,0
2821,`generate .` for an open blank repository,open,BioTurboNick,,,,0,2021-11-02T01:14:27.0,2021-11-02T01:14:58.0,1356,1356,https://github.com/JuliaLang/Pkg.jl/issues/2821,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2821,"I always have trouble with the workflow for generating a new package.\n\nI usually first create the repository, open the folder in VSCode, launch the REPL, and then open the Pkg prompt.\n\n`generate` errors\n`generate .` errors (would be parallel to `activate .`)\n`generate MyPackage.jl` creates a new directory within my open directory to put it all in.\n`instantiate` creates a manifest.\n\nI think perhaps the easiest solution would just be to have `generate .` make a package structure in the current directory using the folder name as the package name?",,0,false,3,3,0,0,0,0,0,0,0
2794,Improve situation with missing `dev`ed packages,open,BioTurboNick,,,,0,2021-10-26T04:48:36.0,2021-10-26T04:48:36.0,1363,1363,https://github.com/JuliaLang/Pkg.jl/issues/2794,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2794,"My repository was in a broken state because multiple packages I had `dev`ed on another computer are missing on my current computer. Leaving aside that I shouldn't have committed the changes to Project.toml in the first place...\n\n```\npkg> add Gtk\n   Resolving package versions...\nERROR: expected package `FFTW [7a1cc6ca]` to exist at path `C:\Users\ncb20\.julia\dev\FFTW`\n```\n\nFair enough to need everything present, but removing it isn't possible:\n```\npkg> rm FFTW\nERROR: The following package names could not be resolved:\n * FFTW (7a1cc6ca-52ef-59f5-83cd-3a7055c09341 in manifest but not in project)\n\n(ClusDoC) pkg> rm C:\Users\ncb20\.julia\dev\FFTW\nERROR: Unable to parse `C:\Users\ncb20\.julia\dev\FFTW` as a package.\n```\n\nAlso can't add one from the registry because another package is missing.\n```\npkg> add FFTW\n   Resolving package versions...\nERROR: expected package `ImageFiltering [6a3955dd]` to exist at path `C:\Users\ncb20\.julia\dev\ImageFiltering`\n```\n\nFinally, I figured out I could add multiple at once separated by a comma, and that allowed it to work.\n\nIt seems like it could be made easier or more obvious how to get back to a good state.",,0,false,1,0,0,0,0,0,1,0,0
2525,`Pkg.add` with a branch (and `Pkg.dev`) chooses a registry inconsistently with `Pkg.add`,open,ericphanson,,,,19,2021-04-23T14:38:51.0,2021-10-17T00:46:22.0,1549,1372,https://github.com/JuliaLang/Pkg.jl/issues/2525,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2525,"If you have a package registered with the same name and UUID in two registries, `Pkg.add(name=...)` will choose whichever registry has a later version. However, `Pkg.dev` will choose some other way (whatever is first in some list it checks, I think). Instead, `Pkg.dev` should choose the same registry as `Pkg.add` would. This mismatch can be very confusing for users.","[fredrikekre]: Could prompt the user in interactive mode and error otherwise. | [ericphanson]: I think that would be an improvement over the current situation, but why not just use the same registry resolution as `add`? Since if you aren’t passing a path or url it needs to use a registry so why not make that consistent. | [fredrikekre]: But `Pkg.add` doesn't really choose a registry, it just collapses them all. | [ericphanson]: Ah ok, I didn’t realize that. Then I guess it’s a bit harder to implement my suggestion. As a user it still seems like the consistent way for it to behave though. | [ericphanson]: But I think a prompt would be a big improvement already. Currently when users dev and get the old version of a package it can make them think something is configured wrong on their end or they have some internal state that is out of date (especially because configuring multiple registries and auth for private registries is not always perfectly smooth). So even if it seems like Pkg should know which registry is the right one, at least giving the options is a big improvement over silently giving the wrong one. | [fredrikekre]: With multiple repo urls there is not really a good way to find the canonical one though. | [ericphanson]: Well I'm saying there is: in the scenario Pkg is given a name or name + uuid and no URL, then it is hopeless to find a URL unless the package is registered in a registry, in which case it has version numbers in that registry. The case of multiple URLs is when it is registered in multiple registries. Which is the canonical one? The registry which contains the highest version number. | [fredrikekre]: > Which is the canonical one? The registry which contains the highest version number.\n\nWhy? This seems almost as arbitrary as the current behavior. For example, you have have a private repo and private registry. You decide to open start making releases to a public registry instead, but you probably still want `Pkg.dev` to track your private repo.\n\nPrompting seems simple enough. `Pkg.dev` is inheritly an interactive function so erroring in the non-interactive case seems good anyways. | [ericphanson]: > Why?\n\nSince when you `dev`, you get the latest copy of the code. Where is the latest copy of the code likely to be? The one with the latest release.\n\n> For example, you have have a private repo and private registry. You decide to open start making releases to a public registry instead, but you probably still want Pkg.dev to track your private repo.\n\nHow are you making releases to a public registry from a private repo? | [fredrikekre]: > How are you making releases to a public registry from a private repo?\n\nI am not, I have a public repo with """"outdated"""" code where all releases are from. | [ericphanson]: If all the releases are from a public repo, how does Pkg know about the private one at all? | [ericphanson]: I think the scenario must be you have registered the package in a public and private registry, then stopped making releases in either but have continued development in the private repo and happen to have the last release be in the public registry.\n\nThat just seems way more unlikely than you’re continuing development in whatever repo you’ve last released from. | [KristofferC]: So you have two different `repo` URLs in the two different registries. And you say that Pkg picks the """"wrong"""" URL? | [ericphanson]: Yep, exactly. This comes about by taking a private package and open sourcing it in a new public repo (in order to not transfer the history to the public one while keeping it around in case some historical git-diving is ever needed) as we did at the [2020 Contributhon](https://julialang.org/blog/2021/01/contributhon/).\n\nSo you have the same name and UUID semantically corresponding to the same package that has some versions in a private registry with a URL corresponding to a private repo, and General with a URL corresponding to a public repo with later versions and all future development. `Pkg.add` works great with this process and selects the latest available version, which in this case is in General.\n\n`Pkg.dev` chooses some other way (seemingly arbitrarily) and often chooses the wrong URL to clone.\n\nMy claim is that even if this is not the situation for all users of multiple registries who are add'ing and dev'ing packages, having the repo you get from `Pkg.dev` correspond to the repo containing the code you get from `Pkg.add` is consistent behavior, and having `Pkg.dev` choose arbitrarily is not. | [fredrikekre]: > If all the releases are from a public repo, how does Pkg know about the private one at all?\n\nBecause if you have multiple different URLs there must be more registries.\n\n> I think the scenario must be you have registered the package in a public and private registry, then stopped making releases in either but have continued development in the private repo and happen to have the last release be in the public registry.\n>\n> That just seems way more unlikely than you’re continuing development in whatever repo you’ve last released from.\n\nOkay, but in that case, why not update the internal repo url? Or are you saying all releases isn't public and Pkg handles that?\n\n | [ericphanson]: > Because if you have multiple different URLs there must be more registries.\n\nRight, that’s why I don’t understand the scenario you outlined in https://github.com/JuliaLang/Pkg.jl/issues/2525#issuecomment-827658782\n\n> Okay, but in that case, why not update the internal repo url?\n\nBecause then Pkg can’t find the old versions because the git history was wiped moving to  the new repo.\n\n> Or are you saying all releases isn't public and Pkg handles that?\n\nNo, there’s n private releases (with valid git tree SHAs in the private repo) followed by m public releases (with valid git tree SHAs in the public repo).\n\n | [ericphanson]: Is it clear what the issue is now? | [ericphanson]: I've retitled the issue because the same thing happens with `add MyPkg#branch` as with `dev`. Hopefully this also shows the inconsistency more directly. | [ericphanson]: I looked into this a little bit tonight, and I think \n\nhttps://github.com/JuliaLang/Pkg.jl/blob/23008ab8e1d37b9ec7d6069c26cf4ffd2282afbb/src/Types.jl#L644-L666\n\nis the relevant function; in particular, we `return` in the loop as soon as we find a registry with the package.\n\nThe fix suggested in https://github.com/JuliaLang/Pkg.jl/issues/2525#issuecomment-827492474 to prompt would only need local code changes, so that sounds not so bad to implement, presumably mimicking \n\nhttps://github.com/JuliaLang/Pkg.jl/blob/9f7eaa36cf91dd92762a394c8c1cc6a7faa6986d/src/Types.jl#L975-L983\n\nI still think `] add MyPkg` and `] add MyPkg#branch` or `] dev MyPkg` should always choose the same registry without the need for a prompt, but I do see how it's a bit complicated-- `] add MyPkg` will look at all the versions (from all the registries) and choose the latest compatible version (while also trying to choose the latest version of all the other packages), and we don't want to do that version resolution just to figure out which registry to use for `] add MyPkg#branch` (especially since it might have totally different compatibility requirements, so doing the resolution for `] add MyPkg` might not find any compatible version and hence would not tell us which registry to use). I still think choosing the registry with the latest version (forgetting compatibility) is a good heuristic though.",19,false,4,4,0,0,0,0,0,0,0
2772,Compat entries for Packages that are not dependencies,open,BeastyBlacksmith,,,,0,2021-10-14T15:07:02.0,2021-10-14T15:07:02.0,1375,1375,https://github.com/JuliaLang/Pkg.jl/issues/2772,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2772,"It would be useful to be able to specify compat entries with Packages, that aren't dependencies.\n\nThis would be useful for packages that use `Requires.jl` to conditionally load packages as well as for packages that use, e.g. `RecipesBase.jl`, but rely on a feature of a specific `Plots.jl` version. \n",,0,false,1,1,0,0,0,0,0,0,0
2748,Error message on version conflict is unclear,open,robsmith11,,,,2,2021-10-02T04:55:59.0,2021-10-02T21:37:57.0,1387,1386,https://github.com/JuliaLang/Pkg.jl/issues/2748,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2748,"I included a screenshot because I was told that the text color is supposed to help show which version range is associated with which package name, but it's still unclear to me.  Couldn't the version numbers just be prefixed by the package name to which they are referring?\n\nThe language is also confusing to me: """"restricted by compatibility requirements with $package"""".  What's being restricted?  The way the subnesting is done isn't intuitive to me either.  For example, the 2nd line makes it sound like Libtask is a dependency of itself.\n\n![p](https://user-images.githubusercontent.com/22622548/135704046-b451f855-c869-4f69-9792-44f5a7e16589.png)\n","[timholy]: Putting the package name in front of the allowed versions does seem like a pretty good idea to me. \n\nHave you read https://pkgdocs.julialang.org/v1.6/managing-packages/#conflicts? That may help you understand the connectors. | [KristofferC]: > I included a screenshot because I was told that the text color is supposed to help show which version range is associated with which package name, but it's still unclear to me. \n\nOnly if your colorscheme doesn't make these virtually unreadable.\n\nThe versions are for the pacakge you get by following the line to the left of """"restricted by ..."""" up.",2,false,0,0,0,0,0,0,0,0,0
2747,julia version requirement for package not satisfied,open,jtrakk,,,,0,2021-09-30T21:11:57.0,2021-09-30T21:12:29.0,1388,1388,https://github.com/JuliaLang/Pkg.jl/issues/2747,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2747,"When I try to install some packages, I get this message:\n\n\n```\nprintln(io, """"julia version requirement for package $(err_rep(pkg)) not satisfied"""")\n```\n\nIt would be helpful to say which Julia version is required.",,0,false,1,1,0,0,0,0,0,0,0
2714,Make tree hash for loaded package accessible,open,philbit,,,,8,2021-08-26T16:13:14.0,2021-09-27T14:01:40.0,1423,1392,https://github.com/JuliaLang/Pkg.jl/issues/2714,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2714,"Sometimes, you want to be able to tell exactly which version of a package is currently loaded. In principle, the tree hash is all that's needed. It can also easily be converted to a commit hash if a commit with the exact same content exists, etc. However, looking at the current `Manifest.toml` (where the tree hash is recorded) is not always sufficient, for example when switching between environments.\n\nIs there currently a possibility to obtain the tree hash of a loaded package? Perhaps I just overlooked it. But if there is not, it would be great to have, for example to debug situations where the wrong version was loaded for some reason. Since `Pkg` computes the tree hash internally anyway for the manifest, I guess it would """"just"""" be a matter of storing this metainformation somewhere.\n\nCurrently, I resort to inserting\n\n```julia\nconst TREE_HASH = bytes2hex(Pkg.GitTools.tree_hash(joinpath(splitpath(@__FILE__)[1:end-2]...)))\n```\n\nin the modules where I need this functionality. This records the tree hash during precompilation so I can access it later. Is it possible and would it be worth enabling `Pkg` to return this information about a package in memory?","[KristofferC]: > Since Pkg computes the tree hash internally anyway for the manifest, \n\nNot for packages that are tracked via path (""""devved packages""""). | [philbit]: Ah, my bad, I forgot. But wouldn't it be nice to always have this info handy anyway? In many cases, it would be useful even for devved packages. But if it's much more difficult for those, it would be nice at least for the """"easy"""" case of non-devved packages. | [philbit]: Just out of interest: How is it decided whether a devved package should be recompiled if not via the tree hash? Good old modification dates? | [KristofferC]: The code for it is here: https://github.com/JuliaLang/julia/blob/1bbba21aa258a99d1ecf1168d72d64cb402fd054/base/loading.jl#L1805-L1903 | [philbit]: Thanks. Thinking about it more I realized that `Pkg` might not be the right place for this... I think the information needs to be saved with the precompile cache so it is available even when the module is already precompiled and just loaded (or precompiled but not by `Pkg`). Alternatively, it could be recomputed when the package is loaded. This should be safe since, at that point, the loaded module is guaranteed to correspond to the files on disc anyway (otherwise it is recompiled). But for huge source trees, recomputing the tree-hash upon loading might slow down loading, so perhaps it would be better to compute it only once upon precompilation.\n\n\nSide note:\nAnother thing I realized was that, for non-devved packages, this information is already sort of available, just a bit hidden. Since the source code for those is assumed immutable, one could just call `Pkg.GitTools.tree_hash(pkgdir(m))` to get the tree hash of the currently loaded module `m`. Of course this assumes that the assumption of immutability is correct (i.e. that nobody messed with the files in `pkgdir(m)` between loading and now), which should theoretically always be the case, but if this is also meant as a tool to track down issues when things go wrong, this assumption could easily be one of them. I just wanted to mention this mainly to justify why in the cases where it would be particularly useful (versioning problems, devving, etc) this method does not work. | [KristofferC]: > Of course this assumes that the assumption of immutability is correct (i.e. that nobody messed with the files in pkgdir(m)\n\nUnfortunately, people do with `build` scripts. There are more modern way of doing things (https://github.com/JuliaPackaging/Scratch.jl) but the old way is still here. | [philbit]: I think I've found a way to implement what I am thinking of in an external package that taps into module loading in `Base` in the same way that `Revise.jl` does. I'll try it and report back here when I've produced something presentable. | [philbit]: [This package](https://github.com/philbit/PackageStates.jl) is my first attempt at providing this sort of functionality. Most of the things I had in mind when opening this issue can be solved with it. It's currently waiting for registration. Let me know if you have any feedback.",8,false,1,1,0,0,0,0,0,0,0
2697,Vague warnings about dependency graph not being a DAG,open,giordano,,,,11,2021-08-12T18:43:22.0,2021-08-16T20:21:53.0,1437,1433,https://github.com/JuliaLang/Pkg.jl/issues/2697,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2697,"For example\n```\n(@v1.8) pkg> add MKL\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Resolving package versions...\n   Installed MKL ───────────── v0.4.1\n   Installed PackageCompiler ─ v1.3.0\n   Installed PaddedViews ───── v0.5.10\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [33e6dc65] + MKL v0.4.1\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [33e6dc65] + MKL v0.4.1\n  [9b87118b] + PackageCompiler v1.3.0\n  [5432bcbf] ↑ PaddedViews v0.5.9 ⇒ v0.5.10\n  [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2\n  [856f044c] + MKL_jll v2021.1.1+1\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/repo/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n```\nI believe this is going to give some headaches to users: there are multiple repeated warnings, it isn't clear what they refer to (any why to point out exactly which packages are involved?), I have a vague idea of what this means, but I expect many users to wonder """"what does this even mean?"""", in addition to """"why I should care?""""","[DilumAluthge]: Should we at least have a `maxlog` on that warning? | [StefanKarpinski]: The simplest fix may be to change the wording of the warning to """"Dependency graph has a cycle, picking an arbitrary ordering."""" Note that this only matters for invoking `deps/build.jl` scripts since the dependees need to be build before the dependers. IIRC when I implemented this I was a bit lazy and printed this warning if there was any cycle, but technically it may be possible to only print this warning if there's a cycle that causes an ambiguity in what order to run the build scripts. You could probably implement that by computing the transitive dependency graph and then looking only at the packages with build scripts and if any of them are mutually dependent in the transitive graph, then print the warning. | [KristofferC]: I've also seen this warning a lot more frequently. I wonder if some popular package has dependencies with a cycle now? | [giordano]: > I wonder if some popular package has dependencies with a cycle now?\n\nMy main gripe about the warning is that it isn't actionable: you're only left wondering what's going on. Especially a non-developer end-user has no idea of what to do with that. It'd be great if the warning could suggest a way forward, for example by pointing out the involved packages. | [KristofferC]: I agree that the warning can be better.\n\nBut even so, I still want to know about the packages with the cycle. Do you have a simple repro? | [giordano]: ```\n(@v1.8) pkg> st\n      Status `~/.julia/environments/v1.8/Project.toml`\n  [33e6dc65] MKL v0.4.1\n  [30cdaa97] SystemBenchmark v0.4.0 `~/.julia/dev/SystemBenchmark`\n  [f50d1b31] Rmath_jll v0.3.0+0\n```\nI saw the warning when adding `MKL`, so I had only `SystemBenchmark` (it's deved but I didn't change the dependencies on `master`) and `Rmath_jll` at that point | [KristofferC]: Yep, thanks:\n\n```\n(jl_x8lBq1) pkg> st\n      Status `/tmp/jl_x8lBq1/Project.toml`\n  [33e6dc65] MKL v0.4.1\n\n(jl_x8lBq1) pkg> build\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n┌ Warning: Dependency graph not a DAG, linearizing anyway\n└ @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.8/Pkg/src/Operations.jl:832\n``` | [KristofferC]: Ok, lol. Here are the cycles:\n\n```\nPkg->p7zip_jll->\nPkg->Downloads->LibCURL->MozillaCACerts_jll->\nPkg->Downloads->LibCURL->LibCURL_jll->\nPkg->Downloads->LibCURL->LibCURL_jll->LibSSH2_jll->\nPkg->Downloads->LibCURL->LibCURL_jll->LibSSH2_jll->MbedTLS_jll->\nPkg->Downloads->LibCURL->LibCURL_jll->MbedTLS_jll->\nPkg->Downloads->LibCURL->LibCURL_jll->nghttp2_jll->\nPkg->Downloads->LibCURL->LibCURL_jll->Zlib_jll->\n```\n\nAnd of course there will be cycles when all jlls depend on Pkg itself.\n\nCode: https://github.com/KristofferC/EnvironmentGraph.jl | [StefanKarpinski]: Do any of them have `deps/build.jl` scripts? If they don't then making it so this warning is only printed when there is an actual build script cycle would make this warning go away.\n\n> My main gripe about the warning is that it isn't actionable: you're only left wondering what's going on. Especially a non-developer end-user has no idea of what to do with that. It'd be great if the warning could suggest a way forward, for example by pointing out the involved packages.\n\nSo the reason for the warning is that this situation can cause package building to fail and this warning is meant to provide a clue as to why that failure is happening. We could modify the message to say something along the lines of """"there's a cyclic dependency among package build scripts which might cause problems; if it does, report this to <who>?"""" Or we could not print the warning unless there's a cyclic dependency among build scripts *and* the build actually fails somewhere. | [giordano]: > Do any of them have deps/build.jl scripts?\n\n[`MKL.jl` does](https://github.com/JuliaLinearAlgebra/MKL.jl/blob/259493b6e811c60fc2436b8efdd65665a91c5bd7/deps/build.jl), yes.\n\n> We could modify the message to say something along the lines of """"there's a cyclic dependency among package build scripts which might cause problems; if it does, report this to ?"""" Or we could not print the warning unless there's a cyclic dependency among build scripts and the build actually fails somewhere.\n\nEither looks fine, especially showing which package to report the issue to: in this way proactive users can do something. | [StefanKarpinski]: MKL isn't in any of the cycles though, so if we only warned for build scripts in an actual cycle loop, then we wouldn't be seeing this warning in these cases.",11,false,0,0,0,0,0,0,0,0,0
2704,Add tab-completions for `registry add`,open,jakobnissen,,REPL,,0,2021-08-16T13:56:05.0,2021-08-16T13:58:08.0,1434,1434,https://github.com/JuliaLang/Pkg.jl/issues/2704,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2704,"Truly minor, but there is currently no tab-completion for e.g. `registry add /path/to/registry`. It would be nice though.",,0,false,0,0,0,0,0,0,0,0,0
2685,gc: treat older manifest as unreachable?,open,StefanKarpinski,,,,7,2021-08-06T04:58:23.0,2021-08-09T09:29:25.0,1444,1441,https://github.com/JuliaLang/Pkg.jl/issues/2685,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2685,"I have manifests lying around from old Julia versions that I haven't used in ages but that are still there and which are therefore keeping old versions of packages and artifacts from being collected. When scanning `manifest_usage.toml`, I think it might make sense to ignore manifests that haven't been modified in some amount of time. Usage would be a better criterion, but we don't record when a manifest is used, only when it's modified. Perhaps that's close enough?","[KristofferC]: One possible scenario I see is that you have a long-running Julia service going and then you login to that computer and do a Pkg operation. Then automatic GC hits and removes all packages and artifacts used by the service. | [StefanKarpinski]: Good point. We could add the load path environments back into the root set even if they haven't been updated. After all, you definitely shouldn't delete anything that is currently loadable. | [IanButterworth]: Wouldn't that only guard against deleting/ignoring manifests in use in the current session, not others, like in the long-running service situation?\n\nPerhaps the usage file needs both a latest used time, and a latest closed time, the latter being updated atexit or when switching environments, and items must be considered in the usage file if \n```\nisnothing(last_closed_time) || last_used_time > last_closed_time\n```\nThat might break backwards compatability for the usage file though\n\n | [DilumAluthge]: @maleadt any thoughts on this? I was thinking it could be useful for the issues we're having in https://github.com/JuliaCI/julia-buildkite-plugin/issues/17 | [StefanKarpinski]: The issue with recording access time is that we don't want to put too much stuff in the code loading path. Even if we did, since code is typically only loaded early in a process, the scenario still exists where the long-running process is using something, logs that usage, then runs for a long time and some other Julia process is started and cleans up that other process's dependencies. The only thing that would prevent that entirely is to periodically re-record usage throughout the duration of the long-running process, which seems like an awful lot to do here. | [StefanKarpinski]: Ah, another possibility: record that a process started using a manifest and on exist that it stopped. Of course, if the program hard crashes or gets SIGKILLed then it won't write the stop and the """"start usage"""" message becomes permanently unpaired. You could do some fancy stuff with recording the PID of the process and seeing if that process still exists, but yikes, that's getting complex. | [StefanKarpinski]: Maybe just make this opt-in with some flag to the `gc` command and maybe have some way to opt into that being the default. People generally know if they're running long-running processes or not.",7,false,2,2,0,0,0,0,0,0,0
2684,Pkg.gc could maybe clean up old precompile files,open,KristofferC,,,,1,2021-08-05T09:26:19.0,2021-08-05T14:42:37.0,1445,1445,https://github.com/JuliaLang/Pkg.jl/issues/2684,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2684,"Think that kind of makes sense? If you have a very old precompile file, it could probably be removed since it hasn't been used in a long itme.",[DilumAluthge]: Makes sense to me.,1,false,2,2,0,0,0,0,0,0,0
708,Pkg.add on git repository with a submodule raises GitError,open,KristofferC,,,,17,2018-09-03T00:53:45.0,2021-07-22T16:12:40.0,2512,1458,https://github.com/JuliaLang/Pkg.jl/issues/708,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/708,"@non-Jedi commented on [Fri Aug 31 2018](https://github.com/JuliaLang/julia/issues/28996)\n\nJust upgraded to 1.0 and tried to checkout some of my projects. One has a git submodule in it as a convenience since it's being developed against a spec contained in another git repo, but I am unable to add that one using `Pkg`:\n\n```julia\njulia> using Pkg\n\njulia> Pkg.add(PackageSpec(url=""""https://github.com/non-Jedi/MatrixClientProtocol.jl"""", rev=""""master""""))\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Updating git-repo `https://github.com/non-Jedi/MatrixClientProtocol.jl`\nERROR: GitError(Code:ERROR, Class:Submodule, cannot get submodules without a working tree)\nStacktrace:\n [1] macro expansion at /builddir/julia/usr/share/julia/stdlib/v1.0/LibGit2/src/error.jl:101 [inlined]\n [2] #checkout_tree#46(::LibGit2.CheckoutOptions, ::Function, ::LibGit2.GitRepo, ::LibGit2.GitTree) at /builddir/julia/usr/share/julia/stdlib/v1.0/LibGit2/src/repository.jl:358\n [3] #add_or_develop at ./none:0 [inlined]\n [4] #add_or_develop#12 at /builddir/julia/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:29 [inlined]\n [5] #add_or_develop at ./none:0 [inlined]\n [6] #add_or_develop#10(::Base.Iterators.Pairs{Symbol,Symbol,Tuple{Symbol},NamedTuple{(:mode,),Tuple{Symbol}}}, ::Function, ::Pkg.Types.PackageSpec) at /builddir/julia/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:27\n [7] #add_or_develop at ./none:0 [inlined]\n [8] #add#18 at /builddir/julia/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:69 [inlined]\n [9] add(::Pkg.Types.PackageSpec) at /builddir/julia/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:69\n [10] top-level scope at none:0\n```\n\nTo be clear, I'm aware that I should have been using `Pkg.develop` for what I was trying to do here, but I still think that this shouldn't be raising this error.\n\n","[mmolignano]: @KristofferC Have you found any workarounds for this? I've created a project with a dependency on a repo with a submodule. I'm not sure the proper workflow here, but the assumption is that others will use this without using `Pkg.develop` and I'm not sure how to get around this error.\n\nI was planning on setting up a build script to properly initialize the submodule and build required dependencies within the submodule (that are not part of julia) but I'm not sure the best way to do this. | [marius311]: I'm curious as well. I'd like keep the docs for a given package in a submodule so as not to bloat the main repository, but I get this error when I try to `Pkg.add` the package (only `Pkg.develop` works, and clones the repo without the submodules, which is indeed the desired behavior in my case). | [vtjeng]: To clarify: if I have a repository with a submodule, is it (currently) going to be unusable by others who are installing it via `Pkg.add`? | [korsbo]: It there a way to ignore submodules? In my case, I tend to have scientific projects as an application and the article src as a submodule to that project. Within Julia, I thus do not have any need for the submodule and would like to simply ignore it. | [StefanKarpinski]: We're not going to have multiple possible behaviors for this, so it needs to be decided whether to automatically check out submodules as though they are just subdirectories or ignore them. It's unclear to me at least, based on what people are saying here, which is the better approach. | [korsbo]: If only one behaviour is to be supported I guess that it would make more sense to check out the submodules. It must be easier for devs to stop using submodules for stuff that is not needed for the package itself than to stop using submodules for things that actually matter.\n\nAlso, even if the submodule is not needed for the operation of a package it might often not be harmful to check them out anyway (unless it's from a private repo). | [StefanKarpinski]: There's also the consideration that it's impossible to compute (or verify) the tree hash of a tree with submodules that it is not in a full git repository. Even if we had the submodule content in the right place (as a subdirectory), that's not enough information since submodules are represented by git as a commit entry in the tree object. To verify the commit value of a submodule, you'd have and hash all of the history of the submodule. This is why Pkg3 moved away from identifying versions by commit to identifying them by tree hash only. By allowing submodules in published versions of packages, we'd be reintroducing the whole """"we need to clone an entire repo just to get any version of it"""" problem. I'm afraid that's just not viable: published package versions must have independently verifiable tree hashes that only depend on content, not history. That rules out submodules. | [StefanKarpinski]: The bad news is that the solution here is going to have to be developer-side: when publishing a version of a package that uses submodules, some tool will have to create the actual tree that you want to tag as a version, without any submodules. The good news is that tool can do whatever you want: ignore the submodules or create a tree that includes their content. But in any case, not an issue for Pkg itself to deal with. We can support dev mode for repositories with submodules, but that's it. You cannot add a package with submodules since the tree hash cannot be computed. | [non-Jedi]: >The bad news is that the solution here is going to have to be developer-side: when publishing a version of a package that uses submodules, some tool will have to create the actual tree that you want to tag as a version, without any submodules.\n\nIs it possible to register a package that isn't a git repository? There's nothing documented to that effect, and as far as I can tell all the packages in the General registry are git repos (but then the structure of Registries isn't documented anywhere in the first place). Or are you saying that to make a release one would have to create a new branch with a commit without the submodules?\n\nI've been wanting to play around with darcs but haven't so far mostly just in case I wanted to register the resulting package at some point... | [StefanKarpinski]: > Is it possible to register a package that isn't a git repository?\n\nNot currently, although in the future it will be. The fallback delivery mechanism for packages currently is to git clone a repo and checkout the right tree. Once the Pkg protocol is the primary delivery mechanism, it doesn't matter where the code comes from, it will be decoupled from git.\n\n> Or are you saying that to make a release one would have to create a new branch with a commit without the submodules?\n\nYes, there would have to be somewhere a tagged source tree that is what is installed without any submodules—because submodules cannot be hashed without full git history of the submodules. | [r-barnes]: Today I'm looking at building a simple Julia wrapper around a C++ library. With recursive submodules it's possible to build this very quickly: include the C++ library as a submodule and then construct the necessary Julia files. If the C++ library is later updated, as a developer I now have a clear path for migrating those changes into the Julia library and tracking what's where.\n\nWithout the recursive submodules, I'm not even sure where to begin. Copying the entire remote code base is one possibility, but now that code is out of sync with upstream. | [korsbo]: @r-barnes I'm not an expert but I'm guessing that you would be able to use [`git subtree`](https://www.atlassian.com/git/tutorials/git-subtree) for this. | [StefanKarpinski]: I explained why supporting git submodules in Pkg.add is _technically_ infeasible: it requires a git clone of every submodules but a package version to install is a tree of files and does not include git history of any kind (we've already done that and it was a disaster). Was there some part of that explanation that was unclear?\n\nYou can, however, develop the project however you want using submodules, but then at release time, take a snapshot of the entire work tree, including the content of all submodules, and make that the release. I should also point out that your C++ library use case is exactly what artifacts are for:\n\nhttps://julialang.org/blog/2019/11/artifacts/ | [korsbo]: I know and I thank you for the time you took to explain this! I was, however, suggesting `subtree`s and not `submodule`s. I have never worked with subtrees myself, so I may be off.  But to my understanding, subtrees ensure that everything resides in the main `.git` folder. For all intents and purposes, it's a normal git project but it still allows you to pull changes from your dependency.\n\nPS. My grammarly plugin is warning me that this text has an angry tone. I don't see that myself but in case grammary is right and I'm wrong I thought I'd be explicit about this not being my intention at all. | [StefanKarpinski]: Agree that `git subtree` seems like a good solution, I was responding to https://github.com/JuliaLang/Pkg.jl/issues/708#issuecomment-582129565. | [Teo-ShaoWei]: Since it has been derived by @StefanKarpinski that it is technically infeasible for `Pkg3` to check out the submodule, I would then like to propose that we go with the implementation of `Pkg.add` ignoring the submodules.\n\nFor my org, sadly we have a centralized language-agnostic CI repo which is included inside all project repo as a submodule. I would be very thankful to be able to add Julia repos to each other as dependencies without writing a script to create non-submodule release commits for all of them. | [StefanKarpinski]: Ignoring isn't really feasible either since the submodule is represented as a commit object in a tree. In particular, the commit hash would be included in the git hash of the entire package tree. That means that if there's a git submodule in a tree, it becomes impossible to verify that tree since you cannot compute the tree hash anymore. So allowing submodules at all would make *all* packages cease to be verifiable since any hash mismatch would potentially be explainable by some ignored submodule entry somewhere in the package tree.",17,false,5,5,0,0,0,0,0,0,0
1945,Wishlist: Pkg.add option to ask for confirmation and report changes,open,mashu,,,,10,2020-08-07T13:21:07.0,2021-07-19T21:59:34.0,1808,1461,https://github.com/JuliaLang/Pkg.jl/issues/1945,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1945,"Hi,\n\nIt would be nice if Pkg.add had an option that informs user what it is going to change and requiring confirmation.\nIt does not need to be default, but at least some sorts of report before accepting any changes to current environment.\n\nThanks,","[KristofferC]: You can just do `undo` after a package operation. | [mashu]: > You can just do `undo` after a package operation.\n\nThanks, that's useful. Does it revert back also pre-compiled binaries? It takes a while to build those.\nBut please consider adding such an option to warn user about changes. \n\nThanks! | [StefanKarpinski]: Unclear what you're referring to. Are you talking about prebuilt binary dependencies that are downloaded? Or precompile files ie `.ji` files? | [mashu]: > Unclear what you're referring to. Are you talking about prebuilt binary dependencies that are downloaded? Or precompile files ie `.ji` files?\n\nI am sorry I wasn't aware that binary dependencies that are downloaded can be re-compiled. I think I am referring to anything that is build by """"precompile"""" command. \n\nBut that's just a side question. I was mainly suggesting adding option for users to see what Pkg.add is going to change. | [StefanKarpinski]: Precompilation doesn't happen unless load the package or explicitly ask for it and the ten most recent `.ji` files for each package are kept around in case they are useful again, so there doesn't seem to be any change needed here. | [Vexatos]: As #1937 was declared a duplicate of this issue, I'll repeat my suggestion from there.\n`Pkg.add`, `Pkg.rm`, and `Pkg.update` should all support this. There should be a non-interactive version that merely produces the changes to be done without actually applying any and without asking for user confirmation. Ideally, this could be in the form of a list or dict containing the packages and versions that change; that would make it easier to parse using update automation programs. | [StefanKarpinski]: There are multiple functionalities that seem to me to make this unnecessary:\n\n1. Updates are non-destructive: all an update does is install new versions which can be used instead; the old versions are all still there and usable still.\n1. Changes are tracked in project-local project & manifest files, which can be version controlled and which you can therefore see changes to, e.g. by doing `git diff Project.toml Manifest.toml`; if you revert the changes to the last checked in state, you have undone everything perfectly, and because of the first point that state is guaranteed to still work.\n2. There is already `pkg> undo` which undoes the last operation: if you didn't like it, then undo it. This works even if you happen to have done multiple changes without making a git commit to your project.\n\nSo what would the benefit of a preview option be? Note that we previously *had* a preview option, but it was not very helpful because it was kind of broken because it is quite hard to implement: you have to thread the option through *all* operations and they all have to work in a mode where they make changes as they go or don't.\n\nUltimately I'm somewhat sympathetic to this for a very different reason: I want Pkg to be rearchitected so that it makes a plan of what it's going to do without actually doing anything and then hands that plan off to a separate stage that goes and does all the things (in parallel). In that architecture, this feature becomes easier because it is just a way of presenting the plan to the user without executing it. In that design every command operates in three stages:\n\n1. Pre-command preparations (e.g. update registries)\n2. Parse/interpret command\n3. Plan how to execute command\n4. Execute the plan\n\nIn this scheme, you could prefix any command with `preview` and it would change the last step to """"Display the plan"""" instead of executing it. Once we have that design, we could have this relatively easily, but until then this does seem like a fairly superfluous feature given how Pkg already works. | [Vexatos]: I can only speak for my own use case as an example. What we have is essentially a wrapper around `Pkg` in our UI application in the form of a """"Check for Updates"""" button which lets the user check for updates before performing any actual update. Actually performing the update can take an immense amount of time (as explained in #1937), especially on Windows and on older hardware (a significant number of our users use laptops older than seven years). Updating the registries alone can take multiple minutes, although Julia 1.7 may partially solve this.\n\nEven if updates are non-destructive, they often take so long that many people have to specifically allocate time for it. Getting a preview would allow our program to check whether any updates are available at all and, if there are, would be able to tell how many packages would have to be updated, giving at least a rough estimate of the time the update would take.\nThe way we currently check whether an update is available at all is by manually comparing the git hash found in the `.julia/clones` directory for our program (which is installed through git) with the latest hash found online, which is obviously far from ideal but the only solution available at this time. The old `preview=true` option wasn't ideal either but by rerouting stdout, one could at least parse the output text.\n\nThe main use case for a machine-readable preview (ideally in the form of a vector or dict, as mentioned) would be integration with UI frameworks targeted at a non-technical audience. Not everyone is able to simply ask their users to run a git command or open a Julia REPL, sadly. Our users will likely only ever update packages through our UI, and many have never opened a terminal in their life. | [mashu]: I second that opinion above, having seen a list of packages pending update\nwould give user rough estimate of time, it can take. Furthermore, some\npackages might have artificat dependencies which would mean additional\ndownload time, extreme case is Flux which seems to be downloading CUDA, and\ntake takes ~15min on my laptop. It's not Pkg fault, but in general\nartifacts add to compile time.\nThere could be also a reason not to update if you think, it could break\nsome of the stuff you're working on currently and you might want to delay\nthe update until you finish your coding, but at the same time you need some\nfunctionality and you need to at this very moment decide from which package\nto get it that is actually not breaking your current project.\nFinally, there is another system Gentoo distribution, which uses git for\ntheir packages. As far as I remember it first presents plan before\nupdating/compiling packages, maybe it's a good place to see how they\nimplemented that.\n\n\nOn Sun, Jul 18, 2021 at 2:03 AM Vexatos ***@***.***> wrote:\n\n> I can only speak for my own use case as an example. What we have is\n> essentially a wrapper around Pkg in our UI application in the form of a\n> """"Check for Updates"""" button which lets the user check for updates before\n> performing any actual update. Actually performing the update can take an\n> immense amount of time (as explained in #1937\n> <https://github.com/JuliaLang/Pkg.jl/issues/1937>), especially on Windows\n> and on older hardware (a significant number of our users use laptops older\n> than seven years). Updating the registries alone can take multiple minutes,\n> although Julia 1.7 may partially solve this.\n> Even if updates are non-destructive, they often take so long that many\n> people have to specifically allocate time for it. Getting a preview would\n> allow our program to check whether any updates are available at all and, if\n> there are, would be able to tell how many packages would have to be\n> updated, giving at least a rough estimate of the time the update would\n> take. The way we currently check whether an update is available at all is\n> by manually comparing the git hash found in the .julia/clones directory\n> for out program (which is installed through git) with the latest hash found\n> online, which is obviously far from ideal but the only solution available\n> at this time. The old preview=true option wasn't ideal either but by\n> rerouting stdout, one could at least parse the output text.\n> The main use case for a machine-readable (ideally in the form of a vector\n> or dict, as mentioned) would be integration with UI frameworks targeted at\n> a non-technical audience. Not everyone is able to simply ask their users to\n> run a git command or open a Julia REPL, sadly. Our users will only ever\n> update packages through our UI, and many have never opened a terminal in\n> their life.\n>\n> —\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/JuliaLang/Pkg.jl/issues/1945#issuecomment-881976212>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAATFB2FEQM64E5FZCXOYBDTYIK6FANCNFSM4PXUB4PA>\n> .\n>\n | [StefanKarpinski]: > It's not Pkg fault, but in general artifacts add to compile time.\n\nArtifacts don't involve any compilation, for what it's worth. You just download and unpack them. There is no compilation step. We don't generally use git for package installation anymore, everything is downloaded from package servers first.\n\nAnyway, having a way of presenting what would get updated if a command were run would be possible with the rearchitecting that I'd like to do. It will take a while to get there, but this feature can be added at that point. It might also be good to have a way of knowing how big all the packages and artifacts that are going to be installed are since that would be a consideration for people.",10,false,0,0,0,0,0,0,0,0,0
1822,Julia 1.4 fails to add local package,open,alkoedl,,,,1,2020-05-12T07:57:20.0,2021-07-16T09:59:44.0,1895,1465,https://github.com/JuliaLang/Pkg.jl/issues/1822,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1822,"With Julia 1.3.1 the following command adds a Julia package `PackageName ` which is hosted on my local git server with IP 10.20.30.40:\n\n`pkg> add """"user@10.20.30.40:PackageName.jl""""`\n\nIn Julia 1.4.0 and 1.4.1 the above throws the error\n\n```\nERROR: Path `user@10.20.30.40:PackagesName.jl` does not exist.`\n```\n\nThe same happens with the alternative form outside Package Manager:\n\n```\njulia> using Pkg\njulia> Pkg.add(PackageSpec(url = """"user@10.20.30.40:PackageName.jl""""))\nERROR: Path `user@10.20.30.40:PackagesName.jl` does not exist.\nStacktrace:\n [1] pkgerror(::String) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\Types.jl:53\n [2] handle_repo_add!(::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\Types.jl:558\n [3] handle_repos_add!(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\Types.jl:620\n [4] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; preserve::Pkg.Types.PreserveLevel, platform::Pkg.BinaryPlatforms.Windows, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\API.jl:139\n [5] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\API.jl:112\n [6] #add#27 at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\API.jl:109 [inlined]\n [7] add at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\API.jl:109 [inlined]\n [8] #add#23 at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\API.jl:106 [inlined]\n [9] add(::Pkg.Types.PackageSpec) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\API.jl:106\n [10] top-level scope at REPL[5]:1\n```\n","[KristofferC]: For the API call you probably want:\n\n```\nPkg.add(PackageSpec(url = """"user@10.20.30.40"""", name = """"PackageName.jl""""))\n```",1,false,0,0,0,0,0,0,0,0,0
2671,Pkg.update help string does not make sense regarding the mode keyword,open,bradcarman,,,,0,2021-07-14T15:17:53.0,2021-07-14T15:17:53.0,1466,1466,https://github.com/JuliaLang/Pkg.jl/issues/2671,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2671,"This sentence is not clear to me...\n\n> If no posistional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT.\n\nIf I want to update only the package I specify and leave the Manifest otherwise preserved as is, what should I do to achieve this?",,0,false,0,0,0,0,0,0,0,0,0
2008,Proposal for more first class handing of sysimages in Pkg,open,KristofferC,,,,9,2020-09-06T13:29:02.0,2021-07-12T20:10:15.0,1778,1468,https://github.com/JuliaLang/Pkg.jl/issues/2008,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2008,"## Issue\n\nUsing a custom sysimage can drastically reduce load times of packages. The goto solution for this is PackageCompiler.jl and it works well but it isn't used as much as perhaps warranted considering the benefits it provides. From some discussion, it seems that it is a bit too much of a """"mental overhead"""" to use it. To use PackageCompiler.jl for a sysimage it requires you to:\n\n- Install the package\n- Manually list the packages you want to precompile into a sysimage\n- Make sure you start Julia with that sysimage\n- Make sure you update the sysimage when your dependencies update or you will load old versions of everything.\n  There is currently no way to automatically detect this.\n- For best effect, also provide a """"precompilation execution script"""" that is used to gather data of what functions to precompile.\n\nSince load time of packages and """"time to first plot"""" are a frequent gripe about Julia, it makes sense to see if\nwe can give a better interface to PackageCompiler.\n\n## Proposal\n\nThe proposal here is to introduce a new set of Pkg API that handles sysimages. To give a taste of what a session would look like:\n\n```\npkg> sysimage create\nInfo: Creating a new sysimage based on the packages in curent project at `~/.julia/environments/v1.5/Project.toml` \nPackages tracked by path and their dependencies not put into sysimage:\n    - OhMyREPL\n    └ DataStructures, Crayons\nInfo: Package `OhMyREPL` not put into sysimage because it is tracked by path. This caused its dependencies `OrderedCollect\n\npkg> sysimage status\n(@v1.5) pkg> status\nStatus `~/.julia/environments/v1.5/sysimage.dylib`\n  [6e4b80f9] BenchmarkTools v0.5.0\n  [f68482b8] Cthulhu v1.2.0\n  [0c46a032] DifferentialEquations v6.15.0\n  [7876af07] Example v0.5.3\n  [8fb92a4a] Exfiltrator v0.1.0\n  [b22a6f82] FFMPEG_jll v4.3.1+2\nPackage in project not in sysimage\n  [6e4b80f9] OhMyREPL v0.7.0 `~/JuliaPkgs/OhMyREPL.jl`\n  [ae3bc0f9] DataStructures v0.5.0\n [a8cc5b0e] + Crayons v4.0.4\n\npkg> up\nUpdating `~/.julia/environments/v1.5/Project.toml`\n  [a8cc5b0e] + Crayons v4.0.4\nUpdating `~/.julia/environments/v1.5/Manifest.toml`\n  [a8cc5b0e] ↑ Crayons v4.0.3 ⇒ v4.0.4\n\npkg> sysimage status\nWarn: Some packages in the sysimage are out of date with project, run `sysimage update` to update it:\n  [a8cc5b0e] ↑ Crayons v4.0.3 ⇒ v4.0.4\n...\n\npkg> sysimage update\n...\n```\n\nNext time we start julia:\n\n```\n> julia --project\n\n❯ /usr/local/bin/julia -q\n\nInfo: Automatically using sysimage at `~/.julia/environments/v1.5/sysimage.dylib`\njulia> @time using DifferentialEquations # look how fast\n0.0202 seconds (144.73 k allocations: 7.456 MiB)\n```\n\nSo the concrete proposal here is to add convenience functionalities to Pkg to make dealing with sysimage easier.\n\nIn addition, this proposes adding some functionality to Julia itself that allows it to automatically detect a custom sysimage next to the project and use that for the Julia process. This could be done via some naming convention.\n\n## Why in Pkg and not in a separate package.\n\nThe main point of this proposal is to reduce the friction in using e.g. PackageCompiler. Bundling it with Pkg allows it to use the super user-friendly Pkg REPL with no need to manually install anything. Also, we likely want to use a lot of the code in Pkg for dealing with projects, for status printing, etc so from that point of view, it makes sense to have it in Pkg. One question is if the code for PackageCompiler itself should move into Pkg. I think it is best to not do this but instead, just install PackageCompiler into the global project from Pkg when the `sysimage` command is used for the first time.\n\n## Possible complications:\n\n- Sysimages are not usable across different Julia versions. Right now, upgrading the Julia minor version is super easy. With a custom sysimage one needs to refresh all the sysimages.\n- Creating a sysimage requires a compiler. PackageCompiler provides a compiler via the artifact system on Windows and tries to use a local one on mac/linux. We could just ship a compiler via the artifact system on Mac and Linux as well if there are problems with using the system one.\n- If one has a custom sysimage for the default environment, starts julia, changes the environment, and then start loading packages, packages from the sysimage for the default environment will still be """"locked-in"""". Pkg could warn about this when a new project is activated.\n\ncc @tkf since I think you have thought a bit about stuff like this","[fredrikekre]: > In addition, this proposes ading some functionality to Julia itself that allows it to automatically detect a custom sysimage\nnext to the project and use that for the Julia process. This could be done via some naming convention.\n\nxref https://github.com/JuliaLang/julia/pull/35794 | [tkf]: Yeah, I wrote JuliaLang/julia#35794 so that user-friendly interface like this would be easy to implement.\n\nFWIW, the proposal LGTM. A few minor comments:\n\n> just install PackageCompiler into the global project from Pkg\n\nMaybe do what `--bug-report` does? IIUC it checks for the current environment and then install BugReporting.jl in a temporary environment if it's not installed.  This approach was very handy for fixing BugReporting.jl bugs.  (Ref @StefanKarpinski's comment https://github.com/JuliaLang/julia/pull/35494#issuecomment-614886055)\n\n> * Right now, upgrading the Julia minor version is super easy. With a custom sysimage one needs to refresh all the sysimages.\n\nMy approach in JuliaLang/julia#35794 was to compute system image storage path from (the hash of) the path to `julia` binary.  This way, unmatched system image is not used and `julia` fallbacks to the default system image.\n\nI think it's likely that minor version would be installed in a different path so this may be enough. To be more careful, I think we can include, e.g., Julia version in the hash.\n | [KristofferC]: > Maybe do what --bug-report does? IIUC it checks for the current environment and then install BugReporting.jl in a temporary environment if it's not installed.\n\nYes, that is better.\n\n> I think it's likely that minor version would be installed in a different path so this may be enough.\n\nNot sure it will be enough on mac where I think it is ` /Applications/Julia-1.5.app/Contents/Resources/julia/bin/julia` for all 1.5 versions. | [tkf]: > `/Applications/Julia-1.5.app/Contents/Resources/julia/bin/julia` for all 1.5 versions.\n\nAh, that's unfortunate. I guess I'd have to put the version in the hash if we are going to use JuliaLang/julia#35794.\n | [ericphanson]: This is only semi related to the feature proposed here, but I think it would be helpful if the resolver could take into account the sysimage when choosing versions of dependencies. E.g. if I start with a """"base"""" sysimage with say things like Plots, and then I make an environment and start adding packages to it, it would be great if my shared dependencies / transitive dependencies chose versions that did not conflict with those baked into the sysimage already. Already the manifest you get from a Project.toml depends on the version of Julia you use, but maybe it should actually depend on the sysimage you use (of which Julia version is kind of a special case). \n\nMy actual use-case isn't plots, but is very similar, something like: some process has produced a docker image with Julia and a sysimage and some code and/or other artifacts. Now I want to start from that image and add some more packages. I don't want to regenerate the sysimage (since that takes awhile and the code I'm adding is comparatively light) but I do want versions resolved correctly so I don't run into weird bugs.\n\n> If one has a custom sysimage for the default environment, starts julia, changes the environment, and then start loading packages, packages from the sysimage for the default environment will still be """"locked-in"""". Pkg could warn about this when a new project is activated.\n\nI think the above could help with this; at least, if you don't have a manifest, it could try to resolve a compatible manifest instead of just giving a warning. And if you do have a Manifest, it could warn or maybe even prompt to regenerate the manifest. | [KristofferC]: > This is only semi related to the feature proposed here, but I think it would be helpful if the resolver could take into account the sysimage when choosing versions of dependencies.\n\nIf we store the version of Plots into the sysimage, this could be done. And yes, I think that should be done as a part of this proposal. | [ericphanson]: It seems to me there might be some overlap with https://github.com/JuliaLang/Pkg.jl/issues/1233 in terms of merging projects. I.e. if you have a sysimage loaded, then any project you activate is kind of a """"subproject"""" of the project baked into that sysimage (with regards to version resolution, I'm not talking about folder structure or anything like that of course). | [KristofferC]: Yes, I think that is a pretty good way to look at it. | [ericphanson]: It would be great if this proposal had some way of excluding packages from the sysimage, e.g. just compile the registered dependenices of the package whose environment you are in, so you don't need to recompile the sysimage if you update a dev'd / add'd dependency or the package code itself.",9,false,16,7,0,0,0,0,9,0,0
2667,allow update of any package in manifest,open,StefanKarpinski,,feature request,,0,2021-07-08T15:30:37.0,2021-07-08T15:30:37.0,1472,1472,https://github.com/JuliaLang/Pkg.jl/issues/2667,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2667,"I just had a situation where it would have been really handy to be able to do `up Foo` where `Foo` is a package that's in the manifest but not in the project file. We give a fairly precise error here that you can't do that, but why not? We could just allow updating any package in the manifest. As long as the package name is unique in the manifest there's no ambiguity about which package will get updated; if the user supplies a UUID then there's no ambiguity at all.",,0,false,0,0,0,0,0,0,0,0,0
1888,Feature request: override artifact downloading for specific URLs,open,aplavin,,,,3,2020-06-28T08:07:58.0,2021-07-08T11:34:10.0,1848,1473,https://github.com/JuliaLang/Pkg.jl/issues/1888,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1888,"Currently `Pkg` assumes that artifact URLs can be reached by plain anonymous HTTP GET requests without any specific headers. This is clearly not the case for many services - notably including github releases of private repos. For now I don't see a reasonable way to specify how downloading from specific services/URL happens (see below for a """"non-reasonable"""" approach that works). This ability would be very useful and allow reusing `Pkg.Artifacts` machinery to handle lazy downloads and invalidation.\n\nI have a working example for private github repos that looks like this:\n```julia\n# in Artifacts.toml:\n# [<art_name>]\n# url = https://api.github.com/repos/<user>/<repo>/releases/assets/<asset_id>\n# lazy = true because it cannot be downloaded before importing the code below\n\n# has to be imported before using artifacts in the code\n# concrete types of positional args - more specific than the original method\nfunction Pkg.PlatformEngines.download(url::String, dest::String; kwargs...)\n        if occursin(r""""^https://api.github.com/repos/.*/releases/assets/.*$"""", url)\n            github_api_download(url, dest)  # set proper headers and download\n        else\n            # call original method for other URLs\n            target_m = only([m for m in methods(Pkg.PlatformEngines.download) |> collect if m.module == Pkg.PlatformEngines])\n            invoke(Pkg.PlatformEngines.download, Tuple{fieldtypes(target_m.sig)[2:end]...}, url, dest; kwargs...)\n        end\nend\n\n# artifacts can be accessed normally afterwards:\nartifact""""<art_name>""""\n```\nAs you see, this is not extensible and just wrong - that's why I'm asking for a better override mechanism.","[QuantumBits]: Now that the beta for Julia 1.6.0 is available, it looks like it might be easier to address this issue? \n\nhttps://github.com/JuliaLang/Downloads.jl/blob/master/src/Downloads.jl#L161\n\nNot sure what the best way to manage private headers would be though - proooobably not a great idea to store that info in the Artifacts.toml file, but might be possible to look in an environment variable?\n\nIt would be great to be able to specify downloads that need custom headers for private repos! | [QuantumBits]: One additional use case for this that I would like to see is integration of AWS services, specifically private S3 buckets. | [StefanKarpinski]: Downloads now supports `~/.netrc` files (and session cookies): https://github.com/JuliaLang/Downloads.jl/pull/98. I'm not sure if that addresses these requirements. We could potentially have a mechanism for automatically injecting headers based on the URL during downloads, the main question for that would be how to design that mechanism.",3,false,0,0,0,0,0,0,0,0,0
2665,`no method matching joinpath(::Nothing)` during `download_source` on 1.6.2-pre,open,IanButterworth,,,,3,2021-07-07T15:29:38.0,2021-07-07T17:13:55.0,1473,1473,https://github.com/JuliaLang/Pkg.jl/issues/2665,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2665,"Happening here https://github.com/IanButterworth/SystemBenchmark.jl/pull/48/checks?check_run_id=2994910850#step:5:6\n\non `1.6-nightly` on all platforms\n```\nJulia Version 1.6.2-pre.59\nCommit 134c34397c (2021-07-01 10:27 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.5.0)\n  CPU: Intel(R) Xeon(R) CPU E5-1650 v2 @ 3.50GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, ivybridge)\n```\n\n```\n[ Info: Attempting to clone the General registry\n     Cloning registry from """"https://github.com/JuliaRegistries/General.git""""\n       Added registry `General` to `~/.julia/registries/General`\n[ Info: Successfully added the General registry\nERROR: MethodError: no method matching joinpath(::Nothing)\nClosest candidates are:\n  joinpath(::AbstractString) at path.jl:251\n  joinpath(::AbstractString, ::AbstractString...) at path.jl:296\nStacktrace:\n  [1] stat(path::Nothing)\n    @ Base.Filesystem ./stat.jl:109\n  [2] ispath(path::Nothing)\n    @ Base.Filesystem ./stat.jl:311\n  [3] download_source(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, urls::Dict{Base.UUID, Vector{String}}; readonly::Bool)\n    @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:743\n  [4] #download_source#57\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:733 [inlined]\n  [5] download_source\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:731 [inlined]\n  [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1406\n  [7] build(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, verbose::Bool)\n    @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:906\n  [8] build(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; verbose::Bool, kwargs::Base.Iterators.Pairs{Symbol, IOContext{Base.PipeEndpoint}, Tuple{Symbol}, NamedTuple{(:io,), Tuple{IOContext{Base.PipeEndpoint}}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:900\n  [9] build(pkgs::Vector{Pkg.Types.PackageSpec}; io::IOContext{Base.PipeEndpoint}, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:80\n [10] build(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:96\n [11] top-level scope\n    @ none:1\nError: Process completed with exit code 1.\n```","[IanButterworth]: This appears to be another way that a manifest from another julia version can cause errors\n\nIn 1.6.2:\n\n### Manifest resolved in 1.6.2\nNo error\n\n### Manifest resolved in 1.7\n```\nERROR: TypeError: in typeassert, expected VersionNumber, got a value of type Pkg.Types.VersionSpec\nStacktrace:\n [1] load_urls(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n   @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:545\n [2] #download_source#57\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:732 [inlined]\n [3] download_source\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:731 [inlined]\n```\n\n### Manifest resolved in 1.8\n```\nERROR: MethodError: no method matching joinpath(::Nothing)\nClosest candidates are:\n  joinpath(::AbstractString) at path.jl:251\n  joinpath(::AbstractString, ::AbstractString...) at path.jl:296\nStacktrace:\n  [1] stat(path::Nothing)\n    @ Base.Filesystem ./stat.jl:109\n  [2] ispath(path::Nothing)\n    @ Base.Filesystem ./stat.jl:311\n  [3] download_source(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, urls::Dict{Base.UUID, Vector{String}}; readonly::Bool)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:743\n``` | [IanButterworth]: IIUC the backport of https://github.com/JuliaLang/Pkg.jl/pull/2620 in https://github.com/JuliaLang/Pkg.jl/pull/2628 omitted backporting the manifest `julia_version` incompatibility warning to 1.6\n\nIf we don't backport the warning, I think there may be various odd errors like above that don't have an actionable warning | [IanButterworth]: I propose https://github.com/JuliaLang/Pkg.jl/pull/2666 goes into 1.6.2",3,false,0,0,0,0,0,0,0,0,0
2643,"""add"" updates unrelated dependencies",open,PallHaraldsson,,,,1,2021-06-23T16:11:54.0,2021-07-04T06:39:14.0,1487,1477,https://github.com/JuliaLang/Pkg.jl/issues/2643,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2643,"If there are no dependencies (as here, not even a Project file), shouldn't """"add"""" be quick, and not update anything?\n\nHappened on Julia 1.6.0 (fixed on later 1.6? or 1.7, 1.8? Not sure).\n\nI'm pretty sure I saw (completely unrelated) """"Libiconv_jll v1.16.1+1"""" before it disappeared, that triggered 97 dependencies updated:\n\n```\n(@v1.6) pkg> add PlusPlus\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n  No Changes to `~/.julia/environments/v1.6/Project.toml`\n    Updating `~/.julia/environments/v1.6/Manifest.toml`\n  Progress [========================================>]  102/102\n  ? Makie\n97 dependencies successfully precompiled in 82 seconds (384 already precompiled, 4 skipped during auto due to previous errors)\n1 dependency failed but may be precompilable after restarting julia\n```\n\nI guess it could be ok to have it updated, since it was a minor version update, if that, it may have been from """"Libiconv_jll v1.16.1+0"""". I'm not sure on which side of the + the zero was at. Anyway, if update can happen for any package (or maybe only JLL), then there could still be a bug/incompatibility in the updated version despite of semver. Mostly the wait is annoying.\n\nI've experienced strange update before, if I recall with a Project file in case it matters, and not as here REQUIRE.","[IanButterworth]: Firstly, I'd recommend updating to 1.6.1 (and 1.6.2 when it comes out shortly). 1.6.1 fixed an overprinting bug in the output above which confuses the info printed. and the precompilation of loaded packages (Makie in your case) has improved a little in 1.6.2.\n\nThe garbled output above has hidden that the work being done during the `Progress [========================================>]  102/102` is precompilation. It's not that the packages are being _updated_.\n\nSomehow your system got into a state where it updated other packages previously, but Pkg didn't finish precompiling them. That could've happened if you `ctrl-C`-ed during precompilation, for instance.\n\nIn typical use, Pkg should be able to keep everything precompiled efficiently. Your experience above should be rare.\nThe one exception is when you're using a new julia version, which will retrigger precompilation for all packages.",1,false,0,0,0,0,0,0,0,0,0
2572,Tree Hash Mismatch installing JLD (error on Lz4 artifact),open,mlakolar,StefanKarpinski,,,0,2021-05-26T03:13:58.0,2021-07-02T16:04:47.0,1516,1478,https://github.com/JuliaLang/Pkg.jl/issues/2572,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2572,"Per suggestion [here](https://discourse.julialang.org/t/tree-hash-mismatch-while-installing-jld-on-julia-1-6-1/61804/5?u=mkolar) I am opening an issue here.\n\nThe error first appeared when adding the JLD package on a newly installed Julia Version 1.6.1 (2021-04-23) on a cluster. But it appears when adding any package that download an artifact.\n\n```\n(@v1.6) pkg> add JLD\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n Downloading artifact: Lz4\n┌ Error: Tree Hash Mismatch!\n│   Expected git-tree-sha1:   ad2663460a9a7c142287f3ccbe13e95952537c6d\n│   Calculated git-tree-sha1: 77e9c15a7afb54ebf1738b5b769a8dd1a8a8683d\n  Downloaded artifact: Lz4\n Downloading artifact: Lz4\n┌ Error: Tree Hash Mismatch!\n│   Expected git-tree-sha1:   ad2663460a9a7c142287f3ccbe13e95952537c6d\n│   Calculated git-tree-sha1: 77e9c15a7afb54ebf1738b5b769a8dd1a8a8683d\n  Downloaded artifact: Lz4\nERROR: Unable to automatically install 'Lz4' from '/home/mkolar/.julia/packages/Lz4_jll/Dno0g/Artifacts.toml'\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:33\n  [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n    @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443\n  [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n    @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508\n  [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706\n  [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683\n  [6] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Vector{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1237\n  [7] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Iterators.Pairs{Symbol, Base.TTY, Tuple{Symbol}, NamedTuple{(:io,), Tuple{Base.TTY}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:203\n  [8] add(pkgs::Vector{Pkg.Types.PackageSpec}; io::Base.TTY, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:79\n  [9] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:77\n [10] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL)\n    @ Pkg.REPLMode /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:408\n [11] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386\n [12] do_cmd\n    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]\n [13] (::Pkg.REPLMode.var""""#24#27""""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool)\n    @ Pkg.REPLMode /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550\n [14] #invokelatest#2\n    @ ./essentials.jl:708 [inlined]\n [15] invokelatest\n    @ ./essentials.jl:706 [inlined]\n [16] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n    @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441\n [17] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n    @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126\n [18] (::REPL.var""""#44#49""""{REPL.LineEditREPL, REPL.REPLBackendRef})()\n    @ REPL ./task.jl:411\n\n```\n\nThis is the output from `DebugArtifacts`\n\n```\njulia> using DebugArtifacts\n\njulia> debug_artifact(""""Lz4"""")\n[ Info: Platform: Linux x86_64 {cxxstring_abi=cxx11, julia_version=1.6.1, libc=glibc, libgfortran_version=4.0.0, libstdcxx_version=3.4.25}\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, westmere)\n\n[ Info: Downloading Artifacts.toml to /tmp/jl_wKhE9K/Artifacts.toml...\n[ Info: Extracting artifact info for platform x86_64-linux-gnu-libgfortran4-cxx11-libstdcxx25-julia_version+1.6.1...\n[ Info: Found meta object with git-tree-sha1 25d411cb0031c3b42c10c945cdf6eb5253cb44b7, attempting download...\n[ Info: No hash cache found\n[ Info: Calculated hash 420a3d41fd0a146a4f29860e35fd02217a3e95b3b08f0cd0bfb6e13f42eb96da for file /tmp/jl_RzWudD-download.gz\n[ Info: Unpacking /tmp/jl_RzWudD-download.gz into /tmp/jl_wKhE9K/unpacked...\n[ Info: Double-checking git-tree-sha (this is skipped on Windows)\n```\n\n\n",,0,false,0,0,0,0,0,0,0,0,0
2615,misleading info given by `Pkg.status()`,open,ThomasBreuer,,,,3,2021-06-11T10:03:06.0,2021-06-11T13:42:21.0,1500,1500,https://github.com/JuliaLang/Pkg.jl/issues/2615,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2615,"The following happens with Julia 1.5.3.\nMy `DEPOT_PATH` consists of two paths, the one to the `.julia` subdirectory of my home directory and another one, and the latter is active.\nWith `Pkg.status()`, I get a list of packages. One of them is marked with an arrow, and an info message says\n\n> packages marked with → not downloaded, use `instantiate` to download\n\nHowever, the package in question can be loaded without problem.\nWhen I try (just for curiosity) `instantiate` then apparently some artifact gets downloaded to `/tmp` but otherwise nothing changes.\nI must admit that `~/.julia/artifacts/Overrides.toml` contains a redirection for the package in question, and the path stored there is not valid anymore (and the problem disappears when I correct this path), but why does `Pkg.status()` look into this place, which is not relevant for the active environment?","[KristofferC]: My guess is that https://github.com/JuliaLang/Pkg.jl/blob/0de93211d96c57c1617000a683b70a70154439d5/src/Operations.jl#L622-L632 returns false which it should return true.\n\nIt could be https://github.com/JuliaLang/julia/blob/e35028acd307db6c33cf857c5faa1da497d197ad/stdlib/Artifacts/src/Artifacts.jl#L252-L254 that is not correctly finding the artifact. You could try calling it manually.\n\nYou could dig down a bit into those functions and see if you find something. | [ThomasBreuer]: @KristofferC Thanks for the hint.\n`Pkg.Artifacts.artifact_paths` returns an array of length two (corresponding to the two paths in `DEPOT_PATH`) if `honor_overrides` is `false`, and in the `true` case it returns an array of length one, corresponding to the entry in `~/.julia/artifacts/Overrides.toml`; this entry is an invalid path.\nThis means that this `Overrides.toml` file overrides the settings for *all* environments, not just for the one where the file resides (the currently inactive `~/.julia`).\nThis seems to be not consistent with the behaviour of `using`, since this command finds the artifact in the path of the active environment (without override). | [KristofferC]: I agree that they should agree with each other. I think this makes it an issue for the Julia repo then since it seems like that is where the disagreement is?",3,false,0,0,0,0,0,0,0,0,0
2591,An option for `]test` to run under `rr`,open,vtjnash,,feature request,,9,2021-06-03T01:17:56.0,2021-06-09T19:27:24.0,1508,1501,https://github.com/JuliaLang/Pkg.jl/issues/2591,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2591,"Being able to specify `--bug-report=rr-local` or `--bug-report=rr` would be very useful. Then reproducing a test failure is as simple as `Base.require(Main, :BugReporting).replay(""""/file/path"""")` without needing to mess with temporary environments and such","[DilumAluthge]: I think that you can provide command-line args in the `julia_args` keyword argument to the `Pkg.test` function. | [DilumAluthge]: Try this and let me know if it works?\n\n```julia\nPkg.test(; julia_args = [""""--bug-report=rr-local""""])\n``` | [vtjnash]: That appears to run the REPL instead of the tests | [vtjnash]: It seems to work, but is pretty long:\n\n`\nwhile true; do ./julia -e 'using Pkg; Pkg.test(""""SPICE"""", julia_args=[""""--bug-report=rr-local"""", """"/home/vtjnash/.julia/packages/SPICE/CjGzi/test/runtests.jl""""])' || break ; done\n` | [vtjnash]: Oh, though perhaps that is also stripping off `--project`? | [DilumAluthge]: Hmmm. In theory, you shouldn't need to worry about passing the `runtests` file or anything like that.\n\nIf you do this, what happens? You just get the REPL?\n\n```julia\njulia> Pkg.test(""""SPICE""""; julia_args = [""""--bug-report=rr-local""""])\n```\n | [KristofferC]: Yes, you get a REPL but the reason for that is that you also get a REPL when doing `julia --bug-report=rr-local --eval 'print(""""hello"""")'` (which is similar to how Pkg invokes Julia to run the tests). | [DilumAluthge]: Oh, interesting.\n\nIt might be useful to add a feature in which you can do e.g. `julia --bug-report=rr-local-no-repl my_script.jl` or `julia --bug-report=rr-local-no-repl --eval 'print(""""hello"""")'` and not get a REPL (i.e. have Julia exit once it is done).\n\nIf that feature were added, then it would be easy enough to do e.g.:\n```julia\nPkg.test(""""SPICE""""; julia_args = [""""--bug-report=rr-local-no-repl""""])\n``` | [vtjnash]: I have solved this with a small helper script:\n\n```\n$ cat bin-rr/julia \n#!/bin/sh\nrr record --nested=detach $(dirname $(dirname $0))/bin/julia """"$@""""\n\n$ JULIA_BINDIR=~+/bin-rr ./bin/julia\n```",9,false,1,1,0,0,0,0,0,0,0
11,Feature Request: Show which versions of a package are installable given the current project,open,Keno,,feature,,16,2017-10-20T22:15:18.0,2021-06-09T12:19:21.0,2829,1502,https://github.com/JuliaLang/Pkg.jl/issues/11,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/11,I'd like to have a command that shows all the versions of a new package I could add to my Project without conflicting with existing requirements.,"[Nosferican]: I think I can work on this. | [StefanKarpinski]: One thing that will be useful here—the `Pkg.Types.compress_versions` function:\n\n>     compress_versions(pool::Vector{VersionNumber}, subset::Vector{VersionNumber})\n> \n> Given `pool` as the pool of available versions (of some package) and `subset` as some\n> subset of the pool of available versions, this function computes a `VersionSpec` which\n> includes all versions in `subset` and none of the versions in its complement.\n\nThis will be very useful for printing out a nice, condensed string for which versions can be installed. So basically the process is:\n\n1. Figure out all the possible versions of a package that could be installed (`pool`)\n2. Go through them and see which are compatible with everything in the current project (`compat`)\n3. Print `compress_versions(pool, compat)` as the compatible version specification. | [KristofferC]: Is there any other way to figure out if installing a package at a certain version will error other than running the full resolver? | [StefanKarpinski]: Just check if it violates any compatibility constraints with the other versions. | [Nosferican]: I was leaning towards testing each version by passing the fixed `add_reqs!(graph, reqs)` and testing whether it finds a solution.\n1. Read dependency and compat from Project.toml\n2. Generate a Graph based on it\n3. Find all versions for a given package\n4. Filter the versions based on graph successfully solving problem\n5. Compress versions | [KristofferC]: > Just check if it violates any compatibility constraints with the other versions.\n\nThe package has dependencies which have possible version ranges that needs to have no violations. Sure you can look at only the compatibility of only the """"top"""" package but it won't tell you very much. | [StefanKarpinski]: Perhaps I'm misunderstanding the feature request. I was assuming that there was was an existing manifest with specific versions that one wants to add a compatible version of some package to. | [Nosferican]: @Keno Could you clarify if it should be related to the `Project.toml` or a `Manifest.toml`?\nMy understanding is that given a `Project.toml`, one would like to find what versions are compatible with the specified dependencies/compat in that file. For example, finding the lowest `Compat.jl` required. | [StefanKarpinski]: > My understanding is that given a `Project.toml`, one would like to find what versions are compatible with the specified dependencies/compat in that file.\n\nIsn't this exactly what `resolve` does? Is this like a speculative resolve feature? | [Nosferican]: I think the only difference between `resolve` and this one would be that `resolve` will yield the solution (pick the latest compatible) while this request wants to get all the pool right before choosing the latest in the `resolve` pipeline. | [StefanKarpinski]: Resolve is allowed to change all the versions of other packages and which version of a given package you pick could potentially affect all of the others. The algorithm does not work by generating all possible combinations of versions and then picking the latest of each. Or put another way, it's not the case that you can choose independently a version of A from 1.2.3-2.4.5 and a version of B from 3.4.5-4.5.6: the choice of A affects the allowable choices of B and vice versa. So finding the set of allowable versions of A taken of the union of all versions of B is kind of meaningless information. The thing that would make sense is asking what set of versions of A are allowed given a fixed version of all the other packages. | [Nosferican]: Aye. I believe that is the request. In other words, get all dependencies except the target package, solve that Graph and fixed to the version in the solution. The iteratively attempt to find a solution by adding the target package and a fixed version from the pool. Exclude versions that fail to find a solution in the graph. | [Keno]: I unfortunately don't remember exactly what I wanted here, but I suspect it's something like """"Which versions of the GPU ecosystem would this work with"""", so I'd ask something like `which CUDAnative` and it'd tell me the version ranges I can use. | [Keno]: Which I think indicates that it's based on `Project` (since I don't really care if I need a different `Compat` version for that). The manifest version with a switch would be useful too though. | [racinmat]: It would be great, it would definitely help to deal with obscure bugs in package dependency incompatibilities. | [fonsp]: This would be very helpful for https://github.com/fonsp/Pluto.jl/pull/844",16,false,1,1,0,0,0,0,0,0,0
2590,Artifact download failure is not reported in package-server mode,open,aviks,,,,0,2021-06-02T22:23:58.0,2021-06-02T22:24:38.0,1508,1508,https://github.com/JuliaLang/Pkg.jl/issues/2590,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2590,"I am trying to install a private pacakge from a package server. The package has an artifact, and download of that artifact fails (in my case, due an incorrect IP whitelist, but that is besides the point). \n\nI would expect Pkg to throw an error with the details of the download failure. Instead, Pkg tries to silently move to cloning the package from git. The artifact download error is completely and sliently ignored. \n\nNow when Pkg successfully gets the package via git (which depends on your git credential setup), it then throws an error around the artificact download. But if git credentials are not setup, it just looks like the package server fails to serve packages, which is not true. \n\n```\n(@v1.6) pkg> add MyPackage\n   Resolving package versions...\n   Installed JLD2 ─────────── v0.4.7\n     Cloning [xxxxxxxx-xxxx-xxxx-xxxx-3dd372e7c8c7] MyPackage from https://github.com/MyOrg/MyPackage.jl.git\n   Installed MyPackage─ v0.3.2\n  Downloaded artifact: ABC\n  Downloaded artifact: ABC\nERROR: Unable to automatically install 'ABC' from 'C:\Users\avik\.julia\packages\MyPackage\zzzzz\Artifacts.toml'\nStacktrace:\n  [1] error(s::String)\n    @ Base .\error.jl:33\n  [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY)\n```\n\n(As an aside, note the dupliaate `Downloaded` lines. Also note that the actual underlying HTTP error is still not reported. But those are peripheral to this issue.)\n",,0,false,1,1,0,0,0,0,0,0,0
2586,Question: Should we document the `manifest` kwarg in the docstring for the `Pkg.instantiate` function?,open,DilumAluthge,,documentation,,5,2021-06-02T06:06:46.0,2021-06-02T12:50:11.0,1509,1509,https://github.com/JuliaLang/Pkg.jl/issues/2586,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2586,"The `Pkg.instantiate` function accepts the `manifest` keyword argument. E.g. you can do `Pkg.instantiate(; manifest = false)` to ignore the manifest file when instantiating.\n\nIs the `manifest` kwarg part of the public API for the `Pkg.instantiate` function? And if so, should we document it in the docstring?","[KristofferC]: Looks like that was there from the start (https://github.com/JuliaLang/Pkg.jl/pull/278). I'd rather just remove the argument, you can just delete the Manifest if you want that. | [DilumAluthge]: I kind of like the argument. I'd rather just leave the argument (and leave it undocumented) than remove the argument. | [DilumAluthge]: Also, the REPL uses the argument, and documents it in the manual: https://pkgdocs.julialang.org/v1/repl/#repl-instantiate | [ufechner7]: > Looks like that was there from the start (#278). I'd rather just remove the argument, you can just delete the Manifest if you want that.\n\nPlease don't delete this argument. For me it is important to have this option. I want to get rid of my bash scripting that is currently needed to update the packages after a git pull, and this feature solves one of the two issues with Pkg. See: https://discourse.julialang.org/t/how-to-update-packages-and-create-a-system-image/62229 | [ufechner7]: Also see: https://github.com/JuliaLang/Pkg.jl/issues/2585",5,false,0,0,0,0,0,0,0,0,0
1938,allow `] add path_or_url/to/tarball`,open,StefanKarpinski,,feature request,,0,2020-08-02T15:29:16.0,2021-06-02T10:18:48.0,1812,1509,https://github.com/JuliaLang/Pkg.jl/issues/1938,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1938,"Despite being called """"fundamentally wrong"""" and """"scum of the earth"""" in [this issue](https://github.com/JuliaLang/Pkg.jl/issues/1506), I do think that it's a good idea to allow installing packages from plain tarballs in addition to supporting git repos. Arguably, installing from tarball should be the core way of adding a package, whereas if the link is a git repo, that's just a special way of producing a tarball (bare clone and `git archive` the default branch to produce a tarball which is then installed). I'm going to aim to get this done for 1.6 as part of the ongoing rework of downloading and installing packages.",,0,false,5,5,0,0,0,0,0,0,0
1724,Give hint for replacement of Pkg.installed() in deprecation warning,open,stefan-m-lenz,,,,6,2020-03-19T18:37:07.0,2021-06-01T10:44:40.0,1948,1510,https://github.com/JuliaLang/Pkg.jl/issues/1724,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1724,"In Julia 1.4.0-rc2, `Pkg.installed()` is now deprecated:\n\n```\njulia> using Pkg\n\njulia> Pkg.installed()\n┌ Warning: Pkg.installed() is deprecated\n└ @ Pkg D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\Pkg.jl:531\nDict{String,VersionNumber} with 3 entries:\n  """"StatsBase""""         => v""""0.32.2""""\n  """"BoltzmannMachines"""" => v""""1.2.0""""\n  """"Tables""""            => v""""1.0.3""""\n```\n\nIt would be helpful if the deprecation message gave some hint about the replacement. Could you tell me what the alternatives are for using `Pkg.installed`?\n\nThank you very much!","[stefan-m-lenz]: In this issue there is already a discussion about `Pkg.installed`: https://github.com/JuliaLang/Pkg.jl/issues/697\n\nI find the solution to use `Pkg.add` not sufficient because it seems a bit heavyweight, in particular I would like to avoid output to the command line. | [DilumAluthge]: The replacement for `Pkg.installed` is `Pkg.dependencies`.\n\nhttps://julialang.github.io/Pkg.jl/dev/api/#Pkg.dependencies | [stefan-m-lenz]: Thanks @DilumAluthge \n\nWhen I click at the link it says that this is an """"experimental feature"""". Will this be experimental after the release of Julia 1.4? If yes, then I would say that the deprecation of `Pkg.installed` is too early. Deprecation says: """"Please migrate your code"""" and this then forces migrating to code that is experimental.\n\nBesides that, the replacement seems worse to me: `Pkg.installed` allows an access via the name of the package. With `Pkg.dependencies`, I need the UUID, which I have to search first. If I use it in code then, I have to document this seperately, whereas I can get the meaning of the code `""""Tables"""" in keys(Pkg.installed())` at one glimpse. (But this could, of course, also be more straigthforward.)\n\n | [MTone92]: If you just want to see the packages installed, you don't necessarily need Pkg. Instead, you can type `]` in your console to get into pkg environment and simply type `st` to show all the packages installed by yourself. | [stefan-m-lenz]: @MTone92 The problem with `Pkg.status` is that it prints something. `Pkg.installed` returns a Dict, which can easily be inspected in code (not only manually). So `Pkg.status` is not a suitable replacement for `Pkg.installed`. | [liurui39660]: If possible, can add a subcommand `list` or `ls`? I think many package managers use this for listing installed packages rather than `status` or `st`. As a new user, I feel quite confused when I can't find the `list` subcommand in such a package manager.",6,false,12,12,0,0,0,0,0,0,0
480,interface for adding a test dependency,open,tpapp,,REPL; sandbox; feature,,12,2018-07-09T08:43:17.0,2021-05-18T00:12:11.0,2568,1524,https://github.com/JuliaLang/Pkg.jl/issues/480,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/480,"It would be great to have the functionality of #340 exposed in the interactive interface, so that one does not have to manually edit the `Project.toml`. Eg something like\n```julia\npkg> add targets.test SomePackage\npkg> rm targets.test SomePackage\n```\nor simply `add test`.","[IainNZ]: I'd be interested in tackling this. Is the idea to add it as a PR for this repo, then it gets copied into julia main repo? | [StefanKarpinski]: Right, package features are developed here and then upstreamed (usually by @KristofferC) into the Julia main repo `stdlib/Pkg` directory. To load a development copy, you'll want to comment out the `uuid = ` entry in the `Project.toml` file and then run `julia --project` from there and do `import Pkg`, although for some reason that has started to give me a conflicting binding error. @JeffBezanson, did you change something that causes `Main.Pkg` to be definitively resolved to `stdlib/Pkg`? | [StefanKarpinski]: @IainNZ, if you haven't started on this yet, you may want to hold off for a bit... I may change things that will conflict significantly with anything you do here. I'm trying to implement #165 but it's leading to a bit of design rethought on targets, alternatives, etc. | [IainNZ]: Haven't started yet - will follow that. Got ~10 days of down time so no rush. | [tkf]: Related to this, is there (or are you planning to implement) an interface for activating test environment?\n\nLet's say I have `JSON` in my `targets.test.deps` but not in `deps`:\n\n```toml\n[deps]\nCompat = """"34da2185-b29b-5c13-b0c7-acf172513d20""""\n\n[targets.test.deps]\nJSON = """"682c06a0-de6a-54ab-a142-c8b1cf79cde6""""\n```\n\nThen how do I debug my tests? If I do `include(""""test/runtests.jl"""")` in REPL started with `julia --project` it says that `ArgumentError: Package JSON not found in current path`.  Checked with:\n\n```\njulia> versioninfo()\nJulia Version 0.7.0-beta2.48\nCommit c6a949a9c3 (2018-07-19 18:28 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-4500U CPU @ 1.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-6.0.0 (ORCJIT, haswell)\n```\n\nOr is there something wrong in my workflow?  Are there better ways to run tests in REPL namespace (i.e., not in subprocess via `pkg> test`)? | [KristofferC]: Yes, this is a bit annoying. You could just comment out the `[targets.test.deps]` and those should then apply to `[deps]`. @StefanKarpinski has another design idea where all packages are put under `[deps]` which might help with this. | [StefanKarpinski]: Yes, I'm working on that and should be done with it today. In this design, `targets` is just a way of choosing subsets of all the dependencies. So far it seems like a cleaner design in general. | [tpapp]: If #531 is the solution for the `Project.toml` file, then I could imagine \n```julia\npkg> add test=SomePackage\n```\nfor\n1. adding `SomePackage` to `[extras]`, if not already present,\n2. pushing `SomePackage` to `test = ` in `[extras]` | [StefanKarpinski]: Maybe `pkg> add SomePackage --target=test`? | [cossio]: Or just `pkg> add SomePackage target=test` (without `--`)? Similar to how you add keyword arguments to macros in proper Julia. | [StefanKarpinski]: We may want to do some design work on the pkg REPL syntax. It's grown somewhat organically and now that we have some more experience with what needs to be supported, we can think about it a bit more thoroughly. Since it's an interactive mode, we can make breaking changes. | [anandijain]: bump on this, it still feels so dang crude to have to manually edit the toml to add the `Test` package as a test dep when starting a fresh project",12,false,21,21,0,0,0,0,0,0,0
2553,The default behavior of the update command is not documented,open,bicycle1885,,,,0,2021-05-06T21:56:32.0,2021-05-06T21:56:32.0,1535,1535,https://github.com/JuliaLang/Pkg.jl/issues/2553,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2553,It's not clear from the current documentation which modes and levels are used if no options are provided.\n\nhttps://github.com/JuliaLang/Pkg.jl/blob/d4089a259fa8765a3486ee6736bbce1518514029/src/REPLMode/command_declarations.jl#L298-L312,,0,false,0,0,0,0,0,0,0,0,0
2507,Support multiple package servers,open,hogandp,,,,6,2021-04-12T13:18:09.0,2021-05-05T18:54:30.0,1560,1536,https://github.com/JuliaLang/Pkg.jl/issues/2507,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2507,"It would be helpful if the JULIA_PKG_SERVER variable accepted more than one package server for use in offline, CI/CD or private environments.\n\nCurrently the JULIA_PKG_SERVER variable takes a single url or path, it would be nice if it accepted a lists of paths such as how the unix PATH variable works, e.g. JULIA_PKG_SERVER=""""http://a.b.c;http://e.f.g""""","[fredrikekre]: You can use https://github.com/fredrikekre/MuxPkgServer.jl. | [StefanKarpinski]: I'm still against this. The point of the pkg server is that provides a single definitive authority for the client's view of the world. If you instantiate a manifest with a pkg server it can later be reinstantiated with the same pkg server. If there is a set of pkg servers, there are suddenly lots of hard questions to answer. What if the same registry is served by different servers in the set but they advertise different states of that registry? What if a manifest uses packages provided by different pkg servers? Is there any closure guarantee that we can make?\n\nSuppose, for the sake of argument, that we get each package or artifact from the first pkg server that knows about it. Now, suppose that only a later server knows about some package version and we get it from there. But one of its dependencies in the manifest is known to the earlier pkg server, so we get it from there. Now, it's entirely possible that the full manifest is never requested from either pkg server, so neither of them gets a chance to fetch the complete set of resources and make sure they are persisted by the storage server.\n\nUltimately, someone needs to decide on a coherent view of the world and be able to store it and reproduce it. A large part of the point of the pkg protocol is that the pkg server presents a single, coherent and reproducible world view. This proposal pushes the responsibility for creating a coherent world view onto the client, which is not persistent or reproducible and which we should basically assume is ephemeral.\n\nRegarding MuxPkgServer: it seems like that should just be PkgServer with upstream pkg servers as is backing storage servers. That would give you caching for free, which is presumably desirable. It has logic to handle the situation when the multiple upstream servers serve the same registry but might be out of sync about what state of it they are serving (serves the latest version). It also makes HEAD requests for each resource to all upstream servers the first time it fetches it, giving each upstream server a chance to have a complete world view. @fredrikekre, is there some reason that PkgServer.jl cannot be used for this? | [johnnychen94]: Muxing the pkg servers might be too risky for reproducibility. Here's an alternative that chooses the nearest pkg server during the Julia start: https://github.com/johnnychen94/PkgServerClient.jl\nBasically, if you have a private pkg server setup of the General registry, you just get there since it's the nearest one.\n\nIt probably won't fit your use case because it assumes that all pkg servers provide the """"same"""" General registry. | [fredrikekre]: > @fredrikekre, is there some reason that PkgServer.jl cannot be used for this?\n\nNo, you can definitely do that. The MuxServer is much more lightweght though (no caching, no registry updating etc). I agree it might not be a good think to configure this to be a """"serious package server"""", but it can still be useful for testing or local usage IMO. | [hogandp]: Rolling back the point of this, which I didn't explain well, is to use more than one pkg server to host a unique registry on each.\n\nThis is not a request to connect to redundant package servers hosting the same content, and I 100% agree with @StefanKarpinski views on that, its a mess and should be prevented.\n\nMuxPkgServer does most of what I'm looking for, but why do we need an external package for this? You can have multiple registries in the Julia world, why do they need to be co-located on the same pkg server?\n\nI am currently supported this use case by manual modification to the pkg server """"registries"""" file as well as some filesystem foo to combine things. Its hackish, and I know I am not the only person looking to do this, exactly why packages like MuxPkgServer, JuliaOffline exist, need more proof: [""""Julia Offline"""" Google Search](https://lmgtfy.app/?q=julia+offline).\n\nI do suggest this be enforced with consistency checks, e.g. only 1 copy of a registry UUID is allowed on """"all"""" specified pkg server servers, in the event of a pkg UUID conflict there be an intelligent error message and stop (maybe the pkg add has to be extended to support <RegistryName>/<PackageName> in this case or throw and error and force the user to correct it manually?\n\nIf you are still vehemently opposed to this I'll continue on my way of hacking at the filesystem to work around this, and looking into MuxPkgServer more but would rather have a clean and reusable solution built directly into the Julia pkg system. | [StefanKarpinski]: The issue is that even if there's zero overlap between what's served by different package servers (which we cannot assume and have to deal with in some sane way), a single manifest will still potentially have packages that it got from multiple different package servers and then there's no entity that can reconstruct any manifests at all. As compared with now where there must be *some* package server that can reconstruct all of a manifest.",6,false,4,3,1,0,0,0,0,0,0
961,status has no option to show all packages across the environment stack,open,krcools,,,,22,2018-12-11T13:19:23.0,2021-04-26T23:39:12.0,2413,1545,https://github.com/JuliaLang/Pkg.jl/issues/961,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/961,Only packages available in the top tranche can be queried. Deeper packages are available for `using` but are not listed.,"[fredrikekre]: `status --verbose`? | [StefanKarpinski]: `status --all` maybe? | [SimonDanisch]: Maybe just show a hint like:\n```\n(pkgtmp) pkg> st\n    Status `C:\Users\sdani\pkgtmp\Project.toml`\n    This environment is part of stack [v1.1, ...] use st --all to show all available packages\n  (empty environment)\n```\nthis would make it self documenting and much easier to learn about stacked environments ;) | [KristofferC]: I don't think the output of commands is a good place to put documentation. You read it once and then it is annoying. | [SimonDanisch]: I think `st` is mainly an exploration tool for environments usually outputting tons of text, so I can't really image how anyone could get annoyed by that one line ^^\nFor a compromise, I do think that the stack part is crucial information we should add - but I see how the """"tool-tip"""" part is more debatable. | [KristofferC]: Stack part is documented at https://docs.julialang.org/en/v1.1/manual/code-loading/#Environments-1 but we can of course add a note about it somewhere. | [SimonDanisch]: Yeah I got that, but I didn't even realize I had to search for it ;) \nAlso, i meant a note about the current stack, not that stacking exists - which is usefull information, since that can be quite different, no? | [KristofferC]: Sorry, https://docs.julialang.org/en/v1.1/manual/code-loading/#Environment-stacks-1 is a better link.\n\n`LOAD_PATH` defines the stack (and the current active project in Pkg). | [SimonDanisch]: Yeah, that's documented if you search for it, but why not have a small hint about the current stack in st? It's a crucial part of your environment, and `st` is the function to call, when you want to learn crucial information about the environment! It's the one and only purpose of `st` after all :D \nAlso, the content of `LOAD_PATH` is pretty verbose:\n```Julia\n(pkgtmp) pkg>\n\njulia> Base.LOAD_PATH\n3-element Array{String,1}:\n """"@""""\n """"@v#.#""""\n """"@stdlib""""\n```\nIs the `@` the pkgtmp environment? | [SimonDanisch]: I guess that's the option one wants to call:\n```julia\njulia> Base.load_path()\n3-element Array{String,1}:\n """"C:\\Users\\sdani\\pkgtmp\\Project.toml""""\n """"C:\\Users\\sdani\\.julia\\environments\\v1.1\\Project.toml""""\n """"C:\\Users\\sdani\\AppData\\Local\\Julia-1.1.0\\share\\julia\\stdlib\\v1.1""""\n``` | [StefanKarpinski]: Agree, we should probably display all packages in the entire load path with some indication of which environment in the stack each one comes from. | [KristofferC]: In 99% of the cases I don't care about my `.julia/environments` packages when I am in another environment. Showing that for `st` would be very spammy imo. `st --all` or something is of course fine. | [SimonDanisch]: Ok, so showing the full path to the toml is by that philosophy also spammy, is it?\nWhy not show a short version like\n```Julia\n(v1.1) pkg> st\n    Environment stack: [v1.1, stdlibs]\n    ...\n```\n```Julia\n(my_env) pkg> st\n    Environment stack: [my_env, v1.1, stdlibs]\n    ...\n```\nThis would be even less characters, and I'd argue in 99% of the use cases you wouldn't want to know the full path to the env. For your own env, you just activated it, and """"v1.1"""" and """"stdlibs"""" seem like pretty clear names... If someone pushes a path, one won't be able to show a short version of that, but that seems exactly like the case where it's crucial information, that even though you just activated a new env, some path in LOAD_PATH sneaked in. | [StefanKarpinski]: I think that a `st -a` would be good. Indicating what's in the environment stack also seems good. | [KristofferC]: I have ~40 packages in my home environment. Showing them all the time on `st` is spammy yes. | [SimonDanisch]: Oh, maybe there has been a missunderstanding? I'm not arguing for showing the packages, I'm just arguing for showing the stack an env belongs to.\nSo the output of an empty env would show as:\n```julia\n(pkgtmp) pkg> st \n Environment stack: [pkgtmp, v1.1, stdlibs]\n(empty environment)\n```\nMaybe one can indicate in the above, that pkgtmp is the main one, by printing it bold or so ;) | [KristofferC]: I was replying to\n\n> we should probably display all packages in the entire load path with some indication of which environment in the stack each one comes from. | [KristofferC]: I don't like showing the stack by default since it is in the majority of cases non-interesting (and show the exact same thing every time). Showing the environment with its packages with a flag seems like a good idea though. | [jekbradbury]: I think something like this would be pretty intuitive; I definitely want to be able to see the contents of the `v1.1` environment without deactivating the environment I have stacked on top of it or seeing the entire stack status:\n```\n(pkgtmp) pkg> st\nStatus for pkgtmp in stack [pkgtmp, v1.1, stdlibs]:\n(empty environment)\n(pkgtmp) pkg> st v1.1\nStatus for v1.1 in stack [pkgtmp, v1.1, stdlibs]:\n  [c52e3926] Atom v0.7.11\n  [6e4b80f9] BenchmarkTools v0.4.1\n  [295af30f] Revise v0.7.14\n  [90137ffa] StaticArrays v0.10.0\n  [b8865327] UnicodePlots v1.0.1\n(pkgtmp) pkg> st --all\nEnvironment stack [pkgtmp, v1.1, stdlibs]\nStatus for pkgtmp:\n(empty environment)\nStatus for v1.1:\n  [c52e3926] Atom v0.7.11\n  [6e4b80f9] BenchmarkTools v0.4.1\n  [295af30f] Revise v0.7.14\n  [90137ffa] StaticArrays v0.10.0\n  [b8865327] UnicodePlots v1.0.1\nStatus for stdlibs:\n  [asdfasdf] LinearAlgebra v1.0.0\n  etc.\n``` | [StefanKarpinski]: I like that although I would replace """"stack"""" with """"load path"""" (which is currently the only instance of a stack, although it would be nice to generalize the concept in the future). Probably also good to use the standard syntax for projects, expanding `@` to the active project and `@#.#` to the actual major/minor, etc. (but probably not expanding `@v1.1` and `@stdlib` absolute paths for brevity. So maybe something like this, building on your example, @jekbradbury:\n```\n(pkgtmp) pkg> st\nStatus for pkgtmp in load path [""""pkgtmp"""", """"@v1.1"""", """"@stdlib""""]:\n(empty environment)\n(pkgtmp) pkg> st v1.1\nStatus for @v1.1 in load path [""""pkgtmp"""", """"@v1.1"""", """"@stdlib""""]:\n  [c52e3926] Atom v0.7.11\n  [6e4b80f9] BenchmarkTools v0.4.1\n  [295af30f] Revise v0.7.14\n  [90137ffa] StaticArrays v0.10.0\n  [b8865327] UnicodePlots v1.0.1\n(pkgtmp) pkg> st --all\nLoad path [""""pkgtmp"""", """"@v1.1"""", """"@stdlib""""]\nStatus for pkgtmp:\n(empty environment)\nStatus for v1.1:\n  [c52e3926] Atom v0.7.11\n  [6e4b80f9] BenchmarkTools v0.4.1\n  [295af30f] Revise v0.7.14\n  [90137ffa] StaticArrays v0.10.0\n  [b8865327] UnicodePlots v1.0.1\nStatus for stdlibs:\n  [asdfasdf] LinearAlgebra v1.0.0\n  etc.\n``` | [samo-lin]: Please have a look at [my answer in this topic](https://discourse.julialang.org/t/how-does-one-set-up-a-centralized-julia-installation/13922/32?u=samo).\nMoreover, if [this issue](https://github.com/JuliaLang/Pkg.jl/issues/1952) gets implemented, then it might also affect/simplify the issue discussed here. | [IanButterworth]: I was just burnt by having a rogue Project.toml hiding in a higher directory.\n\nWhat about put it at the end, with `Stacked on` in a Pkg color like `Status` to differentiate it\n```\n(@v1.6) pkg> st\n      Status `~/.julia/environments/v1.6/Project.toml`\n  [6e4b80f9] BenchmarkTools v0.7.0\n  [7c2e5008] Foo v0.1.0 `~/Documents/Foo.jl`\n  [295af30f] Revise v3.1.15\n  Stacked on @stdlib\n\n(@v1.6) pkg> activate Foo\n  Activating environment at `~/Documents/Foo.jl/Project.toml`\n\n(Foo) pkg> st\n     Project Foo v0.1.0\n      Status `~/Documents/Foo.jl/Bar/Project.toml`\n  [336ed68f] CSV v0.8.1\n  Stacked on @v1.6, @stdlib\n\n(Foo) pkg> activate ~/Documents/Foo.jl/Bar\n  Activating environment at `~/Documents/Foo.jl/Bar/Project.toml`\n\n(Foo) pkg> st\n     Project Foo v0.1.0\n      Status `~/Documents/Foo.jl/Bar/Project.toml`\n  [3da002f7] ColorTypes v0.10.12\n  Stacked on `~/Documents/Foo.jl/Project.toml`, @v1.6, @stdlib\n```\n\nMaybe `@stdlib` could be omitted, as that's kind of obvious?",22,false,8,8,0,0,0,0,0,0,0
2529,Add more info to hash mismatch warning,open,IanButterworth,,,,1,2021-04-26T13:40:06.0,2021-04-26T13:44:18.0,1546,1546,https://github.com/JuliaLang/Pkg.jl/issues/2529,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2529,it's not clear from the warnings what artifact caused this\n```\n   Installed OffsetArrays ─ v1.7.0\n┌ Warning: tarball content does not match git-tree-sha1 1/2\n└ @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:610\n┌ Warning: tarball content does not match git-tree-sha1\n└ @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:610\n  No Changes to `~/.julia/environments/v1.6/Project.toml`\n    Updating `~/.julia/environments/v1.6/Manifest.toml`\n  [6fe1bfb0] ↑ OffsetArrays v1.6.2 ⇒ v1.7.0\n  [efe28fd5] ↑ OpenSpecFun_jll v0.5.3+4 ⇒ v0.5.4+0\n```\n\nThis is on 1.6.1,"[IanButterworth]: Added the bit after, given in this case only a singlle jll changed, so it's more obvious",1,false,0,0,0,0,0,0,0,0,0
1780,Expand artifact selection beyond Platform/CompilerABI,open,staticfloat,,speculative; artifacts,,7,2020-04-17T23:16:20.0,2021-04-23T22:18:35.0,1919,1548,https://github.com/JuliaLang/Pkg.jl/issues/1780,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1780,"In the future, Artifacts are most likely going to need to be split by more than just the `Platform`/`CompilerABI` buckets that we have so far been using.  We may have artifacts compiled for different chip ISAs (e.g. a numerical library with `avx512` support), with alternative backend supports (e.g. a library that has `cuda` support turned on) or other such variants.\n\nIn all these cases, it seems clear to me that the common theme is """"matching an artifact to the current environment"""", whether that environment be the OS, the CPU's capabilities, the currently-mandated `libgfortran` version, or the presence of CUDA libraries.  While we could increase the number of tags that a `Platform` has and solve the problem that way, I personally don't really like that, and would rather create an extensible method by which users can provide code that runs at compile-time, inspects the system, and provides tags that are then matched against the tags recorded in the `Artifacts.toml` file.\n\nAs an example, here's two `Artifacts.toml` entries from `libLLVM_jll.jl`:\n\n```toml\n[[libLLVM]]\narch = """"aarch64""""\ncxxstring_abi = """"cxx11""""\ngit-tree-sha1 = """"bf5710efc0f8c4e00073e832944064380390f7fc""""\nlibc = """"musl""""\nos = """"linux""""\n\n    [[libLLVM.download]]\n    sha256 = """"175d249b0178c4504d9337750f47c76249d16982810127f7507cbf3db53d6001""""\n    url = """"https://github.com/JuliaBinaryWrappers/libLLVM_jll.jl/releases/download/libLLVM-v8.0.1+0/libLLVM.v8.0.1.aarch64-linux-musl-cxx11.tar.gz""""\n\n[[libLLVM]]\narch = """"x86_64""""\ncxxstring_abi = """"cxx03""""\ngit-tree-sha1 = """"955bb29cfbde1b21698c84b67d85a2e1f8e1a6f3""""\nos = """"windows""""\n\n    [[libLLVM.download]]\n    sha256 = """"6a380dd4d4fde4f1b42c6518d64dbf8461544d32f3bb7c2ed5fbec7a5e800f31""""\n    url = """"https://github.com/JuliaBinaryWrappers/libLLVM_jll.jl/releases/download/libLLVM-v8.0.1+0/libLLVM.v8.0.1.x86_64-w64-mingw32-cxx03.tar.gz""""\n```\n\nAt install and compile time, all mentions of the `libLLVM` artifact, (whether it be within `Pkg.add()` or in the user's code via `artifact""""libLLVM""""`) will pass through [`select_platform()`](https://github.com/JuliaLang/Pkg.jl/blob/89792a8a00c619aa5e76798083fda9d80212a07b/src/BinaryPlatforms.jl#L780-L796).  This function, which is currently very tightly integrated with the `Platform` and `CompilerABI` types, takes in a dictionary mapping (which is what that TOML file above defines) and selects the key that """"best matches"""" the current platform's `Platform` object.\n\nI propose that users be able to add arbitrary tags to their `Artifacts.toml` files.  Things like `cuda_capability = """"3""""`, or `cpu_isa = """"avx""""`, etc...  This would couple with a mechanism for the user to provide code that `Pkg` would source, in order to determine the currently-running system's tags.  I'm not sure what the best way to do that would be, here are some options:\n\n* Pkg could check a """"blessed"""" location for this, perhaps `src/pkg_ext/PlatformHooks.jl`, wherein the user would define a `annotate_platform(p::Platform)` function, which is allowed to introspect and determine things about the current system.\n* The `Artifacts.toml` file itself could include a field with inline code.  Ugly, but eminently portable.\n* We could write a `PkgExt.jl` package that monkey-patches `Pkg` upon being loaded, then any package that relies upon this functionality must depend on that package first.  (this doesn't quite work if you need to extend `Pkg` just to install your package outright; the ordering doesn't quite work out there)\n\nI'm open to suggestions for better ways to implement this, or even for someone to change my mind about the best way to deal with this.  But I think as things like CUDA get more and more popular, we're going to have an explosion of `LibFoo_jll` and `LibFooCUDA_jll`.  Note that this starts getting very close to the """"variants"""" debate, but I'd like to keep this feature clear of that by stating that the introspection done by this feature should not depend on what packages are installed, but rather the characteristics of the hardware itself; it should be as idempotent as possible.","[staticfloat]: As an example of what would be acceptable;\n\nCurrently we have `Arpack_jll` and `ArpackMKL_jll`; it would be better if `Arpack_jll` could instead expose a hook to set a `mkl` or `openblas` tag upon the currently-running Julia's `Platform` object depending on what backing BLAS the Julia is built against. | [giordano]: Do you see the possibility to let users choose through, e.g., environment variables or do you want to base the choice exclusively on system properties? | [staticfloat]: I'm willing to have my mind changed, but right now I feel like that kind of user-controlled configuration should probably be taken care of by the user Julia code.  E.g. you should have an environment variable that chooses which JLL to use.\n\nThe reason is that I want to minimize the number of ways you can run a project and have it not find the artifact that was installed at `Pkg.add()` time; I don't want it to be easy to (for instance) `Pkg.add()` something, then later try and use it and have to download a new artifact.  The only way to keep that property stable is to ensure that the number of factors that go in to determining which artifact to load are very slow-moving. (E.g. your CPU type, your Julia version, that fact that you have a GPU installed, etc... are all very slow-moving). | [Petr-Hlavenka]: Is it possible to have two different artefacts (DLLs) loaded in the same Julia process, originating from the different packages used?\nI'm looking into this example:\nMy project depends on \n* `QML.jl` and `Xtensor.jl`, both using the """"CxxWrap.jl"""" with it's DLL downloaded as artifact and compiled crossplatform by BB/gcc\n* `CompanyProprietary.jl` that has a win64-only binary dependency that uses  """"CxxWrap.jl"""", but in this case its `libcxxwrap_julia_jll` has been compiled with MSVC as well as the `CompanyProprietary_jll`. There is just no (economical) way to get  the `CompanyProprietary_jll` compiled by BB, its really windows-only MSVC-only code.\n\nFor now, I needed to branch CxxWrap into CxxWrapMSVC, together with the artifact DLL, just to be able to have them side-by-side loaded into julia process. \nWill your proposal help in the scenario above? Would it be possible for different packages to load different artifacts? Or, complete duplicate of the CxxWrap will be needed also in the future? | [staticfloat]: > Will your proposal help in the scenario above? Would it be possible for different packages to load different artifacts?\n\nIf you want one package to be able to use the MSVC-compatible CxxWrap, and another package to use the normal msys2 CxxWrap, the best way is two completely different CxxWrap packages, because they are fundamentally incompatible, at the binary level. | [Petr-Hlavenka]: Thank you for the answer @staticfloat. How is BB (or more precisely, binaryloader) dealing with DLLs that have the same name? The question is how to do it convenialy? \n* create artifact by hand with the DLL compiled with MSVC19\n* branch and rename libcxxwrap_julia_jll and manually change artifact  UUID\n* branch and rename CxxWrap_jll and pint it to the new UUID\n* \nDoes the binaryloader part of BB require different DLL name in order to be able to load it side-by-side with the mingw libcxxwrap_julia.DLL, so I need to produce a  libcxxwrap_julia_MSVC.DLL ?\n | [staticfloat]: > Does the binaryloader part of BB require different DLL name in order to be able to load it side-by-side with the mingw libcxxwrap_julia.DLL\n\nIt's not BB that requires this, or even Julia.  It's the operating system.  You need to have a unique filename if you want it to not interfere with other things.",7,false,2,0,0,0,0,0,0,0,2
2515,Feature request: expose download URLs,open,colinxs,,,,0,2021-04-17T03:11:18.0,2021-04-17T03:11:18.0,1555,1555,https://github.com/JuliaLang/Pkg.jl/issues/2515,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2515,"I was recently exploring how to package Julia packages with Nix/NixOS and long story short it would be nice if there was some function `foo(project, manifest)` that returned a list of all valid package sources. Currently, on 1.6, I'm resorting to the following *hack* in an attempt to (1) not duplicate the machinery in Pkg and (2) perfectly replicate what Pkg would have done:\n```julia\nconst URLS = []\nPkg.Operations.eval(quote\n    function install_archive(urls::Vector{Pair{String, Bool}}, hash::SHA1, version_path::String)\n        push!(Main.URLS, urls)\n        return false\n    end\nend)\n\nconst GIT = []\nPkg.Operations.eval(quote\n    function install_git(\n        ctx::Context,\n        uuid::UUID,\n        name::String,\n        hash::SHA1,\n        urls::Vector{String},\n        version::Union{VersionNumber,Nothing},\n        version_path::String\n    )::Nothing\n        push!(Main.GIT, (; uuid, name, hash, urls, version, version_path))\n        # to avoid error in caller\n        mkpath(version_path)\n        return nothing\n    end\nend)\n\n@assert length(methods(Pkg.Operations.install_archive)) == 1\n@assert length(methods(Pkg.Operations.install_git)) == 1\n\nPkg.instantiate()\n```\n\nAnd well, it works. `URLS` and `GIT` contain all the possible sources, but it's clearly the wrong solution and could break in the next point release.\n\nHaving some function that maps (pkg_servers, registries, project, manifest) -> map (UUID -> (hash, version_path, etc.)) would be extremely useful. Even better if Artifacts.toml was parsed as well!",,0,false,0,0,0,0,0,0,0,0,0
2503,Feature request: update a `Manifest.toml` file without downloading anything or running any user code,open,DilumAluthge,,,,0,2021-04-11T17:16:04.0,2021-04-11T17:34:03.0,1560,1560,https://github.com/JuliaLang/Pkg.jl/issues/2503,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2503,"I would like this feature for CompatHelper.\n\nCompatHelper used to automatically update `Manifest.toml` files. I removed this feature in https://github.com/JuliaRegistries/CompatHelper.jl/pull/288 because of security concerns. Specifically, CompatHelper has access to secure environment variables (`GITHUB_TOKEN`, `DOCUMENTER_KEY`, and/or `COMPATHELPER_PRIV`). The security concern is this: when you run `Pkg.update()`, it will run the build scripts of packages. A malicious package could add some code to its build script that reads these secure environment variables and submits them to a server maintained by the attacker.\n\nSo I need a way to update a `Manifest.toml` file without running any user code.\n\nI actually once opened a pull request (#1718) to do something similar. The differences are:\n1. #1718 was for `Pkg.add`. This feature request is for `Pkg.update`, since that is how we would update the `Manifest.toml` files.\n2. The motivation for #1718 was different; specifically, the only goal of #1718 was to save time. In contrast, the primary motivation for this feature request is security.",,0,false,0,0,0,0,0,0,0,0,0
2401,"Make printing ""Activating Environment..."" a no-op if you are already in the environment.",open,pdeffebach,,,,3,2021-02-23T18:25:45.0,2021-04-05T23:36:25.0,1607,1566,https://github.com/JuliaLang/Pkg.jl/issues/2401,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2401,"If you want to email a script to someone quickly and dirtily, but you still want it to run on their computer, my understanding is that you need. To send them a .zip with the Manifest.toml and in your script do \n\n```\nimport Pkg\n\nPkg.activate(""""."""")\n\nPkg.instantiate()\n```\n\nat the top. \n\nThis works, but every time you run the script, it prints\n\n```\nActivating environment at `~/Documents/Projects/test/Project.toml`\n```\n\nThis is kind of annoying. \n\nIt would be great if Pkg could know that you are *already* in the project that you wanted to activate and then just not do anything, not even print.","[KristofferC]: You could also do:\n\n```\npush!(empty!(LOAD_PATH), @__DIR__)\n``` \n\nat the top of the script. | [pdeffebach]: Yes, this works well, and is faster. \n\nThe downside is that now you have to explicitly add `Pkg`, `Printf` and other things that ship with Julia. This may not be a bad thing though. \n\nIt's also a bit ugly, and now the user can't debug with their default tools, like Exfiltrator.jl. \n\nSo I think there is still scope for some improvement to `activate` | [00vareladavid]: @pdeffebach I think `Pkg.activate("""".""""; io=devnull)` is sufficient for this, no?",3,false,0,0,0,0,0,0,0,0,0
1654,Activating a directory that doesn't exist,open,EricForgy,,,,5,2020-02-05T06:17:31.0,2021-04-02T20:33:18.0,1992,1569,https://github.com/JuliaLang/Pkg.jl/issues/1654,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1654,"👋 \n\nI'm on a Windows 10 machine running Julia v1.3.1 in Ubuntu WSL2.\n\nI have a setup that looks like:\n\n```\n~/dev/MyApplication\n|- docker-compose.yml\n|- MyPackageA\n   |- Dockerfile\n   |- Project.toml\n   |- src\n      |- MyPackageA.jl\n|- MyPackageB\n   |- Dockerfile\n   |- Project.toml\n   |- src\n      |- MyPackageB.jl\n```\n\nBoth `MyPackageA.jl` and `MyPackageB.jl` are private packages and `MyPackageB.jl` depends on `MyPackageA.jl`, but at this point `MyPackageB / Project.toml` is still empty.\n\nI activate `MyPackageB.jl` in order to add `MyPackageA` as a dependency and from within the directory `~/MyApplication`, I try:\n\n```julia\n(MyPackageB) pkg> dev ./MyPackageA\n```\n\nresulting in the following:\n\n```julia\n(MyPackageB) pkg> dev ./MyPackageA\n Resolving package versions...\n  Updating `~/dev/MyApplication/~/dev/MyApplication/MyPackageB/Project.toml`\n  [********] + MyPackageA [`../../../../../MyPackageA`]\n  Updating `~/dev/MyApplication/~/dev/MyApplication/MyPackageB/Manifest.toml`\n```\nand it creates a new directory `'~'` under `~/dev/MyApplication` with a newly created - not updated - `Project.toml` and a new `Manifest.toml`.\n\nI expected this to update `~/dev/MyApplication/MyPackageB/Project.toml` not create a new one in a weird new directory.\n\nI used this approached effectively in Windows, where it works fine, but doesn't seem to work on Linux. It obviously has something to do with paths getting mangled somehow.\n\nAny ideas?","[EricForgy]: I found the issue. \n\nWhen I activated `PackageB`, I did it by putting the following in my `startup.jl` (an artifact from the fact that I launch Julia in Windows by clicking the icon and not from the command line):\n\n```julia\nusing Pkg; Pkg.activate(""""~/MyApplication/MyPackageB"""")\n```\n\nand didn't notice that it said:\n\n```julia\nActivating new environment at `~/dev/MyApplication/~/dev/MyApplication/MyPackageB/Project.toml`\n```\n\nThat is weird. I'd expect it to error if it tries to activate some location that doesn't exist. At this point it doesn't error and it doesn't create a `Project.toml` / `Manifest.toml` in a newly created directory (yet).\n\nOnly after I try `dev ./MyPackage` from `~/dev/MyApplication` does it create both a new directory\n\n```julia\n~/dev/MyApplication/MyPackageB/~/dev/MyApplication/MyPackageB`\n```\n\nwith new `Project.toml` / `Manifest.toml` inside that new directory.\n\nSo it looks like that `activate` function has an issue with `~`. \n\nI'll leave this issue open even though I found a workaround because I think \n\n```julia\nusing Pkg; Pkg.activate(""""~/MyApplication/MyPackageB"""")\n```\n\nshould work.\n\nMy workaround is to put the full path in `activate`, i.e.\n\n```julia\nusing Pkg; Pkg.activate(""""/home/eric/dev/MyApplication/MyPackageB"""")\n```\n\nThis works. | [KristofferC]: This seems consistent. `~` is never expanded in function calls (both Base and Pkg functions) | [EricForgy]: I'm new to running Julia in Linux and if we're not to expect Julia to expand `~`, that is fine. I call it a learning experience. However, I'm not sure this issue should be closed because I think there is a real problem here. I can change the name of the issue or something, but Julia should probably error if you activate a directory that doesn't exist, right?\n\nIf not, fine 🤦‍♂ | [KristofferC]: > but Julia should probably error if you activate a directory that doesn't exist, right?\n\nMaybe. Or at least if the directory above the directory you try to activate doesn't exist. | [sylvaticus]: Yes, I agree.. I activated by error a wrong folder and all went (apparently) normal - at the beginning of course :-/\nI think as minimum there should be a warning (if not a real error) if one try to activate a non-existing dir... the """"new"""" in the message goes looked behind too easily...",5,false,0,0,0,0,0,0,0,0,0
2433,Registries fail to update when called from project,open,Uroc327,,,,0,2021-03-15T14:04:59.0,2021-03-15T14:08:22.0,1588,1588,https://github.com/JuliaLang/Pkg.jl/issues/2433,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2433,"Issuing `] up` with an active project fails while it succeeds from a 'normal' julia session (environment `~/.julia/environments/v1.5/`):\n\nOutput when called from project:\n```\n> ] activate .\n> ] up\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n┌ Warning: Some registries failed to update:\n│     — ~/.julia/registries/General — failed to fetch from repo\n└ @ Pkg.Types /tmp/portage/dev-lang/julia-1.5.3/work/julia-1.5.3/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:1122\n   Updating `/data/projects/uni/RungePolarDPC.jl/Project.toml`\n [no changes]\n   Updating `/data/projects/uni/RungePolarDPC.jl/Manifest.toml`\n [no changes]\n```\n\nOutput when called with default env (called after the above, so there were new registry entries available):\n```\n> ] up\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Installed IntervalSets ───── v0.5.3\n[...]\nDownloading artifact: Rmath\n   Updating `~/.julia/environments/v1.5/Project.toml`\n  [f6369f11] ↑ ForwardDiff v0.10.16 ⇒ v0.10.17\n[...]\n   Updating `~/.julia/environments/v1.5/Manifest.toml`\n  [3da002f7] ↑ ColorTypes v0.10.10 ⇒ v0.10.12\n[...]\n```\n\nAfter updating the registries, packages themselves are updated successfully:\n```\n> ] up # updates the registry\n> ] activate .\n> ] up\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n┌ Warning: Some registries failed to update:\n│     — ~/.julia/registries/General — failed to fetch from repo\n└ @ Pkg.Types /tmp/portage/dev-lang/julia-1.5.3/work/julia-1.5.3/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:1122\n  Installed Convex ─ v0.14.5\n   Updating `/data/projects/uni/RungePolarDPC.jl/Project.toml`\n  [f65535da] ↑ Convex v0.14.3 ⇒ v0.14.5\n[...]\n   Updating `/data/projects/uni/RungePolarDPC.jl/Manifest.toml`\n  [3da002f7] ↑ ColorTypes v0.10.10 ⇒ v0.10.12\n[...]\n```\n\nThe project is fully instantiated.",,0,false,0,0,0,0,0,0,0,0,0
2385,Feature: Dependency on a privately registered package,open,wildart,,,,5,2021-02-09T07:45:44.0,2021-03-09T08:46:48.0,1622,1594,https://github.com/JuliaLang/Pkg.jl/issues/2385,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2385,"I want to narrow the scope of #492 to the following problem: Is it possible to add a package dependency into the project where the dependency is **registered** in a private registry?\n\nCurrently, a private registry need to be added manually to the Pkg configuration, prior installing any package registered in such registry. Can this process be automated? Sure, if all dependent registries are added to the project file.\n\nAfter some digging, I found that following information is required to support this feature\n-  Add to the package project file reference to the dependent registry\n-  Add the dependent registry info to the package description in the registry storage\n   -  Since only registry located information is used for resolving the dependencies, and not information from the project file\n\n---\n\nOne way to add the dependent registry information to the project by adding an optional `[registries]` section that would specify list of additional registry repositories required to be added to local configuration before installing any dependencies listed in the `[deps]` section.\n```toml\nname = """"Foo""""\nuuid = """"4bdd1c6b-68bb-4dfe-a423-fa0d59eb7384""""\nversion = """"0.1.0""""\n\n[deps]\nBar = """"ce02910b-3083-40c5-958c-8fd1036218f1""""\n\n[registries]\nPrivateRegistry = """"https://www.bar.com/PrivateRegistry.git""""\n```\nThis approach would require to add an additional file to the registry storage format for keeping the dependent registries from version to version, as they linked with corresponding dependencies. So, it will be something lile `Deps.toml` file but for registries.\n\n---\n\nAnother way around is to modify format of the dependency in the project file as follows\n```toml\n[deps]\nFoo = """"4bdd1c6b-68bb-4dfe-a423-fa0d59eb7384""""\nBar = {uuid = """"ce02910b-3083-40c5-958c-8fd1036218f1"""", registry = """"https://www.bar.com/PrivateRegistry.git"""" }\n```\nThis approach would only require the modification of current dependency handling mechanism to handle different dependency representations without extending the registry storage format. The extended dependency description will be stored in `Deps.toml`\n in the same form as described in the project file. \n\n---\n\nThe following steps are necessary take while performing the dependency resolution\n- If the dependency isn't found in any registry, look up for dependent registry info \n- Install the dependent registry\n- Try to resolve the dependency again","[KristofferC]: I don't think I see any technical issue with it. | [GunnarFarneback]: Note that this has non-trivial implications with respect to dependency confusion, #2393. | [KristofferC]: Could you elaborate on the implications? I don't feel they are obvious. | [GunnarFarneback]: Since this installs another registry for you, you don't only need to trust the package you add (maybe you know and trust the author) but you also need to trust the people who have control over the registry not to add (or allow others to add, e.g. via a badly controlled Registrator type service) malignant packages that shadow packages you use in General. \n\nPresumably this can be avoided if the dependent registry is only temporarily added to resolve that exact dependency but I suspect it needs to be done with great care, in particular if recursive dependencies continue into additional private registries. | [KristofferC]: Thanks. So first, I'm not sure I realized whether this was intended to be used for packages that are themselves getting registered in General or just for packages that you add via URL. If the intention was to allow for General packages to depend on packages outside the registry, then I don't think that is workable. The General registry dependency graph should be completely closed in my opinion.\n\nIf this is only about packages that you add via URL, then as you say you still have the issue that the registry lingers about and will influence future package commands.",5,false,3,3,0,0,0,0,0,0,0
1247,Libgit2 has problems cloning on NFS mounts,open,sbromberger,,,,5,2019-07-05T16:30:47.0,2021-02-22T11:11:20.0,2206,1609,https://github.com/JuliaLang/Pkg.jl/issues/1247,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1247,"Using `dev` when home directory is an NFS mount results in the following error:\n```               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.2.0-rc1.0 (2019-05-30)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(v1.2) pkg> dev LightGraphs\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n┌ Warning: Some registries failed to update:\n│     — /nfs/auto/home/seth/.julia/registries/General — failed to fetch from repo\n└ @ Pkg.Types /buildworker/worker/package_linuxarmv7l/build/usr/share/julia/stdlib/v1.2/Pkg/src/Types.jl:1171\n   Cloning git-repo `https://github.com/JuliaGraphs/LightGraphs.jl.git`\nERROR: failed to clone from https://github.com/JuliaGraphs/LightGraphs.jl.git, error: GitError(Code:ERROR, Class:OS, failed to truncate pack file '/nfs/auto/home/seth/.julia/clones/2040551779_full/.git/objects/pack/pack_git2_mBsfFV': Permission denied)\n```\n\nI have r/w permissions for `/nfs/auto/home/seth` and have confirmed there is no concurrent access occurring. Not sure how to go about troubleshooting this but it's reproducible here so please let me know what other information I can provide.\n\n```\njulia> versioninfo()\nJulia Version 1.2.0-rc1.0\nCommit 7097799cf1 (2019-05-30 02:22 UTC)\nPlatform Info:\n  OS: Linux (arm-linux-gnueabihf)\n  CPU: ARMv7 Processor rev 3 (v7l)\n  WORD_SIZE: 32\n  LIBM: libm\n  LLVM: libLLVM-6.0.1 (ORCJIT, cortex-a72)\n```","[sbromberger]: ref: https://github.com/rust-lang/cargo/issues/6652\n | [DilumAluthge]: Is this only happening on NFS mounts? | [sbromberger]: as far as I can tell. I can't reproduce it with a user that is using a local fs. | [thomasjm]: I'm seeing this as well, using NFS in a different context: in a Kubernetes pod that has a mounted volume provisioned by the AWS EFS provisioner. Seems to be the same problem since EFS uses the NFS protocol.\n\nThere's a longstanding issue in libgit2 that might be the root cause: https://github.com/libgit2/git2go/issues/194. Seems like certain filesystems behave slightly differently and cause problems like this. | [pfitzseb]: Did anyone give the [suggested patch](https://github.com/libgit2/libgit2/issues/5556#issuecomment-701404709) a go?",5,false,1,0,0,0,0,0,0,0,1
2381,Unclear error message when adding/updating dependencies on broken module,open,rikhuijzer,,,,1,2021-02-07T21:54:06.0,2021-02-07T22:08:10.0,1623,1623,https://github.com/JuliaLang/Pkg.jl/issues/2381,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2381,"First of all, thanks all for working on the new (Julia 1.6) precompilation interface and the accompanying speedups. I love it. However, I just ran into a confusing error, which might be of interest: When trying to add a package to a broken module, say add HTTP to module Foo, the error is\n```\n(Foo) pkg> add HTTP\n[...]\nPrecompiling project...\n  Progress [========================================>]  1/1\n  ✗ Foo\n0 dependencies successfully precompiled in 2 seconds (5 already precompiled)\n1 dependency errored\n```\nwhich is confusing, because it sounds like HTTP (the dependency) is broken in this case. Note that this can also occur in combination with Revise.\n\nTo reproduce, do\n```\n(@v1.6) pkg> generate Foo\n[...]\n\n(@v1.6) pkg> activate Foo\n[...]\n```\nNow, change something in `src/Foo.jl` to make the module invalid. For example, change it to\n```\nmodule Foo\nf(\nend # module\n```\nFinally, \n```\n(Foo) pkg> add HTTP\n[...]\nPrecompiling project...\n  Progress [========================================>]  1/1\n  ✗ Foo\n0 dependencies successfully precompiled in 2 seconds (5 already precompiled)\n1 dependency errored\n```\nExtra info:\n```\njulia> versioninfo()\nJulia Version 1.6.0-rc1\nCommit a58bdd9010 (2021-02-06 15:49 UTC)\n[...]\n```","[IanButterworth]: Ah, true. The project itself isn't a dependency.. It should say something like `The top-level package """"Foo"""" and n dependencies errored`\nOr in this case just `The top-level package """"Foo"""" errored`\n\nThe tallies on success would also need adjusting.\n\nOr the easier but slightly less precise thing to do might be to just refer to them as """"packages""""",1,false,0,0,0,0,0,0,0,0,0
2291,Manifest relative directory path not respected for `add`,open,jebej,,,,3,2020-12-13T00:43:53.0,2021-01-30T20:22:47.0,1680,1631,https://github.com/JuliaLang/Pkg.jl/issues/2291,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2291,"If you `dev` a relative path, everything works fine: the path is looked up relative to the manifest file, but if the relative path is `add`ed, `Pkg` looks for the package relative  to `pwd()`, which is less useful:\n\n```\n(QuAnalysis) pkg> add AnalyticalTransmon\n   Updating git-repo `C:\Users\Julia\AnalyticalTransmon`\n  Resolving package versions...\nNo Changes to `C:\Users\Julia\QuAnalysis\Project.toml`\nNo Changes to `C:\Users\Julia\QuAnalysis\Manifest.toml`\n\n(QuAnalysis) pkg> st\nProject QuAnalysis v0.2.0\nStatus `C:\Users\Julia\QuAnalysis\Project.toml`\n  [c6417826] AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon#master`\n  [2fda8390] LsqFit v0.11.0\n  [429524aa] Optim v1.2.0\n  [42b8e9d4] ParallelKMeans v0.1.9\n  [d330b81b] PyPlot v2.9.0\n  [de0858da] Printf\n  [10745b16] Statistics\n\n(QuAnalysis) pkg> up\n   Updating registry at `C:\Users\Jeremy\.julia\registries\General`\nERROR: Path `..\AnalyticalTransmon` does not exist.\n\n(QuAnalysis) pkg> dev AnalyticalTransmon\nPath `AnalyticalTransmon\\` exists and looks like the correct package. Using existing path.\n  Resolving package versions...\nUpdating `C:\Users\Julia\QuAnalysis\Project.toml`\n  [c6417826] ~ AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon#master` ⇒ v0.1.0 `..\AnalyticalTransmon`\nUpdating `C:\Users\Julia\QuAnalysis\Manifest.toml`\n  [c6417826] ~ AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon#master` ⇒ v0.1.0 `..\AnalyticalTransmon`\n\n(QuAnalysis) pkg> up\n   Updating registry at `C:\Users\Jeremy\.julia\registries\General`\nNo Changes to `C:\Users\Julia\QuAnalysis\Project.toml`\nNo Changes to `C:\Users\Julia\QuAnalysis\Manifest.toml`\n\n(QuAnalysis) pkg> st\nProject QuAnalysis v0.2.0\nStatus `C:\Users\Julia\QuAnalysis\Project.toml`\n  [c6417826] AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon`\n  [2fda8390] LsqFit v0.11.0\n  [429524aa] Optim v1.2.0\n  [42b8e9d4] ParallelKMeans v0.1.9\n  [d330b81b] PyPlot v2.9.0\n  [de0858da] Printf\n  [10745b16] Statistics\n```","[jebej]: Note that in both cases the relative path added to the toml file is correct, it's the subsequent lookup that is broken for `add`ed packages. | [jebej]: I forgot to add the part where I show it is indeed relative to `pwd()` (it works after `cd()`):\n```\n(QuAnalysis) pkg> add AnalyticalTransmon\n[ Info: Resolving package identifier `AnalyticalTransmon` as a directory at `C:\Users\Julia\AnalyticalTransmon`.\n    Cloning git-repo `C:\Users\Julia\AnalyticalTransmon`\n   Updating git-repo `C:\Users\Julia\AnalyticalTransmon`\n  Resolving package versions...\nUpdating `C:\Users\Julia\QuAnalysis\Project.toml`\n  [c6417826] ~ AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon` ⇒ v0.1.0 `..\AnalyticalTransmon#master`\nUpdating `C:\Users\Julia\QuAnalysis\Manifest.toml`\n  [c6417826] ~ AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon` ⇒ v0.1.0 `..\AnalyticalTransmon#master`\n\n(QuAnalysis) pkg> st\nProject QuAnalysis v0.2.0\nStatus `C:\Users\Julia\QuAnalysis\Project.toml`\n  [c6417826] AnalyticalTransmon v0.1.0 `..\AnalyticalTransmon#master`\n  [2fda8390] LsqFit v0.11.0\n  [429524aa] Optim v1.2.0\n  [42b8e9d4] ParallelKMeans v0.1.9\n  [d330b81b] PyPlot v2.9.0\n  [de0858da] Printf\n  [10745b16] Statistics\n\n(QuAnalysis) pkg> up\n   Updating registry at `C:\Users\jbejanin\.julia\registries\General`\nERROR: Path `..\AnalyticalTransmon` does not exist.\n\njulia> cd(""""QuAnalysis"""")\n\n(QuAnalysis) pkg> up\n   Updating registry at `C:\Users\jbejanin\.julia\registries\General`\n   Updating git-repo `C:\Users\Julia\AnalyticalTransmon`\nNo Changes to `C:\Users\Julia\QuAnalysis\Project.toml`\nNo Changes to `C:\Users\Julia\QuAnalysis\Manifest.toml`\n``` | [BioTurboNick]: +1 on this.",3,false,2,2,0,0,0,0,0,0,0
2368,filename extension in downloading incorrectly specified via Content-Disposition,open,oxinabox,,,,2,2021-01-28T23:11:57.0,2021-01-29T21:30:17.0,1633,1632,https://github.com/JuliaLang/Pkg.jl/issues/2368,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2368,"The code in `download_verify_unpack` using the filename extension to decide if it needs to decompress a thing.\nIt determines the filename via looking at the URL.\nPer this code:\nhttps://github.com/JuliaLang/Pkg.jl/blob/76402b8974aba76f4412e59bee2e4bc6be1b7860/src/PlatformEngines.jl#L443-L459\n\nI have learned the hard way that this is not the correct way to get filenames for downloads.\nThis breaks for common filehosting providers that have URLs that are just a random-id.\n(IIRC this includes GoogleDrive and DropBox)\n\nThe filename (that e.g. a web browswer would download to) can be specified in the `Content-Disposition` HTTP header.\n(Then the URL is used as a fallback).\nThe actual rules for this are rediclously complicted, see references and test-cases at http://test.greenbytes.de/tech/tc2231/\nbut I made for HTTP.jl something that works in every real case we have encountered in DataDeps\nhttps://github.com/JuliaWeb/HTTP.jl/blob/337a372aace7ea80273f5d859b1bbf9d306c13e7/src/download.jl#L57-L61\n(I also once did the same for the old way `Base.download` worked on the commandline, it is super gross  though https://github.com/oxinabox/DataDeps.jl/pull/22)\n\n\nI am sure something similar and nice can be done with libcurl\n",[StefanKarpinski]: It's pretty easy to detect compression formats from magic bytes which doesn't require this. | [oxinabox]: > It's pretty easy to detect compression formats from magic bytes which doesn't require this.\n\nThis would be ideal.\nCan we know that either:\n\n1. everything we need to accept here always has magic bytes. Or:\n2. that things without magic bytes can all be handled the same way and that their chance of clashing with magic bytes are good as nil?,2,false,2,0,0,0,0,0,2,0,0
2320,Inconsistent registry and packages in package server.,open,racinmat,,,,6,2021-01-07T16:22:45.0,2021-01-11T21:27:16.0,1654,1650,https://github.com/JuliaLang/Pkg.jl/issues/2320,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2320,"Sometimes, when new version of package is merged to the https://github.com/JuliaRegistries/General , the new version is present in registry served through package server, but the version itself is not present in package not storage server, and requesting its URL in package server results in 404.\nThis happens usually when package is in registry less than 1 day.\n\nCurrently, clients defaults to download through git, but sometimes, e.g. behind corporate firewall, only package server is accessible, not git. \nThen, currently the whole process crashes, because it's unable to download package through git.\n\nI would be ok with having few days older registry, which has all packages accessible instead of crashing `instantiate`, and I assume other people using julia with strict firewall settings would be too.\n\nWhen client is using package server and registry served through package server, would it be possible to guarantee consistency between versions listed in registry served by package server and versions downloadable through package server?\n\nFor further discussion, see: https://julialang.slack.com/archives/C67EFTEF3/p1610026073111200","[StefanKarpinski]: We originally waited until everything in a registry tree was available before publishing the new tree but there are sometimes new registry commits that introduce a lot of new package versions and artifacts all at once and waiting for all of those to be made available through the packager servers was causing long delays (tens of hours) between when something was registered and when package servers advertised it. This caused many problems for CI throughout the open source ecosystem, because CI expects new versions of dependencies that were used during development to be installable right away. Because of that, we were forced to change `pkg.julialang.org` to start advertising registry trees as soon as possible, letting clients fall back to GitHub for content that isn't yet available. We're working on speeding up the processing of content that the package server system serves, but that would only reduce the problem for you, not eliminate it entirely.\n\nUnlike `pkg.julialang.org`, JuliaHub does wait until everything is available to serve new registry trees, so you can set `pkg.juliahub.com` as your package server to work around this issue. The `pkg.juliahub.com` package server is authenticated, however, so you'll need to create an account and then follow the instructions for setting up the [`PkgAuthentication` package](https://github.com/JuliaComputing/PkgAuthentication.jl). Let me know if that works for you. | [racinmat]: Thanks! During registration to juliahub.com, there were mentions about payments. Is `pkg.juliahub.com` free to use?\nAnd does `pkg.juliahub.com` have all packages which `pkg.julialang.org` has (except the very new packages which did not propagate yet)? Or is it some curated subset? | [racinmat]: This looks it works on my machine. \nWe plan to use it in internal CI platform, so we need to have it headless. \nI use google authentication, is there a way to have it headlessly?\nMy plan is to store the token as a secret in CI, and renew it, if this is possible, but I can't find the description of authentication process without the browser. | [StefanKarpinski]: The only thing you have to pay for on JuliaHub is cloud compute. Everything else is free, including serving packages. If you want to use this for something like internal CI, I can't promise that will work via JuliaHub.com, you may have to look into something like [JuliaHub Enterprise](https://juliacomputing.com/products/juliahub/). | [racinmat]: Thanks. What I'm interested in is only a way how to authenticate headlessly, we have the rest of internal infrastructure worked out already. | [StefanKarpinski]: Sounds like you may want to build and run your own storage service. If you do, it can, [by design](https://github.com/JuliaLang/Pkg.jl/issues/1377), be used as an upstream source for the community-run public package servers, providing redundancy and robustness against failure conditions in the storage and persistence of packages and artifacts. If you want any advice on implementing such a service, I'd be happy to offer it. It would be beneficial to the redundancy, diversity and robustness of the Julia ecosystem to have more than one organization providing independent storage services. The system is designed such that if any upstream storage service can correctly serve something, then the package servers can use that, even if the other services have failures or gaps.",6,false,0,0,0,0,0,0,0,0,0
1155,VersionSpec printed incorrectly,open,pfitzseb,,bug,,6,2019-04-16T20:41:37.0,2020-12-21T21:01:41.0,2286,1671,https://github.com/JuliaLang/Pkg.jl/issues/1155,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1155,"AFAICT this is the cause of the various issues in the new registry (https://github.com/JuliaRegistries/General/pull/59, https://github.com/JuliaRegistries/General/pull/75) where the a compat entry would look like `""""[0.7, 1]""""` instead of the correct `[""""0.7"""", """"1""""]`.\n\nRepro and possible fix:\n```\njulia> using Pkg\n\njulia> Pkg.TOML.print(stdout, Dict(""""julia"""" => Pkg.Types.VersionSpec([""""0.1"""", """"0.8-1""""])))\njulia = """"[0.1, 0.8-1]""""\n\njulia> function Pkg.TOML.printvalue(io::IO, s::Pkg.Types.VersionSpec;sorted=false)\n           isempty(s) && return print(io, _empty_symbol)\n           length(s.ranges) == 1 && return print(io, s.ranges[1])\n           print(io, '[')\n           for i = 1:length(s.ranges)\n               1 < i && print(io, """", """")\n               print(io, '""""', s.ranges[i], '""""')\n           end\n           print(io, ']')\n       end\n\njulia> Pkg.TOML.print(stdout, Dict(""""julia"""" => Pkg.Types.VersionSpec([""""0.1"""", """"0.8-1""""])))\njulia = [""""0.1"""", """"0.8-1""""]\n```","[fredrikekre]: I am guessing Registrator can just monkey patch that for now. Would of course be nice to add the fix here but won't propagate to julia until 1.2. | [pfitzseb]: Yeah, would be good to get that in asap. | [StefanKarpinski]: It's not a bug per se since VersionSpec objects can print however they want, the actual bug is that Registrator shouldn't be relying on stringification of VersionSpec objects like this at all, although changing this is one way to fix it. The appropriate fix is to change this logic:\n\nhttps://github.com/JuliaComputing/Registrator.jl/blob/b539fdd6350fede2/src/regedit/register.jl#L291\n\nIt should also be fixed to call `compress_versions` appropriately. I've tried making this change but I'm unable to run the code which does not seem to be functional since `DEFAULT_REGISTRY` and `REGISTRIES` are defined in the top-level `Registrator` module but used from `Registrator.RegEdit` without being imported. I can only surmise that the code that's on master is not what's running; perhaps @nkottary can clarify? | [nkottary]: The running Registrator is a bunch of commits behind master: https://github.com/JuliaComputing/Registrator.jl/commit/5d26d20c976877aaee6fee6a0e538d4a6fe1d667\n\n...where those definitions are in scope. | [StefanKarpinski]: Thanks, @nkottary, that makes sense. I guess this is why we need more tests—so we can't merge completely broken code to master without realizing it 😂 | [fingolfin]: Some way to serialize and deserialize `VersionSpec` instances to/from strings would be really valuable.",6,false,2,2,0,0,0,0,0,0,0
2278,Document Pkg.rm accepts mode keyword argument,open,musm,,documentation,,0,2020-12-08T17:37:44.0,2020-12-08T17:37:53.0,1684,1684,https://github.com/JuliaLang/Pkg.jl/issues/2278,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2278,"https://julialang.github.io/Pkg.jl/v1/api/#Pkg.rm\n\nLooks like the docstring for at least  `Pkg.rm(pkg::Union{String, Vector{String}})` is missing reference to the `mode` keyword argument.",,0,false,0,0,0,0,0,0,0,0,0
2246,Add DEPOT_PATH[2]/environments/v#.# to the LOAD_PATH by default,open,mauro3,,,,8,2020-11-28T17:41:20.0,2020-11-30T15:34:02.0,1694,1692,https://github.com/JuliaLang/Pkg.jl/issues/2246,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2246,"After doing some system wide installs (#2245), I'm wondering why `DEPOT_PATH[2]/environments/v#.#` is not part of the default load path.  My understanding is that `DEPOT_PATH[2]` is the normal place for system-wide installs and is there  by default.  So it seems strange that the related environment is not there by default.","[KristofferC]: Just noting that this is technically more of a Julia issue than a Pkg issue. Pkg does not decide what is in `LOAD_PATH`. | [StefanKarpinski]: If you don't have a `v#.#` environment in `DEPOT_PATH[1]` then it should be. | [mauro3]: Yes, but usually one has a `v#.#` in DEPOT_PATH[1].  Otherwise the user can't install anything themselves.  I argue here that there should be both present, as stacked environment. | [StefanKarpinski]: There can only be one environment named `v1.5` so there's no way to refer to """"the other `v1.5` environment"""" if you have one in `DEPOT_PATH[1]` already. You can create `DEPOT_PATH[2]/environments/v#.#-system` and then put whatever you want in there. You can also change the user's default load path by arranging for the variable `JULIA_LOAD_PATH=""""@:@v#.#:@v#.#-system:@stdlib""""` to be set in their environment before they log in. Then users will see the named system environment in their default load path. They can still modify the load path further as long as they do it using the recommended `export JULIA_LOAD_PATH=""""/some/path:$JULIA_LOAD_PATH""""` pattern. | [fredrikekre]: > There can only be one environment named v1.5 so there's no way to refer to """"the other v1.5 environment"""" if you have one in DEPOT_PATH[1] already.\n\nTechnically `v#.#` could expand to multiple entries, e.g. `DEPOT_PATH[1]/environments/v1.5`, `DEPOT_PATH[2]/environments/v1.5` though. | [StefanKarpinski]: It could, but then its meaning would be inconsistent between `LOAD_PATH` and say `] activate @v1.5`. Although maybe that's ok since activation is only about modification and modification affects only the top entry in a stack? Would we do the same thing with other named environments? Would `@devtools` in the load path actually expand to all environments named `devtools`? I.e. a stack of `$depot/environments/devtools` for all `depot` in `DEPOT_PATH`? | [StefanKarpinski]: It would be a bit weird if there was a secondary `@v1.5` environment that you can load things from but that you have no way to activate... | [fredrikekre]: Yea, I don't know whats best.\n\nPerhaps to reformulate the problem; there is no default system entry in the load path, so for a global install you have to modify each users `JULIA_LOAD_PATH` if you want a set of system global packages. In contrast; there is a default system entry in the depot path where you can download packages and artifacts and there is no need to modify `JULIA_DEPOT_PATH`. Perhaps they don't have to """"agree"""", but it is slightly annoying to have to modify `JULIA_LOAD_PATH` for all users I suppose.",8,false,1,1,0,0,0,0,0,0,0
2215,prevent package downgrade when pkg server is out-of-date,open,felipenoris,,,,36,2020-11-18T20:11:54.0,2020-11-29T02:08:40.0,1704,1694,https://github.com/JuliaLang/Pkg.jl/issues/2215,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2215,"I was having some conectivity issues with the registry today. When it finally worked, it downgraded a few packages.\nMost likely the mirror I'm connecting to is out-of-date. I would suggest to fail (or implement an update argument command to control behavior) instead of downgrade if the local registry copy is ahead of the mirror's copy\n\n```\n(@v1.5) pkg> up\n   Updating registry at `~/.julia/registries/General`\n######################################################################## 100.0%\nNo Changes to `~/.julia/environments/v1.5/Project.toml`\nUpdating `~/.julia/environments/v1.5/Manifest.toml`\n  [69de0a69] ↓ Parsers v1.0.12 ⇒ v1.0.11\n```","[KristofferC]: How about something like this: we send the current tree hash to the server, if it is newer than the tree hash the server would serve us, we don't update (downgrade) the local registry. | [felipenoris]: That would also have the benefit of preventing from downloading unnecessary data, like an [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag). | [KristofferC]: Cc @StefanKarpinski, @staticfloat, any opinions about this? | [staticfloat]: How do we know if a tree hash is newer? | [felipenoris]: Somewhere someone would need to know the history of the tree hashes, like what git does with commit hashes.\nThe server could do it.\n\n* client sends its current tree hash to the server\n\n* server has a ledger of tree hashes. If the server knows the tree hash given by the client, it is either the current one (no update is sent back to the client, just a status message), or it is outdated, and the server would need to send an update. If the server does not know about the tree hash, the server is possibly outdated and returns maybe an error message.\n\nIn the error case, maybe the client data is corrupted. An update command argument could control if we let the server update the client (potential downgrade) or not.\n\nI don't know how it is done today, but it turns out that this setting could potentially reduce the pressure on your servers. | [StefanKarpinski]: That's way too much work for the server to be doing. Pkg servers need to be as simple and reliable as possible and this is far too complicated. They don't know anything about git and they don't keep git history around. All they do is serve content-addressed tarballs that they get from storage servers. The client could do it, but that's also a lot of work for the client and we haven't had great experiences in the past with clients doing these kinds of fiddly git history computations as part of the normal workflow. Alternatively, the client could send their current hash and if the server doesn't know about it, we could assume that it's newer and refuse to downgrade or ask the user what to do. | [DilumAluthge]: > Alternatively, the client could send their current hash and if the server doesn't know about it, we could assume that it's newer and refuse to downgrade or ask the user what to do.\n\nProbably this is the best approach. | [StefanKarpinski]: Actually, it doesn't really make sense for the server to determine this. The client already has the registry: if the current hash is not in the registry, the client can assume that the server doesn't know about it. Unclear what to do at that point, but if the installed copy has a project file with a version entry, then we can look at that and decide what to do based on that information. | [staticfloat]: I think we're talking about the registry itself here though. | [StefanKarpinski]: In that case we can either try doing a head request on the current hash first or send it along as a header. | [felipenoris]: Based on the ETag approach, it could be anything you want. You could generate a sequential number. Each number gets mapped to a hash. If the client gets the current number along with the hash tree in its local registry then the server would compare this number with the current to decide on sending a new copy of the registry to the client, consuming CPU on the server side to compare two integers instead of looking for a tree hash in a list. This could be layered on top of the current tree hash comparison approach, making it optional and easier to deploy to clients. As with most optimizations, usually you make things more complicated though.\n\nBut, hey, these are just ideas. Just preventing the downgrade thing would be awesome, even based on other approaches. | [DilumAluthge]: > In that case we can either try doing a head request on the current hash first\n\nI think this approach makes the most sense. | [DilumAluthge]: 1. Pkg client sends a head request on the current registry hash.\n2. If the Pkg server knows about the registry hash that the Pkg client currently has, then we proceed to update the registry as normal.\n3. If the Pkg server does not know about the registry hash that the Pkg client currently has, then we do NOT update the registry. We keep the registry copy that the Pkg client currently has, and we proceed with all other Pkg operations (except for registry updating) as normal. | [DilumAluthge]: @StefanKarpinski Regarding the other approach\n> or send it along as a header.\n\nHow would this work? The Pkg client sends its current registry hash as a header to the Pkg server. The Pkg server receives this and... does what with the information?\n\nIf the Pkg server knows about the registry hash that it received in the header, then it can proceed as normal.\n\nBut what should the Pkg server do if it does not know about the registry hash that it received in the header? Just kick back a 404 or something to the Pkg client? | [DilumAluthge]: ~~I like the """"current registry hash in a header"""" idea because it means we can implement this fix on the Pkg server side, without needing to patch Pkg clients. But I'm not sure what that implementation actually looks like.~~\n\nEDIT: This is incorrect. The """"current registry hash in a header"""" would require adding new code to both the Pkg client and the Pkg server. | [StefanKarpinski]: I think the HEAD approach is better. The only thing we could do for the other approach is that if the server doesn't know about the version in the header, it could return a bogus 404 or something, which doesn't seem ideal. | [DilumAluthge]: ~~There is however one big advantage of using the header approach with the bogus 404: we can implement the fix in PkgServer.jl and deploy it as soon as we want, without needing to wait for Julia 1.6 to be available. Also, the fix would be available for all Julia versions that use the Pkg server, not just Julia 1.6.~~ | [DilumAluthge]: > ~There is however one big advantage of using the header approach with the bogus 404: we can implement the fix in PkgServer.jl and deploy it as soon as we want, without needing to wait for Julia 1.6 to be available. Also, the fix would be available for all Julia versions that use the Pkg server, not just Julia 1.6.~\n\nWhoops, I was entirely incorrect about this. If we do the header approach, we need to add code to both the Pkg client and the Pkg server. So the header approach still requires that we add some code to Pkg.jl. | [DilumAluthge]: @StefanKarpinski Here's a possible problem with the HEAD approach.\n\nIf I make a HEAD request to a registry hash that exists, I get a 200.\n- https://pkg.julialang.org/registry/23338594-aafe-5451-b93e-139f81909106/d39164bb8cb93fbab63ebe994c7045e1cdd0f9f3\n- https://pkg.julialang.org/registry/23338594-aafe-5451-b93e-139f81909106/1abd140713596c1f9e52b7cd6c3a2c905411816b\n\nBut, if I make a HEAD request to a registry hash that does NOT exist, it hangs indefinitely.\n- https://pkg.julialang.org/registry/23338594-aafe-5451-b93e-139f81909106/d39164bb8cb93fbab63ebe994c7045e1cdd0f9f4\n- https://pkg.julialang.org/registry/23338594-aafe-5451-b93e-139f81909106/1abd140713596c1f9e52b7cd6c3a2c905411816c | [fredrikekre]: I don't think this is something that should be fixed on the client side. This is also something you only notice if you switch Pkg servers, which, under normal conditions, you never do. Just because a Pkg Server doesn't know about my current hash doesn't mean my current hash is newer. In a perfect world (with functioning servers) I think that the server should be the truth. It might just as well be that the admin has rolled back something. | [felipenoris]: Unfortunately, it happens quite often, about once a week for my region. I would suggest to avoid some corner cases by considering a change in the registry something immutable: if you wanna rollback something, publish a new version instead of going back a version (like a `git revert HEAD`).\n\nThis is right now:\n```julia\nfnoro@dbecceed1666:~/tmp/docker-builder$ julia updeps.jl                                                                                    \n   Updating registry at `~/.julia/registries/General`                                                                                           \n######################################################################################################################################### 100.0%\nUpdating `~/tmp/docker-builder/external_deps/Project.toml`                                                                                  \n  [a93c6f00] ↓ DataFrames v0.22.1 ⇒ v0.21.8                                                                                                     \n  [31c24e10] ↓ Distributions v0.24.4 ⇒ v0.23.12                                                                                                 \n  [e30172f5] ↓ Documenter v0.25.5 ⇒ v0.25.3                                                                                                     \n  [0097028c] ↓ FinancialDSL v0.3.2 ⇒ v0.3.1                                                                                                     \n  [cd3eb016] ↓ HTTP v0.9.0 ⇒ v0.8.19                                                                                                            \n  [0f8b85d8] ↓ JSON3 v1.5.1 ⇒ v1.4.0                                                                                                            \n  [9b8beb19] ↓ JSONWebTokens v0.3.3 ⇒ v0.3.2                                                                                                    \n  [69de0a69] ↓ Parsers v1.0.12 ⇒ v1.0.11                                                                                                        \nUpdating `~/tmp/docker-builder/external_deps/Manifest.toml`                                                                                 \n  [324d7699] ↓ CategoricalArrays v0.9.0 ⇒ v0.8.3                                                                                                \n  [a8cc5b0e] - Crayons v4.0.4                                                                                                                   \n  [a93c6f00] ↓ DataFrames v0.22.1 ⇒ v0.21.8                                                                                                     \n  [b552c78f] ↓ DiffRules v1.0.2 ⇒ v1.0.1                                                                                                        \n  [31c24e10] ↓ Distributions v0.24.4 ⇒ v0.23.12                                                                                                 \n  [e30172f5] ↓ Documenter v0.25.5 ⇒ v0.25.3                                                                                                     \n  [1a297f60] ↓ FillArrays v0.10.1 ⇒ v0.9.7                                                                                                      \n  [0097028c] ↓ FinancialDSL v0.3.2 ⇒ v0.3.1                                                                                                     \n  [59287772] - Formatting v0.4.1                                                                                                                \n  [cd3eb016] ↓ HTTP v0.9.0 ⇒ v0.8.19                                                                                                            \n  [0f8b85d8] ↓ JSON3 v1.5.1 ⇒ v1.4.0                                                                                                            \n  [9b8beb19] ↓ JSONWebTokens v0.3.3 ⇒ v0.3.2                                                                                                    \n  [77ba4419] ↓ NaNMath v0.3.5 ⇒ v0.3.4                                                                                                          \n  [69de0a69] ↓ Parsers v1.0.12 ⇒ v1.0.11                                                                                                        \n  [08abe8d2] - PrettyTables v0.10.1                                                                                                             \n  [4c63d2b9] ↓ StatsFuns v0.9.6 ⇒ v0.9.5                                                                                                        \n  [bd369af6] ↓ Tables v1.2.1 ⇒ v1.1.0                                                                                                           \n  [5c2747f8] - URIs v1.0.1                                                                                                                      \n                                                               \nERROR: Unsatisfiable requirements detected for package FinancialDSL [0097028c]:                                                                 \n FinancialDSL [0097028c] log:\n```\n\nWhat's more strange is that it goes back up to 10 days of updates in the registry. | [Yujie-W]: I encountered the same issue here. If I remove default General registry and add General mannually, it works\n```\n(@v1.5) pkg> registry rm General\n   Removing registry `General` from ~/.julia/registries/General\n(@v1.5) pkg> registry add https://github.com/JuliaRegistries/General\n    Cloning registry from """"https://github.com/JuliaRegistries/General""""\n      Added registry `General` to `~/.julia/registries/General`\n```\nHowever, Github action uses the default registry from the server and fails... | [Yujie-W]: Bt the way, I have to run this command in the workflow to avoid such a problem with the server\n```\njulia -e 'using Pkg; Pkg.Registry.rm(""""General""""); Pkg.Registry.add(RegistrySpec(url=""""https://github.com/JuliaRegistries/General""""))'\n``` | [fredrikekre]: > Unfortunately, it happens quite often, about once a week for my region.\n\nWhat region is that? Are you sure the downgrading is because the newer versions are not in the registry you obtain and not e.g. compat bounds (or possibly https://github.com/JuliaLang/Pkg.jl/issues/1949)? For reference:\n```\nInstalling from eu-central\n  [a93c6f00] DataFrames v0.22.1\nInstalling from us-west\n  [a93c6f00] DataFrames v0.22.1\nInstalling from us-east\n  [a93c6f00] DataFrames v0.22.1\nInstalling from us-east2\n  [a93c6f00] DataFrames v0.22.1\nInstalling from us-east-ci\n  [a93c6f00] DataFrames v0.22.1\nInstalling from kr\n  [a93c6f00] DataFrames v0.22.1\nInstalling from in\n  [a93c6f00] DataFrames v0.22.1\nInstalling from au\n  [a93c6f00] DataFrames v0.22.1\nInstalling from sg\n  [a93c6f00] DataFrames v0.22.1\n```\n\n> What's more strange is that it goes back up to 10 days of updates in the registry.\n\nWhat do you mean with this? | [StefanKarpinski]: Registries (like all projects) should rollback by making revert commits, not by resetting master to an old commit. I do think the general solution here is to improve the up-to-dateness of the pkg servers, which is something that @staticfloat and I will get to as soon as we're done with 1.6-critical work. But there is still the potential for auto-choosing a pkg server to lead to an apparent backwards jump in time, which it might be best to avoid. | [felipenoris]: \n> What region is that? Are you sure the downgrading is because the newer versions are not in the registry you obtain and not e.g. compat bounds (or possibly #1949)? For reference:\n\nMy region is Brazil. And when I posted I could reproduce the issue on at least two internet providers. But looks like pkg server was messed up based on the slack infrastructure channel chat.\n\nIf I remove the current registry and revert to the git protocol, like what @Yujie-W was talking about, everything works fine, so my project compat settings are good.\n\n> > What's more strange is that it goes back up to 10 days of updates in the registry.\n> \n> What do you mean with this?\n\nBy the version tags that I got downgraded to, they were tagged about 10 days ago. | [fredrikekre]: > Registries (like all projects) should rollback by making revert commits, not by resetting master to an old commit.\n\nYea, but jokes on us, we identify by tree-hash. | [StefanKarpinski]: Here's a possibility. We want to switch to client-driven server selection so that pkg clients can choose the pkg server that's the fastest for them. The test could be a HEAD request for their current hashes registries and then the client chooses the that replies fastest with a 200 OK. That would prevent selection of a pkg server that's out of date until it catches up. | [StefanKarpinski]: > Yea, but jokes on us, we identify by tree-hash.\n\nSo? Pkg servers should still be able to serve older registry trees and the only reason to not be able to is if you're out of sync and either have to go fetch the newer tree or don't have access to it at all. | [fredrikekre]: > So? Pkg servers should still be able to serve older registry trees and the only reason to not be able to is if you're out of sync and either have to go fetch the newer tree or don't have access to it at all.\n\nSure, but we there is no notion of """"newest""""? Maybe I misunderstood the proposed solution above. | [StefanKarpinski]: The set of things that each pkg server knows about only grows, so if one server knows about a registry tree but another one doesn't, then the one that doesn't know about has an older view of the world than the other one. | [staticfloat]: > The set of things that each pkg server knows about only grows, so if one server knows about a registry tree but another one doesn't, then the one that doesn't know about has an older view of the world than the other one.\n\nThis is true for storage servers, but not for Pkg servers.  Pkg servers forget things all the time, and they need to ask the storage server whether something exists if that thing has fallen out of their cache.  As it stands, the unreliability of our infrastructure makes this a harder problem than it should be, so I'm just working on getting this to be reliable again. | [StefanKarpinski]: I agree that before doing this sort of thing we should spend some time working on general reliability, which might just make it no longer a problem that needs to be solved. | [ronisbr]: > Are you sure the downgrading is because the newer versions are not in the registry you obtain and not e.g. compat bounds (or possibly #1949)?\n\nJust for the record, I live in the same country as @felipenoris (close to São Paulo), and I do occasionally see the same problems. Hence, it really does not seem related to a versioning problem of the packages. There was a week with so many downgrades that I decided to just `dev` what I needed, and started to manually update those packages.\n | [fredrikekre]: > There was a week with so many downgrades\n\nThis problem has been identified and will be fixed. | [ronisbr]: Nice! Thanks for the info @fredrikekre !",36,false,3,3,0,0,0,0,0,0,0
1952,Introduce ADMIN_DEPOT_PATH and USER_DEPOT_PATH,open,samo-lin,,,,3,2020-08-10T14:22:32.0,2020-11-27T12:22:40.0,1805,1696,https://github.com/JuliaLang/Pkg.jl/issues/1952,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1952,"It would be good if the Pkg manager would allow to set `ADMIN_DEPOT_PATH`, `USER_DEPOT_PATH`, `ADMIN_LOAD_PATH` and `USER_LOAD_PATH`, and create from this the `DEPOT_PATH` and `LOAD_PATH`. This would simplify system wide installations, see here for more details:\nhttps://discourse.julialang.org/t/how-does-one-set-up-a-centralized-julia-installation/13922/32?u=samo","[StefanKarpinski]: That seems like a rather complex setup and it seems like you got it all worked out. Can you provide a more commonplace motivation for adding environment variables and complexity to the standard Julia Pkg behavior? Keep in mind that we have to document and explain every aspect of this and keep it working, so every additional complication to the system is a fairly large maintenance burden. | [mauro3]: Related: I just did an install on a single-server JupyterHub instance (a The Littlest JupyterHub install).  To get the IJulia kernel working automatically was hard work and pretty convoluted, I made notes as otherwise I could probably not do it again:\nhttps://github.com/mauro3/JupyterHubWithJulia\nthe relevant sections for this issue are [here](https://github.com/mauro3/JupyterHubWithJulia#machine-wide-julia-install-ok-tljh-wide-installation) and [here](https://github.com/mauro3/JupyterHubWithJulia#enable-tljh-wide-julia-packages).  Also note that this is a somewhat common problem, e.g. https://discourse.julialang.org/t/installing-ijulia-for-all-users-for-jupyterhub/42528 or https://github.com/jupyterhub/the-littlest-jupyterhub/issues/279.\n\nOf note to this issue are:\n- it's not easy to get a package installed into another depot_path\n- it's not clear to me how to best then make this automatically available to the users, such that they don't have to install anything themselves.  What I did is to copy over the Project and Manifest from the install done above into the user environment.  This, of course, is no good once the user actually installed some other stuff as their files would be overwritten.  Not sure whether there is a way to merge those files or whether there can be a stack of projects.\n- I'm not clear how updating should work.  Of note is that some packages should probably be updated centrally, e.g. IJulia on a JupyterHub install.  Other centrally-provided packages,  say plotting-stuff, should probably be updated by the user but then make use of the (hopefully) already present update in the central depot_path. Edit: this seems to be resolved with https://github.com/mauro3/JupyterHubWithJulia/issues/1 | [mauro3]: Ok, thanks to @fredrikekre's input I got things more sorted out. In particular point two (and I think point three).  However, the first point stands.  Compare Julia's\n https://github.com/mauro3/JupyterHubWithJulia/blob/e2924c29744d148907a900d9335a0d1ea0275c43/tljh_install.sh#L107-L138\nwith the Python equivalent\nhttps://github.com/mauro3/JupyterHubWithJulia/blob/e2924c29744d148907a900d9335a0d1ea0275c43/tljh_install.sh#L99-L101",3,false,0,0,0,0,0,0,0,0,0
2244,Strange behavior with existing manifest and missing project,open,fredrikekre,,,,2,2020-11-26T11:35:21.0,2020-11-26T12:51:23.0,1697,1697,https://github.com/JuliaLang/Pkg.jl/issues/2244,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2244,"I verified that I did not have a project file before, but I guess from the output that I must have had a manifest. On `add Crayons`, why was JSON@0.19.0 installed in the first place leading to a failure later where it was (rightfully) missing from the manifest?\n```\n$ pkg --project=. add Crayons\n  Resolving package versions...\n  Installed JSON ─ v0.19.0\nUpdating `~/Project.toml`\n  [a8cc5b0e] + Crayons v4.0.4\nUpdating `~/Manifest.toml`\n  [a8cc5b0e] + Crayons v4.0.4\n  [fb57b044] - Foo v0.1.0 `Foo`\n  [682c06a0] - JSON v0.19.0\n  [2a0f44e3] - Base64\n  [ade2ca70] - Dates\n  [8ba89e20] - Distributed\n  [b77e0a4c] - InteractiveUtils\n  [76f85450] - LibGit2\n  [8f399da3] - Libdl\n  [37e2e46d] - LinearAlgebra\n  [56ddb016] - Logging\n  [d6f4376e] - Markdown\n  [a63ad114] - Mmap\n  [44cfe95a] - Pkg\n  [de0858da] - Printf\n  [3fa0cd96] - REPL\n  [9a3f8284] - Random\n  [ea8e919c] - SHA\n  [9e88b42a] - Serialization\n  [6462fe0b] - Sockets\n  [8dfed614] - Test\n  [cf7118a7] - UUIDs\n  [4ec0a83e] - Unicode\nERROR: LoadError: could not find entry with uuid 682c06a0-de6a-54ab-a142-c8b1cf79cde6 in manifest /home/fredrik/Manifest.toml\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] build_versions(::Pkg.Types.Context, ::Array{Base.UUID,1}; might_need_to_resolve::Bool, verbose::Bool) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:898\n```","[fredrikekre]: Reproducer:\n```\n$ cd $(mktemp -d)\n\n$ export JULIA_DEPOT_PATH=$PWD\n\n$ export JULIA_LOAD_PATH=$PWD/Project.toml\n\n$ jlpkg add JSON &> /dev/null \n\n$ rm -rf packages/JSON Project.toml\n\n$ jlpkg add Crayons\n  Resolving package versions...\n  Installed Crayons ─ v4.0.4\n  Installed JSON ──── v0.21.1\nUpdating `/tmp/tmp.NKv4yx8IEc/Project.toml`\n  [a8cc5b0e] + Crayons v4.0.4\nUpdating `/tmp/tmp.NKv4yx8IEc/Manifest.toml`\n  [a8cc5b0e] + Crayons v4.0.4\n  [682c06a0] - JSON v0.21.1\n  [69de0a69] - Parsers v1.0.12\n  [ade2ca70] - Dates\n  [a63ad114] - Mmap\n  [de0858da] - Printf\n  [4ec0a83e] - Unicode\nERROR: LoadError: could not find entry with uuid 682c06a0-de6a-54ab-a142-c8b1cf79cde6 in manifest /tmp/tmp.NKv4yx8IEc/Manifest.toml\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] build_versions(::Pkg.Types.Context, ::Array{Base.UUID,1}; might_need_to_resolve::Bool, verbose::Bool) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:898\n [3] build_versions at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:888 [inlined]\n [4] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}, ::Array{Base.UUID,1}; preserve::Pkg.Types.PreserveLevel, platform::Pkg.BinaryPlatforms.Linux) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1145\n [5] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; preserve::Pkg.Types.PreserveLevel, platform::Pkg.BinaryPlatforms.Linux, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:188\n [6] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:139\n [7] add(::Array{Pkg.Types.PackageSpec,1}; kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67\n [8] add(::Array{Pkg.Types.PackageSpec,1}) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67\n [9] do_cmd!(::Pkg.REPLMode.Command, ::Pkg.REPLMode.MiniREPL) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/REPLMode/REPLMode.jl:404\n [10] do_cmd(::Pkg.REPLMode.MiniREPL, ::String; do_rethrow::Bool) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/REPLMode/REPLMode.jl:382\n [11] pkgstr(::String) at /home/fredrik/julia15/usr/share/julia/stdlib/v1.5/Pkg/src/REPLMode/REPLMode.jl:464\n [12] top-level scope at /usr/local/bin/jlpkg:192\n [13] include(::Function, ::Module, ::String) at ./Base.jl:380\n [14] include(::Module, ::String) at ./Base.jl:368\n [15] exec_options(::Base.JLOptions) at ./client.jl:296\n [16] _start() at ./client.jl:506\nin expression starting at /usr/local/bin/jlpkg:191\n``` | [KristofferC]: So what I think happens:\n\n- JSON is in the manifest\n- The tiered resolver tries to fix all the packages in the manifest and resolve.\n- This causes JSON to get installed (even though it is not a dep anything in the project).\n- The manifest is pruned, removing the JSON entry from the manifest.\n- The build step runs, notices that JSON should be built because it was installed but it is no longer in the manifest\n\nThis should be fixable by just pruning the manifest on the creation of the `EnvCache`.\n\nThe second problem is the whole `Vector{::PackageSpec}` we have going around everywhere. When this gets desynced with the environment, weird things happen. I have some local work that only uses `PackageSpec` as an input to the resolver step, which returns a new environment and then the environment is used everywhere, but that is quite a bit away from PR-ing.",2,false,1,1,0,0,0,0,0,0,0
2217,bypass registry sync when handling stdlib packages,open,felipenoris,,,,6,2020-11-18T20:22:21.0,2020-11-25T12:43:55.0,1704,1698,https://github.com/JuliaLang/Pkg.jl/issues/2217,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2217,"`General` does not record state for stdlib packages AFAIK. In that case, maybe it shouldn't be required to sync with the general registry when adding a stdlib to a project.\n\n```\nλ julia -q --project=@.\n(Si1Client) pkg> add Dates\n   Updating registry at `D:\Users\FNORO\.julia\registries\General`\n```\n\nI remember this discussion before, but I couldn't find an issue. I'm sorry if this is something already settled or if there is already a solution that I'm not aware of.","[KristofferC]: Instead, maybe we should just update the registry a bit more seldom on `add`. One time per session is perhaps excessive.. | [felipenoris]: If you wanna go on that direction, I would suggest to never sync to registry during an `add` command. For that we have the `update`. It would be a bit less user-friendly, but helpful in a few corner-case situations. | [KristofferC]: Hm, I still think there is some value doing it sometimes on `add`. Just so it doesn't drift too far off. | [StefanKarpinski]: We used to (pre-1.0) not update the registry on `add`, only on `up` and it was very, very confusing to people. | [felipenoris]: Maybe it should just bypass registry sync when the set of package names that the command receives contains only stdlib packages. | [fredrikekre]: Seems like a micro-optimization thats probalby not worth it. We could consider updating more seldom, but I don't think it is a good idea to base that on whether you work with stdlibs or not.",6,false,0,0,0,0,0,0,0,0,0
1614,Unable to install a test dependency,open,timholy,,,,17,2020-01-14T17:20:35.0,2020-11-23T16:26:11.0,2013,1699,https://github.com/JuliaLang/Pkg.jl/issues/1614,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1614,"In https://github.com/JuliaIO/MetaImageFormat.jl/pull/6, I encountered a new phenomenon: on Julia 1.0 (but not 1.3), tests [failed because of the inability to install a test dependency](https://travis-ci.org/JuliaIO/MetaImageFormat.jl/jobs/636998554?utm_medium=notification&utm_source=github_status). I then tried putting bounds in `[compat]` for the dependency without adding it to `[deps]`, but this did not fix it (https://github.com/JuliaIO/MetaImageFormat.jl/pull/6/commits/feb0e032bf15880eef42de3bb559bc8ca73993f5). Then I added it to `[deps]` and it worked (https://github.com/JuliaIO/MetaImageFormat.jl/pull/6/commits/72ffea1015347a45995e1a1fc205dda9376e2438). However, the package does not reference `Images` directly.\n\nThe problem seems to be that it chose specific package versions and then asked which versions of the test dependencies needed to be installed. Unfortunately there was no solution to that problem. By putting the test dependencies into the version resolution, it was able to come to a satisfactory solution.","[mcabbott]: I think I ran into this today. In my case, one of my dependencies depends on SpecialFunctions, which recently tagged 1.0, and so this gets installed. But (at least) one of my test dependencies does not (yet) accept that, so cannot be installed, and it fails. \n\nThe same solution, of making SpecialFunctions version 0.10 a direct dependency, eventually worked. But I'm not sure why test dependencies aren't included, the first time, when installing packages to test a package? If you were trying to run the tests by hand locally, you would install everything you needed before starting.\n\nAlong the way I was surprised that other things did not work. Such as creating a `test/Project.toml` file with version bounds. (They seemed to be silently ignored, for already-installed packages.) Or checking in `test/Manifest.toml` (which seemed to do nothing?).\n\nIs how this works documented somewhere? All I could find is https://julialang.github.io/Pkg.jl/dev/creating-packages/#Adding-tests-to-the-package which isn't very explicit, but makes it sound like it should just work -- that a `test/Project` + `Manifest` would be like an ordinary Project, except with the package being tested automatically included. But it seems to be quite different. | [timholy]: > But I'm not sure why test dependencies aren't included, the first time, when installing packages to test a package?\n\nThey are, on every julia version except 1.0.x. Or more accurately, Pkg can downgrade packages as needed to install a test dependency.\n\n1.6 can't come fast enough :smile:. | [mcabbott]: I confess that I did not keep detailed notes. But I was testing 1.3 + 1.5 + nightly, and I think 1.3 had this initial problem of installing first the wrong versions & then failing to install test deps. | [DilumAluthge]: > Pkg can downgrade packages as needed to install a test dependency.\n\nThis functionality (known as the """"tiered resolver"""") should be available in Julia 1.4 and greater. | [mcabbott]: Well maybe I should dump 1.3, when next I feel like playing poke-the-CI games. Is this all written down somewhere? I couldn't find a NEWS file, nor really parse what the PRs were doing as (understandably) they aren't written for end-users. | [DilumAluthge]: There is some documentation about the tiered resolver: https://julialang.github.io/Pkg.jl/v1/api/#Pkg.add\n\nUnfortunately, it does not mention that the tiered resolver was implemented in Julia 1.4. | [mcabbott]: OK, I did not think to look at `add`, since I don't call that, CI test is just supposed to sort it out... although I guess it must. \n\nBut it's not so clear to me what """"tiered"""" means there, except that I now know it has something to do with this issue. The """"tiers"""" in question are the options, or are subsets of packages like previous/new which get treated differently? | [DilumAluthge]: The tiers have to do with how strictly the resolver tries to preserve the current versions of dependencies when adding new dependencies. | [mcabbott]: I see it has something to do with that. But what exactly does """"tier"""", the noun, refer to? That's what seems confusingly circular. The docstring introducing this concept seems to expect you to know what the concept is. Are they the same thing as the """"values"""" listed below? Does """"key into"""" mean something apart from choose? \n\n(Sorry about all the griping here, probably not your fault, etc! Was just frustrated how hard this was to sort out.) | [DilumAluthge]: Each """"tier"""" is a level of strictness. There are five """"tiers"""" of strictness, ranging from most strict to least strict. They are listed under """"Resolution Tiers"""" in the link above.\n\nI'll admit that this documentation is not immediately obvious to someone that comes to the documentation looking for information on test dependencies. | [DilumAluthge]: In Julia 1.4 and above, when Pkg adds test dependencies, it uses the `PRESERVE_TIERED` tier by default. This allows Pkg to downgrade some direct dependencies in order to be able to add all of the test dependencies.\n\nHowever, in Julia 1.3 and earlier, when Pkg adds test dependencies, it is not allowed to downgrade any direct dependencies. | [mcabbott]: Does this mean the behaviour of 1.3 & down was """"PRESERVE_ALL"""", or something subtly different? \n\nI can have a go at editing the docstring, if this is likely to be welcomed, but would like not to introduce misinformation. | [DilumAluthge]: > Does this mean the behaviour of 1.3 & down was """"PRESERVE_ALL""""\n\nI believe this is correct, but it would be good for @KristofferC or @00vareladavid to confirm. | [mcabbott]: OK, #2231 is my edit. | [KristofferC]: These stuff might not be documented precisely simply because it isn't clear what the correct/intended behavior is yet. | [mcabbott]: It's just super-frustrating that the method of finding out the actual implemented behaviour seems to be """"push it and see whether travis complains or not"""". Especially if trying to support & test a reasonable number of versions is something we encourage. | [KristofferC]: Sure, but that doesn't really change anything, or?",17,false,0,0,0,0,0,0,0,0,0
2165,Can `Resolve.Fixed` be removed?,open,KristofferC,,,,6,2020-10-24T17:20:10.0,2020-11-20T15:31:58.0,1729,1702,https://github.com/JuliaLang/Pkg.jl/issues/2165,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2165,"`Resolve.Fixed` is a struct that is used for packages where a fixed version is required. However, why cannot I treat that as a normal dependency with a `VersionSpec` containing one valid version, e.g.\n\n```\njulia> Pkg.Types.VersionSpec(v""""1.2.3"""")\nVersionSpec(""""1.2.3"""")\n```\n\nDoes `Fixed` have any specific semantics when it comes to the resolver? cc @carlobaldassi","[carlobaldassi]: I think that the only real difference from the point of view of the resolver is in the logging and error messages. In the initial stages of solving, they are used to simplify the graph right away (all their requirements are propagated etc.). A package with a single allowed version would be pruned anyway, [with this log message though](https://github.com/JuliaLang/Pkg.jl/blob/827a740800d047074046f89835e903cc49ba31e2/src/Resolve/graphtype.jl#L744).\n\nA small complication is that juiia itself is treated as a fixed package, so using it to simplify the graph right away might affect the performance significantly perhaps? I think it's hard to tell without trying. Then if we remove the special treatment of fixed packages but keep it for Julia, we might not have gained much I guess. | [KristofferC]: But perhaps we could still do that optimization by running it on all packages with a `VersionSpec` that is dynamically checked to only a version while still being able to simplify the code (by removing the Fixed struct). | [carlobaldassi]: I think that's what we do already, basically, see [here](https://github.com/JuliaLang/Pkg.jl/blob/827a740800d047074046f89835e903cc49ba31e2/src/Resolve/graphtype.jl#L1351-L1354) and then [here](https://github.com/JuliaLang/Pkg.jl/blob/827a740800d047074046f89835e903cc49ba31e2/src/Resolve/graphtype.jl#L1351-L1354).\n\nIn fact, upon looking again at the code, I'm not sure the performance issue is actually relevant.\n\nThe log issue might be addressed, but we would still need to pass the information about which packages were fixed to the graph constructor. The packages uuids would probably suffice though.\n\nIt might make sense to begin with to try passing no `Fixed` packages to the resolver, and only single-version requirements, and then take it from there, | [KristofferC]: > I think that's what we do already, basically, see [here](https://github.com/JuliaLang/Pkg.jl/blob/827a740800d047074046f89835e903cc49ba31e2/src/Resolve/graphtype.jl#L1351-L1354) and then [here](https://github.com/JuliaLang/Pkg.jl/blob/827a740800d047074046f89835e903cc49ba31e2/src/Resolve/graphtype.jl#L1351-L1354).\n\nI think those are the same link twice.\n\n> It might make sense to begin with to try passing no Fixed packages to the resolver, and only single-version requirements, and then take it from there,\n\nI'll try it out. \n\n\n | [KristofferC]: @carlobaldassi Does it ever make sense for a package to be both """"fixed"""" and """"required""""? Or does fixed imply required? | [carlobaldassi]: I think fixed implies required. A fixed package is removed from the graph right away and it's not involved in the resolver's process. So it shouldn't even be possible to require it, I guess. A required package in general has a range of versions allowed, but it's still removed from the graph if in practice it turns out that only one version is possible.",6,false,0,0,0,0,0,0,0,0,0
2211,Resolve failure with odd error message,open,yha,,,,2,2020-11-15T17:54:16.0,2020-11-15T19:21:30.0,1707,1707,https://github.com/JuliaLang/Pkg.jl/issues/2211,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2211,"A reproducing example:\n1. Create a simple package with one dependency\n```\n]generate TmpPkg\n]activate TmpPkg\n]add CircularArrays\n```\n2. Add a compat entry in `TmpPkg/Project.toml`:\n```\n[compat]\nCircularArrays = """"~1.0""""\n```\n3. Create a new project with `TmpPkg` as dependency:\n```\nmkdir(""""tmp-proj"""")\n]activate tmp-proj\n]dev ./TmpPkg\n```\n4. Change compat section in `TmpPkg/Project.toml` to read\n```\n[compat]\nCircularArrays = """"1.1""""\n```\n5. Try `resolve` to use new compat data\n```\n(tmp-proj) pkg> resolve\nERROR: Unsatisfiable requirements detected for package CircularArrays [7a955b69]:\n CircularArrays [7a955b69] log:\n ├─possible versions are: [0.1.0, 1.0.0, 1.1.0-1.1.1] or uninstalled\n ├─restricted to versions 1.1.0-1 by TmpPkg [933ce275], leaving only versions 1.1.0-1.1.1\n │ └─TmpPkg [933ce275] log:\n │   ├─possible versions are: 0.1.0 or uninstalled\n │   └─TmpPkg [933ce275] is fixed to version 0.1.0\n └─restricted to versions 1.0.0 by an explicit requirement — no versions left\n```\n\nA possible workaround at this point is `add CircularArrays; remove CircularArrays`. \nI see two issues here:\n- I think it's surprising that `resolve` fails. It only needs to upgrade a single dependency that is not required anywhere else.\n- The error message is confusing, since it claims version 1.0 is an """"explicit requirement"""", although no version of that package was explicitly added in current environment (`tmp-proj`), and version 1.0 is not mentioned in the project file of the environment or of any of its dependencies – so it's far from """"explicit"""". As far as I can tell, this is just an artifact of a previous version resolution.\n","[DilumAluthge]: Instead of doing `] resolve`, you should be doing `] up`.\n\n---\n\n`] resolve` is equivalent to `] up --fixed` (i.e. `up` with the `--fixed` upgrade level).\nhttps://github.com/JuliaLang/Pkg.jl/blob/f6b1c45eada0ed34d9ed8abd03304b38cb1597e8/src/API.jl#L260-L264\n\nIt is the expected behavior that doing `] up --fixed` will not upgrade any of the packages that already exist in the manifest. In your example, CircularArrays already exists at version 1.0.0 in the current manifest. Therefore, when you run `] up --fixed`, Pkg is not allowed to upgrade the version of CircularArrays (because the upgrade level is `--fixed`).\n\nMore details on upgrade levels here: https://julialang.github.io/Pkg.jl/v1.5/repl/#repl-update | [yha]: > ] resolve is equivalent to ] up --fixed (i.e. up with the --fixed upgrade level).\n\nThe docs for `resolve` should probably mention that.\nReading the documentation of `update` it sounds like `]up --fixed` (without specifying a package) is a no-op. I assume that's wrong if it's equivalent to `]resolve`, so that's another doc issue.\n\nWhat should I be running if I changed the compats of a deved package, and want to minimally change package versions to comply with it?",2,false,0,0,0,0,0,0,0,0,0
1855,Improve appearance of Conflict messsages,open,oxinabox,,,,0,2020-06-09T12:43:50.0,2020-11-12T21:17:35.0,1867,1710,https://github.com/JuliaLang/Pkg.jl/issues/1855,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1855,"People often complain about getting conflicts, and not knowing what to do from the logs.\nI don't mind the conflicts myself, and i have learned how to read the logs to get the information i need to resolve it.\n\nBut I do think the logs are a bit of a wall of text when you see them.\nSo this issue proposed some thing to do to improve them.\n\nWhile I am going to list a bunch of things, in order,\nthey don't all have to be done, nor done in this order.\nBut I only wanted to create 1 set of mockups\n\n----\n\nWe start with a message like:\n\n```\n(@v1.4) pkg> pin CSV@0.6.2\nERROR: Unsatisfiable requirements detected for package CSV [336ed68f]:\n CSV [336ed68f] log:\n ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.3, 0.5.0-0.5.26, 0.6.0-0.6.2] or uninstalled\n ├─restricted to versions 0.6.2 by an explicit requirement, leaving only versions 0.6.2\n └─restricted by compatibility requirements with FilePathsBase [48062228] to versions: [0.3.0-0.3.1, 0.4.0-0.4.3, 0.5.0-0.5.13] or uninstalled — no versions left\n   └─FilePathsBase [48062228] log:\n     ├─possible versions are: [0.2.0, 0.3.0-0.3.1, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0, 0.8.0, 0.9.0-0.9.3] or uninstalled\n     └─restricted to versions 0.9.3 by an explicit requirement, leaving only versions 0.9.3\n```\n\n----\n\n- [ ] Remove possible versions line, or leaving only versions bit, Or both (shown)\n\nThis information is not really that helpful.\nHaving both is almost(but not quiet) redundant.\nIf we are getting rid of one but not both, i suggest the possible versions one.\n\nOne effect to bare in mind is humans are fairly good at spotting this kind of satisfiablity problem (its basically easier sudoku),\nand actually working it out probably makes them happier about the error message (yay i solved a problem),\nand front loads into there thoughts the packages they are going to have to workout how to change.\n\n- [ ] make explict version restriction line, like compatiblity requriment line say """"by ... restricted to ..."""", *not* """"to ... by ..."""".\n\nThis just makes it visually easier to parse since the lines will all follow same structure.\nEsp with colors as proposed further down.\n\nThese changes would take us to:\n```\n(@v1.4) pkg> pin CSV@0.6.2\nERROR: Unsatisfiable requirements detected for package CSV [336ed68f]:\n CVS@0.6.2 incompatible\n CSV [336ed68f] log:\n ├─restricted by an explicit requirement restricted to versions: [0.6.2]\n └─restricted by compatibility requirements with FilePathsBase [48062228] to versions: [0.3.0-0.3.1, 0.4.0-0.4.3, 0.5.0-0.5.13]\n   └─FilePathsBase [48062228] log:\n     └─restricted by an explicit requirement restricted to versions: [0.9.3]\n```\n\n---\n\n- [x] Compress the ranges based on what currently exists\n\nI am not sure how hard this is, I think not too hard and i think we have tooling for it already maybe for the registry?\nBasically we don't need to have more than 1  interval listed, except if there is something disjoint like `1-2, 3-5`\n\n\nThis cuts down a lot of text and thus makes it much more readable:\n```\n(@v1.4) pkg> pin CSV@0.6.2\nERROR: Unsatisfiable requirements detected for package CSV [336ed68f]:\n CVS@0.6.2 incompatible\n CSV [336ed68f] log:\n ├─restricted by an explicit requirement restricted to versions: [0.6.2]\n └─restricted by compatibility requirements with FilePathsBase [48062228] to versions: [0.3.0 - 0.5.13]\n   └─FilePathsBase [48062228] log:\n     └─restricted by an explicit requirement restricted to versions: [0.9.3]\n```\n\n---\n\n- [x] Add color. Shown is colorizing package names and version intervals\n\n@KristofferC  suggests maybe we could color each package name differently.\nIf we did that we should probably colorize the `explict requirements` with the colour for the current project/package\n\n![image](https://user-images.githubusercontent.com/5127634/84148209-8a27e080-aa56-11ea-9e3f-2801ac0a6075.png)\n\n---\n\n - [ ] Remove excess words, this improves signal to noise ratio and makes it more likely to fit on 1 line, thus being more readable.\n\nHere i removed `log` and rephrased `by compatiblity requirements with` to `by compat with`\n(I feel the abbreviation is justified since if they can solve it then the know the section is called `[compat]`)\n\n<img width=""""1028"""" alt=""""image"""" src=""""https://user-images.githubusercontent.com/5127634/84149024-b7c15980-aa57-11ea-8846-1c92f6f2e578.png"""">\n",,0,false,3,3,0,0,0,0,0,0,0
2206,Include restricted package versions on log lines,open,imciner2,,,,1,2020-11-12T16:04:51.0,2020-11-12T21:16:49.0,1710,1710,https://github.com/JuliaLang/Pkg.jl/issues/2206,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2206,"Currently, the unsatisfiable package requirements error can be very long and difficult to read for some errors (such as the one shown at the bottom of this report), and many sections of large/complex logs make reference to log lines further up in the report. This makes it very difficult to read which package versions it is trying to use in some places. For instance, the last lines of the below report say:\n```\n └─restricted by compatibility requirements with Plots [91a5bcdd] to versions: 0.32.0-0.32.2 — no versions left\n   └─Plots [91a5bcdd] log:\n     ├─possible versions are: [0.12.1-0.12.4, 0.13.0-0.13.1, 0.14.0-0.14.2, 0.15.0-0.15.1, 0.16.0, 0.17.0-0.17.4, 0.18.0, 0.19.0-0.19.3, 0.20.0-0.20.6, 0.21.0, 0.22.0-0.22.5, 0.23.0-0.23.2, 0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1] or uninstalled\n     ├─restricted to versions [0.24-0.29, 1] by ControlSystems [a6e380b2], leaving only versions [0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─ControlSystems [a6e380b2] log: see above\n     ├─restricted by compatibility requirements with StatsPlots [f3b207a7] to versions: [0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─StatsPlots [f3b207a7] log: see above\n     ├─restricted by compatibility requirements with Requires [ae029012] to versions: [0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1] or uninstalled, leaving only versions: [0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─Requires [ae029012] log: see above\n     └─restricted by compatibility requirements with RecipesBase [3cdcf5f2] to versions: [0.12.1-0.12.4, 0.13.0-0.13.1, 0.14.0-0.14.2, 0.15.0-0.15.1, 0.16.0, 0.17.0-0.17.4, 0.18.0, 0.19.0-0.19.3, 0.20.0-0.20.6, 0.21.0, 0.22.0-0.22.5, 0.23.0-0.23.2, 0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4] or uninstalled, leaving only versions: 0.28.4\n       └─RecipesBase [3cdcf5f2] log: see above\n```\nwhich contains no information in these lines about which version of RecipesBase was being used force only one version of the Plots package to be used, and forces the user to go spelunking further up in the report to figure out which version is actually being used (which for some reports can be difficult to parse)\n\nIn my opinion, it would be nicer to include the versions the package is restricted to on a log line in this report before the `see above` statement. E.g. something like\n```\n └─restricted by compatibility requirements with Plots [91a5bcdd] to versions: 0.32.0-0.32.2 — no versions left\n   └─Plots [91a5bcdd] log:\n     ├─possible versions are: [0.12.1-0.12.4, 0.13.0-0.13.1, 0.14.0-0.14.2, 0.15.0-0.15.1, 0.16.0, 0.17.0-0.17.4, 0.18.0, 0.19.0-0.19.3, 0.20.0-0.20.6, 0.21.0, 0.22.0-0.22.5, 0.23.0-0.23.2, 0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1] or uninstalled\n     ├─restricted to versions [0.24-0.29, 1] by ControlSystems [a6e380b2], leaving only versions [0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─ControlSystems [a6e380b2] log:\n     │   ├─fixed to version 0.8.0\n     │   └─see above\n     ├─restricted by compatibility requirements with StatsPlots [f3b207a7] to versions: [0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─StatsPlots [f3b207a7] log:\n     │   ├─restricted to versions: 0.14.11-0.14.17\n     │   └─see above\n     ├─restricted by compatibility requirements with Requires [ae029012] to versions: [0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1] or uninstalled, leaving only versions: [0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─Requires [ae029012] log:\n     │   ├─restricted to versions: [1.0.0-1.0.3, 1.1.0]\n     │   └─see above\n     └─restricted by compatibility requirements with RecipesBase [3cdcf5f2] to versions: [0.12.1-0.12.4, 0.13.0-0.13.1, 0.14.0-0.14.2, 0.15.0-0.15.1, 0.16.0, 0.17.0-0.17.4, 0.18.0, 0.19.0-0.19.3, 0.20.0-0.20.6, 0.21.0, 0.22.0-0.22.5, 0.23.0-0.23.2, 0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4] or uninstalled, leaving only versions: 0.28.4\n       └─RecipesBase [3cdcf5f2] log:\n         ├─restricted to versions: 0.7.0\n         └─see above\n```\n\nNote: this log is from running Julia 1.5.3\n\n# Sample complex report where this would be useful\n```\nERROR: Unsatisfiable requirements detected for package StatsBase [2913bbd2]:\n StatsBase [2913bbd2] log:\n ├─possible versions are: [0.24.0, 0.25.0, 0.26.0, 0.27.0, 0.28.0-0.28.1, 0.29.0, 0.30.0, 0.31.0, 0.32.0-0.32.2, 0.33.0-0.33.2] or uninstalled\n ├─restricted to versions * by RowActionMethods [8996f5da], leaving only versions [0.24.0, 0.25.0, 0.26.0, 0.27.0, 0.28.0-0.28.1, 0.29.0, 0.30.0, 0.31.0, 0.32.0-0.32.2, 0.33.0-0.33.2]\n │ └─RowActionMethods [8996f5da] log:\n │   ├─possible versions are: 0.1.0 or uninstalled\n │   └─RowActionMethods [8996f5da] is fixed to version 0.1.0\n ├─restricted by compatibility requirements with Distributions [31c24e10] to versions: [0.32.0-0.32.2, 0.33.0-0.33.2]\n │ └─Distributions [31c24e10] log:\n │   ├─possible versions are: [0.16.0-0.16.4, 0.17.0, 0.18.0, 0.19.1-0.19.2, 0.20.0, 0.21.0-0.21.3, 0.21.5-0.21.12, 0.22.0-0.22.6, 0.23.0-0.23.12, 0.24.0-0.24.3] or uninstalled\n │   ├─restricted to versions * by RowActionMethods [8996f5da], leaving only versions [0.16.0-0.16.4, 0.17.0, 0.18.0, 0.19.1-0.19.2, 0.20.0, 0.21.0-0.21.3, 0.21.5-0.21.12, 0.22.0-0.22.6, 0.23.0-0.23.12, 0.24.0-0.24.3]\n │   │ └─RowActionMethods [8996f5da] log: see above\n │   ├─restricted by compatibility requirements with FillArrays [1a297f60] to versions: [0.16.0-0.16.4, 0.17.0, 0.18.0, 0.19.1-0.19.2, 0.20.0, 0.21.0-0.21.3, 0.21.5-0.21.9, 0.23.9-0.23.12, 0.24.0-0.24.3] or uninstalled, leaving only versions: [0.16.0-0.16.4, 0.17.0, 0.18.0, 0.19.1-0.19.2, 0.20.0, 0.21.0-0.21.3, 0.21.5-0.21.9, 0.23.9-0.23.12, 0.24.0-0.24.3]\n │   │ └─FillArrays [1a297f60] log:\n │   │   ├─possible versions are: [0.2.0-0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.4, 0.7.0-0.7.4, 0.8.0-0.8.14, 0.9.0-0.9.7, 0.10.0] or uninstalled\n │   │   └─restricted to versions 0.9.6-0.10 by BlockArrays [8e7c35d0], leaving only versions [0.9.6-0.9.7, 0.10.0]\n │   │     └─BlockArrays [8e7c35d0] log:\n │   │       ├─possible versions are: 0.12.14 or uninstalled\n │   │       └─BlockArrays [8e7c35d0] is fixed to version 0.12.14\n │   ├─restricted by compatibility requirements with SpecialFunctions [276daf66] to versions: [0.21.6-0.21.12, 0.22.0-0.22.6, 0.23.0-0.23.12, 0.24.0-0.24.3] or uninstalled, leaving only versions: [0.21.6-0.21.9, 0.23.9-0.23.12, 0.24.0-0.24.3]\n │   │ └─SpecialFunctions [276daf66] log:\n │   │   ├─possible versions are: [0.7.0-0.7.2, 0.8.0, 0.9.0, 0.10.0-0.10.3] or uninstalled\n │   │   └─restricted by compatibility requirements with DSP [717857b8] to versions: [0.8.0, 0.9.0, 0.10.0-0.10.3]\n │   │     └─DSP [717857b8] log:\n │   │       ├─possible versions are: [0.5.1-0.5.2, 0.6.0-0.6.8] or uninstalled\n │   │       ├─restricted to versions 0.6.1-0.6 by ControlSystems [a6e380b2], leaving only versions 0.6.1-0.6.8\n │   │       │ └─ControlSystems [a6e380b2] log:\n │   │       │   ├─possible versions are: 0.8.0 or uninstalled\n │   │       │   ├─restricted to versions * by ControlBenchmarks [3abdc708], leaving only versions 0.8.0\n │   │       │   │ └─ControlBenchmarks [3abdc708] log:\n │   │       │   │   ├─possible versions are: 0.1.0 or uninstalled\n │   │       │   │   └─ControlBenchmarks [3abdc708] is fixed to version 0.1.0\n │   │       │   └─ControlSystems [a6e380b2] is fixed to version 0.8.0\n │   │       └─restricted by compatibility requirements with Polynomials [f27b6e38] to versions: 0.6.7-0.6.8 or uninstalled, leaving only versions: 0.6.7-0.6.8\n │   │         └─Polynomials [f27b6e38] log:\n │   │           ├─possible versions are: [0.5.0-0.5.3, 0.6.0-0.6.1, 0.7.0, 0.8.0, 1.0.0-1.0.6, 1.1.0-1.1.11] or uninstalled\n │   │           └─restricted to versions 1 by ControlSystems [a6e380b2], leaving only versions [1.0.0-1.0.6, 1.1.0-1.1.11]\n │   │             └─ControlSystems [a6e380b2] log: see above\n │   └─restricted by compatibility requirements with KernelDensity [5ab0869b] to versions: [0.23.0-0.23.12, 0.24.0-0.24.3], leaving only versions: [0.23.9-0.23.12, 0.24.0-0.24.3]\n │     └─KernelDensity [5ab0869b] log:\n │       ├─possible versions are: [0.5.0-0.5.1, 0.6.0-0.6.2] or uninstalled\n │       ├─restricted by compatibility requirements with StatsPlots [f3b207a7] to versions: [0.5.0-0.5.1, 0.6.0-0.6.2]\n │       │ └─StatsPlots [f3b207a7] log:\n │       │   ├─possible versions are: [0.10.0-0.10.2, 0.11.0, 0.12.0, 0.13.0, 0.14.0-0.14.17] or uninstalled\n │       │   ├─restricted to versions * by an explicit requirement, leaving only versions [0.10.0-0.10.2, 0.11.0, 0.12.0, 0.13.0, 0.14.0-0.14.17]\n │       │   ├─restricted by compatibility requirements with RecipesBase [3cdcf5f2] to versions: [0.12.0, 0.13.0, 0.14.0-0.14.17] or uninstalled, leaving only versions: [0.12.0, 0.13.0, 0.14.0-0.14.17]\n │       │   │ └─RecipesBase [3cdcf5f2] log:\n │       │   │   ├─possible versions are: [0.4.0, 0.5.0, 0.6.0, 0.7.0, 0.8.0, 1.0.0-1.0.2, 1.1.0-1.1.1] or uninstalled\n │       │   │   ├─restricted by compatibility requirements with StatsPlots [f3b207a7] to versions: [0.5.0, 0.6.0, 0.7.0, 0.8.0, 1.0.0-1.0.2, 1.1.0-1.1.1]\n │       │   │   │ └─StatsPlots [f3b207a7] log: see above\n │       │   │   ├─restricted by compatibility requirements with Polynomials [f27b6e38] to versions: [0.7.0, 0.8.0, 1.0.0-1.0.2, 1.1.0-1.1.1]\n │       │   │   │ └─Polynomials [f27b6e38] log: see above\n │       │   │   └─restricted by compatibility requirements with RecursiveArrayTools [731186ca] to versions: [0.4.0, 0.5.0, 0.6.0, 0.7.0], leaving only versions: 0.7.0\n │       │   │     └─RecursiveArrayTools [731186ca] log:\n │       │   │       ├─possible versions are: [0.16.0-0.16.3, 0.17.0-0.17.2, 0.18.0-0.18.6, 0.19.0-0.19.1, 0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1, 2.0.0-2.0.5, 2.1.0-2.1.2, 2.2.0, 2.3.0-2.3.5, 2.4.0-2.4.4, 2.5.0, 2.6.0, 2.7.0-2.7.2] or uninstalled\n │       │   │       ├─restricted by compatibility requirements with DifferentialEquations [0c46a032] to versions: [0.16.0-0.16.3, 0.17.0-0.17.2, 0.18.0-0.18.6, 0.19.0-0.19.1, 0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1, 2.0.0-2.0.5, 2.1.0-2.1.2, 2.2.0, 2.3.0-2.3.5, 2.4.0-2.4.4, 2.5.0, 2.6.0, 2.7.0-2.7.2]\n │       │   │       │ └─DifferentialEquations [0c46a032] log:\n │       │   │       │   ├─possible versions are: [5.0.0, 5.1.0, 5.2.0-5.2.1, 5.3.0-5.3.1, 6.0.0, 6.1.0, 6.2.0, 6.3.0, 6.4.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0-6.10.1, 6.11.0, 6.12.0, 6.13.0, 6.14.0, 6.15.0] or uninstalled\n │       │   │       │   ├─restricted to versions * by an explicit requirement, leaving only versions [5.0.0, 5.1.0, 5.2.0-5.2.1, 5.3.0-5.3.1, 6.0.0, 6.1.0, 6.2.0, 6.3.0, 6.4.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0-6.10.1, 6.11.0, 6.12.0, 6.13.0, 6.14.0, 6.15.0]\n │       │   │       │   ├─restricted by compatibility requirements with DiffEqPDEBase [34035eb4] to versions: [6.3.0, 6.4.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0-6.10.1, 6.11.0, 6.12.0, 6.13.0, 6.14.0, 6.15.0] or uninstalled, leaving only versions: [6.3.0, 6.4.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0-6.10.1, 6.11.0, 6.12.0, 6.13.0, 6.14.0, 6.15.0]\n │       │   │       │   │ └─DiffEqPDEBase [34035eb4] log:\n │       │   │       │   │   ├─possible versions are: 0.4.0 or uninstalled\n │       │   │       │   │   └─restricted by compatibility requirements with Compat [34da2185] to versions: uninstalled\n │       │   │       │   │     └─Compat [34da2185] log:\n │       │   │       │   │       ├─possible versions are: [1.0.0-1.0.1, 1.1.0, 1.2.0, 1.3.0, 1.4.0, 1.5.0-1.5.1, 2.0.0, 2.1.0, 2.2.0-2.2.1, 3.0.0, 3.1.0, 3.2.0, 3.3.0-3.3.1, 3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.9.0-3.9.1, 3.10.0, 3.11.0, 3.12.0, 3.13.0, 3.14.0, 3.15.0, 3.16.0, 3.17.0, 3.18.0, 3.19.0, 3.20.0, 3.21.0, 3.22.0, 3.23.0] or uninstalled\n │       │   │       │   │       ├─restricted to versions 2.2.0-3 by BlockArrays [8e7c35d0], leaving only versions [2.2.0-2.2.1, 3.0.0, 3.1.0, 3.2.0, 3.3.0-3.3.1, 3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.9.0-3.9.1, 3.10.0, 3.11.0, 3.12.0, 3.13.0, 3.14.0, 3.15.0, 3.16.0, 3.17.0, 3.18.0, 3.19.0, 3.20.0, 3.21.0, 3.22.0, 3.23.0]\n │       │   │       │   │       │ └─BlockArrays [8e7c35d0] log: see above\n │       │   │       │   │       └─restricted by compatibility requirements with ArrayLayouts [4c555306] to versions: [3.16.0, 3.17.0, 3.18.0, 3.19.0, 3.20.0, 3.21.0, 3.22.0, 3.23.0]\n │       │   │       │   │         └─ArrayLayouts [4c555306] log:\n │       │   │       │   │           ├─possible versions are: [0.1.0-0.1.5, 0.2.0-0.2.6, 0.3.0-0.3.8, 0.4.0-0.4.10] or uninstalled\n │       │   │       │   │           └─restricted to versions 0.4.8-0.4 by BlockArrays [8e7c35d0], leaving only versions 0.4.8-0.4.10\n │       │   │       │   │             └─BlockArrays [8e7c35d0] log: see above\n │       │   │       │   ├─restricted by compatibility requirements with StochasticDiffEq [789caeaf] to versions: [5.0.0, 5.1.0, 5.2.0-5.2.1, 5.3.0-5.3.1, 6.0.0, 6.1.0, 6.2.0, 6.3.0, 6.4.0, 6.6.0] or uninstalled, leaving only versions: [6.3.0, 6.4.0, 6.6.0]\n │       │   │       │   │ └─StochasticDiffEq [789caeaf] log:\n │       │   │       │   │   ├─possible versions are: [5.0.0, 5.1.0, 5.2.0-5.2.3, 5.3.0, 5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.1, 6.10.0, 6.11.0-6.11.2, 6.12.0, 6.13.0, 6.14.0, 6.15.0, 6.16.0-6.16.1, 6.17.0-6.17.1, 6.18.0, 6.19.0-6.19.2, 6.20.0, 6.21.0-6.21.1, 6.22.0, 6.23.0-6.23.1, 6.24.0, 6.25.0-6.25.1, 6.26.0] or uninstalled\n │       │   │       │   │   ├─restricted by compatibility requirements with FillArrays [1a297f60] to versions: [5.0.0, 5.1.0, 5.2.0-5.2.3, 5.3.0, 5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.25.1, 6.26.0] or uninstalled\n │       │   │       │   │   │ └─FillArrays [1a297f60] log: see above\n │       │   │       │   │   ├─restricted by compatibility requirements with DifferentialEquations [0c46a032] to versions: [5.0.0, 5.1.0, 5.2.0-5.2.3, 5.3.0, 5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.1, 6.10.0, 6.11.0-6.11.2, 6.12.0, 6.13.0, 6.14.0, 6.15.0, 6.16.0-6.16.1, 6.17.0-6.17.1, 6.18.0, 6.19.0-6.19.2, 6.20.0, 6.21.0-6.21.1, 6.22.0, 6.23.0-6.23.1, 6.24.0, 6.25.0-6.25.1, 6.26.0], leaving only versions: [5.0.0, 5.1.0, 5.2.0-5.2.3, 5.3.0, 5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.25.1, 6.26.0]\n │       │   │       │   │   │ └─DifferentialEquations [0c46a032] log: see above\n │       │   │       │   │   ├─restricted by compatibility requirements with Compat [34da2185] to versions: [5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.1, 6.10.0, 6.11.0-6.11.2, 6.12.0, 6.13.0, 6.14.0, 6.15.0, 6.16.0-6.16.1, 6.17.0-6.17.1, 6.18.0, 6.19.0-6.19.2, 6.20.0, 6.21.0-6.21.1, 6.22.0, 6.23.0-6.23.1, 6.24.0, 6.25.0-6.25.1, 6.26.0] or uninstalled, leaving only versions: [5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.25.1, 6.26.0]\n │       │   │       │   │   │ └─Compat [34da2185] log: see above\n │       │   │       │   │   ├─restricted by compatibility requirements with DataStructures [864edb3b] to versions: [5.0.0, 5.1.0, 5.2.0-5.2.3, 5.3.0, 5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.1, 6.10.0, 6.11.0-6.11.2, 6.12.0, 6.13.0, 6.14.0, 6.15.0, 6.16.0-6.16.1, 6.17.0-6.17.1, 6.18.0, 6.19.0-6.19.2, 6.20.0, 6.21.0-6.21.1, 6.22.0, 6.23.0-6.23.1, 6.24.0, 6.25.0] or uninstalled, leaving only versions: [5.4.0, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0, 5.9.0-5.9.2, 5.10.0-5.10.4, 5.11.0-5.11.4, 5.12.0, 6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0]\n │       │   │       │   │   │ └─DataStructures [864edb3b] log:\n │       │   │       │   │   │   ├─possible versions are: [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20, 0.18.0-0.18.8] or uninstalled\n │       │   │       │   │   │   ├─restricted to versions * by RowActionMethods [8996f5da], leaving only versions [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20, 0.18.0-0.18.8]\n │       │   │       │   │   │   │ └─RowActionMethods [8996f5da] log: see above\n │       │   │       │   │   │   ├─restricted by compatibility requirements with OrdinaryDiffEq [1dea7af3] to versions: [0.15.0, 0.16.1, 0.17.0-0.17.20, 0.18.0-0.18.8]\n │       │   │       │   │   │   │ └─OrdinaryDiffEq [1dea7af3] log:\n │       │   │       │   │   │   │   ├─possible versions are: [4.0.0, 4.1.0, 4.2.0, 4.3.0, 4.4.0-4.4.1, 4.5.0, 4.6.0, 4.7.0-4.7.1, 4.8.0-4.8.1, 4.9.0, 4.10.0, 4.11.0-4.11.1, 4.12.0-4.12.4, 4.13.0, 4.14.0, 4.15.0-4.15.1, 4.16.0-4.16.5, 4.17.0-4.17.2, 4.18.0-4.18.3, 4.19.0, 4.20.0, 4.21.0-4.21.1, 5.0.0, 5.1.0-5.1.4, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0, 5.15.0-5.15.1, 5.16.0, 5.17.0-5.17.2, 5.18.0, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8, 5.27.0-5.27.1, 5.28.0-5.28.1, 5.29.0, 5.30.0, 5.31.0, 5.32.0-5.32.2, 5.33.0, 5.34.0-5.34.1, 5.35.0-5.35.5, 5.36.0-5.36.1, 5.37.0, 5.38.0-5.38.3, 5.39.0-5.39.1, 5.40.0, 5.41.0, 5.42.0-5.42.10, 5.43.0, 5.44.0, 5.45.0] or uninstalled\n │       │   │       │   │   │   │   ├─restricted to versions 5.2.0-5 by ControlSystems [a6e380b2], leaving only versions [5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0, 5.15.0-5.15.1, 5.16.0, 5.17.0-5.17.2, 5.18.0, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8, 5.27.0-5.27.1, 5.28.0-5.28.1, 5.29.0, 5.30.0, 5.31.0, 5.32.0-5.32.2, 5.33.0, 5.34.0-5.34.1, 5.35.0-5.35.5, 5.36.0-5.36.1, 5.37.0, 5.38.0-5.38.3, 5.39.0-5.39.1, 5.40.0, 5.41.0, 5.42.0-5.42.10, 5.43.0, 5.44.0, 5.45.0]\n │       │   │       │   │   │   │   │ └─ControlSystems [a6e380b2] log: see above\n │       │   │       │   │   │   │   ├─restricted by compatibility requirements with DataStructures [864edb3b] to versions: [4.0.0, 4.1.0, 4.2.0, 4.3.0, 4.4.0-4.4.1, 4.5.0, 4.6.0, 4.7.0-4.7.1, 4.8.0-4.8.1, 4.9.0, 4.10.0, 4.11.0-4.11.1, 4.12.0-4.12.4, 4.13.0, 4.14.0, 4.15.0-4.15.1, 4.16.0-4.16.5, 4.17.0-4.17.2, 4.18.0-4.18.3, 4.19.0, 4.20.0, 4.21.0-4.21.1, 5.0.0, 5.1.0-5.1.4, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0, 5.15.0-5.15.1, 5.16.0, 5.17.0-5.17.2, 5.18.0, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8, 5.27.0-5.27.1, 5.28.0-5.28.1, 5.29.0, 5.30.0, 5.31.0, 5.32.0-5.32.2, 5.33.0, 5.34.0-5.34.1, 5.35.0-5.35.5, 5.36.0-5.36.1, 5.37.0, 5.38.0-5.38.3, 5.39.0-5.39.1, 5.40.0, 5.41.0, 5.42.0-5.42.3] or uninstalled, leaving only versions: [5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0, 5.15.0-5.15.1, 5.16.0, 5.17.0-5.17.2, 5.18.0, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8, 5.27.0-5.27.1, 5.28.0-5.28.1, 5.29.0, 5.30.0, 5.31.0, 5.32.0-5.32.2, 5.33.0, 5.34.0-5.34.1, 5.35.0-5.35.5, 5.36.0-5.36.1, 5.37.0, 5.38.0-5.38.3, 5.39.0-5.39.1, 5.40.0, 5.41.0, 5.42.0-5.42.3]\n │       │   │       │   │   │   │   │ └─DataStructures [864edb3b] log: see above\n │       │   │       │   │   │   │   ├─restricted by compatibility requirements with SparseDiffTools [47a9eef4] to versions: [4.0.0, 4.1.0, 4.2.0, 4.3.0, 4.4.0-4.4.1, 4.5.0, 4.6.0, 4.7.0-4.7.1, 4.8.0-4.8.1, 4.9.0, 4.10.0, 4.11.0-4.11.1, 4.12.0-4.12.4, 4.13.0, 4.14.0, 4.15.0-4.15.1, 4.16.0-4.16.5, 4.17.0-4.17.2, 4.18.0-4.18.3, 4.19.0, 4.20.0, 4.21.0-4.21.1, 5.0.0, 5.1.0-5.1.4, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8, 5.27.0-5.27.1, 5.28.0-5.28.1, 5.29.0, 5.30.0, 5.31.0, 5.32.0-5.32.2, 5.33.0, 5.34.0-5.34.1, 5.35.0-5.35.5, 5.36.0-5.36.1, 5.37.0, 5.38.0-5.38.3, 5.39.0-5.39.1, 5.40.0, 5.41.0, 5.42.0-5.42.10, 5.43.0, 5.44.0, 5.45.0] or uninstalled, leaving only versions: [5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8, 5.27.0-5.27.1, 5.28.0-5.28.1, 5.29.0, 5.30.0, 5.31.0, 5.32.0-5.32.2, 5.33.0, 5.34.0-5.34.1, 5.35.0-5.35.5, 5.36.0-5.36.1, 5.37.0, 5.38.0-5.38.3, 5.39.0-5.39.1, 5.40.0, 5.41.0, 5.42.0-5.42.3]\n │       │   │       │   │   │   │   │ └─SparseDiffTools [47a9eef4] log:\n │       │   │       │   │   │   │   │   ├─possible versions are: [0.1.0, 0.2.0, 0.3.0, 0.4.0-0.4.1, 0.5.0, 0.6.0, 0.7.0, 0.8.0, 0.9.0-0.9.2, 0.10.0-0.10.3, 1.0.0, 1.1.0-1.1.1, 1.2.0, 1.3.0-1.3.3, 1.4.0, 1.5.0, 1.6.0, 1.7.0-1.7.1, 1.8.0, 1.9.0-1.9.1, 1.10.0-1.10.1] or uninstalled\n │       │   │       │   │   │   │   │   ├─restricted by compatibility requirements with BlockBandedMatrices [ffab5731] to versions: [0.10.0-0.10.3, 1.0.0, 1.1.0-1.1.1, 1.2.0, 1.3.0-1.3.3, 1.4.0, 1.5.0, 1.6.0, 1.7.0-1.7.1, 1.8.0, 1.9.0-1.9.1, 1.10.0-1.10.1] or uninstalled\n │       │   │       │   │   │   │   │   │ └─BlockBandedMatrices [ffab5731] log:\n │       │   │       │   │   │   │   │   │   ├─possible versions are: [0.2.0, 0.3.0-0.3.5, 0.4.0-0.4.6, 0.5.0-0.5.3, 0.6.0, 0.7.0-0.7.2, 0.8.0-0.8.11, 0.9.0-0.9.5] or uninstalled\n │       │   │       │   │   │   │   │   │   ├─restricted by compatibility requirements with BlockArrays [8e7c35d0] to versions: [0.8.0-0.8.11, 0.9.0-0.9.5] or uninstalled\n │       │   │       │   │   │   │   │   │   │ └─BlockArrays [8e7c35d0] log: see above\n │       │   │       │   │   │   │   │   │   └─restricted by compatibility requirements with ArrayLayouts [4c555306] to versions: [0.2.0, 0.3.0-0.3.5, 0.4.0-0.4.6, 0.5.0-0.5.3, 0.9.0-0.9.5] or uninstalled, leaving only versions: 0.9.0-0.9.5 or uninstalled\n │       │   │       │   │   │   │   │   │     └─ArrayLayouts [4c555306] log: see above\n │       │   │       │   │   │   │   │   ├─restricted by compatibility requirements with Requires [ae029012] to versions: [0.1.0, 0.2.0, 0.3.0, 1.1.0-1.1.1, 1.2.0, 1.3.0-1.3.3, 1.4.0, 1.5.0, 1.6.0, 1.7.0-1.7.1, 1.8.0, 1.9.0-1.9.1, 1.10.0-1.10.1] or uninstalled, leaving only versions: [1.1.0-1.1.1, 1.2.0, 1.3.0-1.3.3, 1.4.0, 1.5.0, 1.6.0, 1.7.0-1.7.1, 1.8.0, 1.9.0-1.9.1, 1.10.0-1.10.1] or uninstalled\n │       │   │       │   │   │   │   │   │ └─Requires [ae029012] log:\n │       │   │       │   │   │   │   │   │   ├─possible versions are: [0.5.0-0.5.2, 1.0.0-1.0.3, 1.1.0] or uninstalled\n │       │   │       │   │   │   │   │   │   ├─restricted by compatibility requirements with LazySets [b4f0291d] to versions: [0.5.0-0.5.2, 1.0.0-1.0.3, 1.1.0]\n │       │   │       │   │   │   │   │   │   │ └─LazySets [b4f0291d] log:\n │       │   │       │   │   │   │   │   │   │   ├─possible versions are: [1.3.0, 1.4.0, 1.5.0-1.5.3, 1.6.0, 1.7.0, 1.8.0, 1.9.0, 1.10.0, 1.11.0, 1.12.0, 1.13.0, 1.14.0-1.14.1, 1.15.0, 1.16.0, 1.17.0, 1.18.0-1.18.1, 1.19.0, 1.20.0, 1.21.0, 1.22.0, 1.23.0, 1.24.0, 1.25.0, 1.26.0, 1.27.0, 1.28.0, 1.29.0, 1.30.0, 1.31.0, 1.32.0-1.32.1, 1.33.0, 1.34.0, 1.35.0, 1.36.0-1.36.3, 1.37.0-1.37.14] or uninstalled\n │       │   │       │   │   │   │   │   │   │   ├─restricted to versions * by ControlBenchmarks [3abdc708], leaving only versions [1.3.0, 1.4.0, 1.5.0-1.5.3, 1.6.0, 1.7.0, 1.8.0, 1.9.0, 1.10.0, 1.11.0, 1.12.0, 1.13.0, 1.14.0-1.14.1, 1.15.0, 1.16.0, 1.17.0, 1.18.0-1.18.1, 1.19.0, 1.20.0, 1.21.0, 1.22.0, 1.23.0, 1.24.0, 1.25.0, 1.26.0, 1.27.0, 1.28.0, 1.29.0, 1.30.0, 1.31.0, 1.32.0-1.32.1, 1.33.0, 1.34.0, 1.35.0, 1.36.0-1.36.3, 1.37.0-1.37.14]\n │       │   │       │   │   │   │   │   │   │   │ └─ControlBenchmarks [3abdc708] log: see above\n │       │   │       │   │   │   │   │   │   │   ├─restricted by compatibility requirements with Compat [34da2185] to versions: [1.12.0, 1.13.0, 1.14.0-1.14.1, 1.15.0, 1.16.0, 1.17.0, 1.18.0-1.18.1, 1.19.0, 1.20.0, 1.21.0, 1.22.0, 1.23.0, 1.24.0, 1.25.0, 1.26.0, 1.27.0, 1.28.0, 1.29.0, 1.30.0, 1.31.0, 1.32.0-1.32.1, 1.33.0, 1.34.0, 1.35.0, 1.36.0-1.36.3, 1.37.0-1.37.14] or uninstalled, leaving only versions: [1.12.0, 1.13.0, 1.14.0-1.14.1, 1.15.0, 1.16.0, 1.17.0, 1.18.0-1.18.1, 1.19.0, 1.20.0, 1.21.0, 1.22.0, 1.23.0, 1.24.0, 1.25.0, 1.26.0, 1.27.0, 1.28.0, 1.29.0, 1.30.0, 1.31.0, 1.32.0-1.32.1, 1.33.0, 1.34.0, 1.35.0, 1.36.0-1.36.3, 1.37.0-1.37.14]\n │       │   │       │   │   │   │   │   │   │   │ └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │   │   └─restricted by compatibility requirements with GLPKMathProgInterface [3c7084bd] to versions: [1.36.3, 1.37.0-1.37.14] or uninstalled, leaving only versions: [1.36.3, 1.37.0-1.37.14]\n │       │   │       │   │   │   │   │   │   │     └─GLPKMathProgInterface [3c7084bd] log:\n │       │   │       │   │   │   │   │   │   │       ├─possible versions are: [0.4.1-0.4.4, 0.5.0] or uninstalled\n │       │   │       │   │   │   │   │   │   │       ├─restricted by compatibility requirements with LazySets [b4f0291d] to versions: [0.4.1-0.4.4, 0.5.0]\n │       │   │       │   │   │   │   │   │   │       │ └─LazySets [b4f0291d] log: see above\n │       │   │       │   │   │   │   │   │   │       └─restricted by compatibility requirements with Compat [34da2185] to versions: 0.5.0 or uninstalled, leaving only versions: 0.5.0\n │       │   │       │   │   │   │   │   │   │         └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │   └─restricted by compatibility requirements with COSMO [1e616198] to versions: [1.0.0-1.0.3, 1.1.0]\n │       │   │       │   │   │   │   │   │     └─COSMO [1e616198] log:\n │       │   │       │   │   │   │   │   │       ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.4, 0.5.0, 0.6.0, 0.7.0-0.7.7] or uninstalled\n │       │   │       │   │   │   │   │   │       ├─restricted to versions * by PredictiveControl [0acd8c25], leaving only versions [0.3.0-0.3.1, 0.4.0-0.4.4, 0.5.0, 0.6.0, 0.7.0-0.7.7]\n │       │   │       │   │   │   │   │   │       │ └─PredictiveControl [0acd8c25] log:\n │       │   │       │   │   │   │   │   │       │   ├─possible versions are: 0.1.0 or uninstalled\n │       │   │       │   │   │   │   │   │       │   └─PredictiveControl [0acd8c25] is fixed to version 0.1.0\n │       │   │       │   │   │   │   │   │       ├─restricted by compatibility requirements with UnsafeArrays [c4a57d5a] to versions: [0.3.0-0.3.1, 0.4.0, 0.7.4-0.7.7] or uninstalled, leaving only versions: [0.3.0-0.3.1, 0.4.0, 0.7.4-0.7.7]\n │       │   │       │   │   │   │   │   │       │ └─UnsafeArrays [c4a57d5a] log:\n │       │   │       │   │   │   │   │   │       │   ├─possible versions are: [0.2.0, 0.3.0, 0.4.0, 1.0.0-1.0.1] or uninstalled\n │       │   │       │   │   │   │   │   │       │   ├─restricted by compatibility requirements with Compat [34da2185] to versions: [0.4.0, 1.0.0-1.0.1] or uninstalled\n │       │   │       │   │   │   │   │   │       │   │ └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │       │   └─restricted by compatibility requirements with COSMO [1e616198] to versions: [0.3.0, 1.0.0-1.0.1], leaving only versions: 1.0.0-1.0.1\n │       │   │       │   │   │   │   │   │       │     └─COSMO [1e616198] log: see above\n │       │   │       │   │   │   │   │   │       └─restricted by compatibility requirements with MathOptInterface [b8f27783] to versions: [0.5.0, 0.6.0, 0.7.0-0.7.7] or uninstalled, leaving only versions: 0.7.4-0.7.7\n │       │   │       │   │   │   │   │   │         └─MathOptInterface [b8f27783] log:\n │       │   │       │   │   │   │   │   │           ├─possible versions are: [0.5.0-0.5.1, 0.6.0-0.6.4, 0.7.0, 0.8.0-0.8.4, 0.9.0-0.9.18] or uninstalled\n │       │   │       │   │   │   │   │   │           ├─restricted to versions * by RowActionMethods [8996f5da], leaving only versions [0.5.0-0.5.1, 0.6.0-0.6.4, 0.7.0, 0.8.0-0.8.4, 0.9.0-0.9.18]\n │       │   │       │   │   │   │   │   │           │ └─RowActionMethods [8996f5da] log: see above\n │       │   │       │   │   │   │   │   │           ├─restricted by compatibility requirements with SCS [c946c3f1] to versions: [0.6.0-0.6.4, 0.7.0, 0.8.0-0.8.4, 0.9.0-0.9.18]\n │       │   │       │   │   │   │   │   │           │ └─SCS [c946c3f1] log:\n │       │   │       │   │   │   │   │   │           │   ├─possible versions are: [0.4.0-0.4.1, 0.5.0-0.5.1, 0.6.0-0.6.6, 0.7.0-0.7.1] or uninstalled\n │       │   │       │   │   │   │   │   │           │   ├─restricted to versions * by an explicit requirement, leaving only versions [0.4.0-0.4.1, 0.5.0-0.5.1, 0.6.0-0.6.6, 0.7.0-0.7.1]\n │       │   │       │   │   │   │   │   │           │   └─restricted by compatibility requirements with Compat [34da2185] to versions: [0.6.0-0.6.6, 0.7.0-0.7.1] or uninstalled, leaving only versions: [0.6.0-0.6.6, 0.7.0-0.7.1]\n │       │   │       │   │   │   │   │   │           │     └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │           ├─restricted by compatibility requirements with OSQP [ab2f91bb] to versions: [0.6.0-0.6.4, 0.8.0-0.8.4, 0.9.1-0.9.18]\n │       │   │       │   │   │   │   │   │           │ └─OSQP [ab2f91bb] log:\n │       │   │       │   │   │   │   │   │           │   ├─possible versions are: [0.1.8, 0.2.0, 0.3.0-0.3.2, 0.4.0-0.4.1, 0.5.0-0.5.3, 0.6.0] or uninstalled\n │       │   │       │   │   │   │   │   │           │   ├─restricted to versions * by PredictiveControl [0acd8c25], leaving only versions [0.1.8, 0.2.0, 0.3.0-0.3.2, 0.4.0-0.4.1, 0.5.0-0.5.3, 0.6.0]\n │       │   │       │   │   │   │   │   │           │   │ └─PredictiveControl [0acd8c25] log: see above\n │       │   │       │   │   │   │   │   │           │   ├─restricted by compatibility requirements with MathOptInterface [b8f27783] to versions: [0.4.1, 0.5.0-0.5.3, 0.6.0] or uninstalled, leaving only versions: [0.4.1, 0.5.0-0.5.3, 0.6.0]\n │       │   │       │   │   │   │   │   │           │   │ └─MathOptInterface [b8f27783] log: see above\n │       │   │       │   │   │   │   │   │           │   ├─restricted by compatibility requirements with Compat [34da2185] to versions: [0.5.2-0.5.3, 0.6.0] or uninstalled, leaving only versions: [0.5.2-0.5.3, 0.6.0]\n │       │   │       │   │   │   │   │   │           │   │ └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │           │   └─restricted by compatibility requirements with MathOptInterface [b8f27783] to versions: [0.5.3, 0.6.0] or uninstalled, leaving only versions: [0.5.3, 0.6.0]\n │       │   │       │   │   │   │   │   │           │     └─MathOptInterface [b8f27783] log: see above\n │       │   │       │   │   │   │   │   │           ├─restricted by compatibility requirements with Compat [34da2185] to versions: 0.9.0-0.9.18 or uninstalled, leaving only versions: 0.9.1-0.9.18\n │       │   │       │   │   │   │   │   │           │ └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │           ├─restricted by compatibility requirements with ProxSDP [65e78d25] to versions: 0.9.5-0.9.18\n │       │   │       │   │   │   │   │   │           │ └─ProxSDP [65e78d25] log:\n │       │   │       │   │   │   │   │   │           │   ├─possible versions are: [0.1.0-0.1.1, 0.2.0-0.2.3, 1.0.0, 1.1.0, 1.2.0, 1.3.0-1.3.1, 1.4.0, 1.5.0-1.5.1, 1.6.0] or uninstalled\n │       │   │       │   │   │   │   │   │           │   ├─restricted to versions * by an explicit requirement, leaving only versions [0.1.0-0.1.1, 0.2.0-0.2.3, 1.0.0, 1.1.0, 1.2.0, 1.3.0-1.3.1, 1.4.0, 1.5.0-1.5.1, 1.6.0]\n │       │   │       │   │   │   │   │   │           │   └─restricted by compatibility requirements with Compat [34da2185] to versions: [1.2.0, 1.3.0-1.3.1, 1.4.0, 1.5.0-1.5.1, 1.6.0] or uninstalled, leaving only versions: [1.2.0, 1.3.0-1.3.1, 1.4.0, 1.5.0-1.5.1, 1.6.0]\n │       │   │       │   │   │   │   │   │           │     └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │           ├─restricted by compatibility requirements with COSMO [1e616198] to versions: 0.9.7-0.9.18\n │       │   │       │   │   │   │   │   │           │ └─COSMO [1e616198] log: see above\n │       │   │       │   │   │   │   │   │           └─restricted by compatibility requirements with JuMP [4076af6c] to versions: 0.9.10-0.9.18\n │       │   │       │   │   │   │   │   │             └─JuMP [4076af6c] log:\n │       │   │       │   │   │   │   │   │               ├─possible versions are: [0.18.3-0.18.6, 0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.5] or uninstalled\n │       │   │       │   │   │   │   │   │               ├─restricted to versions * by ControlBenchmarks [3abdc708], leaving only versions [0.18.3-0.18.6, 0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.5]\n │       │   │       │   │   │   │   │   │               │ └─ControlBenchmarks [3abdc708] log: see above\n │       │   │       │   │   │   │   │   │               ├─restricted by compatibility requirements with Compat [34da2185] to versions: [0.18.6, 0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.5] or uninstalled, leaving only versions: [0.18.6, 0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.5]\n │       │   │       │   │   │   │   │   │               │ └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │               ├─restricted by compatibility requirements with ReverseDiffSparse [89212889] to versions: [0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.5] or uninstalled, leaving only versions: [0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.5]\n │       │   │       │   │   │   │   │   │               │ └─ReverseDiffSparse [89212889] log:\n │       │   │       │   │   │   │   │   │               │   ├─possible versions are: 0.8.2-0.8.6 or uninstalled\n │       │   │       │   │   │   │   │   │               │   └─restricted by compatibility requirements with Compat [34da2185] to versions: uninstalled\n │       │   │       │   │   │   │   │   │               │     └─Compat [34da2185] log: see above\n │       │   │       │   │   │   │   │   │               ├─restricted by compatibility requirements with DataStructures [864edb3b] to versions: [0.18.3-0.18.6, 0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.4] or uninstalled, leaving only versions: [0.19.0-0.19.2, 0.20.0-0.20.1, 0.21.0-0.21.4]\n │       │   │       │   │   │   │   │   │               │ └─DataStructures [864edb3b] log: see above\n │       │   │       │   │   │   │   │   │               ├─restricted by compatibility requirements with MathOptInterface [b8f27783] to versions: [0.18.3-0.18.6, 0.20.0-0.20.1, 0.21.0-0.21.5] or uninstalled, leaving only versions: [0.20.0-0.20.1, 0.21.0-0.21.4]\n │       │   │       │   │   │   │   │   │               │ └─MathOptInterface [b8f27783] log: see above\n │       │   │       │   │   │   │   │   │               └─restricted by compatibility requirements with LazySets [b4f0291d] to versions: 0.21.0-0.21.5, leaving only versions: 0.21.0-0.21.4\n │       │   │       │   │   │   │   │   │                 └─LazySets [b4f0291d] log: see above\n │       │   │       │   │   │   │   │   └─restricted by compatibility requirements with OrdinaryDiffEq [1dea7af3] to versions: [0.9.0-0.9.2, 0.10.0-0.10.3, 1.0.0, 1.1.0-1.1.1, 1.2.0, 1.3.0-1.3.3, 1.4.0, 1.5.0, 1.6.0, 1.7.0-1.7.1, 1.8.0, 1.9.0-1.9.1, 1.10.0-1.10.1], leaving only versions: [1.1.0-1.1.1, 1.2.0, 1.3.0-1.3.3, 1.4.0, 1.5.0, 1.6.0, 1.7.0-1.7.1, 1.8.0, 1.9.0-1.9.1, 1.10.0-1.10.1]\n │       │   │       │   │   │   │   │     └─OrdinaryDiffEq [1dea7af3] log: see above\n │       │   │       │   │   │   │   ├─restricted by compatibility requirements with RecursiveArrayTools [731186ca] to versions: [4.0.0, 4.1.0, 4.2.0, 4.3.0, 4.4.0-4.4.1, 4.5.0, 4.6.0, 4.7.0-4.7.1, 4.8.0-4.8.1, 4.9.0, 4.10.0, 4.11.0-4.11.1, 4.12.0-4.12.4, 4.13.0, 4.14.0, 4.15.0-4.15.1, 4.16.0-4.16.5, 4.17.0-4.17.2, 4.18.0-4.18.3, 4.19.0, 4.20.0, 4.21.0-4.21.1, 5.0.0, 5.1.0-5.1.4, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0, 5.15.0-5.15.1, 5.16.0, 5.17.0-5.17.2, 5.18.0, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8] or uninstalled, leaving only versions: [5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0-5.6.1, 5.7.0-5.7.1, 5.8.0-5.8.1, 5.9.0, 5.10.0, 5.11.0-5.11.1, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8]\n │       │   │       │   │   │   │   │ └─RecursiveArrayTools [731186ca] log: see above\n │       │   │       │   │   │   │   └─restricted by compatibility requirements with DiffEqBase [2b5f629d] to versions: [5.16.0, 5.17.0-5.17.2, 5.18.0, 5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8] or uninstalled, leaving only versions: [5.19.0, 5.20.0-5.20.1, 5.21.0, 5.22.0, 5.23.0, 5.24.0, 5.25.0, 5.26.0-5.26.8]\n │       │   │       │   │   │   │     └─DiffEqBase [2b5f629d] log:\n │       │   │       │   │   │   │       ├─possible versions are: [3.13.2-3.13.3, 4.0.0-4.0.1, 4.1.0, 4.2.0, 4.3.0-4.3.1, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, 4.9.0, 4.10.0-4.10.1, 4.11.0-4.11.1, 4.12.0, 4.13.0, 4.14.0-4.14.1, 4.15.0, 4.16.0, 4.17.0, 4.18.0, 4.19.0, 4.20.0-4.20.3, 4.21.0, 4.21.2-4.21.3, 4.22.0-4.22.2, 4.23.0, 4.23.2-4.23.4, 4.24.0-4.24.3, 4.25.0-4.25.1, 4.26.0-4.26.3, 4.27.0-4.27.1, 4.28.0-4.28.1, 4.29.0-4.29.2, 4.30.0-4.30.2, 4.31.0-4.31.2, 4.32.0, 5.0.0-5.0.1, 5.1.0, 5.2.0-5.2.3, 5.3.0-5.3.2, 5.4.0-5.4.1, 5.5.0-5.5.2, 5.6.0-5.6.4, 5.7.0, 5.8.0-5.8.1, 5.9.0, 5.10.0-5.10.3, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3, 6.45.0-6.45.1, 6.46.0-6.46.1, 6.47.0-6.47.1, 6.48.0-6.48.2] or uninstalled\n │       │   │       │   │   │   │       ├─restricted by compatibility requirements with DifferentialEquations [0c46a032] to versions: [3.13.2-3.13.3, 4.0.0-4.0.1, 4.1.0, 4.2.0, 4.3.0-4.3.1, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, 4.9.0, 4.10.0-4.10.1, 4.11.0-4.11.1, 4.12.0, 4.13.0, 4.14.0-4.14.1, 4.15.0, 4.16.0, 4.17.0, 4.18.0, 4.19.0, 4.20.0-4.20.3, 4.21.0, 4.21.2-4.21.3, 4.22.0-4.22.2, 4.23.0, 4.23.2-4.23.4, 4.24.0-4.24.3, 4.25.0-4.25.1, 4.26.0-4.26.3, 4.27.0-4.27.1, 4.28.0-4.28.1, 4.29.0-4.29.2, 4.30.0-4.30.2, 4.31.0-4.31.2, 4.32.0, 5.0.0-5.0.1, 5.1.0, 5.2.0-5.2.3, 5.3.0-5.3.2, 5.4.0-5.4.1, 5.5.0-5.5.2, 5.6.0-5.6.4, 5.7.0, 5.8.0-5.8.1, 5.9.0, 5.10.0-5.10.3, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3, 6.45.0-6.45.1, 6.46.0-6.46.1, 6.47.0-6.47.1, 6.48.0-6.48.2]\n │       │   │       │   │   │   │       │ └─DifferentialEquations [0c46a032] log: see above\n │       │   │       │   │   │   │       ├─restricted by compatibility requirements with OrdinaryDiffEq [1dea7af3] to versions: [5.3.2, 5.4.0-5.4.1, 5.5.0-5.5.2, 5.6.0-5.6.4, 5.7.0, 5.8.0-5.8.1, 5.9.0, 5.10.0-5.10.3, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3, 6.45.0-6.45.1, 6.46.0-6.46.1, 6.47.0-6.47.1, 6.48.0-6.48.2]\n │       │   │       │   │   │   │       │ └─OrdinaryDiffEq [1dea7af3] log: see above\n │       │   │       │   │   │   │       ├─restricted by compatibility requirements with DelayDiffEq [bcd4f6db] to versions: [5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3, 6.45.0-6.45.1, 6.46.0-6.46.1, 6.47.0-6.47.1, 6.48.0-6.48.2]\n │       │   │       │   │   │   │       │ └─DelayDiffEq [bcd4f6db] log:\n │       │   │       │   │   │   │       │   ├─possible versions are: [4.0.0, 4.1.0, 4.2.0-4.2.1, 4.3.0, 4.4.0-4.4.1, 4.5.0-4.5.2, 4.6.0-4.6.1, 4.7.0-4.7.1, 4.8.0, 5.0.0, 5.1.0-5.1.1, 5.2.0, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 5.9.0-5.9.1, 5.10.0, 5.11.0, 5.12.0, 5.13.0, 5.14.0, 5.15.0, 5.16.0, 5.17.0, 5.18.0, 5.19.0, 5.20.0, 5.21.0, 5.22.0, 5.23.0, 5.24.0-5.24.2, 5.25.0-5.25.1] or uninstalled\n │       │   │       │   │   │   │       │   ├─restricted to versions 5.6.0-5 by ControlSystems [a6e380b2], leaving only versions [5.6.0, 5.7.0, 5.8.0, 5.9.0-5.9.1, 5.10.0, 5.11.0, 5.12.0, 5.13.0, 5.14.0, 5.15.0, 5.16.0, 5.17.0, 5.18.0, 5.19.0, 5.20.0, 5.21.0, 5.22.0, 5.23.0, 5.24.0-5.24.2, 5.25.0-5.25.1]\n │       │   │       │   │   │   │       │   │ └─ControlSystems [a6e380b2] log: see above\n │       │   │       │   │   │   │       │   ├─restricted by compatibility requirements with DataStructures [864edb3b] to versions: [4.0.0, 4.1.0, 4.2.0-4.2.1, 4.3.0, 4.4.0-4.4.1, 4.5.0-4.5.2, 4.6.0-4.6.1, 4.7.0-4.7.1, 4.8.0, 5.0.0, 5.1.0-5.1.1, 5.2.0, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 5.9.0-5.9.1, 5.10.0, 5.11.0, 5.12.0, 5.13.0, 5.14.0, 5.15.0, 5.16.0, 5.17.0, 5.18.0, 5.19.0, 5.20.0, 5.21.0, 5.22.0, 5.23.0, 5.24.0-5.24.1] or uninstalled, leaving only versions: [5.6.0, 5.7.0, 5.8.0, 5.9.0-5.9.1, 5.10.0, 5.11.0, 5.12.0, 5.13.0, 5.14.0, 5.15.0, 5.16.0, 5.17.0, 5.18.0, 5.19.0, 5.20.0, 5.21.0, 5.22.0, 5.23.0, 5.24.0-5.24.1]\n │       │   │       │   │   │   │       │   │ └─DataStructures [864edb3b] log: see above\n │       │   │       │   │   │   │       │   └─restricted by compatibility requirements with RecursiveArrayTools [731186ca] to versions: [4.0.0, 4.1.0, 4.2.0-4.2.1, 4.3.0, 4.4.0-4.4.1, 4.5.0-4.5.2, 4.6.0-4.6.1, 4.7.0-4.7.1, 4.8.0, 5.0.0, 5.1.0-5.1.1, 5.2.0, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 5.9.0-5.9.1, 5.10.0, 5.11.0, 5.12.0, 5.13.0, 5.14.0, 5.15.0, 5.16.0, 5.17.0, 5.18.0, 5.19.0] or uninstalled, leaving only versions: [5.6.0, 5.7.0, 5.8.0, 5.9.0-5.9.1, 5.10.0, 5.11.0, 5.12.0, 5.13.0, 5.14.0, 5.15.0, 5.16.0, 5.17.0, 5.18.0, 5.19.0]\n │       │   │       │   │   │   │       │     └─RecursiveArrayTools [731186ca] log: see above\n │       │   │       │   │   │   │       ├─restricted by compatibility requirements with DataStructures [864edb3b] to versions: [3.13.2-3.13.3, 4.0.0-4.0.1, 4.1.0, 4.2.0, 4.3.0-4.3.1, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, 4.9.0, 4.10.0-4.10.1, 4.11.0-4.11.1, 4.12.0, 4.13.0, 4.14.0-4.14.1, 4.15.0, 4.16.0, 4.17.0, 4.18.0, 4.19.0, 4.20.0-4.20.3, 4.21.0, 4.21.2-4.21.3, 4.22.0-4.22.2, 4.23.0, 4.23.2-4.23.4, 4.24.0-4.24.3, 4.25.0-4.25.1, 4.26.0-4.26.3, 4.27.0-4.27.1, 4.28.0-4.28.1, 4.29.0-4.29.2, 4.30.0-4.30.2, 4.31.0-4.31.2, 4.32.0, 5.0.0-5.0.1, 5.1.0, 5.2.0-5.2.3, 5.3.0-5.3.2, 5.4.0-5.4.1, 5.5.0-5.5.2, 5.6.0-5.6.4, 5.7.0, 5.8.0-5.8.1, 5.9.0, 5.10.0-5.10.3, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3] or uninstalled, leaving only versions: [5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3]\n │       │   │       │   │   │   │       │ └─DataStructures [864edb3b] log: see above\n │       │   │       │   │   │   │       ├─restricted by compatibility requirements with BoundaryValueDiffEq [764a87c0] to versions: [6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3, 6.45.0-6.45.1, 6.46.0-6.46.1, 6.47.0-6.47.1, 6.48.0-6.48.2], leaving only versions: [6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3]\n │       │   │       │   │   │   │       │ └─BoundaryValueDiffEq [764a87c0] log:\n │       │   │       │   │   │   │       │   ├─possible versions are: [2.0.0, 2.1.0-2.1.1, 2.2.0-2.2.3, 2.3.0-2.3.1, 2.4.0, 2.5.0] or uninstalled\n │       │   │       │   │   │   │       │   ├─restricted by compatibility requirements with DifferentialEquations [0c46a032] to versions: [2.0.0, 2.1.0-2.1.1, 2.2.0-2.2.3, 2.3.0-2.3.1, 2.4.0, 2.5.0]\n │       │   │       │   │   │   │       │   │ └─DifferentialEquations [0c46a032] log: see above\n │       │   │       │   │   │   │       │   └─restricted by compatibility requirements with BandedMatrices [aae01518] to versions: 2.5.0 or uninstalled, leaving only versions: 2.5.0\n │       │   │       │   │   │   │       │     └─BandedMatrices [aae01518] log:\n │       │   │       │   │   │   │       │       ├─possible versions are: [0.5.1-0.5.2, 0.6.0, 0.7.0-0.7.2, 0.8.0-0.8.2, 0.9.0-0.9.4, 0.10.0-0.10.1, 0.11.0-0.11.1, 0.12.0-0.12.4, 0.13.0-0.13.2, 0.14.0-0.14.3, 0.15.0-0.15.25] or uninstalled\n │       │   │       │   │   │   │       │       ├─restricted by compatibility requirements with ArrayLayouts [4c555306] to versions: [0.5.1-0.5.2, 0.6.0, 0.7.0-0.7.2, 0.8.0-0.8.2, 0.9.0-0.9.4, 0.10.0-0.10.1, 0.11.0-0.11.1, 0.12.0-0.12.4, 0.13.0-0.13.2, 0.15.16-0.15.25] or uninstalled\n │       │   │       │   │   │   │       │       │ └─ArrayLayouts [4c555306] log: see above\n │       │   │       │   │   │   │       │       ├─restricted by compatibility requirements with FillArrays [1a297f60] to versions: 0.15.16-0.15.25 or uninstalled\n │       │   │       │   │   │   │       │       │ └─FillArrays [1a297f60] log: see above\n │       │   │       │   │   │   │       │       └─restricted by compatibility requirements with BoundaryValueDiffEq [764a87c0] to versions: [0.5.1-0.5.2, 0.6.0, 0.7.0-0.7.2, 0.8.0-0.8.2, 0.9.0-0.9.4, 0.10.0-0.10.1, 0.11.0-0.11.1, 0.12.0-0.12.4, 0.13.0-0.13.2, 0.14.0-0.14.3, 0.15.0-0.15.25], leaving only versions: 0.15.16-0.15.25\n │       │   │       │   │   │   │       │         └─BoundaryValueDiffEq [764a87c0] log: see above\n │       │   │       │   │   │   │       ├─restricted by compatibility requirements with RecursiveArrayTools [731186ca] to versions: [3.13.2-3.13.3, 4.0.0-4.0.1, 4.1.0, 4.2.0, 4.3.0-4.3.1, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, 4.9.0, 4.10.0-4.10.1, 4.11.0-4.11.1, 4.12.0, 4.13.0, 4.14.0-4.14.1, 4.15.0, 4.16.0, 4.17.0, 4.18.0, 4.19.0, 4.20.0-4.20.3, 4.21.0, 4.21.2-4.21.3, 4.22.0-4.22.2, 4.23.0, 4.23.2-4.23.4, 4.24.0-4.24.3, 4.25.0-4.25.1, 4.26.0-4.26.3, 4.27.0-4.27.1, 4.28.0-4.28.1, 4.29.0-4.29.2, 4.30.0-4.30.2, 4.31.0-4.31.2, 4.32.0, 5.0.0-5.0.1, 5.1.0, 5.2.0-5.2.3, 5.3.0-5.3.2, 5.4.0-5.4.1, 5.5.0-5.5.2, 5.6.0-5.6.4, 5.7.0, 5.8.0-5.8.1, 5.9.0, 5.10.0-5.10.3, 5.11.0-5.11.1, 5.12.0, 5.13.0, 5.14.0-5.14.2, 5.15.0, 5.16.0-5.16.5, 5.17.0-5.17.1, 5.18.0, 5.19.0, 5.20.0-5.20.1, 6.0.0, 6.1.0, 6.2.0-6.2.4, 6.3.0-6.3.6, 6.4.0-6.4.2, 6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2] or uninstalled, leaving only versions: [6.5.0-6.5.1, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2]\n │       │   │       │   │   │   │       │ └─RecursiveArrayTools [731186ca] log: see above\n │       │   │       │   │   │   │       └─restricted by compatibility requirements with Requires [ae029012] to versions: [6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2, 6.11.0, 6.12.0-6.12.5, 6.13.0-6.13.3, 6.14.0-6.14.2, 6.15.0-6.15.2, 6.16.0, 6.17.0-6.17.3, 6.18.0-6.18.1, 6.19.0, 6.20.0, 6.21.0-6.21.1, 6.22.0-6.22.2, 6.23.0, 6.24.0, 6.25.0-6.25.2, 6.26.0, 6.27.0, 6.28.0, 6.29.0-6.29.3, 6.30.0-6.30.4, 6.31.0-6.31.1, 6.32.0-6.32.2, 6.33.0-6.33.1, 6.34.0-6.34.3, 6.35.0-6.35.2, 6.36.0-6.36.4, 6.37.0, 6.38.0-6.38.4, 6.39.0-6.39.1, 6.40.0-6.40.9, 6.41.0-6.41.3, 6.42.0, 6.43.0-6.43.1, 6.44.0-6.44.3, 6.45.0-6.45.1, 6.46.0-6.46.1, 6.47.0-6.47.1, 6.48.0-6.48.2] or uninstalled, leaving only versions: [6.8.0, 6.9.0-6.9.4, 6.10.0-6.10.2]\n │       │   │       │   │   │   │         └─Requires [ae029012] log: see above\n │       │   │       │   │   │   ├─restricted by compatibility requirements with JLD2 [033835bb] to versions: [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20], leaving only versions: [0.15.0, 0.16.1, 0.17.0-0.17.20]\n │       │   │       │   │   │   │ └─JLD2 [033835bb] log:\n │       │   │       │   │   │   │   ├─possible versions are: [0.1.0-0.1.14, 0.2.0-0.2.4] or uninstalled\n │       │   │       │   │   │   │   └─restricted by compatibility requirements with BinaryBuilder [12aac903] to versions: 0.1.0-0.1.14\n │       │   │       │   │   │   │     └─BinaryBuilder [12aac903] log:\n │       │   │       │   │   │   │       ├─possible versions are: [0.1.0-0.1.2, 0.1.4, 0.2.0-0.2.6] or uninstalled\n │       │   │       │   │   │   │       └─restricted to versions * by an explicit requirement, leaving only versions [0.1.0-0.1.2, 0.1.4, 0.2.0-0.2.6]\n │       │   │       │   │   │   └─restricted by compatibility requirements with COSMO [1e616198] to versions: 0.17.0-0.17.20\n │       │   │       │   │   │     └─COSMO [1e616198] log: see above\n │       │   │       │   │   ├─restricted by compatibility requirements with DifferentialEquations [0c46a032] to versions: [6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0-6.9.1, 6.10.0, 6.11.0-6.11.2, 6.12.0, 6.13.0, 6.14.0, 6.15.0, 6.16.0-6.16.1, 6.17.0-6.17.1, 6.18.0, 6.19.0-6.19.2, 6.20.0, 6.21.0-6.21.1, 6.22.0, 6.23.0-6.23.1, 6.24.0, 6.25.0-6.25.1, 6.26.0], leaving only versions: [6.0.0, 6.1.0-6.1.1, 6.2.0, 6.3.0, 6.4.0]\n │       │   │       │   │   │ └─DifferentialEquations [0c46a032] log: see above\n │       │   │       │   │   └─restricted by compatibility requirements with DiffEqBase [2b5f629d] to versions: [6.2.0, 6.3.0, 6.4.0, 6.5.0, 6.6.0, 6.7.0, 6.10.0, 6.11.0-6.11.2, 6.12.0, 6.13.0, 6.14.0, 6.15.0, 6.16.0-6.16.1] or uninstalled, leaving only versions: [6.2.0, 6.3.0, 6.4.0]\n │       │   │       │   │     └─DiffEqBase [2b5f629d] log: see above\n │       │   │       │   └─restricted by compatibility requirements with DiffEqBase [2b5f629d] to versions: [6.4.0, 6.6.0, 6.7.0, 6.8.0, 6.9.0] or uninstalled, leaving only versions: [6.4.0, 6.6.0]\n │       │   │       │     └─DiffEqBase [2b5f629d] log: see above\n │       │   │       ├─restricted by compatibility requirements with OrdinaryDiffEq [1dea7af3] to versions: [0.18.6, 0.19.0-0.19.1, 0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1, 2.0.0-2.0.5, 2.1.0-2.1.2, 2.2.0, 2.3.0-2.3.5, 2.4.0-2.4.4, 2.5.0, 2.6.0, 2.7.0-2.7.2]\n │       │   │       │ └─OrdinaryDiffEq [1dea7af3] log: see above\n │       │   │       ├─restricted by compatibility requirements with StochasticDiffEq [789caeaf] to versions: [0.16.0-0.16.3, 0.17.0-0.17.2, 0.18.0-0.18.6, 0.19.0-0.19.1, 0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1], leaving only versions: [0.18.6, 0.19.0-0.19.1, 0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1]\n │       │   │       │ └─StochasticDiffEq [789caeaf] log: see above\n │       │   │       ├─restricted by compatibility requirements with DiffEqJump [c894b116] to versions: [0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1, 2.0.0-2.0.5, 2.1.0-2.1.2, 2.2.0, 2.3.0-2.3.5, 2.4.0-2.4.4, 2.5.0, 2.6.0, 2.7.0-2.7.2], leaving only versions: [0.20.0, 1.0.0-1.0.2, 1.1.0-1.1.1, 1.2.0-1.2.1]\n │       │   │       │ └─DiffEqJump [c894b116] log:\n │       │   │       │   ├─possible versions are: [5.0.0, 5.1.0-5.1.2, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 6.0.0, 6.1.0-6.1.1, 6.2.0-6.2.2, 6.3.0, 6.4.0, 6.5.0, 6.6.0-6.6.3, 6.7.0-6.7.7, 6.8.0-6.8.3, 6.9.0-6.9.5, 6.10.0-6.10.1] or uninstalled\n │       │   │       │   ├─restricted by compatibility requirements with DifferentialEquations [0c46a032] to versions: [5.0.0, 5.1.0-5.1.2, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 6.0.0, 6.1.0-6.1.1, 6.2.0-6.2.2, 6.3.0, 6.4.0, 6.5.0, 6.6.0-6.6.3, 6.7.0-6.7.7, 6.8.0-6.8.3, 6.9.0-6.9.5, 6.10.0-6.10.1]\n │       │   │       │   │ └─DifferentialEquations [0c46a032] log: see above\n │       │   │       │   ├─restricted by compatibility requirements with Compat [34da2185] to versions: [6.2.0-6.2.2, 6.3.0, 6.4.0, 6.5.0, 6.6.0-6.6.3, 6.7.0-6.7.7, 6.8.0-6.8.3, 6.9.0-6.9.5, 6.10.0-6.10.1] or uninstalled, leaving only versions: [6.2.0-6.2.2, 6.3.0, 6.4.0, 6.5.0, 6.6.0-6.6.3, 6.7.0-6.7.7, 6.8.0-6.8.3, 6.9.0-6.9.5, 6.10.0-6.10.1]\n │       │   │       │   │ └─Compat [34da2185] log: see above\n │       │   │       │   ├─restricted by compatibility requirements with DiffEqBase [2b5f629d] to versions: [5.0.0, 5.1.0-5.1.2, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 6.0.0, 6.1.0-6.1.1, 6.2.0-6.2.2, 6.3.0, 6.4.0, 6.5.0, 6.6.0-6.6.3, 6.7.0-6.7.7, 6.8.0-6.8.3, 6.9.0-6.9.5, 6.10.0] or uninstalled, leaving only versions: [6.2.0-6.2.2, 6.3.0, 6.4.0, 6.5.0, 6.6.0-6.6.3, 6.7.0-6.7.7, 6.8.0-6.8.3, 6.9.0-6.9.5, 6.10.0]\n │       │   │       │   │ └─DiffEqBase [2b5f629d] log: see above\n │       │   │       │   └─restricted by compatibility requirements with RecursiveArrayTools [731186ca] to versions: [5.0.0, 5.1.0-5.1.2, 5.2.0-5.2.1, 5.3.0, 5.4.0-5.4.1, 5.5.0, 5.6.0, 5.7.0, 5.8.0, 6.0.0, 6.1.0-6.1.1, 6.2.0-6.2.2, 6.3.0, 6.4.0] or uninstalled, leaving only versions: [6.2.0-6.2.2, 6.3.0, 6.4.0]\n │       │   │       │     └─RecursiveArrayTools [731186ca] log: see above\n │       │   │       └─restricted by compatibility requirements with Requires [ae029012] to versions: [1.2.1, 2.0.0-2.0.5, 2.1.0-2.1.2, 2.2.0, 2.3.0-2.3.5, 2.4.0-2.4.4, 2.5.0, 2.6.0, 2.7.0-2.7.2] or uninstalled, leaving only versions: 1.2.1\n │       │   │         └─Requires [ae029012] log: see above\n │       │   └─restricted by compatibility requirements with KernelDensity [5ab0869b] to versions: 0.14.11-0.14.17 or uninstalled, leaving only versions: 0.14.11-0.14.17\n │       │     └─KernelDensity [5ab0869b] log: see above\n │       └─restricted by compatibility requirements with Optim [429524aa] to versions: 0.6.0-0.6.2 or uninstalled, leaving only versions: 0.6.0-0.6.2\n │         └─Optim [429524aa] log:\n │           ├─possible versions are: [0.15.3, 0.16.0, 0.17.0-0.17.2, 0.18.0-0.18.1, 0.19.0-0.19.7, 0.20.0-0.20.6, 0.21.0, 0.22.0, 1.0.0, 1.1.0, 1.2.0] or uninstalled\n │           ├─restricted by compatibility requirements with FillArrays [1a297f60] to versions: [0.15.3, 0.16.0, 0.17.0-0.17.2, 0.18.0-0.18.1, 1.0.0, 1.1.0, 1.2.0] or uninstalled\n │           │ └─FillArrays [1a297f60] log: see above\n │           ├─restricted by compatibility requirements with Compat [34da2185] to versions: [0.17.2, 0.18.0-0.18.1, 0.19.0-0.19.7, 0.20.0-0.20.6, 0.21.0, 0.22.0, 1.0.0, 1.1.0, 1.2.0] or uninstalled, leaving only versions: [0.17.2, 0.18.0-0.18.1, 1.0.0, 1.1.0, 1.2.0] or uninstalled\n │           │ └─Compat [34da2185] log: see above\n │           └─restricted by compatibility requirements with Calculus [49dc2e85] to versions: [0.19.2-0.19.7, 0.20.0-0.20.6, 0.21.0, 0.22.0, 1.0.0, 1.1.0, 1.2.0] or uninstalled, leaving only versions: [1.0.0, 1.1.0, 1.2.0] or uninstalled\n │             └─Calculus [49dc2e85] log:\n │               ├─possible versions are: [0.4.1, 0.5.0-0.5.1] or uninstalled\n │               ├─restricted by compatibility requirements with JuMP [4076af6c] to versions: [0.4.1, 0.5.0-0.5.1]\n │               │ └─JuMP [4076af6c] log: see above\n │               └─restricted by compatibility requirements with Compat [34da2185] to versions: 0.5.0-0.5.1 or uninstalled, leaving only versions: 0.5.0-0.5.1\n │                 └─Compat [34da2185] log: see above\n ├─restricted by compatibility requirements with KernelDensity [5ab0869b] to versions: 0.33.0-0.33.2\n │ └─KernelDensity [5ab0869b] log: see above\n └─restricted by compatibility requirements with Plots [91a5bcdd] to versions: 0.32.0-0.32.2 — no versions left\n   └─Plots [91a5bcdd] log:\n     ├─possible versions are: [0.12.1-0.12.4, 0.13.0-0.13.1, 0.14.0-0.14.2, 0.15.0-0.15.1, 0.16.0, 0.17.0-0.17.4, 0.18.0, 0.19.0-0.19.3, 0.20.0-0.20.6, 0.21.0, 0.22.0-0.22.5, 0.23.0-0.23.2, 0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1] or uninstalled\n     ├─restricted to versions [0.24-0.29, 1] by ControlSystems [a6e380b2], leaving only versions [0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─ControlSystems [a6e380b2] log: see above\n     ├─restricted by compatibility requirements with StatsPlots [f3b207a7] to versions: [0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─StatsPlots [f3b207a7] log: see above\n     ├─restricted by compatibility requirements with Requires [ae029012] to versions: [0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1] or uninstalled, leaving only versions: [0.28.4, 0.29.0-0.29.9, 1.0.0-1.0.14, 1.1.0-1.1.4, 1.2.0-1.2.6, 1.3.0-1.3.7, 1.4.0-1.4.4, 1.5.0-1.5.9, 1.6.0-1.6.12, 1.7.0-1.7.3, 1.8.0-1.8.1]\n     │ └─Requires [ae029012] log: see above\n     └─restricted by compatibility requirements with RecipesBase [3cdcf5f2] to versions: [0.12.1-0.12.4, 0.13.0-0.13.1, 0.14.0-0.14.2, 0.15.0-0.15.1, 0.16.0, 0.17.0-0.17.4, 0.18.0, 0.19.0-0.19.3, 0.20.0-0.20.6, 0.21.0, 0.22.0-0.22.5, 0.23.0-0.23.2, 0.24.0, 0.25.0-0.25.3, 0.26.0-0.26.3, 0.27.0-0.27.1, 0.28.0-0.28.4] or uninstalled, leaving only versions: 0.28.4\n       └─RecipesBase [3cdcf5f2] log: see above\n```",[oxinabox]: cf https://github.com/JuliaLang/Pkg.jl/issues/1855,1,false,0,0,0,0,0,0,0,0,0
2205,internal assertion error if a local copy of a package exists,open,vtjnash,,,,0,2020-11-12T06:08:44.0,2020-11-12T06:08:44.0,1711,1711,https://github.com/JuliaLang/Pkg.jl/issues/2205,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2205,"https://travis-ci.com/github/JuliaCI/CoverageTools.jl/jobs/434214463\n```\n$ julia --color=yes -e """"if VERSION < v\""""0.7.0-DEV.5183\""""; cd(Pkg.dir(\""""${JL_PKG}\"""")); else using Pkg; end; Pkg.add(\""""Coverage\""""); using Coverage; Coveralls.submit(process_folder())""""\n339    Updating registry at `~/.julia/registries/General`\n340   Resolving package versions...\n341   Installed CoverageTools ─ v1.1.0\n342No Changes to `~/build/JuliaCI/CoverageTools.jl/Project.toml`\n343No Changes to `~/build/JuliaCI/CoverageTools.jl/Manifest.toml`\n344ERROR: AssertionError: sourcepath !== nothing\n345Stacktrace:\n346  [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec)\n347    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1745\n348  [2] #12\n349    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:118 [inlined]\n350  [3] _all\n351    @ ./reduce.jl:923 [inlined]\n352  [4] #all#691\n353    @ ./reducedim.jl:886 [inlined]\n354  [5] all\n355    @ ./reducedim.jl:886 [inlined]\n356  [6] is_instantiated(ctx::Pkg.Types.Context)\n357    @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:118\n358  [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n359    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1292\n360  [8] precompile(ctx::Pkg.Types.Context; internal_call::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n361    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:909\n362  [9] _auto_precompile(ctx::Pkg.Types.Context)\n363    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:902\n364 [10] add(pkgs::Vector{Pkg.Types.PackageSpec}; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n365    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:74\n366 [11] add\n367    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:72 [inlined]\n368 [12] #add#21\n369    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:70 [inlined]\n370 [13] add\n371    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:70 [inlined]\n372 [14] #add#20\n373    @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:69 [inlined]\n374 [15] add(pkg::String)\n375    @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:69\n376 [16] top-level scope\n377    @ none:1\n378The command """"julia --color=yes -e """"if VERSION < v\""""0.7.0-DEV.5183\""""; cd(Pkg.dir(\""""${JL_PKG}\"""")); else using Pkg; end; Pkg.add(\""""Coverage\""""); using Coverage; Coveralls.submit(process_folder())"""""""" exited with 1.\n```",,0,false,0,0,0,0,0,0,0,0,0
2131,missing docstrings in artifacts API reference,open,simeonschaub,staticfloat,documentation,,4,2020-10-17T10:21:52.0,2020-11-03T19:27:31.0,1737,1719,https://github.com/JuliaLang/Pkg.jl/issues/2131,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2131,"Documenter complains about some docstrings missing [here](https://julialang.github.io/Pkg.jl/dev/api/#Artifacts-Reference). It seems like `@artifact_str` at least does actually have a docstring, so it looks like there's something else that's broken.","[KristofferC]: They are defined in the `Artifacts` stdlib now. @staticfloat it would be nice if you could take a pass over the Pkg.Artifacts docs now with the Artifact stdlib in place, and see that things are updated. | [staticfloat]: I took at quick look, but I don't see anything that needs changing.  What do I need to change in the docstrings? | [KristofferC]: > What do I need to change in the docstrings?\n\nThere are a bunch of \n\n<img width=""""928"""" alt=""""image"""" src=""""https://user-images.githubusercontent.com/1282691/97969913-ff5ad000-1dc0-11eb-8e7c-cab068d4a42c.png"""">\n\nfor example. | [staticfloat]: Hmmm, this seems like a `Documenter` bug.  `find_artifacts_toml` isn't defined in `Pkg.Artifacts`, it's imported then re-exported, and where it _is_ defined, it has a docstring.",4,false,0,0,0,0,0,0,0,0,0
1725,Stop using common remote tracking ref namespace (`remotes`) for cache,open,iamed2,,help wanted,,2,2020-03-20T15:48:08.0,2020-11-02T14:09:58.0,1947,1721,https://github.com/JuliaLang/Pkg.jl/issues/1725,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1725,"This came up on https://github.com/foriequal0/git-trim/issues/73 and @DilumAluthge asked me to make an issue here.\n\n`git-trim` was assuming that the refs in `refs/remotes` were all remote-tracking branches, since that is the current convention (i.e., what `git` puts there). The author of that program said:\n\n> I think that it would be better Pkg.jl to use refspec `refs/*:refs/cache/*`, since `refs/heads` and `refs/remotes` are somewhat reserved ref namespaces, and they are not remote-tracking branches. The most widely known example might be GitHub. They stores pull request heads under `refs/pull/`.\n\nThe code in Pkg.jl that deals with these refs is here: https://github.com/JuliaLang/Pkg.jl/search?q=refs%2Fremotes%2Fcache&unscoped_q=refs%2Fremotes%2Fcache","[KristofferC]: Help with this would be appreciated. I personally have no idea where these refspecs we use originated. | [StefanKarpinski]: Copy-pasta. I, for one, do not understand refspecs at all. One of the areas of git that I have no clue about.",2,false,1,1,0,0,0,0,0,0,0
411,Is the package manager ready for moving out stdlibs in their own repos.,open,KristofferC,,Discussion,,3,2018-06-19T13:26:26.0,2020-11-01T10:10:47.0,2588,1722,https://github.com/JuliaLang/Pkg.jl/issues/411,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/411,"Right now, an stdlib is simply represented in the Manifest with a\n\n```\n[[Stdlib]]\nuuid = """"$stdlib_uuid""""\n```\n\nentry. No dependencies for the stdlibs are recorded, no versions (and no git-tree-sha). This make instantiating existing manifests after the fact that the stdlib has been moved to a repository difficult. We should figure how thing should be recorded so we can instantiate old manifests that where created before the stdlib got moved out.\n\nInstantiating projects (with no manifests) should be no problem, the names will just be resolved from the registry and download like any other package.","[StefanKarpinski]: One option is to record the `julia` version and just bake in the additional knowledge about the stdlibs based on that. So when you have\n```toml\n[julia]\nversion = """"0.7.0""""\ngit-tree-sha1 = """"4e54b1066faedd2b8c5c7e3f4c1f580479ee11f3""""\n```\nwe know that the stdlibs have certain versions implied by that Julia version. | [KristofferC]: 2 years later, no, not really. | [timholy]: Aside from that, we'd lose a lot of goodness we currently get from REPL precompilation (which includes native codegen). I suppose we could tell everyone to PackageCompiler them all in to the sysimage, but that defeats part of the purpose.\n\nI sure am hoping that better precompilation is a priority for Julia 1.7.",3,false,0,0,0,0,0,0,0,0,0
2182,Investigate open files after test run,open,KristofferC,,,,0,2020-10-31T13:48:50.0,2020-10-31T13:48:50.0,1723,1723,https://github.com/JuliaLang/Pkg.jl/issues/2182,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2182,I think we (still) have some problems with files being open after tests are runs. It would be good to investigate where these come from (using e.g. ``` `lsof -p $(getpid())` ```) and make sure they are deterministically closed.,,0,false,1,1,0,0,0,0,0,0,0
2177,[FR] Terse names for unregistered packages,open,gustaphe,,,,0,2020-10-30T06:19:39.0,2020-10-30T06:19:39.0,1724,1724,https://github.com/JuliaLang/Pkg.jl/issues/2177,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2177,"Using several unregistered packages, you end up writing `https://github.com/` many times. As a QoL feature, you could have \n`gustaphe/UnitfulColors` expand to `https://github.com/gustaphe/UnitfulColors.jl`. Maybe with a `github:` prefix.\n\nThis could also clean up manifesti somewhat.",,0,false,0,0,0,0,0,0,0,0,0
2168,Packages with special characters like ∂ (U+2202) cannot be removed but can be generated,open,arhik,,,,1,2020-10-25T17:46:08.0,2020-10-29T18:23:51.0,1728,1724,https://github.com/JuliaLang/Pkg.jl/issues/2168,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2168,"Package name with special characters like ∂ cannot be removed. \n\nThere is also an inconsistency because other characters like Δ (ex: ΔComponents as opposed to ∂Components) work. I can remove them. But thats not the case with ∂. Had to remove using its unique id. I could not find other cases. Will comment if I find any.\n\n\n---\n**Details:**\n(@v1.5) pkg> rm ∂xxxxx\nERROR: Unable to parse `∂xxxxx` as a package.\n\n\n----\n**Platform:**\nJulia Version 1.5.2\nLinux X86 Ubuntu 20.04\n\n----\n**My opinion:**\n\nWhile its unusual to have to those names specially when github doesn't support these charecters in repo names (Ex: ∂Components) I feel it should be consistent. Either 'generate' should not work or 'remove' should work. I also agree, this is a _very low priority_ bug.\n",[StefanKarpinski]: We should just delete the generate command.,1,false,1,1,0,0,0,0,0,0,0
2164,Can the function `Resolve.sanity_check` be moved to be a test utility?,open,KristofferC,,,,6,2020-10-24T16:34:15.0,2020-10-25T17:36:17.0,1729,1728,https://github.com/JuliaLang/Pkg.jl/issues/2164,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2164,"It is only called from the tests, could it be moved there? If not, when it is supposed to be used in Pkg? cc @carlobaldassi","[carlobaldassi]: Indeed, it's only used for testing that the repository information does not have any inconsistencies. It used to be ran by pull-requests against METADATA in Pkg2 times, I'm not sure whether it's used in the general registry now. But I suppose it could still be useful for registries in general? | [KristofferC]: Could you give a description of what it does and how you are supposed to use it? You load all of the registry and run it and it finds inconsistencies? | [carlobaldassi]: Basically yes. You build a Graph object from the dependency data, and pass it to `sanity_check`. It then simplifies the graph keeping only the packages that are compatible with the current julia version, and it also groups together versions that are indistinguishable from the point of view of the resolver (they have the same dependencies and they always appear together in all the requirements). Then it simulates the installation of each version of each package one by one, as if it was the only requirement. If it finds that a version of a package cannot be installed (the resolution process fails), then it assumes that there is an inconsistency. It returns the list of un-installable `(package,version)`. It's pretty heavy, obviously. | [KristofferC]: I'll try run it on the current registry to see what the status is. | [KristofferC]: For posterity, here is some code that runs it on the registry using https://github.com/JuliaLang/Pkg.jl/pull/2163\n\n```jl\nusing Pkg\nusing Pkg.Types\nusing Pkg: RegistryHandling, Resolve\nreg = Context().env.registries[1]\n\nall_versions = VersionsDict()\nall_compat   = CompatDict()\nuuid_to_name = Dict{UUID, String}()\nreqs = Resolve.Requires()\nfixed = Dict{UUID, Resolve.Fixed}()\n\nfor (uuid, pkg) in reg\n    pkg_info = RegistryHandling.registry_info(pkg)\n    uuid_to_name[pkg.uuid] = pkg.name\n    all_versions[pkg.uuid] = keys(pkg_info.version_info)\n    all_compat[pkg.uuid] = RegistryHandling.uncompressed_data(pkg_info)\nend\n\n# Add stdlibs\nfor (uuid, name) in Pkg.Types.stdlibs()\n    path = Pkg.Types.stdlib_path(stdlibs()[uuid])\n    proj_file = Pkg.Operations.projectfile_path(path; strict=true)\n    proj = Pkg.Operations.read_package(proj_file)\n    all_compat_u_vr = Dict{UUID, VersionSpec}()\n    for (_, other_uuid) in proj.deps\n        all_compat_u_vr[other_uuid] = VersionSpec()\n    end\n    v = something(proj.version, VERSION)\n    all_compat[uuid] = Dict(VERSION => all_compat_u_vr)\n    all_versions[uuid] = Set((VERSION,))\n    uuid_to_name[uuid] = name\nend\n\ng = Resolve.Graph(all_versions, all_compat, uuid_to_name, reqs, fixed, false, VERSION)\n\nResolve.sanity_check(g)\n``` | [KristofferC]: ```\njulia> include(""""/home/kristofferc/julia/reg_sanity.jl"""")\nfound 418 problematic versions\n10633.818614 seconds (29.62 G allocations: 1.728 TiB, 13.15% gc time, 0.00% compilation time)\n418-element Vector{Tuple{String, VersionNumber}}:\n (""""AmplNLReader [77dd3d4c]"""", v""""0.1.0"""")\n (""""ApplicationBuilder [f9309374]"""", v""""0.2.1"""")\n (""""ApplicationBuilder [f9309374]"""", v""""0.3.1"""")\n (""""ApproxFun [28f2ccd6]"""", v""""0.9.0"""")\n (""""ApproxFun [28f2ccd6]"""", v""""0.10.1"""")\n (""""ApproxFun [28f2ccd6]"""", v""""0.10.2"""")\n (""""ApproxFun [28f2ccd6]"""", v""""0.10.3"""")\n (""""ApproxFun [28f2ccd6]"""", v""""0.10.4"""")\n...\n```\n\nHere is a full list: https://gist.github.com/KristofferC/79566b8588bc7049c9e058bc8a08579d\n\nAnd indeed:\n\n```\n(@v1.6) pkg> add ApproxFun@0.9.0\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package BlockArrays [8e7c35d0]:\n BlockArrays [8e7c35d0] log:\n ├─possible versions are: 0.4.1-0.12.13 or uninstalled\n ├─restricted by compatibility requirements with ApproxFun [28f2ccd6] to versions: 0.4.1\n │ └─ApproxFun [28f2ccd6] log:\n │   ├─possible versions are: 0.9.0-0.12.2 or uninstalled\n │   └─restricted to versions 0.9.0 by an explicit requirement, leaving only versions 0.9.0\n └─restricted by compatibility requirements with BlockBandedMatrices [ffab5731] to versions: 0.5.0-0.7.0 — no versions left\n   └─BlockBandedMatrices [ffab5731] log:\n     ├─possible versions are: 0.2.0-0.9.5 or uninstalled\n     └─restricted by compatibility requirements with ApproxFun [28f2ccd6] to versions: 0.2.0\n       └─ApproxFun [28f2ccd6] log: see above\n```\n\nWhat should be done with these versions? Also, 3 hours is a bit long for CI probably :P\n",6,false,0,0,0,0,0,0,0,0,0
1743,Refer to binary files in package directory as artifact for relocatable apps,open,sdewaele,,,,17,2020-04-02T00:58:50.0,2020-10-21T21:52:36.0,1935,1732,https://github.com/JuliaLang/Pkg.jl/issues/1743,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1743,"Applications and packages frequently depend on (small) binary files. For example, [XLSX.jl](https://github.com/felipenoris/XLSX.jl) uses template Excel files. Other applications may include a small dataset, a logo image, etc. These can conveniently be maintained in the package repository. However, currently the only easy method to use these is to refer to them using `@__DIR__` , see [here](https://github.com/felipenoris/XLSX.jl/blob/48e6c47ecdc43e63f0f487c324dfac0e418b5eee/src/write.jl#L11) for an example in XLSX.jl. This issue is that this breaks [relocatability](https://julialang.github.io/PackageCompiler.jl/dev/apps/#Apps-1).\n\nWould it be possible to expand the artifact mechanism to refer to binary files as an artifact, thus eliminating the need to use `@__DIR__`? Please note that the location of the file is not of interest in this case, only the content of the file. Besides eliminating the usage of `@__DIR__`, a further benefit is that PackageCompiler will automatically include the file into the executable.\n\nHosting files like these in a web server is not very attractive IMO, because (i) it requires a package developer to find a hosting server, just for that small excel template file (ii) this cannot be versioned along with the code in the repo.\n\nPerhaps the entry in the artifact file could be something like this:\n```toml\n[blank_xlsx]\ngit-tree-sha1 = """"43563e7631a7eafae1f9f8d9d332e3de44ad7239""""\n\n    [[blank_xlsx.get]]\n    relpath = """"data/blank.xlsx""""\n    sha256 = """"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58""""\n```\nI am not at all an expert in artifact files, so this can probably be improved! I hope that including this is easier than supporting libraries, which need to be built separately for different target platforms.\n\nSee also https://github.com/felipenoris/XLSX.jl/issues/127.","[staticfloat]: I think I recently addressed a similar question here: https://discourse.julialang.org/t/a-couple-of-questions-about-artifacts/33367/4 so I'm linking to that, as much of what I have to say is the same.\n\nFirst off, a few design decisions that you may not be aware of and that will help inform some of the discussion:\n\n* Artifacts are **containers**, not files.  This simplifies talking about moving them around; I don't have to specify, for instance, the local name of the object when downloading it from a remote resource; I get the thing, then unpacking it specifies everything I need to know about how to lay it out on disk.  You can think of `Pkg.Artifacts` as a way to serialize, transfer, and unserialize a tree reliably.\n\n* Artifacts are content-addressed, and as such are explicitly decoupled from their location on disk.  Artifacts can and will be loaded from any depot currently on the depot path; we don't care about where we're getting them from, as wherever we find it, we are guaranteed that the bits on-disk are correct.  Because of this, it's totally valid for some future version of Julia to completely change how it searches for artifacts and where they're stored.  It's not like packages where you can specify a """"dev"""" directory and the code will be loaded from a path you give to Julia; we want Artifacts to be a little more of an abstraction than that, because it's a fairly restricted set of functionality.\n\n* Artifacts are built for write-once, read-many patterns.  This lines up well with what you're describing above, but I thought I would mention it anyway; nothing in the tree of files that the artifact contains can change after it has been created.  The contents are """"frozen"""" and anything that you might want to change would have to be placed into an entirely different artifact that has no relationship to the first.\n\nAlright, now that the philosophizing is out of the way, let's address the current proposal.  I see three separate questions in your post:\n\n* > Artifacts are nice because they are portable, how can we get the same ease of use for files delivered through the package itself:\n\nYes, artifacts are portable in things like PackageCompilerX because they perform their path lookup at runtime, whereas macros like `@__DIR__()` will bake in their path at compile-time.  There's nothing magical about `Artifacts` here, you can generate a portable path to a file in your package by doing a similar lookup that `Artifacts` do:\n\n```julia\nusing Pkg\n\n# This will be re-initialized at __init__() time.\npkg_dir = @__DIR__\n\nfunction __init__()\n    # Get the current manifest, look up our own package by UUID\n    env = Pkg.Types.Context().env\n    pkg_uuid = Pkg.Types.UUID(""""12aac903-9f7c-5d81-afc2-d9565ea332ae"""")\n    entry = env.manifest[pkg_uuid]\n\n   # Convert the PkgEntry into a PackageSpec\n    spec = Pkg.Types.PackageSpec(\n        name=entry.name,\n        uuid=pkg_uuid,\n        version=entry.version,\n        path=entry.path,\n        repo=entry.repo,\n        tree_hash=entry.tree_hash,\n    )\n\n    # Ask `Pkg` to find our source path\n    global pkg_dir = Pkg.Operations.source_path(spec)\nend\n```\n\nLet me know if that doesn't work (I haven't tested it with things like `PackageCompiler`), but I believe it should, as the current environment manifest should always point to the proper path, I believe.\n\n> How can we reduce friction of developers publishing artifacts?\n\nThis is a very good point.  Ideally, we would have a `Pkg.publish(artifact_hash)` that allows you to effortlessly upload the artifact to some service, whether it be a GitHub release, or JuliaTeam, or your own S3 account or whatever.  There are plenty of free/cheap, stable hosting platforms (GitHub releases is my favorite) but as it stands, there are a few steps you have to jump through:\n * `Pkg.Artifacts.archive_artifact()` to create a tarball\n * click-n-drag it into a GitHub release\n * `Pkg.Artifacts.bind_artifact()` with the appropriate download info to write out the entry into an `Artifacts.toml` file)\n\nI expect us to improve this eventually, but probably not in the near future (although we're always happy to review and merge pull requests!)\n\n> How can we build artifacts of files generated by local packages?\n\nPackages can certainly generate artifacts, and `PackageCompiler` should bundle them alongside the application when it creates one.  That is to say, if your package has an artifact bound within its `Artifacts.toml` file, it will get bundled along with the application.  Therefore, it's quite easy for a package to generate some data upon first load, and if that artifact exists, it will get bundled along with the application via `PackageCompiler`.  Example:\n\n```julia\nfunction create_artifacts()\n    # This is the path to the Artifacts.toml we will manipulate\n    artifact_toml = joinpath(@__DIR__, """"Artifacts.toml"""")\n\n\t# Query the `Artifacts.toml` file for the hash bound to the name """"iris""""\n\t# (returns `nothing` if no such binding exists)\n\tiris_hash = artifact_hash(""""iris"""", artifact_toml)\n\n\tif iris_hash == nothing || !artifact_exists(iris_hash)\n\t    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n\t    iris_hash = create_artifact() do artifact_dir\n\t        # We create the artifact by simply downloading a few files into the new artifact directory\n\t        iris_url_base = """"https://archive.ics.uci.edu/ml/machine-learning-databases/iris""""\n\t        download(""""$(iris_url_base)/iris.data"""", joinpath(artifact_dir, """"iris.csv""""))\n\t        download(""""$(iris_url_base)/bezdekIris.data"""", joinpath(artifact_dir, """"bezdekIris.csv""""))\n\t        download(""""$(iris_url_base)/iris.names"""", joinpath(artifact_dir, """"iris.names""""))\n\t    end\n\t\n\t    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n\t    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n\t    # the content hash to change, so this should not cause unnecessary version control churn.\n\t    bind_artifact!(artifact_toml, """"iris"""", iris_hash)\n\tend\nend\n\nfunction __init__()\n    create_artifacts()\nend\n```\n\nYou could of course just do a `cp()` instead of a `download()` when creating the artifact, however this approach clearly makes more sense if you're somehow _generating_ the artifacts rather than just copying them, because if you already have the files on disk, I think it makes more sense to just use the files directly, as suggested at the beginning of this enormous post. :) | [KristofferC]: > you can generate a portable path to a file in your package by doing a similar lookup that Artifacts do:\n\nI don't think that will work. After running `PackageCompiler` there are no source files, no project files no artifact files etc. There is only the sysimage and the unpacked artifacts. The reason Julia can find the artifact files is because:\n\n1. We load and store the content of the artifact file during precompilation (not `__init__`).\n2. PackageCompiler sets `JULIA_DEPOT_PATH` before initializing the Julia runtime.\n3. The paths of artifacts are resolved at runtime by looking at `JULIA_DEPOT_PATH`.\n\n | [KristofferC]: For this to work with PackageCompiler we need to establish:\n\n- A way to tell PackageCompiler what files it should bundle.\n- A convention about how these files should be stored in the compiled state\n- A function/macro that can resolve to this path during runtime based on some \n\nAn example implementation could be:\n\n- All files in `Package/assets` are bundled when compiling.\n- They get put into a separate `assets` folder along `bin` and `artifacts`\n- PackageCompiler sets a flag telling the package if it is running in compiled mode. If it is you resolve the asset path to `joinpath(Sys.BINDIR, """".."""", """"assets"""")` otherwise to `joinpath(pkgdir(@__MODULE__), """"assets"""")`.\n\nThe last part doesn't feel super clean. | [staticfloat]: Ah, I didn’t realize that Package Compiler doesn’t ship the source code at all. Indeed, then the only two options are to create artifacts or to modify Package Compiler as you suggest. | [sdewaele]: Thanks @staticfloat  and @KristofferC for your detailed answers! I wonder what would be the best solution. If artifacts are not the answer, perhaps we should move the issue to PackageCompiler?\n\nRelocatable apps can be major benefit of Julia compared to Python/Matlab. Therefore, I hope that this can be addressed in such a way that most Julia code (and perhaps _all_ packages) stop using `@__DIR__`, e.g. by making it harder to find (not export from Base) and put a big warning in the docs. What do you think? If you agree I can open an issue for Julia in general to this effect, but perhaps there should be a solid replacement in place first. | [StefanKarpinski]: I feel like the simpler piece here is to have an easy way to load data relative to source code. Yes, that doesn't address the PackageCompiler part, but perhaps it could if we made PackageCompiler aware of the mechanism so that it could convert that into an artifact during compilation? | [StefanKarpinski]: Also, I wonder how breaking it would be if `@__DIR__` were expanded at run-time... | [KristofferC]: > I feel like the simpler piece here is to have an easy way to load data relative to source code.\n\nWhat's hard about that right now? | [StefanKarpinski]: How do you do it? | [KristofferC]: Just use `@__DIR__`? That's what everyone does now and it seems to work fine, the problem is when you don't have the file so """"relative to file"""" makes no sense. | [staticfloat]: `@__DIR__` doesn't work when you're relocating files even when the files are there (e.g. if you just copy a whole depot from one computer to another) because the file path is ingrained at compile-time. | [KristofferC]: But won't that invalidate the precompile file anyway? Maybe not? | [StefanKarpinski]: It doesn't work fine because it's not relocatable. | [sdewaele]: @KristofferC  Thanks for your ideas about a possible implementation!\n\n> An example implementation could be:\n> \n> * All files in `Package/assets` are bundled when compiling.\n> * They get put into a separate `assets` folder along `bin` and `artifacts`\n> * PackageCompiler sets a flag telling the package if it is running in compiled mode. If it is you resolve the asset path to `joinpath(Sys.BINDIR, """".."""", """"assets"""")` otherwise to `joinpath(pkgdir(@__MODULE__), """"assets"""")`.\n> \n> The last part doesn't feel super clean.\n\nI think it would be better if the application does not have to figure out whether or not it is running in compiled mode, but rather that the final solution always """"just works"""". That would be the attraction of using the artifact mechanism for it...\n | [nielsls]: Hi all - I've made a small package - [https://github.com/nielsls/Assets](https://github.com/nielsls/Assets) - that does what @KristofferC  suggested. \nIt allows you to retrieve an asset using `asset""""my_image.gif""""`. As Kristoffer suggested:\n- Assets are located in `package/assets`\n- When compiled, they get put into a separate `assets` folder along `bin` and `artifacts` (currently a manual step...).\n- At runtime I determine whether this is a standard Julia session or a PackageCompile'd app using:\n```\n""""""""""""\nReturns true if called from a standard Julia session.\nFalse if called from an app created using PackageCompiler.\n""""""""""""\nfunction is_standard_julia_session()\n    julia_folder = splitpath(Sys.BINDIR)[end-1]\n    return match(r""""Julia.\d+\.\d+\.\d+"""", julia_folder) !== nothing\nend\n```\nThe last part is tested on Windows only and should probably be improved - but it does """"just works"""".\n\n*Note*: There's no dependence on Artifacts or content hashes here. A file is identified purely by its filename (with all the pros and cons that follows).\n\nLet me know what you think - thx | [sdewaele]: Cool, thanks! I like the usage of the usage of the string macro to get `asset""""my_image.gif`. Perhaps there is a possibility to leverage the code offered by @staticfloat to turn a local file into an artifact. The benefit of that would be that `PackageCompiler` will automatically ship them!\n\nBecause I think there is still a good case for the functionality proposed in this issue, I will leave it open for now - perhaps it is an inspiration to the devs. Unfortunately, I currently don't have the opportunity to contribute a solution myself. | [StefanKarpinski]: Very cool!",17,false,0,0,0,0,0,0,0,0,0
1829,`update Package` sometimes doesn't update Package even though it could,open,KristofferC,,,,5,2020-05-19T15:24:47.0,2020-10-16T09:59:04.0,1887,1738,https://github.com/JuliaLang/Pkg.jl/issues/1829,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1829,"```\n(@v1.4) pkg> up DataFrames\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Updating `~/.julia/environments/v1.4/Project.toml`\n [no changes]\n   Updating `~/.julia/environments/v1.4/Manifest.toml`\n [no changes]\n\n(@v1.4) pkg> up\n   Updating registry at `~/.julia/registries/General`\n   Updating `~/.julia/environments/v1.4/Project.toml`\n  [336ed68f] ↑ CSV v0.6.1 ⇒ v0.6.2\n  [a93c6f00] ↑ DataFrames v0.20.2 ⇒ v0.21.0\n   Updating `~/.julia/environments/v1.4/Manifest.toml`\n  [336ed68f] ↑ CSV v0.6.1 ⇒ v0.6.2\n  [324d7699] ↑ CategoricalArrays v0.7.7 ⇒ v0.8.0\n  [a93c6f00] ↑ DataFrames v0.20.2 ⇒ v0.21.0\n  [48062228] ↑ FilePathsBase v0.7.0 ⇒ v0.8.0\n```\n\nAll the below where updates, why didn't `up DataFrames` update?","[KristofferC]: ```\n(@v1.4play) pkg> up DataFrames\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Updating `~/.julia/environments/v1.4play/Project.toml`\n [no changes]\n   Updating `~/.julia/environments/v1.4play/Manifest.toml`\n [no changes]\n\n(@v1.4play) pkg> rm CSV\n   Updating `~/.julia/environments/v1.4play/Project.toml`\n  [336ed68f] - CSV v0.6.1\n   Updating `~/.julia/environments/v1.4play/Manifest.toml`\n  [336ed68f] - CSV v0.6.1\n  [48062228] - FilePathsBase v0.7.0\n  [ea10d353] - WeakRefStrings v0.6.2\n\n(@v1.4play) pkg> up DataFrames\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Updating `~/.julia/environments/v1.4play/Project.toml`\n  [a93c6f00] ↑ DataFrames v0.20.2 ⇒ v0.21.0\n   Updating `~/.julia/environments/v1.4play/Manifest.toml`\n  [324d7699] ↑ CategoricalArrays v0.7.7 ⇒ v0.8.0\n  [a93c6f00] ↑ DataFrames v0.20.2 ⇒ v0.21.0\n```\n\nWhy did removing CSV allow it to update? | [KristofferC]: I'm guessing it has something to do with CSV 0.6.1 and DataFrames 0.21 being incompatible:\n```\n(@v1.4play) pkg> add CSV@0.6.1 DataFrames@0.21\n  Resolving package versions...\nERROR: Unsatisfiable requirements detected for package CSV [336ed68f]:\n CSV [336ed68f] log:\n ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.3, 0.5.0-0.5.26, 0.6.0-0.6.2] or uninstalled\n ├─restricted to versions 0.6.1 by an explicit requirement, leaving only versions 0.6.1\n └─restricted by compatibility requirements with DataFrames [a93c6f00] to versions: [0.3.0-0.3.1, 0.4.0-0.4.3, 0.6.2] or uninstalled — no versions left\n   └─DataFrames [a93c6f00] log:\n     ├─possible versions are: [0.11.7, 0.12.0, 0.13.0-0.13.1, 0.14.0-0.14.1, 0.15.0-0.15.2, 0.16.0, 0.17.0-0.17.1, 0.18.0-0.18.4, 0.19.0-0.19.4, 0.20.0-0.20.2, 0.21.0] or uninstalled\n     └─restricted to versions 0.21 by an explicit requirement, leaving only versions 0.21.0\n``` | [KristofferC]: I'm not even sure what the exact semantics to `update Package` is. | [fredrikekre]: I just ran into this too, pretty annoying that a bunch of other stuff is upgraded except the one thing you request.\n\n> I'm not even sure what the exact semantics to update Package is.\n\nI guess it can really only mean """"at least don't downgrade"""", but it would be nice if it would be prioritized a bit more or something. | [fredrikekre]: > I'm guessing it has something to do with CSV 0.6.1 and DataFrames 0.21 being incompatible:\n\nYea, looks like we lock everything in Project.toml and in this case I that means we can't upgrade DataFrames since CSV is locked.",5,false,0,0,0,0,0,0,0,0,0
2092,remove unfinished artifact when there's an exception,open,johnnychen94,,,,2,2020-10-07T19:44:39.0,2020-10-07T20:53:15.0,1746,1746,https://github.com/JuliaLang/Pkg.jl/issues/2092,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2092,"```julia\nJULIA_DEPOT_PATH=tmp julia-latest --startup=no -e 'using Pkg; pkg""""add Polymake""""'\n```\n\nand `Ctrl-C` when there are some artifacts downloading and installing.\n\nthen `rm -rf tmp` would fail with permission error:\n\n```julia\nrm: cannot remove ‘tmp/artifacts/b801935f313061d64e28d8a28c39cdc24f139920/share/terminfo/t’: Permission denied\nrm: cannot remove ‘tmp/artifacts/b801935f313061d64e28d8a28c39cdc24f139920/share/terminfo/j’: Permission denied\nrm: cannot remove ‘tmp/artifacts/b801935f313061d64e28d8a28c39cdc24f139920/share/terminfo/7’: Permission denied\n```\n\nthat I don't have write permission to the newly extracted tarball\n\n```bash\nls -al tmp/artifacts/1a9c9d412428e70857d32b50ef93d251c1468732/share\ntotal 13\ndrwxr-xr-x  3 jc jc  3 Oct  8 03:46 ./\ndrwx------  3 jc jc  3 Oct  8 03:46 ../\ndr-xr-xr-x 11 jc jc 11 Oct  8 03:46 polymake/\n```","[fredrikekre]: Looks a bit similar to https://github.com/JuliaLang/Pkg.jl/issues/2053 | [johnnychen94]: Oh sorry I forgot to give the version info\n\n```julia\njulia> versioninfo()\nJulia Version 1.6.0-DEV.1150\nCommit 5d213f6018 (2020-10-07 16:12 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.5.0)\n  CPU: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-10.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 8\n  JULIA_PKG_SERVER = https://mirrors.sjtug.sjtu.edu.cn/julia\n  JULIA_PKG_PRECOMPILE_AUTO = 1\n```\n\nIt seems `Ncurses_jll` is a smaller test case.\n\n<details>\n<summary> long logs </summary>\n\n```\n ~  JULIA_DEPOT_PATH=tmp julia-latest --startup=no -e 'using Pkg; pkg""""add Polymake""""'                                                                                                                                                                                                                                                                2002ms  Thu Oct  8 04:46:02 2020\n Installing known registries into `tmp`\n######################################################################## 100.0%\n      Added registry `General` to `tmp/registries/General`\n  Resolving package versions...\n  Installed Gettext_jll ────────────────── v0.20.1+6\n  Installed libpolymake_julia_jll ──────── v0.1.2+0\n  Installed Ninja_jll ──────────────────── v1.10.0+0\n  Installed PPL_jll ────────────────────── v1.2.0+0\n  Installed bliss_jll ──────────────────── v0.73.0+0\n  Installed libcxxwrap_julia_jll ───────── v0.8.0+0\n  Installed Libiconv_jll ───────────────── v1.16.0+6\n  Installed Polymake ───────────────────── v0.5.0\n  Installed normaliz_jll ───────────────── v3.8.5+0\n  Installed OpenSSL_jll ────────────────── v1.1.1+5\n  Installed Readline_jll ───────────────── v8.0.4+0\n  Installed Zstd_jll ───────────────────── v1.4.5+1\n  Installed Ncurses_jll ────────────────── v6.1.0+4\n  Installed CxxWrap ────────────────────── v0.11.0\n  Installed Mongoc ─────────────────────── v0.6.1\n  Installed LZO_jll ────────────────────── v2.10.0+2\n  Installed polymake_jll ───────────────── v4.1.0+2\n  Installed FLINT_jll ──────────────────── v2.6.3+0\n  Installed snappy_jll ─────────────────── v1.1.8+0\n  Installed MPFR_jll ───────────────────── v4.1.0+1\n  Installed GMP_jll ────────────────────── v6.2.0+2\n  Installed lrslib_jll ─────────────────── v0.1.0+1\n  Installed Zlib_jll ───────────────────── v1.2.11+16\n  Installed JSON ───────────────────────── v0.21.1\n  Installed boost_jll ──────────────────── v1.71.0+2\n  Installed CompilerSupportLibraries_jll ─ v0.3.3+0\n  Installed MongoC_jll ─────────────────── v1.16.2+0\n  Installed cddlib_jll ─────────────────── v0.94.10+0\n  Installed XML2_jll ───────────────────── v2.9.10+2\n  Installed MacroTools ─────────────────── v0.5.5\n  Installed Parsers ────────────────────── v1.0.11\n  Installed nauty_jll ──────────────────── v2.6.12+0\n  Installed Perl_jll ───────────────────── v5.30.3+0\nDownloading artifact: Gettext\nDownloading artifact: libpolymake_julia\nDownloading artifact: PPL\nDownloading artifact: Ninja\nDownloading artifact: bliss\nDownloading artifact: libcxxwrap_julia\nDownloading artifact: Libiconv\nDownloading artifact: normaliz\nDownloading artifact: OpenSSL\nDownloading artifact: Readline\nDownloading artifact: Zstd\nDownloading artifact: Ncurses\n  ERROR: InterruptException:\nStacktrace:\n  [1] poptask(W::Base.InvasiveLinkedListSynchronized{Task})\n    @ Base ./task.jl:737\n  [2] wait\n    @ ./task.jl:745 [inlined]\n  [3] wait(c::Base.GenericCondition{Base.Threads.SpinLock})\n    @ Base ./condition.jl:106\n  [4] wait(x::Base.Process)\n    @ Base ./process.jl:621\n  [5] success\n    @ ./process.jl:483 [inlined]\n  [6] run(cmds::Cmd, args::Tuple{Base.DevNull, Base.TTY, Base.TTY}; wait::Bool)\n    @ Base ./process.jl:440\n  [7] run(cmds::Cmd, args::Tuple{Base.DevNull, Base.TTY, Base.TTY})\n    @ Base ./process.jl:438\n  [8] download(url::String, dest::String; verbose::Bool, auth_header::Nothing)\n    @ Pkg.PlatformEngines /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/PlatformEngines.jl:820\n  [9] download_verify(url::String, hash::Nothing, dest::String; verbose::Bool, force::Bool, quiet_download::Bool)\n    @ Pkg.PlatformEngines /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/PlatformEngines.jl:886\n [10] download_verify_unpack(url::String, hash::Nothing, dest::String; tarball_path::Nothing, ignore_existence::Bool, force::Bool, verbose::Bool, quiet_download::Bool)\n    @ Pkg.PlatformEngines /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/PlatformEngines.jl:1124\n [11] #20\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:339 [inlined]\n [12] create_artifact(f::Pkg.Artifacts.var""""#20#21""""{Bool, Bool, String, Nothing})\n    @ Pkg.Artifacts /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:41\n [13] download_artifact(tree_hash::Base.SHA1, tarball_url::String, tarball_hash::Nothing; verbose::Bool, quiet_download::Bool)\n    @ Pkg.Artifacts /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:338\n [14] (::Pkg.Artifacts.var""""#24#26""""{Bool, Bool, Base.SHA1})()\n    @ Pkg.Artifacts /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:401\n [15] with_show_download_info(f::Pkg.Artifacts.var""""#24#26""""{Bool, Bool, Base.SHA1}, name::String, quiet_download::Bool)\n    @ Pkg.Artifacts /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:434\n [16] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool)\n    @ Pkg.Artifacts /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:400\n [17] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool)\n    @ Pkg.Artifacts /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:484\n [18] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool)\n    @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:674\n [19] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, verbose::Bool)\n    @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:653\n [20] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, new_git::Vector{Base.UUID}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform)\n    @ Pkg.Operations /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1171\n [21] add(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; preserve::Pkg.Types.PreserveLevel, platform::Base.BinaryPlatforms.Platform, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:192\n [22] add\n    @ /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:143 [inlined]\n [23] add(pkgs::Vector{Pkg.Types.PackageSpec}; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:68\n [24] add(pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.API /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:68\n [25] do_cmd!(command::Pkg.REPLMode.Command, repl::Pkg.REPLMode.MiniREPL)\n    @ Pkg.REPLMode /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:403\n [26] do_cmd(repl::Pkg.REPLMode.MiniREPL, input::String; do_rethrow::Bool)\n    @ Pkg.REPLMode /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:381\n [27] top-level scope\n    @ none:1\n !  ~  rm -rf tmp                                                                                                                                                                                                                                                                                                                                   22.4s  Thu Oct  8 04:46:25 2020\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/termcap.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/form.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/nc_tparm.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/unctrl.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/term.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/panel.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/ncurses.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/tic.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/eti.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/ncurses_dll.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/term_entry.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/menu.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw/curses.h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include/ncursesw: Directory not empty\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/include: Directory not empty\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/r: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/u: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/9: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/7: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/i: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/N: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/g: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/6: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/z: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/1: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/8: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/t: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/s: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/A: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/f: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/o: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/h: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/M: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/j: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/c: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/d: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/v: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/Q: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/4: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/x: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/3: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/E: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/b: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/k: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/L: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/2: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/5: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/P: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo/w: Permission denied\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share/terminfo: Directory not empty\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6/share: Directory not empty\nrm: tmp/artifacts/8344c1b8ea361bf3844084aab5d53294431ca5a6: Directory not empty\nrm: tmp/artifacts: Directory not empty\nrm: tmp: Directory not empty\n```\n\n</details>",2,false,0,0,0,0,0,0,0,0,0
2060,"With global depot, still automatically clone General",open,Keno,,,,1,2020-10-01T05:53:22.0,2020-10-01T05:57:40.0,1753,1753,https://github.com/JuliaLang/Pkg.jl/issues/2060,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2060,"I was playing with julia on a supercomputer that has a globally managed julia install,\nincluding a global, read-only depot. This depot had an outdated copy of General, so\nPkg wouldn't let me install newer versions of packages. I was quite confused for a\nwhile, since I'm not used to the whole global depot setup. I would like to suggest two\nthings:\n1. Still clone the general registry to the user-local writable depot, so the latest registry information is available\n2. Give more information in `registry status` (e.g. where the registry is saved and how old it is)\n\nThat said, after I installed a newer copy of the registry manually using `registry add`, everything\nwent through just fine, which I was very happy about.\n",[DilumAluthge]: Makes sense to me.,1,false,3,3,0,0,0,0,0,0,0
1873,Partial Artifacts,open,staticfloat,,,,10,2020-06-20T22:19:23.0,2020-09-30T03:17:36.0,1855,1754,https://github.com/JuliaLang/Pkg.jl/issues/1873,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1873,"## Problem statement\n\nArtifacts are indivisible chunks of data.  It would be useful to have the capability to slice them into unions of subtrees, to allow for flexible installation of partial artifacts.  Motivating examples:\n\n* In JLL packages, there is a clear delineation between the data needed at (C/C++) compile time, and the data needed at runtime.  Binaries and dynamic libraries are generally the only things needed at runtime, however when building a library that will link against it, the headers (and possibly even static libraries) are needed.  If something goes wrong, debugging symbols can be very helpful.  Having the ability to download only the pieces needed for the basic situation would be great.  This use case could be fulfilled by simply generating a `minimal`, `build` and `full` (which includes debug files) artifact for each and every JLL package, but it would be wasteful of server storage and bandwidth, as if the debug information is stored in separate files, these artifacts are all strict subsets of eachother.\n\n* In distributed analysis, datasets are often split into multiple files, and each node may only need a small subset of files from the overall dataset.  Having a single large artifact for the entire dataset is simple, but wasteful of time and bandwidth.  Splitting the dataset into separate artifacts for each worker is inflexible, and splitting the dataset into thousands of small artifacts, allowing each worker to grab the ones it wants is bothersome.\n\n## Proposed solution\n\nArtifacts are, in their most abstract sense, content trees that are identified by their treehash, typically with some extra information about where to download it from.  A content tree contains within it many sub-content trees, and one can construct a very large number of trees that are unions of those sub-content trees.  If the Pkg client can communicate to a Pkg server a desired union of subtrees, the Pkg server can generate a tarball for that union that has its own content treehash, and serve it to the client.\n\n### Specification of union trees\n\nThe Pkg client will request an artifact from the Pkg server, including with the request a set of sub-tree hashes.  Each subtree hash must be a _primal_ treehash, e.g. one that corresponds to a leaf or full subtree of the full content tree.\n\nAs an example, here is a file tree, with example file hashes at each node:\n\n```\n151e8ff64bf82449ba700f35800ccf4dd7fa6c6b Antic_jll\n45979ab0ea4b5a6b75542451b1fa43157c7ed66d ├── include\nfe0ea5902b21d3ce0e2ee321d34d97d848be6b60 │   ├── antic\n0b8f4b014d8449c25d857966d7c9257bc47f97b4 │   │   ├── nf_elem.h\n3b226dd64bf2c56ed76912182f7388fd3c28838d │   │   ├── nf.h\n38d9b42383972a7a500861aa9079adb9f499e37c │   │   └── qfb.h\ne69de29bb2d1d6434b8b29ae775ad8c2e48c5391 │   └── antic.h\n2424fac4ebaedc111308e12465363e640cd1b7dd └── lib\nc1d4423e4e089a0890f3f5d9677d7bbd56388423     ├── libantic.so -> libantic.so.0.0.1\nc1d4423e4e089a0890f3f5d9677d7bbd56388423     ├── libantic.so.0 -> libantic.so.0.0.1\n35938f6e1b7765b32cf6c2b014c24de3cc116b00     └── libantic.so.0.0.1\n```\n\nAll hashes shown in the above diagram are _primal_ treehashes; all unions must be expressed in terms of these primal treehashes.  Therefore, it would be valid to request the union of:\n\n```\n3b226dd64bf2c56ed76912182f7388fd3c28838d\n2424fac4ebaedc111308e12465363e640cd1b7dd\n```\n\nWhich would result in the following union tree:\n```\n90a3a8c35da0eab2c30f33c699b42b3da8555263 Antic_jll\n5981c69027c66fbbc08fab118231375795d5c7d7 ├── include\na10deb59bddaa1afe8247e38708073338abb16d1 │   └── antic\n3b226dd64bf2c56ed76912182f7388fd3c28838d │       └── nf.h\n2424fac4ebaedc111308e12465363e640cd1b7dd └── lib\nc1d4423e4e089a0890f3f5d9677d7bbd56388423     ├── libantic.so -> libantic.so.0.0.1\nc1d4423e4e089a0890f3f5d9677d7bbd56388423     ├── libantic.so.0 -> libantic.so.0.0.1\n35938f6e1b7765b32cf6c2b014c24de3cc116b00     └── libantic.so.0.0.1\n```\n\nNote that we now have a bunch of new hashes on the left, but these new hashes are _not_ primal hashes, and they cannot be used to request trees from the Pkg server.  This limitation reduces the number of hashes that the Pkg server must know about to simply `N` instead of `2^N` (where `N` is the number of files/directories within the full content tree).\n\n## Pkg Client Implementation\n\nThe Pkg client makes its request via a `GET /artifact/$hash/partial` request, where `$hash` is the root primal hash (e.g. `151e8ff64bf82449ba700f35800ccf4dd7fa6c6b` in the example above, and the hash that is recorded in `Artifacts.toml` files today).  The `GET` request includes a body of partial hashes, the response to this request is a tarball containing at least those hashes, or an error.  On error, a Pkg client may attempt to download the full artifact.\n\nWhen a Pkg client receives a tarball, it must verify it.  In keeping with the rest of the Pkg server web of trust, we do not require sha256 verification of tarballs from Pkg servers (we only require strict tarball identity when downloading from unknown servers), but we always verify content tree hashes.  When verifying a partial content tree hash, the Pkg client will only verify that the requested tree hashes are present tree; not that the overall content tree matches exactly.  This enables two core behaviors:\n\n* The Pkg server is allowed to serve more than was asked for.  This leaves open the option for Pkg Servers to serve an extremely similar but not identical partial artifact, in the event that it already has one cached and ready to serve.  This can be used to, for instance, bound latency for users by starting to generate a partial artifact, and if it's taking too long, serve the next closest artifact on disk.\n* The Pkg client is able to """"merge"""" multiple partial artifacts from the same root content tree.  Taking the JLL example above, if a user has already installed the """"full"""" variant of an artifact on disk, that variant would satisfy both the """"minimal"""" and """"build"""" variants, despite the fact that the content tree is not the same.  Similarly, taking the distributed analysis example above, if a worker node has already downloaded dataset pieces `A`, `C` and `D`, and next needs to analyze pieces `A` and `B`, the presence of `C` and `D` within the same content tree should not interfere.  We therefore make the assertion that, within a single artifact, extra pieces of data that still belong to the overall root content tree are never a problem.\n\nIn order to properly manage and verify all of this, metadata is needed.  We will maintain a TOML file alongside the partial artifact directories, keeping track of what was installed by us and the primal hashes of all elements within.  The organization of files on-disk will be:\n\n```\n~/.julia/artifacts/<root_hash>/...\n~/.julia/artifacts/<root_hash>.toml\n```\n\nIn such a manner, `Pkg.gc()` performs its same sweeping as before, only if it should remove a content tree because it is no longer reachable, it must now remove the corresponding metadata `.toml` file as well.  When performing artifact installation operations, if a `.toml` file is present, it is first loaded and checked to see what pieces of the artifact must actually be downloaded and added into the `artifacts/<root_hash>/` directory.  If an artifact installation operation ever installs all elements into an `artifacts/<root_hash>/` directory such that it is now complete, the `.toml` file is deleted.\n\n## Pkg Server implementation\n\nWhen fetching a new resource from the storage server, a Pkg server would record its primal hashes in a `.toml` file that is stored alongside the tarball.  Thereafter, when servicing partial artifact requests, it would load the `.toml` file, match the requested primal hashes to content path prefixes, then generate a new tarball using `Tar.rewrite()` with a predicate that includes only files that match the set of path prefixes requested.  The resultant tarball would then be cached under its own content hash.  Note that finding imperfect matches (e.g. already-cached tarballs that contain a superset of the requested hashes) in this organizational scheme is not easy, but this does not bother us.  We leave room open in the protocol for the server to be clever/lazy, but we don't require it.\n\n### Misc. notes\n* Partial artifacts are only implementable through Pkg Server cooperation; if a Pkg client is unable to contact a Pkg server, it should fall back to simply fetching the entire artifact, unless a keyword argument `force_partial` is set to `true`.  This prevents e.g. worker nodes on a cluster from falling back to fetching a multi-GB file when they only wanted a few 10's of MBs of tarballs.  In this case, we assert that a cooperative Pkg server is willing to serve us a partial artifact, and we error out if this is not the case.\n\n* JLL packages may record a set of subtree hashes for each artifact, denoting the list of hashes that correspond to the `minimal` and `build` trees.  When installing a package, by default, they would request the `minimal` set of hashes from the Pkg server.  (If the Pkg server is unavailable, falling back to the `full` set is non-fatal; it's slightly larger but functionally it serves, with the possible exception of LLVM_jll, which is truly enormous when debug info is included 😉).\n\n* We already have plans to store some metadata alongside package installs, so-called """"skeleton tarballs"""".  If these metadata repositories contained hashes, we could use those instead of the extra `.toml` files above.  The time spent hashing will already be performed in all cases, as we always verify tarball content hashes when downloading a new resource, so it would be a matter of extracting that information from our hashing routines, and storing the results in a tarball efficiently.","[DilumAluthge]: > Partial artifacts are only implementable through Pkg Server cooperation; if a Pkg client is unable to contact a Pkg server, it should fall back to simply fetching the entire artifact, unless a keyword argument `force_partial` is set to `true`.  This prevents e.g. worker nodes on a cluster from falling back to fetching a multi-GB file when they only wanted a few 10's of MBs of tarballs.\n\nWhat happens if `force_partial` is set to `true` and the Pkg client is unable to contact a Pkg server? Presumably, we will throw a fatal error in that case? | [staticfloat]: > Presumably, we will throw a fatal error in that case?\n\nCorrect, I have updated the comment to make that more clear. | [johnnychen94]: > Partial artifacts are only implementable through Pkg Server cooperation; if a Pkg client is unable to contact a Pkg server, it should fall back to simply fetching the entire artifact\n\nThe [BFSU mirror](https://mirrors.bfsu.edu.cn/julia/static/) is a pure static https server in storage protocol with no advanced Pkg protocol feature, IIUC this is still compatible, except that Pkg client would always download the full tarball since fetching partial tarballs would get a 404 code? | [staticfloat]: This is only proposing an alteration between the Pkg client and the Pkg server; the storage server is untouched by this.  The Pkg server would always be downloading the full tarball from the storage server, then serving smaller chunks of it to Pkg clients. | [johnnychen94]: Let me clarify it a bit since this kind of mirror isn't documented anywhere in Pkg. \n\nThe intersection of the storage protocol and pkg protocol becomes an https server with no advanced pkg protocol features. This makes it possible for a pkg client to directly connect to a storage server to download tarballs (the status quo); the BFSU mirror is used in such way: `JULIA_PKG_SERVER=https://mirrors.bfsu.edu.cn/julia/static/ julia`.\n\nWe built BFSU mirror this way because mirror site maintainers refuse the Pkg server solution; as they declared, there are real performance issues serving a mirror via reverse-proxy manner (e.g., Nexus) even if there is a caching mechanism. Check the [server status](https://mirrors.bfsu.edu.cn/status/#server-status) and you'll find it's of very high bandwidth and IO pressure.\n\nIIUC, advanced pkg server features such as diff, partial artifacts will be provided via HTTP request in form of `$pkg_server/artifacts/$hash-$diff` and `$pkg_server/artifacts/$hash`. """"If what the pkg client connects to is a storage server, it would always receive a `404` code in such cases, and then immediately falls back to downloading the full tarball from the server."""" <-- I just want to make sure this routine still works. BFSU works great and it's currently the best solution for users in mainland China.\n\n> if a Pkg client is unable to contact a Pkg server\n\nIf this means receiving a `404` when fetching partial artifacts, then it's great because pkg client can't distinguish between whether it's a pkg server or storage server in this case. But if it means fetching and checking some data preserved only to pkg server(e.g., `/stats`), then it would break the current routine.\n | [staticfloat]: > I just want to make sure this routine still works. BFSU works great and it's currently the best solution for users in mainland China.\n\nWhile you can currently point a Pkg client at a static server and use it like this, (and this design will not change that) I do not think we will be able to always guarantee this.  There's too much that we want to do with the Pkg servers to always guarantee that a static server will be sufficient.  We won't go out of our way to break it, but I do think it likely that eventually the BFSU solution is going to stop working.\n\nThe BFSU could still be the backing storage server that other Pkg servers use, but that would require someone else to host a Pkg server.\n\nI expect by the time we get that far, we will have done the paperwork to get proper Chinese servers. | [c42f]: Thanks @staticfloat for pointing me toward this issue.\n\n> * In distributed analysis, datasets are often split into multiple files, and each node may only need a small subset of files from the overall dataset.  Having a single large artifact for the entire dataset is simple, but wasteful of time and bandwidth.  Splitting the dataset into separate artifacts for each worker is inflexible, and splitting the dataset into thousands of small artifacts, allowing each worker to grab the ones it wants is bothersome.\n\nOne thing I think is interesting and difficult is dynamic partitioning in distributed compute jobs where there is no natural partitioning of the data. For example, the input to a job may be a single huge file (eg, a batch of data from a sensor, or even a big CSV file with time series data). In these cases you would often like to read a portion of the data per compute node, but this partitioning is a *property of the compute available*, not a property of the data.\n\nIt's hard to cleanly deal with this in a model where the partitions are a property of the data set. A workaround is to have a compute job which runs before the main compute and partitions the data by creating a new partitioned dataset which the distributed compute can work on. But for large datasets copying data like this isn't very satisfying. | [johnnychen94]: One thing that might be related, is to also support partial package under the same mechanisim.\n\nLike Interpolations.jl (https://github.com/JuliaMath/Interpolations.jl/issues/372), many packages have bundled their documentation altogether in one big repo and release them. And this could contribute to a large part of the download size, although they're still relatively smaller than artifacts.\n\nThe `]up` part could be largely solved by the diff feature, if implemented. | [staticfloat]: That Interpolations.jl is an interesting case, but remember that the client needs to know the subset of primal hashes it wants to request from the server before it does anything else; so you'd need to record the set of primal hashes you want a """"partial package"""" to consist of within the Registry, which is a pretty big change.  I think in general we're probably going to rely upon the diff feature for this, which we are still working on. | [mkitti]: I'm currently maintaining Interpolations.jl and am now following this issue.",10,false,8,6,0,0,0,0,1,0,1
2056,Feature request: `dev` for a repository containing multiple packages,open,fingolfin,,,,0,2020-09-29T23:42:20.0,2020-09-29T23:42:20.0,1754,1754,https://github.com/JuliaLang/Pkg.jl/issues/2056,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2056,"Suppose you have a single git repository with several Julia packages each in its own subdirectory. This is now quite well supported.\n\nOne thing that is slightly annoying is dev'ing these packages; in particular, we regularly may need to dev *all* packages in that single mono repository. For me personally, that's no problem: I clone the repository manually, and then dev the subdirs in there with a simple script involving a for-loop... thus bypassing `~/.julia/dev`. But I know others prefer other workflows, in particular they want Julia to manage the cloning etc. for them.\n\nOne can of course manually dev each subdir package in the repository as described in issue #2055.\n\nBut I was wondering: would it be possible resp. acceptable (if somebody submitted a PR) to teach `dev` to be recursive (at least optionally)? E.g. by using a simple glob syntax. E.g. to dev all subdirs one level deep, use this:\n```\npkg> dev URL/*\n```\nThis would clone the repository once, then iterate over all subdirs and dev each of them containing a `Project.toml`.",,0,false,0,0,0,0,0,0,0,0,0
2055,dev'ing several subdirs of a single git repository cause the repo to be cloned multiple times,open,fingolfin,,,,0,2020-09-29T23:34:17.0,2020-09-29T23:34:17.0,1754,1754,https://github.com/JuliaLang/Pkg.jl/issues/2055,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2055,"Suppose I have a repository with several Julia packages in subdirectories. I might run this to dev one of the packages:\n```\npkg> dev """"git@github.com:myorg/myrepo.git"""":MySubdir.jl\n```\nAs far as I can tell, this clones the repository into `~/.julia/dev/myrepo` and the package is put into `~/.julia/dev/myrepo/MySubdir.jl`.\n\nNow suppose I want to dev another package from the same repository:\n```\npkg> dev """"git@github.com:myorg/myrepo.git"""":AnotherSubdir.jl\n```\nTo my surprise, this actually seems to trigger a fresh full clone (tested with Julia 1.5 as well as latest master, and the Pkg.jl bundled with each). It says:\n```\n    Cloning git-repo `git@github.com:myorg/myrepo.git `\nPath `/Users/mhorn/.julia/dev/myrepo` exists and looks like the correct repo. Using existing path.\n  Resolving package versions...\n...\n```\nAs far as I can tell, in the end there is indeed still just one copy of the repository.\n\nCan this second (and 3rd, 4th, ... if I dev more subdirs) clone be avoided?\n\n",,0,false,0,0,0,0,0,0,0,0,0
2007,Symbolic linked julia home make `dev` outside `.julia/dev` fail,open,yiyuezhuo,,,,3,2020-09-05T15:34:13.0,2020-09-25T22:23:18.0,1778,1758,https://github.com/JuliaLang/Pkg.jl/issues/2007,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2007,"I created symbolic linking to point `.julia` to another directory like this:\n\n```shell\nyiyuezhuo@yiyuezhuo-System-Product-Name:~$ ls ~/.julia -l\nlrwxrwxrwx 1 yiyuezhuo yiyuezhuo 43 Jun  2 21:39 /home/yiyuezhuo/.julia -> /home/yiyuezhuo/linux/home/yiyuezhuo/.julia\n```\n\n(So I can use files from another Ubuntu system by mounting to decrease disk usage.)\n\nWhile most things works as expected, `dev` a path outside `.julia/dev` will fail:\n\n```\njulia> pwd()\n""""/home/yiyuezhuo/pkg_test""""\n(v1.5) pkg> generate TestPackage11\n Generating  project TestPackage11:\n    TestPackage11/Project.toml\n    TestPackage11/src/TestPackage11.jl\n\n(v1.5) pkg> dev TestPackage11\n[ Info: Resolving package identifier `TestPackage11` as a directory at `~/pkg_test/TestPackage11`.\nPath `TestPackage11` exists and looks like the correct package. Using existing path.\n  Resolving package versions...\nUpdating `~/linux/home/yiyuezhuo/.julia/environments/v1.5/Project.toml`\n  [883d5c9b] + TestPackage11 v0.1.0 `../../../../../../pkg_test/TestPackage11`\nUpdating `~/linux/home/yiyuezhuo/.julia/environments/v1.5/Manifest.toml`\n  [883d5c9b] + TestPackage11 v0.1.0 `../../../../../../pkg_test/TestPackage11`\n\njulia> using TestPackage11\nERROR: ArgumentError: Package TestPackage11 [883d5c9b-2d9f-45d1-a08a-ef6f210670d5] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\nStacktrace:\n [1] _require(::Base.PkgId) at ./loading.jl:999\n [2] require(::Base.PkgId) at ./loading.jl:928\n [3] require(::Module, ::Symbol) at ./loading.jl:923\n```\n\nWhile `dev` in `.julia/dev` works as usual:\n\n```\njulia> cd(expanduser(""""~/.julia/dev""""))\n\n(v1.5) pkg> generate TestPackage12\n Generating  project TestPackage12:\n    TestPackage12/Project.toml\n    TestPackage12/src/TestPackage12.jl\n\n(v1.5) pkg> dev TestPackage12\n[ Info: Resolving package identifier `TestPackage12` as a directory at `~/linux/home/yiyuezhuo/.julia/dev/TestPackage12`.\nPath `TestPackage12` exists and looks like the correct package. Using existing path.\n  Resolving package versions...\nUpdating `~/linux/home/yiyuezhuo/.julia/environments/v1.5/Project.toml`\n  [1fea3e19] + TestPackage12 v0.1.0 `../../dev/TestPackage12`\nUpdating `~/linux/home/yiyuezhuo/.julia/environments/v1.5/Manifest.toml`\n  [1fea3e19] + TestPackage12 v0.1.0 `../../dev/TestPackage12`\n\njulia> using TestPackage12\n[ Info: Precompiling TestPackage12 [1fea3e19-b2e1-4bee-a823-2524150014be]\n```\n\n`Pkg.status` gives:\n\n```\n(v1.5) pkg> status\nStatus `~/linux/home/yiyuezhuo/.julia/environments/v1.5/Project.toml`\n...\n  [883d5c9b] TestPackage11 v0.1.0 `../../../../../../pkg_test/TestPackage11`\n  [1fea3e19] TestPackage12 v0.1.0 `../../dev/TestPackage12`\n...\n```\n\nI guess that the problem is due to relative path `../../../../../../pkg_test/TestPackage11`, the `] dev` records the de-symbolic path `~/linux/home/yiyuezhuo/.julia/environments/v1.5/Project.toml` while `using` use `.julia/environments/v1.5/Project.toml` so we can observe that `dev` in `.julia/dev` just works but fail when `dev` a path outside the `.julia/dev`.",[johnnychen94]: FYI one way to work this around is to specify `JULIA_DEPOT_PATH` environment variable to `/home/yiyuezhuo/linux/home/yiyuezhuo/.julia`\n\nhttps://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH | [yiyuezhuo]: Closed as the workaround is good enough and one is interested. | [StefanKarpinski]: I've reopened since this could be fixed at some point.,3,false,0,0,0,0,0,0,0,0,0
2044,Stop using the raw manifest `Dict' inside Pkg operations,open,KristofferC,,,,0,2020-09-25T12:04:07.0,2020-09-25T12:04:07.0,1759,1759,https://github.com/JuliaLang/Pkg.jl/issues/2044,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2044,"Looking at invalidations, a lot of them come from indexing into the manifest dict which is non-typed, getting inference to infer `Any` and things are bad. I think it is better if we just statically type the whole manifest, read everything into a `Manifest` struct, and then just use that one. The raw dictionary need not be stored anywhere after being read.",,0,false,3,3,0,0,0,0,0,0,0
2028,"Should `Pkg.Types.semver_spec(""0"")` throw an error?",open,DilumAluthge,,,,3,2020-09-21T03:05:12.0,2020-09-25T02:57:29.0,1763,1759,https://github.com/JuliaLang/Pkg.jl/issues/2028,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2028,"> Feels like a bug in the Pkg spec handler?\n> \n> ```\n> julia> Pkg.Types.semver_spec(""""0"""")\n> VersionSpec(""""0"""")\n> \n> julia> Pkg.Types.semver_spec(""""0.0"""")\n> VersionSpec(""""0.0"""")\n> \n> julia> Pkg.Types.semver_spec(""""0.0.0"""")\n> ERROR: invalid version: """"0.0.0""""\n> Stacktrace:\n>  [1] error(::String) at ./error.jl:33\n>  [2] semver_interval(::RegexMatch) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/versions.jl:306\n>  [3] semver_spec(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/versions.jl:287\n>  [4] top-level scope at REPL[8]:1\n> ```\n> \n> should maybe error for all?\n\n_Originally posted by @KristofferC in https://github.com/JuliaRegistries/RegistryCI.jl/pull/269#issuecomment-691988076_","[fredrikekre]: But the last one results in an empty set, the others don't, why should they error? | [KristofferC]: Because we want a single version identifier, like `0.1`, `1.1.0` etc to correspond to the version range of the version given up to the next semver incompatile version. `0` does not follow this. So it seems this got allowed by accident.\n\n```\njulia> v""""0.8"""" in Pkg.Types.semver_spec(""""0"""")\ntrue\n``` | [DilumAluthge]: > Because we want a single version identifier, like `0.1`, `1.1.0` etc to correspond to the version range of the version given up to the next semver incompatile version. `0` does not follow this. So it seems this got allowed by accident.\n> \n> ```\n> julia> v""""0.8"""" in Pkg.Types.semver_spec(""""0"""")\n> true\n> ```\n\nYeah this was my rationale as well.",3,false,0,0,0,0,0,0,0,0,0
2023,Project file validation,open,fredrikekre,,,,0,2020-09-16T23:39:14.0,2020-09-16T23:39:14.0,1767,1767,https://github.com/JuliaLang/Pkg.jl/issues/2023,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2023,"From https://github.com/JuliaLang/julia/pull/37340#issuecomment-693717907\n```\njulia> Pkg.update()\n   Updating registry at `~/.julia/registries/General`\n   Updating git-repo `https://github.com/fonsp/PlutoUtils.jl`\nERROR: Dependency `Test` in target `test` not listed in `deps` or `extras` section.\n\nStacktrace:\n  [1] pkgerror(::String, ::Vararg{String, N} where N)\n    @ Pkg.Types ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:52\n  [2] validate(project::Pkg.Types.Project)\n    @ Pkg.Types ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/project.jl:100\n  [3] Pkg.Types.Project(raw::Dict{String, Any})\n    @ Pkg.Types ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/project.jl:123\n  [4] read_project(f_or_io::String)\n    @ Pkg.Types ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/project.jl:136\n  [5] read_package(path::String)\n    @ Pkg.Types ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:403\n  [6] deps_graph(ctx::Pkg.Types.Context, uuid_to_name::Dict{Base.UUID, String}, reqs::Dict{Base.UUID, Pkg.Types.VersionSpec}, fixed::Dict{Base.UUID, Pkg.Resolve.Fixed})\n    @ Pkg.Operations ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:441\n  [7] resolve_versions!(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})\n    @ Pkg.Operations ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:370\n  [8] up(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, level::Pkg.Types.UpgradeLevel)\n    @ Pkg.Operations ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1223\n  [9] up(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; level::Pkg.Types.UpgradeLevel, mode::Pkg.Types.PackageMode, update_registry::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:245\n [10] up\n    @ ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:221 [inlined]\n [11] #up#38\n    @ ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:67 [inlined]\n [12] up\n    @ ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:67 [inlined]\n [13] up(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n    @ Pkg.API ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:80\n [14] up()\n    @ Pkg.API ~/julia-master/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:72\n [15] top-level scope\n    @ REPL[2]:1\n```\nPerhaps we don't have to be so strict and only error on Pkg.test here?",,0,false,0,0,0,0,0,0,0,0,0
2016,pkg update document defaults,open,RossBoylan,,,,0,2020-09-12T03:04:00.0,2020-09-12T09:04:00.0,1772,1772,https://github.com/JuliaLang/Pkg.jl/issues/2016,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2016,"The help for the `update` command of `pkg` (I believe the convention is to call it ']update'), whether interactive in the REPL or in https://julialang.github.io/Pkg.jl/v1/repl/, appears to be partly incorrect and partly unhelpful.\n\nThe incorrect part is that the syntax given for the command implies a """"pkg"""" argument must be specified.  As mentioned in https://docs.julialang.org/en/v1/stdlib/Pkg/, it can be omitted, in which case everything is updated.  There is no mention of this behavior here.\n\nSecond, the description does not describe the defaults for any of the options.  What happens if `--project` and `--manifest` are both omitted?  If the other `opts` are omitted, which is the default?\n\nIf other commands have similar issues, it would be good to fix those too.\n\nFor reference, here's what I get in Julia 1.5.1 in the REPL:\n```\n(MyFirst) pkg> ?update\n  [up|update] [-p|--project]  [opts] pkg[=uuid] [@version] ...\n  [up|update] [-m|--manifest] [opts] pkg[=uuid] [@version] ...\n  \n  opts: --major | --minor | --patch | --fixed\n\n  Update pkg within the constraints of the indicated version specifications. These specifications are of the form @1, @1.2 or @1.2.3,\n  allowing any version with a prefix that matches, or ranges thereof, such as @1.2-3.4.5. In --project mode, package specifications\n  only match project packages, while in manifest mode they match any manifest package. Bound level options force the following\n  packages to be upgraded only within the current major, minor, patch version; if the --fixed upgrade level is given, then the\n  following packages will not be upgraded at all.\n```\n\n",,0,false,0,0,0,0,0,0,0,0,0
2013,REPL package mode completion for path with spaces,open,yha,,,,0,2020-09-09T15:16:01.0,2020-09-09T16:33:51.0,1775,1774,https://github.com/JuliaLang/Pkg.jl/issues/2013,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/2013,"```\njulia> mkdir(""""dir with spaces"""")\n\njulia> cd(""""dir with spaces"""")\n\n(@v1.5) pkg> generate MyPkg\n Generating  project MyPkg:\n    MyPkg\Project.toml\n    MyPkg\src/MyPkg.jl\n\njulia> cd("""".."""")\n\n(@v1.5) pkg> dev dir<TAB>\n```\ncompletes incorrectly to\n```\n(@v1.5) pkg> dev dir with spaces\\\n```\nUsing double quotes\n```\n(@v1.5) pkg> dev """"dir<TAB>\n```\ndoes not complete, although this works:\n```\n(@v1.5) pkg> dev """"dir with spaces\\MyPkg""""\n```\n\nVersion info:\n```\njulia> versioninfo()\nJulia Version 1.5.1\nCommit 697e782ab8 (2020-08-25 20:08 UTC)\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: Intel(R) Core(TM) i7-9800X CPU @ 3.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)\n```\n",,0,false,0,0,0,0,0,0,0,0,0
1989,Julia 1.5 stopped showing status of dependencies,open,fredrikekre,,bug; regression,,1,2020-08-27T10:17:14.0,2020-09-01T09:34:32.0,1788,1783,https://github.com/JuliaLang/Pkg.jl/issues/1989,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1989,"```\n$ for julia in julia11 julia12 julia13 julia14 julia15 julia-master; do echo """"$julia""""; pkg --julia=$julia st -m Literate; done\njulia11\n    Status `/tmp/tmp.gUqpB6gKep/Manifest.toml`\n  [682c06a0] JSON v0.21.0\n  [98b081ad] Literate v2.6.0\n  [2a0f44e3] Base64 \n  [3fa0cd96] REPL \njulia12\n    Status `/tmp/tmp.gUqpB6gKep/Manifest.toml`\n  [682c06a0] JSON v0.21.0\n  [98b081ad] Literate v2.6.0\n  [2a0f44e3] Base64 \n  [3fa0cd96] REPL \njulia13\n    Status `/tmp/tmp.gUqpB6gKep/Manifest.toml`\n  [682c06a0] JSON v0.21.0\n  [98b081ad] Literate v2.6.0\n  [2a0f44e3] Base64 \n  [3fa0cd96] REPL \njulia14\nStatus `/tmp/tmp.gUqpB6gKep/Manifest.toml`\n  [682c06a0] JSON v0.21.0\n  [98b081ad] Literate v2.6.0\n  [2a0f44e3] Base64 \n  [3fa0cd96] REPL \njulia15\nStatus `/tmp/tmp.gUqpB6gKep/Manifest.toml`\n  [98b081ad] Literate v2.6.0\njulia-master\nStatus `/tmp/tmp.gUqpB6gKep/Manifest.toml`\n  [98b081ad] Literate v2.6.0\n```",[KristofferC]: I think this was just lost in https://github.com/JuliaLang/Pkg.jl/pull/1621.,1,false,0,0,0,0,0,0,0,0,0
1995,"The ""Using Artifacts"" example in the docs is incompatible with ""immutable packages""",open,helgee,,,,1,2020-08-28T19:44:35.0,2020-08-30T08:16:41.0,1786,1785,https://github.com/JuliaLang/Pkg.jl/issues/1995,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1995,"I failed to understand how to work with artifacts today and needed the help of some friendly people on Slack to grasp why I was getting nowhere. After some deliberation we have identified the following reasons:\n\n1. It was unclear that currently Pkg only deals with tarballs (i.e. #1921) but this is documented on `master`.\n2. The [iris example](https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/artifacts.md#using-artifacts) seems to be incompatible with the notion of """"immutable packages"""".\n\nMy understanding of artifacts was based on reading the stable docs and the coverage during JuliaCon. Subsequently my misconception was that the code in the aforementioned example would lead to a """"usable"""" `Artifacts.toml` file, i.e. a file that is read-only and can be shipped as part of an immutable package. I did not understand that this is not the case.\n\nThese quotes from the docs seem problematic in this context:\n\n> First, it modifies the package directory, making package installation stateful, which we want to avoid. In the future, we would like to reach the point where packages can be installed completely read-only, instead of being able to modify themselves after installation.\n\n> For the specific use case of using artifacts that were previously bound, we have the shorthand notation artifact""""name"""" which will automatically search for the Artifacts.toml file contained within the current package, look up the given artifact by name, install it if it is not yet installed, then return the path to that given artifact.\n\nCC: @giordano\n\nEDIT: My use case was downloading a ZIP file and making the extrated data available.","[KristofferC]: I think I've gotten similar confusion. To me, it seems that the whole `bind_artifact!` thing is supposed to be done in an offline phase (offline meaning just running it once locally) and the code to do that should not be committed to the repo?\n\nRewriting the docs into a """"setup"""" - phase and a usage phase might make sense.",1,false,0,0,0,0,0,0,0,0,0
1975,Add a Pkg.audit command to check dependencies against reported vulnerabilities,open,SaschaMann,,speculative; security,,7,2020-08-21T12:38:00.0,2020-08-28T06:29:31.0,1794,1787,https://github.com/JuliaLang/Pkg.jl/issues/1975,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1975,"**TL;DR:** A new command `Pkg.audit()` that checks installed dependencies/environment files for reported security vulnerabilities; inspired by [`npm audit`](https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities).\n\nThis is meant to start a discussion first, rather than providing details on how to implement the feature.\n\n---\n\n`npm` has a command to check dependencies against security vulnerabilities known to the registry. Imo it would be useful to have a similar command in Julia’s package manager. This primarily benefits (deployed) Julia applications, not libraries.\n\nUpdating all dependencies, while recommended, often comes with some work to ensure that everything will still work after the update, and in more secure environments it also requires reviewing the new versions of the dependencies. It’s often common that dependencies of applications are only updated when absolutely necessary. The audit command could be run on a very frequent schedule, so that potential vulnerabilities can be found quicker than the usual update cycles.\n\n`npm` also runs this automatically whenever you install or update any dependency. Further, they provide an `npm audit fix` command that bumps dependency versions if a later version of the package does not contain the vulnerability anymore.\n\nInstead of repeating everything, take a look at https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities to find out more about the details, what info is shown etc.\n\n---\n\nDo you think this would generally be a useful addition to Pkg?\n\n---\n\nA first step to implement this in Pkg would be a way for package authors to mark versions as potentially affected by a vulnerability, as well as attaching some information on the details of the vulnerability (even if it's just a link to an issue).\n\nIdeally you’d also want to allow others to report them, but that would likely require human work to verify the reports. Publishing more info on the vulnerabilities, e.g. like the [security advisories](https://www.npmjs.com/advisories) on npmjs.com, would also be nice in the future, but is not needed for basic functionality.","[KristofferC]: I think having it as a separate package makes more sense because then it isn't locked to the Julia release cycle like Pkg currently is. For something like this you want to be able to quickly make new releases, fixes etc.\n\nAlso, to me, it feels a bit too speculative to directly put into Pkg. I haven't seen a single security report for any Julia package ever, so it is unclear how much it will be used and how much it then makes sense to maintain it. In any case, it is probably best to develop something like this outside of Pkg. | [StefanKarpinski]: I do think it would be generally useful to be able to add commands to the Pkg REPL that can install, update and call external packages, so that when you do `pkg> audit` it starts an external Julia process with its own environment, installs/updates the `PkgAudit` package in that environment, and then calls `PkgAudit.audit()`. There are a few commands that people have wanted that could work like this. E.g. `pkg> search` would be handy but probably shouldn't be built in, and of course `pkg> generate` which could prompt you for what package generator to use, install that, record that choice and then use that going forward from the Pkg REPL. | [fredrikekre]: I believe it is already possible to hook into the Pkg REPL. I had a branch with that, but I got sniped by David that made the same changes so I think it should work. Not a nice interface for doing it, but IIRC it is doable. | [KristofferC]: A plugin system might be useful but we should really try to avoid exposing as much of the internals of the Pkg REPL as possible. Also, it isn't super clear to me that `using PkgAudit; audit()` is that much worse than `using PkgAudit;  ] audit`. | [SaschaMann]: > Also, to me, it feels a bit too speculative to directly put into Pkg. I haven't seen a single security report for any Julia package ever, so it is unclear how much it will be used and how much it then makes sense to maintain it. In any case, it is probably best to develop something like this outside of Pkg.\n\nIt's definitely more speculative/planning ahead. I think it's inevitable that these issues will show up eventually the more Julia is used in production applications.\n\n---\n\nDeveloping it as a separate package at first sounds like a good idea. However, there are many advantages to closely connecting it to the registries, which is the main reason why I think eventually it would make sense to have it in Pkg (assuming there will be enough demand for it). Automatically running it when doing other Pkg operations also seems quite useful. | [StefanKarpinski]: Note that there is already a mechanism for yanking package versions in the registry. | [SaschaMann]: > Note that there is already a mechanism for yanking package versions in the registry.\n\nDoesn't solve the same problem. If something is already deployed, yanking a version won't affect it. It's also fairly common that a vulnerability only affects a part of a package or a lot of different versions. Yanking would likely not be the optimal solution in those cases.",7,false,0,0,0,0,0,0,0,0,0
1965,Compatibility with rusty environment chains,open,thisrod,,,,15,2020-08-18T01:34:57.0,2020-08-27T07:46:27.0,1797,1788,https://github.com/JuliaLang/Pkg.jl/issues/1965,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1965,"Once upon a time, I installed `Plots`.  I've been slack about updating it.\n\n    % julia -e 'using Pkg; pkg""""status"""" ' | grep Plots\n      [91a5bcdd] Plots v0.28.4\n\nRecently, I created a package `Superfluids`, which depends on `RecipesBase` in the normal way.  (Some irrelevant `pkg""""status""""` output has been elided.)\n\n    % pwd\n    /Users/rpolkinghorne/.julia/dev/Superfluids\n    % julia --project\n                   _\n       _       _ _(_)_     |  Documentation: https://docs.julialang.org\n      (_)     | (_) (_)    |\n       _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n      | | | | | | |/ _` |  |\n      | | |_| | | | (_| |  |  Version 1.5.0 (2020-08-01)\n     _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n    |__/                   |\n    \n    ┌ Warning: Terminal not fully functional\n    └ @ Base client.jl:390\n    julia> using Pkg; pkg""""status""""\n    Project Superfluids v0.1.0\n    Status `~/.julia/dev/Superfluids/Project.toml`\n      [3cdcf5f2] RecipesBase v1.0.2\n\nThis is all straight out of the manual, so it will just work, right?\n\n    julia> using Superfluids\n    [ Info: Precompiling Superfluids [01347403-e5cf-4a60-9350-9edf4e6960f2]\n    \n    julia> using Plots\n    [ Info: Precompiling Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80]\n    ERROR: LoadError: LoadError: Unknown ColorScheme `:YlOrRd_r`. Check https://juliagraphics.github.io/ColorSchemes.jl/stable/ for available ColorSchemes.\n    ... crash and burn ...\n\nAnd `Pkg` knew that was going to happen:\n\n    julia> pkg""""add Plots@0.28.4""""\n    ...\n    \n    julia> pkg""""status""""\n    Project Superfluids v0.1.0\n    Status `~/.julia/dev/Superfluids/Project.toml`\n      [91a5bcdd] Plots v0.28.4\n      [3cdcf5f2] RecipesBase v0.7.0\n\nA fix would have to involve `Pkg` checking for compatibility with the whole environment chain, and presumably adding packages to the active Manifest to shadow incompatible ones in other environments.  I don't understand `Pkg` well enough to fill in the details.\n","[StefanKarpinski]: Without the contents of your Project and Manifest files, it's unclear (to me at least) what's going on here. | [KristofferC]: What is going on is that an old Plots version in the global v1.x environment loads a newer incompatible version of RecipesBase,  which is installed in the current active environment. | [StefanKarpinski]: If you change or upgrade packages, things may break, so I'm unclear if there's anything to be fixed here? | [KristofferC]: > If you change or upgrade packages, things may break, so I'm unclear if there's anything to be fixed here?\n\nThe argument is that Plots is declared incompatible with that version of RecipesBase that got loaded, but since Plots is loaded from a different environment (the global one) than its dependency (the local one), and the package manager only ensures that compatibility is satisfied within an environment, this can cause faulty configurations to load. What is desired is a warning or something that a package loads an incompatible dependency. I think this is pretty hard to do with the current system in place though. Best might be to just advice to run with `LOAD_PATH = [""""@""""]` if you don't want this to happen. | [StefanKarpinski]: The dependencies of earlier environments in the load path are always loaded intact, so your current project should never break because of this. Your development tools later in the load path might break because of something in the current project, which is what you're seeing here.\n\nThis is a code loading issue, and code loading cannot do things like add or remove different package versions. It loads code, that is all. If this kind of thing happens, the solution is to install a version of Plots that is compatible with the current project. A simple way to do that is to temporarily add it to the project, note the version that is installed and then add that specific version to your global environment.\n\nI don't really get the """"straight out of the manual"""" bit. What manual is this from? If you're reproducing an example, the way to do it is to use a manifest and install the exact versions of everything that the example used. | [StefanKarpinski]: One possible improvement is to record the compatibility constraints of each package in its manifest stanza. So the idea is that when we resolve a manifest, we look at all the things in the manifest that have compat constraints on package A and compute the intersection of all of those and record it in A's stanza. If the set of versions resolved is compatible, then the version of A that is chosen will be in this set. Then, when loading code, one still loads A from the first manifest it appears in and this version will be in the compat set for that manifest, but then we can look through all the later manifests in the load path as well, and if A appears in any of them, we can check if the version of A we loaded is in the compat set for that manifest. If it's not, then it's possible that something in that manifest that depends on A will be broken and we can print a warning about that, either when A is loaded or whenever something in that manifest that depends on A is loaded. | [thisrod]: I think this is an issue with package installation, not just code loading.  When I told `Pkg` to add `RecipesBase` to the `Superfluids` package environment, it knew that `Plots v0.28.4` was available to be loaded in that environment.  It should have chosen a compatible version of `RecipesBase`.\n\nIf I did things the other way round, adding `Plots` to the outer environment after I added `RecipesBase` to the inner one, then it would be a lot harder for `Pkg` to detect the problem.  Recording compatibility in manifests would allow it to be caught at code loading time, which would be a lot better than `Plots` failing to compile for no obvious reason.\n\n>  What manual is this from?\n\nDoing this is the entire point of `RecipesBase`.  The `PackageCompiler` manual encourages you to compile `Plots` into your system image, which puts it in the same category as development tools.\n | [StefanKarpinski]: I really don't think that trying to make all the environments in the load path compatible is reasonable. I really don't want random tools I have installed in my global environment to affect the resolution of packages in the project I'm working on. If I try loading one of my dev tools and it doesn't work, then it's the dev tool I should mess with. Even if we did try to do this, you activate a different environment or modify the load path and, boom, possibly broken. | [KristofferC]: > The PackageCompiler manual encourages you to compile Plots into your system image, which puts it in the same category as development tools.\n\nPackageCompiler.jl is very explicit about the drawbacks of custom sysimages and that this is exactly one of the things you have to look out for. | [thisrod]: > I really don't want random tools I have installed in my global environment to affect the resolution of packages in the project I'm working on.\n\nNo doubt that's the right thing for core developers who spend all day working on Julia.  But maybe environments under `~/.julia/dev` are a special case.\n\nFor those of us who work in Julia rather than on it (OK, we're a minority), and use the packages installed in our global environment to do our work, the right thing is for `Pkg` to resolve a usable environment.  (And, ideally, it would be easy to understand the constraints on that environment and diagnose what's stopping it from being updated.)\n\nReal use case: I have a """"vortex dynamics paper"""" project environment, which necessarily includes `Plots`, either directly or through the global environment.  This has a nested """"supercomputer simulations"""" environment, which needs to stay compatible with the project, but should not install `Plots` every time it is instantiated on the supercomputer. | [StefanKarpinski]: No, I say that entirely as a developer of Julia projects: I do not want the versions of dependencies that my projects use affected by whatever happens to be in the rest of my load path. Each project should be resolved independently, anything else seems like madness. If global dev tools happen to be compatible, great; if not, I can tinker with them.\n\nLet's say Pkg did what you're suggesting: I'm working on some project and I do `julia --project` and do a `] resolve` to make sure that it's compatible with the full load path. Then I start Julia without the `--project` flag and add/remove/upgrade global packages. Since the project is not in my load path, Pkg picks versions of global packages that are incompatible with the project. Then I do `julia --project` again and Julia sees that the unchanged project which is now incompatible with the rest of the load path. What is supposed to happen? Refuse to run? Automatically re-resolve everything?\n\nIt sounds like for your real use case, what you need is a development tools environment that's associated with your project and resolved together with it, where you can have `Plots` as an optional dev dependency that gets resolved every time the main project dependencies get resolved, but is not installed when someone uses the main project. Note that this can already be accomplished by having a dev environment that depends on the core vortex dynamics environment. Then when you resolve the dev environment, it will pick compatible versions for the entire version graph. There's certainly tooling improvements that could be good to have and the concept of subprojects would potentially be very useful. | [thisrod]: > What is supposed to happen? Refuse to run? Automatically re-resolve everything?\n\nI like your idea of refusing to load packages that have become incompatible with the project.\n\n> Note that this can already be accomplished by having a dev environment that depends on the core vortex dynamics environment.\n\nOr in my case, a vortex paper environment that depends on the supercomputer environment.  Thanks, neat trick.  I guess I can copy the vortex manifest to the supercomputer, then resolve the supercomputer environment to use the same versions as the paper one.\n\nBut I'm a bit confused.  The supercomputer project environment doesn't have a name or a UUID, so what is there for the vortex environment to depend on? | [StefanKarpinski]: I think that people would be very annoyed if Julia refused to run a project because there was a hypothetical conflict with any dev tool that happens to be in the global environment. What if you don't currently care about plotting? Should Julia refuse to let your project load because you might want to plot something later? Note that the project itself is guaranteed to work, so why is it not allowed to run because some dev tool that you're not even using might not work? That seems fairly silly.\n\nA better approach would be to refuse to load the conflicting dev tool. So, if something later in the load path conflicts with something earlier then Julia refuses to load it. That at least makes sense. Better still, since we don't actually know that it won't work just because the compat bounds claim this combination is untested, print a warning and let them at least give it a go. Which is what I originally suggested. A downside to loading with a warning is that once something is successfully loaded into the process, you can't unload it and get a different version whereas if it refuses to load, you have the option to try to fix the load path and try again.\n\n> But I'm a bit confused. The supercomputer project environment doesn't have a name or a UUID, so what is there for the vortex environment to depend on?\n\nSo give the project a name and a UUID then. Some additional support for this pattern would be a good idea. Several people have expressed desire for it; it really needs the subproject concept to be made to work smoothly. The idea is that each project could have a `dev` subproject that gets resolved along with the project and then we change the default load path to include the dev subproject of the active project after the active project itself. | [thisrod]: > A better approach would be to refuse to load the conflicting dev tool.\n\nThat's what I meant.  Sorry for the confusion.\n\n> The idea is that each project could have a dev subproject that gets resolved along with the project and then we change the default load path to include the dev subproject of the active project after the active project itself.\n\nHere's another hack.  I could maintain separate files for `Project.toml` and `supercomputer/Project.toml`, but symlink `supercomputer/Manifest.toml` to `Manifest.toml`.  That would be fragile, but perhaps it could be made to work if every supercomputer dependency was also a project dependency.\n\nHas anyone thought about making the subproject idea more symmetric?  Instead of a hierarchy of subprojects, there could be a set of projects that share a common manifest, and resolve their dependencies to be compatible with the whole set.  (Handling the intersections of those sets could get complicated.)  Those sets would be independent of the loading path hierarchy, which might be simpler to implement. | [thisrod]: I might have a go at implementing project sets.  From what I can see, the required changes would be:\n\n* There is a way for `Project.toml` to specify the path to `Manifest.toml`.\n\n* A project can be listed in its own manifest.\n\n* When a project is listed in a manifest, there is a way to record that the project uses this manifest.  Probably a flag like `pinned`.\n\n* I understand the pre- and postconditions and invariants of the `load_*_deps` functions.\n\n* At the appropriate moment, those functions load the direct dependencies of the other projects that share a manifest with this one.",15,false,0,0,0,0,0,0,0,0,0
1973,"include(""test/runtests.jl"") + Revise workflow with test/Project.toml",open,willtebbutt,,,,0,2020-08-19T19:09:09.0,2020-08-19T19:10:53.0,1795,1795,https://github.com/JuliaLang/Pkg.jl/issues/1973,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1973,"@iamed2 suggested that I post this as an example workflow / use case. Maybe this is a common workflow, but I couldn't see any discourse posts about it / open issues.\n\nAssume that we're currently located at the top level of a package that we're doing something approximating test-driven development on, so the core workflow is something like\n\n1. Start Julia\n1. `] activate .`\n1. `] test`\n1. Try to fix test failures and go to previous step. Continue if no failures\n1. Commit changes\n\nI've found this workflow to be quite time consuming, so in the pre-1.2 world had taken to incorporating Revise as follows:\n\n1. Start Julia\n1. Ensure that all test deps are present in the top-most environment\n1. `using Revise`\n1. `] activate .`\n1. `include(""""test/runtests.jl"""")`\n1. If tests fail, attempt a fix and return to the previous step. Otherwise continue\n1. Run `] test` to ensure that everything still works with a fresh session before commiting changes\n\nThe advantage of this workflow over repeatedly running `] test` is that everything is _way_ faster to run the second time you call `include(""""test/runtests"""")` (as you would expect). It has the downside that you have to ensure that your test dependencies are available, and if you modify types it breaks, but I've found that it works well in a large number of cases and is generally much faster than the first workflow discussed.\n\nIn a post-1.1 world where your package has a `test/Project.toml`, this workflow changes a little:\n\n1. Start Julia\n1. `using Revise`\n1. `]activate test`\n1. `add .`\n1. `include(""""test/runtests"""")`\n1. If tests fail, attempt a fix and return to the previous step. Otherwise continue\n1. `rm PackageName`\n1. `] activate .`\n1. `] test` to ensure that everything still works with a fresh session before commiting changes\n\nSo in the post-1.1 world, there's no longer a need to manually ensure that the test deps are available, which is great. It's a really significant improvement over my old way of doing things and makes e.g. test-dep-heavy packages like `Zygote` much simpler to incorporate into a `Revise`-based workflow.\n\nHowever, it would be signficantly improved if it were somehow possible to avoid adding / removing the package being developed from the test deps whenever one switches between `include(""""test/runtests"""")` and `] test`. IIUC it's not possible to explicitly make the package you're developing a test-dep. In particular, the following error seems to stem directly from doing that:\n```julia\n(Zygote) pkg> test\n    Testing Zygote\nERROR: can not merge projects\n```",,0,false,2,2,0,0,0,0,0,0,0
1928,Feature Request: multi-package .git repositories,open,ma-laforge,,,,4,2020-07-14T15:15:17.0,2020-07-14T16:03:24.0,1832,1831,https://github.com/JuliaLang/Pkg.jl/issues/1928,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1928,"I am creating this feature request in response to @KristofferC 's comment: https://github.com/JuliaLang/Pkg.jl/issues/1874#issuecomment-658052205.\n\n### Overview\nThe following describes a workflow I would like to achieve using Julia's Pkg/Registration/CI systems. The intent is to reduce the .git repository clutter, while maintaining the fine-grained package hierarchy we have now.  Oh, did I mention I want to do this while simultaneously maintaining the minimal dependency requirements of our """"base"""" packages (i.e. `RecipesBase.jl` for `Plots.jl`, or `SnoopCompileCore.jl` for `SnoopCompile.jl`).\n\nIdeally, this feature should provide the facilities necessary to make package development, registration, and testing relatively easy.\n\n### Multiple packages per repository\nTo avoid repo-clutter, a Julia repository should be able to store multiple (typically related) packages:\n\n```\nPkgRepo\n├── somepkgdir\n│   ├── PkgA\n│   │   └── Project.toml\n│   ├── PkgB\n│   │   └── Project.toml\n│   └── PkgC\n│       └── Project.toml\n├── RepoManifest.toml\n└── RepoProject.toml\n```\n\n### Locating packages\n\nUnless we intend on freely moving packages across .git repositories, UUIDs only really need to be assigned to the repositories themselves.  The same goes for the repository version number:\n\n```\nRepoProject.toml\n\nname = """"PkgRepo""""\nuuid = """"aa65fe97-06da-5843-b5b1-d5d13cad87d2""""\nversion = """"1.7.1""""\n\n[packages]\nPkgA = """"somepkgdir/PkgA""""\nPkgB = """"somepkgdir/PkgB""""\nPkgC = """"somepkgdir/PkgC""""\n```\nNote that we can place packages anywhere (`somepkgdir`) to accommodate multi-use repositories (not only pure-julia repos).  See mention of """"Arrow repository"""" in https://github.com/JuliaLang/Pkg.jl/issues/1874#issuecomment-649352313.\n\nAs mentioned above, individual packages don't need a UUID - only the repo.  The (full) UUID of a package, say `PkgA` is therefore:\n```\n{PkgRepo_UUID}!PkgA #Or something similar\n```\n\nSo, using this system, your code can import packages from multi-package repo with the following:\n```\nimport PkgRepo!PkgA\n```\n\nNote: I decided to introduce `!` because (`:`, `.`) are already used in import statements, and `@` is a bit confusing (`PkgRepo@PkgA` or `PkgA@PkgRepo`??)\n\n### Registration at the repository level\n\nTo simplify the registration process ***for developers*** (but not necessarily developers of `Pkg.jl`, `Registrator.jl`, ...), only package ***repositories*** should be registered directly.\n\nWhen a new version is registered with JuliaRegistrator, `PkgRepo.RepoProject.toml` is parsed, then all packages in that repo get registered simultaneously.  I guess this will be somewhat taxing on the dependency tree parser because it will have to be run once for each project in that repository.\n\n***The advantage*** of registering julia package repositories instead of individual packages is that developers can more easily add/remove packages as they split up/combine their solution.  No need to re-register each individual package, and no need to worry about potential naming collisions because packages are imported through the repository name (`PkgRepo!PkgA`).\n\n***The limitation*** in this scheme is that versioning is done at the repository level, not the package level (which is kindof what we had at the beginning anyways). I think this is great! It will be much simpler for developers to function with this mindset anyways!\n\n### Package development\n\nTo keep things simple, I think it is best we triggered the `dev` command at the repository level, and not the package level:\n\nThis is the most natural solution because really, as soon as you clone the repository, you are able to make changes to all packages anyhow. It is also very natural because when you add a feature to your package collection, chances are you will need to add code across multiple, interdependent packages.  Let's also not forget that the point of this feature request is so we can collect ***related*** packages together in a single repository.\n\n### Unit testing\n\nAgain, I think the best idea is to keep unit testing at the repository level.  Of course, from the point of view of the developer, testing can be broken down into individual packages.  That's quite fine and logical.  Nonetheless, CI testing gets triggered when we push our changes to Github.  Moreover, a single commit in `PkgRepo!PkgA` might require `PkgRepo!PkgB` to be re-tested if it depends on `PkgRepo!PkgA`.  It therefore makes sense that CI be configured to perform package testing for the entire repo irrespective of the changes being made.\n\n","[KristofferC]: > Unless we intend on freely moving packages across .git repositories, UUIDs only really need to be assigned to the repositories themselves.\n\nDisagree with this. Each package should have a unique UUID. Moving packages between .git repositories should be possible. This is assuming we are talking about actual packages and not """"individually loadable submodules"""".\n\nOn the surface, this looks pretty similar to my proposal in https://github.com/JuliaLang/Pkg.jl/issues/1874#issuecomment-649418577. For example, the proposal here suggests a new way of importing packages `import PkgRepo!PkgA` while my suggestion used `import PkgRepo@PkgA`.\n\nHowever, this proposal suggests a bunch of additions to the project file which is not needed with my proposal which could be done with no changes to Pkg and small changes to the code loading in Julia. What is the advantage here over the one I posted? | [ma-laforge]: > Disagree with this. Each package should have a unique UUID. Moving packages between .git repositories must be possible. This is assuming we are talking about actual packages and not """"individually loadable submodules"""".\n\nUnique UUID: Not sure this is true - and also, I have to take back what I said as well. You could still move your package between .git repositories.  If we import modules with the `PkgRepo!PkgA` model, movement between packages ***is*** still possible.\n\nWhat changes is that the calling program would have to change from: `import OriginalPkgRepo!PkgA` to `import NewPkgRepo!PkgA` when it decides it requires to upgrade to the new version of `PkgA`. Of course, it would also have to add `NewPkgRepo` (and its UUID) to its `Project.toml` file when it chooses to do so.  I don't think this is an unreasonable thing to do.\n\n> On the surface, this looks pretty similar to my proposal in [#1874 (comment)](https://github.com/JuliaLang/Pkg.jl/issues/1874#issuecomment-649418577). For example, the proposal here suggests a new way of importing packages `import PkgRepo!PkgA` while my suggestion used `import PkgRepo@PkgA`.\n\nIndeed. I very much liked that part of your proposal.  I hope you don't feel like misappropriated your idea.  But as I implied, I find `import PkgRepo@PkgA` to be a bit confusing because it sort of sounds like you want to use package `PkgRepo` which is located """"at"""" repository `PkgA`, instead of the inverse.\n\n> However, this proposal suggests a bunch of additions to the project file which is not needed with my proposal which could be done with no changes to Pkg and small changes to the code loading in Julia. What is the advantage here over the one I posted?\n\n  1. Developers don't need to add """"version"""" fields to their `Project.toml` files and try to ensure they all match within that repository.\n  1. and developers don't need to run special registration functions that will ensure all package version numbers match, to avoid doing this completely manually.\n  1. `dev PkgRepo` always affects all packages simultaneously, and there is no possibility that individual packages in that repository get out of sync from the rest.  I think that is much easier way for developers to think.\n  1. The barrier to adding/removing projects from a repository as your multi-package solution evolves is severely lowered because the registration tool can infer the list of supported projects from the RepoProject.toml file.\n  1. The risk of naming collision is lowered significantly because project names are always prefixed with the repository name.  In other words both SnoopCompile.jl and Plots.jl could supply their own """"Core"""" Package: `import SnoopCompile@Core`, `import Plots@Core`. This is not true in the current scheme, because packages are currently only registered in a global fashion (not relative to the parent repository). | [KristofferC]: 1-5 are all true for my proposal as well though? | [ma-laforge]: Well if so, I'm all for it!\n\nThe impression I got when I read your proposal was that these things were not possible.  If I am mistaken, then I am sorry.\n\nI would be very happy to use your solution if it does this.\n\n### Add/remove projects\nI am curious though: how can you easily add/remove projects from a repository with your solution?\n\nI get the impression you have to register each one manually with JuliaRegistries to have this happen.  Also, from my understanding, once something is registered, it can't be un-registered.  I'm ok with that for registering package repositories, but I am less fond of this when it comes to individual projects of those repositories.\n\n### Lowered risk of naming collisions\nI also don't quite get how you can release """"Core"""" packages for two different repositories (ex: `SnoopCompile@Core`, `Plots@Core`) if packages are registered in a global fashion.  I must not have understood your proposal, then.\n",4,false,0,0,0,0,0,0,0,0,0
1921,Support for non-tarball dependencies in Pkg.Artifacts,open,racinmat,,artifacts,,7,2020-07-10T14:25:15.0,2020-07-13T19:37:24.0,1836,1832,https://github.com/JuliaLang/Pkg.jl/issues/1921,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1921,"I think it would be great if there would be support for non-tarball dependencies, sometimes I need a single file (non-tarball) as a dependency and it's sometimes not even available in the tarball version.\nAre there some plans for this?","[StefanKarpinski]: I presume you're talking about artifacts. An artifact, by definition is a source tree, addressed by its content hash. So no, since a file is not a tree. However, you do not need to download an artifact as a tarball, any way of acquiring the right tree will do. Therefore, you could have some code that downloads a file and put that into a folder and call that folder the artifact. The only thing that's needed is a way to hook into the artifact acquisition system. Any thoughts on allowing packages to hook other ways of accessing artifacts into the system, @staticfloat? | [racinmat]: Yes, my bad, I talk about artifacts. | [staticfloat]: The only reason Pkg can't do this is because all our tooling is based around tarballs.  If you want to support other filetypes, we can add those smarts into Pkg, but even if it's not there, you can still call code at runtime that downloads and extracts zip files or dmgs or whatever else you want, inside of a `create_artifact()` call and you'll get an artifact on-disk.  You just can't use things like `@artifact_str()` to automatically download them because Pkg only knows how to deal with tarballs. | [racinmat]: I see, thanks for answer.\nJust to be sure, will the artifacts in `Artifacts.toml` downloaded through the package server, or does the client directly reach to the urls in `Artifacts.toml`?\nWhen artifacts would not be listed in `Artifacts.toml`, I don't see much advantage of using `create_artifact()`. | [staticfloat]: The Pkg client first reaches out to a PkgServer to see if it has anything with the same treehash as what is in your Artifacts.toml file.  If your artifacts don't exist on any of the storage servers, it will return a 404, and then your client will reach out and try and download it directly.\n\nI don't think we're going to have Pkg servers ever deal in anything but tarballs, because we have invested too much into tarballs as a convenient way to move data around. | [staticfloat]: I think it would be worthwhile to create better tooling to help package authors import data into tarballs though; if you have suggestions on how to make that easier, feel free to let us know. | [racinmat]: It's ok, so far I needed just some file from repo so I solved it by downloading whole repo as a tarball in Artifacts and using only the single file I need, but it's good information since I haven't found it stated explicitly in the docs that it must be tarball.",7,false,0,0,0,0,0,0,0,0,0
1464,artifact string macro in the REPL,open,KristofferC,,artifacts,,1,2019-10-22T12:54:58.0,2020-07-07T09:46:54.0,2098,1839,https://github.com/JuliaLang/Pkg.jl/issues/1464,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1464,"This feels like it should just work:\n\n```\njulia> artifact""""clang""""\nERROR: Cannot locate '(Julia)Artifacts.toml' file when attempting to use artifact 'clang' in 'Main'\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Artifacts.jl:909\n\njulia> isfile(""""Artifacts.toml"""")\ntrue\n```","[racinmat]: Confirming, still happening, in Pkg UUID `44cfe95a-1eb2-52ea-b672-e2afdf69b78f`. \n```julia\njulia> using Pkg\njulia> Pkg.activate(""""."""")\n Activating environment at `C:\Projects\something\some_new_env\Project.toml`\njulia> using Pkg.Artifacts\njulia> artifact""""tzdata_1996l""""\nERROR: LoadError: Cannot locate '(Julia)Artifacts.toml' file when attempting to use artifact 'tzdata_1996l' in 'Main'\nStacktrace:\n [1] error(::String) at .\error.jl:33\n [2] @artifact_str(::LineNumberNode, ::Module, ::Any) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\Pkg\src\Artifacts.jl:1041\n [3] eval(::Module, ::Any) at .\boot.jl:331\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.4\REPL\src\REPL.jl:86\n [5] run_backend(::REPL.REPLBackend) at C:\Users\racinsky\.julia\packages\Revise\kqqw8\src\Revise.jl:1163\n [6] top-level scope at none:0\nin expression starting at REPL[5]:1\nshell> cat Artifacts.toml\n[tzdata_1996l]\ngit-tree-sha1 = """"835e88b3b0a560e79dfc0a2a6c350adeaa4ef907""""\nlazy = true\n    [[tzdata_1996l.download]]\n    sha256 = """"623a48745864731e7ecb4d97d9174b3e0e856a1c25d79cd5fb64942cf282d3e1""""\n    url = """"https://data.iana.org/time-zones/releases/tzdata1996l.tar.gz""""\njulia> isfile(artifacts_toml)\ntrue\n```",1,false,5,5,0,0,0,0,0,0,0
1859,Feature request: start recording SHA-256 tree hashes in registries,open,DilumAluthge,,,,2,2020-06-10T04:14:10.0,2020-06-30T01:09:50.0,1866,1846,https://github.com/JuliaLang/Pkg.jl/issues/1859,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1859,"Currently in registries we store the SHA-1 hash of the tree of each registered version (`git-tree-sha1`).\n\nSince SHA-1 is not super secure anymore, and since Git is planning to move to SHA-256, I think we should start also storing the SHA-256 hash of tree of each registered version. Presumably we will call it `git-tree-sha256`.\n\n---\n\nI'm not sure where this issue should go. Candidates include:\n- General registry\n- Pkg.jl\n- Registrator.jl\n- RegistryTools.jl\n- some other place?\n\nFeel free to move this issue to a different repo","[StefanKarpinski]: Two steps here:\n\n1. Update the tooling to start saving git-tree-sha256 as well as git-tree-sha1 when registering new versions.\n2. Write a script to run through all the versions in the registry, get a tarball for each one and compute the git-tree-sha256 hash of the tarball and add it to the registry data.\n\nIt should be helpful that Tar.jl can compute the git-tree-256 hash of any tarball, e.g.:\n```jl\njulia> import Tar\n\njulia> Tar.tree_hash(`bzcat /Users/stefan/tmp/General.tar.bz2`)\n""""e387f456eb982cf13aed1a214df2a8b8434302c4""""\n\njulia> Tar.tree_hash(`bzcat /Users/stefan/tmp/General.tar.bz2`, algorithm=""""git-sha256"""")\n""""87a284f324fc6df4778b81de03bdc303d59587b4b1c839d586cf49a80bb3eec3""""\n```\nI'm not even sure how to coax git into doing that yet, so we're definitely getting the jump on this.\n\n@staticfloat, since the storage servers already have all the tarballs in question, what's the best way to leverage that? Hit them directly to serve said tarballs, thereby avoiding trashing the LRU cache on the package servers? Or run a script directly on one of those machines?\n | [StefanKarpinski]: Regarding location of issue, I think we can coordinate from here and open specific issues on various other repos about specific changes. E.g. RegistryTools seems like the right place for step 1 while General is where the PR resulting from doing step 2 will have to go. They can link back here to make it easier to keep track of what's going on.",2,false,1,1,0,0,0,0,0,0,0
1704,Paths to library directories in Overrides.toml,open,vchuravy,,,,6,2020-02-26T22:23:35.0,2020-06-29T07:39:34.0,1970,1847,https://github.com/JuliaLang/Pkg.jl/issues/1704,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1704,"@staticfloat I have been working with `Overrides.toml` the last few days and I have encountered several minor nuisances, related to\nlibraries.\n\n1. Overriding dependencies of stdlibs. E.g. I want OpenBLAS_jll to pickup the Julia OpenBLAS that I built instead of trying to load the artifact. Those libraries are in `$prefix/lib/julia`\n2. Overriding `CompilerSupportLibraries_jll` I wanted to point it at `${gcc-prefix}/usr/lib64`\n\nThis of course is due to my wonderful live on RHEL 7.6\n\n```\njulia> using CompilerSupportLibraries_jll\nERROR: InitError: could not load library """"/home/vchuravy/.julia/artifacts/59ca0cd093f9b05d3c6365c1147e7d908fa6954a/lib/libstdc++.so""""\n/lib64/ld64.so.2: version `GLIBC_2.22' not found (required by /home/vchuravy/.julia/artifacts/59ca0cd093f9b05d3c6365c1147e7d908fa6954a/lib/libstdc++.so)\n``` \n\n\n\n","[StefanKarpinski]: cc @staticfloat | [KristofferC]: Could you give a bit more details about what you tried and what the actual problems were? So far, it isn't (at least to me) clear what is going wrong and what would be more convenient. | [vchuravy]: As an example the `Overrides.toml` I have is:\n\n```\n[bea87d4a-7f5b-5778-9afe-8cc45184846c]\nSuiteSparse = """"/home/software/julia/1.3.0/local/share/julia""""\n\n[efe28fd5-8261-553b-a9e1-b2916fc3738e]\nOpenSpecFun = """"/home/software/julia/1.3.0/local/share/julia""""\n\n[4536629a-c528-5b80-bd46-f80d51c5b363]\nOpenBLAS = """"/home/software/julia/1.3.0/local/share/julia""""\n```\n\nJulia vendors the libraries it ships with so they go into `/home/software/julia/1.3.0/usr/lib/julia`. The reason why I am pointing to `/home/software/julia/1.3.0/local/share/julia` is because I created a softlink from `/home/software/julia/1.3.0/local/share/julia/lib` to `/home/software/julia/1.3.0/usr/lib/julia`.\n\nWhat I would have wanted to say is:\n```\n[4536629a-c528-5b80-bd46-f80d51c5b363]\nOpenBLAS.libdir = """"/home/software/julia/1.3.0/usr/lib/julia""""\n```\n\nSimilarly with CompilerSupportLibraries_jll I wanted to point it at the lib suffix there is `lib64` and not `lib` so I need to create yet another softlink instead of just specifing the path to look in directly. | [KristofferC]: My guess is https://github.com/JuliaLang/julia/issues/33973 might help with some of that,. | [vchuravy]: Yes and no. My problem indirectly is that BB requires a glibc that is newer than what ever RedHat 7.6 is shipping with. I am working on remedying this separately. But it won't change the fact that library directories for Overrides.toml will have different suffixes than just `lib`, `lib64` is rather common. | [barche]: Same problem trying to override Qt_jll on Fedora, only workaround I could find was to make a symlink.",6,false,0,0,0,0,0,0,0,0,0
973,Add post-add hook?,open,tkf,,feature,,0,2018-12-23T02:10:24.0,2020-06-24T14:05:00.0,2401,1852,https://github.com/JuliaLang/Pkg.jl/issues/973,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/973,"It would be nice to have a mechanism (say, `Pkg.afteradd(function)`) to register callbacks to be executed after `Pkg.add` completes (like `Base.atexit` and `Base.atreplinit`).  A primary usage I have in mind is something like\n\n```julia\nusing Pkg\nPkg.afteradd(Pkg.precompile)\n```\n\nin `~/.julia/config/startup.jl`.  This can be used to ease the pain in precompilation (e.g., https://github.com/JuliaLang/julia/issues/30487).\n\nAlthough it can be done by a simple customizable boolean flag, I'd suggest to keep it as a generic hook mechanism.  For example, some users may not want to block the REPL while waiting for precompilation of the packages that are not required immediately.  If it is a generic hook mechanism, you can have a quick implementation to run precompilation in background:\n\n```julia\nPkg.afteradd() do\n    code = """"""""""""\n    $(Base.load_path_setup_code())\n    using Pkg\n    Pkg.precompile()\n    """"""""""""\n    run(`$(Base.julia_cmd()) --startup-file=no -e $code`; wait=false)\nend\n```\n\nOf course, this then becomes a bit hairy when you start considering resource locking and error report.  It can be a little project in itself.  So, generic hook mechanism seems to be useful.\n\nAnother useful thing you can do in `Pkg.afteradd` is to backup Manifest.toml by copying it somewhere.\n",,0,false,3,3,0,0,0,0,0,0,0
1856,curation & trust (registries are not the answer),open,StefanKarpinski,,,,39,2020-06-09T13:35:51.0,2020-06-10T07:55:58.0,1867,1866,https://github.com/JuliaLang/Pkg.jl/issues/1856,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1856,"This is a slightly unusual issue because I'm going to post an edited for readability rant from Slack.\n\n---\n\nEveryone keeps assuming that a more curated registry is the right way to have a curated subset of packages. But I’ve said many times that’s wrong and that’s not what registries are for. I get why everyone thinks of registries for curation: registries include sets of packages and we want a curated set of packages, so seems like a great fit, right? Despite that, it’s entirely the wrong tool. The fundamental issue is that registries are about knowledge whereas curation is about trust. It’s fine to know about all public packages whether they're trustworthy or not. It’s a different thing to trust all of them and assume that it’s ok to install or use them.\n\nMoreover, Julia Computing has already tried using a registry as a trusted subset of the public registry with the JuliaPro registry, so we have very real world experience with this and I can definitively say that it’s not a good approach, which I'll demonstrate by walking through a typical user experience with that approach.\n\nSuppose someone using a curated registry is trying to follow an online tutorial, like people do. What’s their experience? They try installing `ExperimentalPackage` and what happens? Pkg says “I have no idea what that is.” They mess around for a while, wondering what’s wrong, trying it again, checking if they spelled it incorrectly. Eventually, if they're lucky, they may figure out: “oh, it’s not in the Curated registry, I guess I have to install the General registry—that’s annoying, why didn’t I have that installed in the first place?” So they install the General registry, follow along with the tutorial and move on with their lives. But... they’ve lost all protection they ever had against installing or using uncurated packages, forever. The user starts out confused and frustrated, becomes annoyed, and then ends up blithely unprotected. In short, it's an unmitigated user experience and security disaster.\n\nNow suppose instead that the user has the normal General registry installed, so Pkg knows about `ExperimentalPackage`—knows what it is, how to install it, etc. But it also knows something else: there's a layer of metadata about what packages are in a “curated” set and there's a policy in place that Pkg knows about that any package in the “curated” set can be installed without approval but any other package requires an explicit approval via a prompt. Then the above experience is quite different: the person tries to follow along with the tutorial and gets a prompt saying\n\n> `ExperimentalPackage` (<https://github.com/SomeUser/ExperimentalPackage.jl>) is not pre-approved and may not be safe to use. Do you want to install it anyway?\n> * [x] No, I don't trust this package, do not install it.\n> * [ ] Yes, install this version of this package one time.\n> * [ ] Trust and install this package now and in the future.\n\nThat way they immediately know what the problem is and they can take a look for themselves. Let’s say they look the package over and decide that it’s not dangerous and that all its dependencies are common, already-curated or trusted packages so they install it and finish the tutorial. Yay. The users was never confused or frustrated.\n\nBetter still, the next time they try to install a different uncurated package they are still protected because, unlike in the scenario where we use registries for curation and they install all of General just to get one package, in this scenario, approving the installation of a single uncurated package doesn’t eliminate all protections. The next time they try to install a different uncurated package, they are still protected.\n\n\nThe ultimate point is that registries are about knowledge: if a package is registered, you know what it is. Knowledge is safe—the more things you know about, the better. So the idea of a curated registry if like an ostrich sticking its head in the sand: “if I don’t know about all these bad packages, then I’ll be safe.” But of course, that's not the way things work. If things are potentially dangerous, you're safer knowing about them than not knowing about them. It’s way better to know about all the public packages, good or bad, and have a mechanism for deciding which ones to trust. Yes, we don’t _currently_ have a mechanism for that, but that does not mean that we should shove the functionality into the registry mechanism just because that mechanism already exists. We should, instead, build a layer for managing trust.\n\n---\n\nSo this is the issue I'm opening for discussing that trust layer. But first, I had to post a bunch of text dispelling the apparently irresistible notion that we should use registries for this.","[StefanKarpinski]: The pieces that are needed...\n\n* A metadata layer: a way of associating information with packages and versions of packages. This could be binary like """"curated"""" or not. But it could also be more complex stuff like who has contributed code to this package; various parties assigning a trust level to code based on a review.\n\n* A policy system: a mechanism for determining for a given package version, based on information provided by the metadata layer, whether you should trust a version of not. There are three possibilities: trust, ask, deny. Trust means """"just trust this, no questions asked"""". Ask means """"someone needs to be prompted for approval to use this"""". Deny means: """"you cannot use this, it's already been decided.""""\n\nAnother way to look at this is that the metadata layer is what's shared among everyone—we all get the same information about what is and isn't curated and who committed to what things. But each person has to make a decision for themselves about what to trust or not based on that information. | [DilumAluthge]: cc: @sbromberger | [StefanKarpinski]: Also, note that even though registries have the capacity to hold metadata, I anticipate that the next argument I'll end up having to make is that the trust metadata should probably not go into the registry even though it could. Why? Because the source of trust metadata need not be the same as the source of the registry. Different third parties can provide trust metadata about the same registry or registries. There could be an official """"curated packages"""" metadata layer, but someone else may disagree with that data set and offer their own, alternative curation. A potential policy could be to combine these and only trust packages that are on both curated sets, or in either one. Some trust metadata may not be public. In short: let's not jump to the conclusion that because registries hold some metadata that they should hold this metadata too. Trust metadata should be external. Fortunately, UUIDs and tree hashes offer a perfect mechanism for providing metadata externally in an unambiguous way. | [StefanKarpinski]: Just to clarify, @sbromberger, this is not a policy issue, it is intended to be a technical issue to discuss how to design and implement a trust layer in Pkg. In that light your post seems to be largely off topic and probably better suited for the ongoing discussion already on discourse. | [StefanKarpinski]: The next concrete steps I'd like to take here are:\n\n1. Figure out a format for trust metadata source (external to a registry).\n2. Figure out a mechanism for defining policies based on that metadata. | [PetrKryslUCSD]: But just the fact that the package *is* registered is a certain sign of quality, isn't it? | [StefanKarpinski]: @PetrKryslUCSD, I’m not sure what that’s meant to address. Is it relevant to constructing a trust metadata system? | [DilumAluthge]: > Just to clarify, @sbromberger, this is not a policy issue, it is intended to be a technical issue to discuss how to design and implement a trust layer in Pkg. In that light your post seems to be largely off topic and probably better suited for the ongoing discussion already on discourse.\n\n@StefanKarpinski If you intend for this issue to be a technical discussion (not a policy discussion), would it be possible for you to copy the contents of @sbromberger's comment to https://github.com/JuliaRegistries/General/pull/16058, which provides a concrete implementation of some policy changes? (I would do it myself, but I am now unable to view that comment.) | [DilumAluthge]: > But just the fact that the package _is_ registered is a certain sign of quality, isn't it?\n\nThe fact that a package is registered should in no way imply anything about that package's quality. | [PetrKryslUCSD]: That is certainly not true. I have had package registrations held up or\nrejected because they did not comply with some rules about documentation or\ndependencies. Passing tests is also checked.\n\nOn Tue, Jun 9, 2020, 12:23 PM Dilum Aluthge <notifications@github.com>\nwrote:\n\n> But just the fact that the package *is* registered is a certain sign of\n> quality, isn't it?\n>\n> The fact that a package is registered should in no way imply anything\n> about that package's quality.\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://urldefense.com/v3/__https://github.com/JuliaLang/Pkg.jl/issues/1856*issuecomment-641521298__;Iw!!Mih3wA!RGEONvOEuZ1K1ynYOkbaLHO0WDuZgLXy6xDqszONHBwS97a-m_7qy7Ok8KBs--Y$>,\n> or unsubscribe\n> <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWCBAXHEE7WURVKYDQDRV2D47ANCNFSM4NZNHLFQ__;!!Mih3wA!RGEONvOEuZ1K1ynYOkbaLHO0WDuZgLXy6xDqszONHBwS97a-m_7qy7Okj3eicEo$>\n> .\n>\n | [DilumAluthge]: > That is certainly not true. I have had package registrations held up or rejected because they did not comply with some rules about documentation or dependencies. Passing tests is also checked.\n\nCurrently we have no official policy. Which means that different registry maintainers apply different standards, leading to inconsistent treatment of packages.\n\nAs Stefan pointed out, this discussion is off-topic for this issue. Let us move this discussion to https://github.com/JuliaRegistries/General/pull/16058#issuecomment-641527127 | [StefanKarpinski]: Ok, so here's one possibility. The metadata files live in `$depot/metadata/$uuid.toml` where `uuid` is the UUID of a package and has a format like this:\n```toml\ncurated = true\n\n[1.0-1.3]\ntrust-level = 0.3\n\n[1.3-1.7]\nreviewed = true\ntrust-level = 0.9\n```\nThe top-level keys apply to any version of the package, the other key-value pairs apply if the header range matches, using the same compression scheme as the registry.\n\nA policy is fundamentally a function that takes a collection of this kind of metadata and computes an allow/ask/deny value. I.e. it's a function where the input is a `Dict{UUID, Dict{String, Any}}` where the UUID is the metadata source UUID; the output is one of `:allow`, `:ask` or `:deny`.\n\nIf we're considering installing a version of a package, we look up its metadata across the depot path (merging dicts as we go), then pass that dict-of-dicts to the policy function and if the result is `:allow` we install it without any further ado; if the result is `:deny` we refuse to install it with an error; if there are one or more package versions to be installed for which the policy function returns `:ask`, then we prompt the user about them, all at once, giving links to them and enough information for them to make an informed decision. For each one, they may be asked to decide between not installing, installing this one version for now, and remembering this package and trusting it. If we mark a package as trusted then the policy determination will be skipped in the future for that package and it will just be installed without prompting.\n\nAn alternative approach for the policy part would be to allow the policy function to see the package's UUID and the version info and the metadata and allow the policy function to see the whitelist of trusted packages and make some kind of nuanced decision about whether to continue to trust it or not. | [sbromberger]: what is `trust-level`, and how do we reduce trust to a single metric? | [StefanKarpinski]: It's made up. I'm just throwing some arbitrary key-value pairs in there. It's up to the curator of the metadata source what they put in there and up to the policy author (who may be the same person) what they do with it. This is just the bare bone mechanism for building these things. | [StefanKarpinski]: I'm generally against using code for configuration, but for trust policies, I can't think of any good reason why it shouldn't be just Julia code. The main reason would be if you want to put a UI on it for generating policies, but I'm not sure how necessary that would be. | [tkf]: Is `$depot/metadata/$uuid.toml` created (potentially) by a third-party?  If so, isn't it a bit too flexible?\n\nFor example, why not set the trust level for each release?  Version range doesn't seem to be """"static"""" enough.  A package may release a backport with a patch version bump after the trust metadata is created.\n\nAlso, since UUID is open and it might be possible to disguise as another package if you have a different set of registries than whoever compiled the metadata, wouldn't it be better to use the tree sha?  It'd be better to have a format that allows us to upgrade to a stronger hash (e.g. after Git moved to SHA‑256).\n | [sbromberger]: I just had a great conversation with @DilumAluthge about a problem I've been noodling on for a while, and it makes sense to bring it up here, I think. (If not, please mark as OT.)\n\nWhatever trust mechanism we use for curation needs to curate the registry BEFORE the registry content is downloaded. This will help prevent users from downloading metadata or other content that may be illegal in their country or environment. I can go into details elsewhere. | [StefanKarpinski]: > Is `$depot/metadata/$uuid.toml` created (potentially) by a third-party? If so, isn't it a bit too flexible?\n\nHow so? You have to install a metadata source yourself.\n\n> For example, why not set the trust level for each release? Version range doesn't seem to be """"static"""" enough. A package may release a backport with a patch version bump after the trust metadata is created.\n\nWe could also use individual trees as keys, but then the default is that when a new release comes out it has no trust metadata except that which is associated with the package as a whole. But perhaps that would be good.\n\n> Also, since UUID is open and it might be possible to disguise as another package if you have a different set of registries than whoever compiled the metadata, wouldn't it be better to use the tree sha? It'd be better to have a format that allows us to upgrade to a stronger hash (e.g. after Git moved to SHA‑256).\n\nI'm unclear about what the attack model here is. | [StefanKarpinski]: > I just had a great conversation with @DilumAluthge about a problem I've been noodling on for a while, and it makes sense to bring it up here, I think. (If not, please mark as OT.)\n> \n> Whatever trust mechanism we use for curation needs to curate the registry BEFORE the registry content is downloaded. This will help prevent users from downloading metadata or other content that may be illegal in their country or environment. I can go into details elsewhere.\n\nI do think this is both off topic and logically impossible. A client side mechanism cannot filter the registry without downloading it. If the registry must be filtered before reaching the client, that must be done on the server side. | [tkf]: > > Also, since UUID is open and it might be possible to disguise as another package if you have a different set of registries than whoever compiled the metadata, wouldn't it be better to use the tree sha? It'd be better to have a format that allows us to upgrade to a stronger hash (e.g. after Git moved to SHA‑256).\n> \n> I'm unclear about what the attack model here is.\n\nIs this scenario possible?:\n\n* Registry1 has PkgA with UUID_A\n* Registry2 does not have PkgA\n* A metadata provider trusts PkgA in Registry1 and publish it (suppose that this metadata provider covers multiple registries, say General and Registry1)\n* A user has Registry2 (and General) and install the metadata\n* An attacker copied UUID_A and register PkgA with UUID_A in Registry2 but with completely different content\n\nNow the user installs PkgA from Registry2 with malicious content even though the metadata provider says it's safe.\n | [DilumAluthge]: I imagine that we would be certifying trust in tuples of the form `(uuid, tree_hash)`. You wouldn't blindly trust all versions of a package. You would trust one or more specific versions of a package. | [tkf]: Yeah, that's my thought, too.\n\nBut, if we want to have a way to (mildly?) trust future releases, my guess is that the only way to do this is to have a way to trust the authors and provide a mechanism to sign/verify each release.  I guess this should also be outside the registry mechanism and maybe somehow integrated in the metadata framework.\n | [StefanKarpinski]: Ok, that attack does make sense. Having metadata apply to each tree hash makes sense. We can include a SHA256 hash of the same tree as well since SHA1 is broken. We should probably add that info to registries as well. The compression scheme doesn’t really make sense in that case. Another option is to scope metadata attestations to registries and then only apply claims to those registries. That implicitly assumes that the registry is fairly safe. | [DilumAluthge]: > Ok, that attack does make sense. Having metadata apply to each tree hash makes sense. We can include a SHA256 hash of the same tree as well since SHA1 is broken. We should probably add that info to registries as well. The compression scheme doesn’t really make sense in that case. Another option is to scope metadata attestations to registries and then only apply claims to those registries. That implicitly assumes that the registry is fairly safe.\n\nPersonally, I prefer the approach of storing `(uuid, tree_sha1, tree_sha256)`. It just seems safer to me. | [DilumAluthge]: Also, if we have trust info for Foo 1.0.0, we can use that in any registry. So the trust info is more portable and thus more useful. | [tkf]: @StefanKarpinski  Without thinking very long about this, I think decoupling the metadata layer and registry as much as possible would be a good guideline.  At least that's how I digested the design philosophy you laid out in the OP.  Exchanging only UUID and tree hash(es) between the metadata layer and the registry sounds like a good idea.  I think avoiding trust being a function of the registry helps this, too.  Also, it'd be nice to trust immutable data identified by the hash (which is the source of the portability @DilumAluthge mentioned) rather than a mutable data store like the registry.\n | [c42f]: Coincidentally, trust and code review (perhaps via crev) is also being discussed on the JuliaHub issue tracker https://github.com/JuliaComputing/JuliaHub/issues/2#issuecomment-641278038 | [non-Jedi]: > We can include a SHA256 hash of the same tree as well since SHA1 is broken. We should probably add that info to registries as well.\n\nTo keep options open for deeper integration with Crev in the future, it would be nice if this could instead be BLAKE2 following the algorithm described here: https://github.com/crev-dev/recursive-digest#algorithm. I realize that either adding a dependency on a library that implements BLAKE2 or writing a Julia implementation just for this purpose may be a nonstarter though. | [DilumAluthge]: > > We can include a SHA256 hash of the same tree as well since SHA1 is broken. We should probably add that info to registries as well.\n> \n> To keep options open for deeper integration with Crev in the future, it would be nice if this could instead be BLAKE2 following the algorithm described here: https://github.com/crev-dev/recursive-digest#algorithm.\n\nI would be fine with storing the following:\n1. UUID of the package\n2. Tree SHA-1 hash - since that's what Git currently uses)\n3. Tree SHA-256 hash - because that is planned to be the successor to SHA-1 ([source 1](https://github.blog/2018-09-10-highlights-from-git-2-19/), [source 2](https://github.com/git/git/commit/0ed8d8da374f648764758f13038ca93af87ab800), [source 3](https://github.com/git/git/blob/master/Documentation/technical/hash-function-transition.txt))\n4. Tree BLAKE2 hash in the format required for compatibility with `crev` - this is because I think `crev` is our best option as far as getting some kind of whole-code review system into the Julia ecosystem.\n\nBut I think we should draw the line at those four. Certainly we can't store every hash in the world. I think those four pieces of information (UUID plus three tree hashes) are sufficient. | [DilumAluthge]: > Coincidentally, trust and code review (perhaps via crev) is also being discussed on the JuliaHub issue tracker [JuliaComputing/JuliaHub#2 (comment)](https://github.com/JuliaComputing/JuliaHub/issues/2#issuecomment-641278038)\n\nI've opened https://github.com/JuliaLang/Pkg.jl/issues/1858 as a meta-issue to track the integration of `crev` into Pkg. | [tkf]: > But I think we should draw the line at those four. Certainly we can't store every hash in the world.\n\nIIUC, you don't need to store BLAKE2 in registries.\n\nAlso, I think it's actually OK to specify a release of a package with UUID and package version.  This way, the registry and the metadata layer communicate via UUID-version pair.  Then the metadata layer can store completely different hash (say BLAKE2).  The metadata layer doesn't need to know about SHA1 because it is the system that ultimately verifies the package (maybe by interfacing with crev).\n\nI don't know if it's possible to hook UUID into crev's data model, though: https://github.com/JuliaComputing/JuliaHub/issues/2#issuecomment-641703944\n | [DilumAluthge]: > Also, I think it's actually OK to specify a release of a package with UUID and package version.\n\nI definitely want the trust metadata to store a tree hash for each version. | [DilumAluthge]: > I don't know if it's possible to hook UUID into crev's data model, though: [JuliaComputing/JuliaHub#2 (comment)](https://github.com/JuliaComputing/JuliaHub/issues/2#issuecomment-641703944)\n\nI like your idea of doing `https://pkg.julialang.org/package/$uuid` as the `source`. | [DilumAluthge]: The trust metadata should store a tree hash for each version it trusts.\n\nAnd registries should store a tree hash for each registered version.\n\nIf the hash function is """"secure enough"""", then this gives us a good way of linking the trust metadata to the registry.\n\nThis is why we should at least have some """"more secure"""" hash in addition to SHA-1, in both the trust metadata and the registry. | [tkf]: > > Also, I think it's actually OK to specify a release of a package with UUID and package version.\n> \n> I definitely want the trust metadata to store a tree hash for each version.\n\nYes, the metadata layer definitely must have _some_ kind of hash (maybe BLAKE2).  What I meant was that the """"key"""" to identify the release record in the registry can be the UUID-version pair.\n | [DilumAluthge]: > > > Also, I think it's actually OK to specify a release of a package with UUID and package version.\n> > \n> > \n> > I definitely want the trust metadata to store a tree hash for each version.\n> \n> Yes, the metadata layer definitely must have _some_ kind of hash (maybe BLAKE2). What I meant was that the """"key"""" to identify the release record in the registry can be the UUID-version pair.\n\nI see.\n\nI would be more comfortable saying that the """"key"""" is the tuple `(uuid, tree hash)` for a """"secure"""" hash. It just feels better to me. Plus it prevents against that attack you mentioned above.\n\nBut also, I can see this situation (two registries, same package, same version number, but different trees) happening in a non-attack situation. Someone has a private registry, registers 1.0 of their package, continues to develop package, later registers it in General, but was careless and registered it in General as 1.0. Nothing malicious here, but still, we want a trust metadata repository (which should be agnostic of registry) to work with both registries simultaneously. | [tkf]: That makes sense. Yeah, I agree tree hash is much better for identifying a release.\n | [dpc]: I don't think I fully understand all the details so I'll just state couple of things, to maybe help you figure it by yourself:\n\nCrev proofs can be arbitrarily extended. Implementations are supposed to ignore fields they don't understand. And except for `Pkg` and maybe some auxiliary aggregating tools nothing would even look into package reviews of Julia package. Each ecosystem would pretty much only care about their own subset. The trust proofs (WoT) are more valuable for sharing between communities. \n\nI'd be happy to add any fields that you might need as optional fields in the reference implementation. I was aware that I am designing everything with limited knowledge, and I hoped that when more people would start looking at it, we will crystallize the format. `uuid` seems like a generic  extension that would be easy to add. It's backward compatible anyway, and even if it wasn't, the format is still in [`version: -1`](https://github.com/dpc/crev-proofs/blob/c324d06567368b03cc89c659723b3729cf083a96/FYlr8YoYGVvDwHQxqEIs89reKKDy-oWisoO0qXXEfHE/reviews/2018-12-packages-Ua7DxQ.proof.crev#L2) and I plan to bump it to `0` when certain level of popularity is reached. Even after that, it will always be possible (though harder and laborious for everyone) to roll even newer versions if it is ever necessary.\n\nI have used `blake2` because it was fast and seemed like a raising star. Might have been unwise of me, to go with a newer, less popular algorithm. But all hope is not lost. The whole algorithm of recursive filesystem hash that crev uses is generic over the hashing algorithm. Literally the library that implements it does not include any digest algo. dependency and requires the caller to specify it. There would be little problem of adding a `digest-algorithm` field, that would default to `blake2` if missing, and supporting a set of digest functions. It's not even an additional dependency for Rust version of `crev` because I'm quite sure `dalek-ed22559` used for crypto uses sha256 internally.\n\nYou seem to be talking about the metadata and such, that I don't fully understand, but just remember that you can add any extra fields you want in the proof and other clients will just ignore them. | [dpc]: Oh, and one more thing. `crev` is very modular. You can pretty much take any piece you want and do it differently. I very explicitly avoid coupling any layer/part with any other one.\n\nOne thing like this is the proof distribution. In `cargo-crev` I've implemented a system in which users just create github repositories (example: [my """"proof repository""""](https://github.com/dpc/crev-proofs)) and Ids always advertise an url that means [""""you can possibly find more of my stuff at this url""""](https://github.com/dpc/crev-proofs/blob/c324d06567368b03cc89c659723b3729cf083a96/FYlr8YoYGVvDwHQxqEIs89reKKDy-oWisoO0qXXEfHE/reviews/2018-12-packages-Ua7DxQ.proof.crev#L7).\n\nBut it doesn't have to be this way. This system seemed like a good start because devs tend to already have github accounts etc, and git gives a decent differential sync, and also free hosting, but I don't think it will scale very well. Once users have web of trust spanning across thousands of people downloading updates might become rather slow.\n\nProofs are detached from their context, so they can be distributed in any way. They could be downloaded via bittorrrent or from central location, or sent via email. They could come in a one big tarball, can be cached and aggregated in bigger websites, and project could even include their own reviews inside the package itself and so on. The point is `crev` does not mandate how the proofs are distributed.\n\nWhen I started I didn't have any community buy-in etc. and I don't fully understand if you do, but if you could - it would probably be better if the package registry itself allowed uploading and downloading review proofs (as well as trust proofs) - it would be possibly much more efficient than having each user download repos of a thousands users periodicaly. P2p distribution via git works OK so far, but I think we will eventually hit problems of scaling it.",39,false,21,13,0,0,0,0,8,0,0
1854,Package groups,open,c42f,,,,10,2020-06-09T05:25:30.0,2020-06-10T01:38:35.0,1867,1866,https://github.com/JuliaLang/Pkg.jl/issues/1854,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1854,"A recent [discussion on discourse](https://discourse.julialang.org/t/ann-numerics-jl-the-extended-standard-library/40694/40) sparked the idea that some concept of """"curated environments"""" / """"package groups"""" might be useful. That thread introduced Numerics.jl which is a grab bag of somewhat unrelated packages which were useful to the author. As a trivial package which re-exports other packages, Numerics.jl doesn't doesn't contain any code and I think versioning it would be a bit of a nightmare! But the underlying idea makes sense if viewed as a curated environment or group of packages.\n\nIn particular, I could see it being useful for Julia beginners where they'd be able to take a standard curated environment and have all the packages relevant to their domain installed and ready to use. Perhaps as part of a base environment on top of which sub-environments could be built in the style of https://github.com/JuliaLang/Pkg.jl/issues/1233\n\nFor handling versions, it might be possible to take a strict mixin-style approach: mixing in the curated environment would add the latest versions of packages in it using the usual version resolution declared in those packages. That is, the mixin could come without any version information in its own right, but just as a convenient grouping.\n\nSeveral linux package managers have this concept as [package groups](https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux)\n\nRelated: `pkg> env` repl-mode discussion in https://github.com/JuliaLang/Pkg.jl/issues/621","[PetrKryslUCSD]: I think the environment concept is orthogonal to which packages the user actually uses once she activated the environment. See also https://discourse.julialang.org/t/ann-numerics-jl-the-extended-standard-library/40694/41 | [StefanKarpinski]: https://github.com/JuliaLang/Pkg.jl/issues/1856 | [KristofferC]: Who decides what goes into a group? For the Linux case I guess the maintainers of the distro set up these groups but for a case like General which is contributed to by users, I feel like it can easily lead to a lot of """"my favorite package bundles"""" with a bunch of close copies of groups. | [StefanKarpinski]: That’s why in my proposal metadata sources are external (everyone can have their known if they want to), and users create policies that compute an allow/ask/deny for each package version based on some function of metadata sources. | [PetrKryslUCSD]: I was simply pointing out that at present users take the presence of a\npackage in the registry to mean *something* in terms of quality. I think\nrelegating the responsibility of checking the """"quality"""" to the user, who is\nnow being asked to inspect the curation metadata, will require a certain\nchange of culture.\n\nOn Tue, Jun 9, 2020, 11:33 AM Stefan Karpinski <notifications@github.com>\nwrote:\n\n> That’s why in my proposal metadata sources are external (everyone can have\n> their known if they want to), and users create policies that compute an\n> allow/ask/deny for each package version based on some function of metadata\n> sources.\n>\n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://urldefense.com/v3/__https://github.com/JuliaLang/Pkg.jl/issues/1854*issuecomment-641495973__;Iw!!Mih3wA!Rat_9Q0SC_UU06yELsa8GpM3am53ejGuaiWW3UqR2KMQh37gIcjrcVjQPs8URws$>,\n> or unsubscribe\n> <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWBDW2OQA5QKI5OBVN3RVZ56TANCNFSM4NZBX3YA__;!!Mih3wA!Rat_9Q0SC_UU06yELsa8GpM3am53ejGuaiWW3UqR2KMQh37gIcjrcVjQzsEkkAQ$>\n> .\n>\n | [StefanKarpinski]: The user is not being asked to inspect curation metadata, that would be done automatically. | [PetrKryslUCSD]: Okay, that makes more sense now. Now, who is in control of the curation\nmetadata?\n\nOn Tue, Jun 9, 2020, 12:43 PM Stefan Karpinski <notifications@github.com>\nwrote:\n\n> The user is not being asked to inspect curation metadata, that would be\n> done automatically.\n>\n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://urldefense.com/v3/__https://github.com/JuliaLang/Pkg.jl/issues/1854*issuecomment-641530593__;Iw!!Mih3wA!UIQ1uAGgC6dL4kJ3MGX7VxpH6TrhafO4ZX2jwtGgQBedWQLXtfYaM-dwqHM_q_Y$>,\n> or unsubscribe\n> <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWH542QMA3Z6PXTQ45DRV2GG7ANCNFSM4NZBX3YA__;!!Mih3wA!UIQ1uAGgC6dL4kJ3MGX7VxpH6TrhafO4ZX2jwtGgQBedWQLXtfYaM-dwV0xEr1k$>\n> .\n>\n | [StefanKarpinski]: I don't want to seem churlish here, but have you read https://github.com/JuliaLang/Pkg.jl/issues/1856? Anyone who wants to produce curation metadata could do so an people would choose which curation metadata and trust policies they're interested in using. It would make sense to ship a simple but reasonably safe default policy with the default Julia install. | [PetrKryslUCSD]: Well, I do apologize if I missed it, but yes, I read #1856, and this was left open. Who will vet the providers of curation data? Unless one can trust the provider of this information, the whole scheme is suspect. Right now I trust Julia registry implicitly, but if I am given a choice and I have to make this decision on the fly (so to speak), doesn't the need to trust in arbitrary provider of curation data leave me open to attack? (And, yes, I realize that someone might register a malignant package right now, but the point is, if I have to trust too many sources based on limited information, I am in trouble.) | [c42f]: > Who decides what goes into a group?\n\nAnyone — a user could want their own locally named groups for convenience, or we could have a way to serve these (in which case #1856 comes into play).\n\nI don't mean to open a can of worms here regarding how one *trusts* a given curated environment and the exact mechanism by which that trust is conveyed. That seems a somewhat separate issue from whether having a group abstraction is a good thing in the first place.\n\nWith that in mind, I'll rename this issue to """"package groups"""" as one can have a local version of a group abstraction without any trust issues at all (unless you don't trust yourself :-) )",10,false,0,0,0,0,0,0,0,0,0
1849,depot where package is compiled is dependent on filesystem state.,open,Orbots,,,,7,2020-06-02T23:50:10.0,2020-06-05T18:05:38.0,1873,1870,https://github.com/JuliaLang/Pkg.jl/issues/1849,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1849,"Julia 1.3.1, Linux ( centos )\n\nI have JULIA_DEPOT_PATH set in the environment.  First is the users home, next is a central depot where the administrator adds packages for all users.  \n~/.julia:path_to_shared_central_depot\n\nIf ~/.julia does not exist, e.g. user runs julia for the first time.  It seems to silently ignore ~/.julia.  Now central depot is in the privileged first slot of the DEPOT_PATH and is read/write and will get treated as the users home directory.  All kinds of trouble there.\n\nWe want central depot to be write only, aside from admin who will initially `popfirst!(DEPOT_PATH)` before adding packages.  If the admin for some reason doesn't have ~/.julia this is also confusing as popping the only DEPOT_PATH empties the list.\n\nWould be happy if ~/.julia was created.  Isn't that the default behavior if JULIA_DEPOT_PATH is not set?  Would be less happy but also not annoyed if a warning was issued when ~/.julia doesn't exist.\n","[Orbots]: It appears to be more subtle.  We are launching julia via a wrapper script.  If I launch julia directly it seems to always create ~/.julia if it doesn't exist.  From the wrapper, nope.  Julia must be getting the information that it failed to create ~/.julia.  A warning would be best, in that case. | [StefanKarpinski]: How do you mean you're launching Julia from a wrapper? As in you're embedding it? | [Orbots]: The user launches julia via a python or bash script.  This script sets up the environment variables for a users specific role and then launches the application ( in this case Julia ).   That script doesn't have permissions to create a directory in the users home dir.   I'm guessing it won't let julia create that directory either for some reason.  \n\nSo it silently fails and promotes the shared depot to first position (read-write). | [StefanKarpinski]: It's kind of strange that the script that launches julia runs as your user but doesn't have permission to create `~/.julia`. Can you try to investigate from within that process what the situation is? What the UID and GID (effective and real) are and why the process can't make directories? | [Orbots]: The script doesn't run julia? as my user, actually I'm not totally clear on this, but running a process which alters filesystem state is prevented in some way.   We try to have these wrappers avoid changing any state other than environment variables.  There are things I can do to try to work around this limitation.  Anyways, this isn't Julia's issue.\n\nThe issue with Julia is that it silently fails finding/creating the first directory in the DEPOT_PATH, which then promotes the next depot in line to a read-write.  If I expect every depot after the first to be read only its' quite surprising when new packages or compilation artifacts end up there. | [StefanKarpinski]: If you're doing package operations, Julia needs a writable depot. Would you prefer that it just fail if the first depot doesn't exist or isn't writable? | [Orbots]: It does fail after I've set the central depot read-only.  \n\nI would prefer less surprising behaviour.  What I want to see are all the directories listed in JULIA_DEPOT_PATH present in the same order in julia's DEPOT_PATH.\n\nI just tried to do a simple example and in fact I get the behaviour I would like to see.  \n\nWhat I would like to see is:\n```\n(base) Lagerkvist:testdepots mewert$ ls\nB\tD\n(base) Lagerkvist:testdepots mewert$ env JULIA_DEPOT_PATH=./A:./B:./C:./D:./E julia\n\njulia> DEPOT_PATH\n5-element Array{String,1}:\n """"./A""""\n """"./B""""\n """"./C""""\n """"./D""""\n """"./E""""\n\nshell> ls\nA\tB\tD\n```\n \nSeems like some combination of user permissions and filesystem read/write state leads to me seeing for that example:\n\n```\njulia> DEPOT_PATH\n5-element Array{String,1}:\n""""./B""""\n""""./D""""\n```\n\nAppears there is some logic in julia that filters the JULIA_DEPOT_PATH when mapping to DEPOT_PATH.  I'd like in my case for A, C and E to be present.  \n\nYou can close this actually, the repro steps are so convoluted I think I'm probably the only one who has this problem!  \n\nI have a working system now, as I was able to put some logic in the wrapper to handle the weirdness.\n",7,false,0,0,0,0,0,0,0,0,0
1836,"Feature request: first-class support for ""namespaces"" in registries",open,DilumAluthge,,,,66,2020-05-24T05:09:33.0,2020-06-03T05:11:58.0,1883,1873,https://github.com/JuliaLang/Pkg.jl/issues/1836,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1836,"This issue is a feature request and proposal for first-class support for """"namespaces"""" in registries.\n\n---\n\nThe core idea is this: currently, you can register a package, and that package has a URL. In this proposal, you will also be able to register a namespace, and that namespace has a URL. Once a namespace has been registered, a package can be registered under that namespace if and only if the URL for the package begins with the URL for the namespace.\n\n---\n\nTo avoid confusion, let's be careful about our terminology.\n\n- Let us use the term """"organization"""" to refer to a GitHub/GitLab/Bitbucket/etc organization.\n- Let us use the term """"namespace"""" to refer to the namespaces we are creating in the Julia General registry (or any Julia registry, for that matter).\n\n---\n\nHere is a rough sketch of the workflow: \n\nSo I am envisioning something like this workflow:\n\nStep 1: I create an organization in GitHub, GitLab, BitBucket, etc. For example, suppose I create an organization at `github.com/MyFooGitHub`.\n\nStep 2: I use some process to register an namespace with the Julia General registry. For example, I make a PR to the General registry that registers a new namespace called `MyFooNamespace`. And as part of that PR, I provide the URL `https://github.com/MyFooGitHub/`. Once the PR has been merged, we have created the namespace `MyFooNamespace` in the Julia General registry. **A package can be registered in the `MyFooNamespace` namespace if and only if its URL begins with the string `https://github.com/MyFooGitHub/`.**\n\nTo go into more detail, a namespace is a """"thing"""" that is registered in the General registry and has the following properties, all of which are constants:\n- Name for that namespace.\n- UUID for that namespace.\n- URL prefix for that namespace.\n\nFor example, in my example, we might have a file in the General registry with filename `/namespaces/MyFooNameSpace/Namespace.toml` with the following contents:\n```toml\nname = """"MyFooNamespace""""\nuuid = """"00000000-0000-0000-0000-000000000000""""\nrepo_url_prefix = """"https://github.com/MyFooGitHub/""""\n```\n\nStep 3: I register packages. For example, I create a package called `CoolDilumStuff.jl`. The URL for this package is `https://github.com/MyFooGitHub/CoolDilumStuff.jl`. I choose to register this package in the `MyFooNamespace` namespace. So the """"full name"""" of my package is `MyFooNamespace/CoolDilumStuff`.\n\nWhen Registrator makes the PR to register this package, it would, for example, create a file with filename `/namespaces/MyFooNameSpace/C/CoolDilumStuff/Package.toml` with the following contents:\n```toml\nname = """"CoolDilumStuff""""\nuuid = """"11111111-1111-1111-1111-111111111111""""\nrepo = """"https://github.com/MyFooGitHub/CoolDilumStuff.jl.git""""\nnamespace_name = """"MyFooNameSpace""""\nnamespace_uuid = """"00000000-0000-0000-0000-000000000000""""\n```\n\nStep 4: I can install my package in Pkg. In the Pkg REPL mode, I would install with this:\n\n```julia\n] add MyFooNamespace/CoolDilumStuff\n```\n\nIf I want to use the Pkg API, I would install with either this:\n```julia\nimport Pkg\nPkg.add(Pkg.PackageSpec(namespace = """"MyFooNamespace"""", name = """"CoolDilumStuff""""))\n```\n\nOr, equivalently, this:\n```julia\nusing Pkg\nPkg.add(PackageSpec(namespace = """"MyFooNamespace"""", name = """"CoolDilumStuff""""))\n```\n\nStep 5: After I install my package, I can import it by simply typing either this:\n\n```julia\nimport CoolDilumStuff\n```\n\nOr this:\n\n```julia\nusing CoolDilumStuff\n```\n\n---\n\nThis issue is kind of related to https://github.com/JuliaLang/Pkg.jl/issues/1071. However, the proposal in this issue is a little different than what is proposed in https://github.com/JuliaLang/Pkg.jl/issues/1071. If I understand correctly, https://github.com/JuliaLang/Pkg.jl/issues/1071 does some automatic pattern-matching on the URL. In contrast, this issue explicitly adds full first-class support for official namespaces in registries.\n\n---\n\nThis issue is not the same as https://github.com/JuliaLang/Pkg.jl/pull/1064.","[DilumAluthge]: Now here is the important part.\n\nSuppose that somebody else creates a GitLab organization (technically GitLab calls them """"groups"""" instead of """"organizations"""") at the location `gitlab.com/MyFooGitLab`.\n\nNow this person wants to register a new namespace in the Julia General registry that corresponds to their `gitlab.com/MyFooGitLab` GitLab organization. They would like to have the `MyFooNamespace` namespace. Unfortunately, they cannot have this namespace, because it has already been registered.\n\nThis is not a bad thing. This is just the same as when someone registers a package, and then later, someone else wants to register the same package name. For example, Fredrik has an excellent package with the name `Literate`. I cannot have that name. If I want to register a package, I have to pick a different name.\n\nSame thing here. If the namespace name already exists, you must pick a different name for your namespace.\n\nSo let us return to the previous example. We have someone that has created the `gitlab.com/MyFooGitLab` GitLab organization. Now they want to create a namespace in the Julia General registry that corresponds to their `gitlab.com/MyFooGitLab` GitLab organization. They cannot have the `MyFooNamespace` namespace, because the `MyFooNamespace` namespace has already been registered.\n\nSo they have to pick a different name for their namespace. For example, they may choose to pick the name `CoolFooStuff` for their namespace. So they make a PR to register the `CoolFooStuff` namespace, with the restriction that all packages in the `CoolFooStuff` namespace must have URLs that begin with the string `https://gitlab.com/MyFooGitLab/`. | [DilumAluthge]: In the above examples, I used different names for the GitHub/GitLab organizations and the namespaces. I did this to emphasize the difference between a GitHub/GitLab organization and the namespace in the Julia General registry. They are not the same thing, and they do not need to have different names.\n\nNow, that being said, I think in the vast majority of cases, people will choose to have a namespace that is the same as (or very similar) to the name of their GitHub/GitLab/Bitbucket/etc organization.\n\nFor example, take @EricForgy's GitHub organization `github.com/JuliaFinance`. My guess is that for the namespace, he will choose to register the `JuliaFinance` namespace.\n\nIf he chooses `JuliaFinance`, then he can install his packages with `] add JuliaFinance/Positions` and load them with `import Positions` and/or `using Positions`. | [EricForgy]: This would be beautiful ❤️ Thanks for spelling it out like that and getting the conversation started @DilumAluthge 🙌 | [EricForgy]: For reference, in addition to the mentioned:\n\n- #1064: [POC] Add scoping, e.g. @MyRegistry/MyPackage\n- #1071: allow package to be disambiguated by `@user/package`\n- #1791: Allow to register a registry in a registry\n\nThere is also:\n\n- #1067: [RFC] Accommodate dependencies from other registries\n- #1072: allow registries to depend on other registries\n | [EricForgy]: I had a quick look at General and given the directory structure, it might make sense to allow one level of nesting for namespaces, e.g.\n\n![image](https://user-images.githubusercontent.com/8954730/82747726-029d5a80-9d51-11ea-93cf-b333045a6efa.png)\n\nThis seems minimally disruptive as a start. | [DilumAluthge]: I was thinking this kind of layout:\n\nNormal packages:\n- `/F/Foo/Package.toml`\n- `/B/Bar/Package.toml`\n\nNamespaced packages:\n- `/namespaces/JuliaFinance/F/Foo/Package.toml`\n- `/namespaces/JuliaFinance/B/Bar/Package.toml`\n\nAnd e.g. the information for a namespace would be here:\n- `/namespaces/JuliaFinance/Namespace.toml` | [DilumAluthge]: > For reference, in addition to the mentioned:\n> \n>     * #1064: [POC] Add scoping, e.g. @MyRegistry/MyPackage\n> \n>     * #1071: allow package to be disambiguated by `@user/package`\n> \n>     * #1791: Allow to register a registry in a registry\n> \n> \n> There is also:\n> \n>     * #1067: [RFC] Accommodate dependencies from other registries\n> \n>     * #1072: allow registries to depend on other registries\n\nTo elaborate, one of the major advantages that this proposal has over those other issues/PRs is that this proposal does not require any other registries. Everything is registered in the Julia General registry. In contrast, most or all of those other issues/PRs requires people to maintain their own Julia package registries. | [EricForgy]: > I was thinking this kind of layout:\n>\n>Normal packages:\n>\n>/F/Foo/Package.toml\n>/B/Bar/Package.toml\n>Namespacedd packages:\n>\n>namespaces/JuliaFinance/F/Foo/Package.toml\n>namespaces/JuliaFinance/B/Bar/Package.toml\n>And e.g. the information for a namespace would be here:\n>\n>namespaces/JuliaFinance/Namespace.toml\n\nThat is probably better. Looking at, just as an example, `JuliaFEM`. That is a package, but it could also be a namespace. With your approach you can accommodate both 👍 | [EricForgy]: What about not having a separate `namespaces` directory, but split the difference:\n\n```\n/J/JuliaFinance/C/Currencies\n```\n\nwith \n\n```\n/J/JuliaFinance/Namespace.toml\n```\n\n? 🤔 \n\nEdit: I'm not sure the second """"letter"""" folder is necessary. It is unlikely an org is going to have enough packages to warrant that, but it is more future proof 🤔 | [EricForgy]: ~Looking at this: https://julialang.github.io/Pkg.jl/v1/api/#Package-API-Reference-1~\n\n~I wonder if~\n\n```julia\nadd Namespace/Package\n```\n\n~would get confused with `PackageSpec(path=""""local/path"""")`. Maybe we do need an `@`~\n\n```julia\nadd @Namespace/Package => PackageSpec(namespace=""""Namespace"""", name=""""Package"""")\n```\n\n~https://github.com/JuliaLang/Pkg.jl/blob/master/src/REPLMode/argument_parsers.jl#L27-L54~\n\nNevermind. It is an error, so it is fine without `@`.\n\nEdit:\n\nNotes: \n- [core_parse: Code that takes a REPL input and converts to a Statement](https://github.com/JuliaLang/Pkg.jl/blob/master/src/REPLMode/REPLMode.jl#L237-L281)\n- [registry_resolve!: Code that takes a PackageSpec and resolves the package](https://github.com/JuliaLang/Pkg.jl/blob/master/src/Types.jl#L764-L781)\n- [find_registered!: called by above](https://github.com/JuliaLang/Pkg.jl/blob/master/src/Types.jl#L1203-L1257)\n- [registered_uuid: Code that takes a package name and returns uuid](https://github.com/JuliaLang/Pkg.jl/blob/master/src/Types.jl#L1278-L1309)\n- [parse_package_identifier: Takes REPL input and creates PackageSpec](https://github.com/JuliaLang/Pkg.jl/blob/master/src/REPLMode/argument_parsers.jl#L119-L137) | [fredrikekre]: Why do we need namespaces when we have UUIDs? | [DilumAluthge]: > Why do we need namespaces when we have UUIDs?\n\nI think that `] add Foo/Bar` is much more user friendly than adding a package by UUID, right?\n\nBy that same argument, why do we have package names when we have package UUIDs? For user convenience. | [EricForgy]: Update:\n\nI spent most of today looking into this. I have some upcoming high-profile projects that can potentially highlight JuliaFinance so I'd like to register some packages, but hope to get this namespace stuff worked out first.\n\nA picture is worth a thousand words so...\n\n![image](https://user-images.githubusercontent.com/8954730/82786366-54a9b300-9e19-11ea-84cf-28cf34eb08c3.png)\n\nI can now add packages with a namespace and it will split the namespace from the package name. I did end up adding a new field `namespace` to `PackageSpec`, but that shouldn't break anything.\n\nAt the moment, it just falls back to using the name to determine the UUID, but the idea is that if there are multiple packages with the same name, it can use the namespace, if any, to determine which one to use.\n\nNext, on the registry side, I made some [minor changes](https://github.com/JuliaFinance/General/tree/master/J/JuliaFinance).\n\nFirst, I moved all JuliaFinance packages currently registered with General, i.e.\n\n- Currencies.jl\n- CurrenciesBase.jl (which is actually archived)\n- BusinessDays.jl\n- DayCounts.jl\n\nto `J/JuliaFinance` and changed Registry.toml accordingly, i.e.\n\n```toml\n0fd90b74-7c1f-579e-9252-02cd883047b9 = { name = """"Currencies"""", path = """"J/JuliaFinance/Currencies"""" }\n44e31299-2c53-5a9b-9141-82aa45d7972f = { name = """"DayCounts"""", path = """"J/JuliaFinance//DayCounts"""" }\n4f18b42c-503e-5345-9536-bb0f25fc7038 = { name = """"BusinessDays"""", path = """"J/JuliaFinance/BusinessDays"""" }\na33ca353-0707-5c2b-b398-646075a850cd = { name = """"CurrenciesBase"""", path = """"J/JuliaFinance/CurrenciesBase"""" }\n```\n\nIt seems to be working as I hoped.\n\nUntil the tooling (Registrator, TagBot, etc) gets updated to handle namespaces, I don't mind doing this manually with PRs diretcly to General, but don't worry. There will not be so many updates.\n\nThere is certainly work to do with tooling, but that can come later I think. For example, Registrator could check a Namespace.toml before registering new packages, etc, but that is """"nice to have"""" I think.\n\nThis will solve one of my major problems so I appreciate your consideration.\n\nWhat do you think? | [EricForgy]: I started with the REPL, but now the API is working as well 👍 \n\n![image](https://user-images.githubusercontent.com/8954730/82790807-8a529a00-9e21-11ea-8739-47fe9773542f.png)\n | [fredrikekre]: > By that same argument, why do we have package names when we have package UUIDs? For user convenience.\n\nI mean, adding by name is just a key to finding the UUID. We can add user/package as another key to that same UUID without having to mess with namespaces etc. | [EricForgy]: >> By that same argument, why do we have package names when we have package UUIDs? For user convenience.\n>\n>I mean, adding by name is just a key to finding the UUID. We can add user/package as another key to that same UUID without having to mess with namespaces etc.\n\nFor what it's worth, that is pretty much all I'm doing. It still uses name to find UUID, but if there is more than one UUID it will use the namespace before giving up. I'll try to submit a PR tomorrow. It is just a few lines added. Not major surgery by any means 🙏 \n\nEdit: I think I have an idea that is in the spirit of your comment and of #1071. I'll probably still need that `namespace` field, but then we can just compare that against the user / org info with no other changes. I think that is what you mean. | [DilumAluthge]: > We can add user/package as another key to that same UUID without having to mess with namespaces etc.\n\nWhat do you mean when you say """"user""""? | [DilumAluthge]: Also, if we add """"user"""" as another key, then we have the issue where the package name by itself is not a good name.\n\nOne purpose of a namespace is that `packagename` by itself is not a good name for the General registry, but is a good name within the context of the namespace.\n\nAn example is the JuliaFinance package `Positions.jl`. We would not want to register a package in the General registry. It is too vague/ambiguous of a name.\n\nBut `JuliaFinance/Positions` is specific and unambiguous. | [fredrikekre]: I just meant that we can try harder to """"pattern match"""" against info that is in the registry. `add fredrikekre/Literate` could be made to work for example, it would be find from the repo URL.\n\n> An example is the JuliaFinance package Positions.jl. We would not want to register a package in the General registry. It is too vague/ambiguous of a name.\n\n🤷 it is their loss really if they want to use such regular names. And from above, if it will be used in the code only by name, then what is the point of differentiating namespaces when installing? | [DilumAluthge]: One of the big issues we have had in the General registry is that people want to register packages with names that in my opinion are not suitable for the registry.\n\nFor example, someone might make a package for doing expectation-maximization algorithms. They might want to name their package `EM.jl`. I would certainly object to this name. It is too ambiguous to add a package named `EM` to the General registry.\n\nSo what does that person do? The only way for them to get to keep the name `EM.jl` for their package is for them to maintain their own Julia package registry.\n\nAnd this is how we ended up with multiple open source organizations maintaining their own registries. Examples include (but are not limited to) the BioJulia registry and the JuliaFinance registry.\n\nBut there are many ecosystem problems with organizations having their own registries. Just to give one example: NewPkgEval only tests packages in General. So packages in other registries are not tested.\n\nSo one of my main goals here is to give open source organizations the ability to have whatever package names they want, without polluting the """"top-level namespace"""" of the General registry, and without having multiple registries.\n\nSo in my `EM.jl` example, maybe the `EM.jl` package is maintained by an organization called `JuliaStatistics`. So then they will register the package in the `JuliaStatistics` namespace. And then you can add the package by doing `] add JuliaStatistics/EM`. But you **cannot** add the package by doing `] add EM`.\n\nAnd then later, someone else writes a package for solving problems in electricity and magnetism. They call this package `EM.jl`. The package is maintained by an organization called `JuliaPhysics`. Now they want to register their package `EM.jl`. No problem! They can register it in the `JuliaPhysics` namespace. And then you can add the package by doing `] add JuliaPhysics/EM`. But you **cannot** add the package by doing `] add EM`. | [DilumAluthge]: > I just meant that we can try harder to """"pattern match"""" against info that is in the registry. `add fredrikekre/Literate` could be made to work for example, it would be find from the repo URL.\n\nPersonally I think this has the potential to get confusing. What if there is a GitHub user named `johnsmith` and a GitLab user named `johnsmith`, but those are two different humans. Now I do `] add johnsmith/Foo` and I don't really know which `johnsmith` I will get.\n\nBut anyway, this sort of URL pattern matching doesn't get to one of the core issues, which is that we want to register names that do not pollute the top-level namespace of the General registry. | [DilumAluthge]: > 🤷 it is their loss really if they want to use such regular names.\n\nActually I think it is our loss 😂 . Because as @StefanKarpinski said on Slack, if it isn't typo-squatting and it isn't offensive, then we let the package author choose the name. If the package author insists on a """"bad"""" name, we still merge it.\n\nSo it's our loss in that we end up with these """"bad"""" package names polluting the top-level namespace of the registry. | [fredrikekre]: I don't understand these arguments. There will still be a package named `EM` in the registry. There will be a package you can load with `using EM`. Then, why not let users add it by `add EM` if that is unambiguous? Just seems unfriendly to users to not let them.\n\n> Personally I think this has the potential to get confusing. What if there is a GitHub user named johnsmith and a GitLab user named johnsmith, but those are two different humans. Now I do ] add johnsmith/Foo and I don't really know which johnsmith I will get.\n\nYes, because Pkg won't just blindly add a package if the specification is ambiguous.\n\n\n> So it's our loss in that we end up with these """"bad"""" package names polluting the top-level namespace of the registry.\n\nBut how is that a loss for us as registry maintainers? It will just be a loss for the package maintainer in the sense that people will not find the package as easily. | [DilumAluthge]: > I don't understand these arguments. There will still be a package named `EM` in the registry. There will be a package you can load with `using EM`. Then, why not let users add it by `add EM` if that is unambiguous? Just seems unfriendly to users to not let them.\n\nSo that's fine for the first organization to register the name `EM`. But what if a second organization comes along and wants to register the name `EM`. They can't have it because it's taken. Wouldn't it be nice to let them register `MyOrganization/EM`? | [DilumAluthge]: Last I checked, we don't actually allow two packages in the General registry to have the same name. Am I mistaken? | [EricForgy]: Thanks @DilumAluthge and thanks @fredrikekre for thoughts and feedback 🙌 \n\nFrom the above, I can tell the issue is understood and hope it can be taken seriously (I haven't registered a package on General for ages because of it). Naming is important. A name that isn't appropriate in a general context could be perfectly appropriate in the context of a namespace. So I hope we are past the question of whether disambiguating is a good thing and focus on how to do it 🙏 \n\nIn my first attempt at namespacing (#1064), I went too far. The namespace actually pointed to a different registry. I can still imagine a time when we could allow registries to depend on other registries, e.g. #1072, #1791, but that is a bigger question than we are addressing with this issue. In this issue, we are trying to allow namespacing within one registry, namely General.\n\nIf I understand, Stefan and Frederik are both suggesting disambiguating along the lines of #1071. For example, we already know the repo url which is typically of the form:\n\n> https://githostingservice/UserOrOrgName/PackageName.jl\n\nso we can just parse that if we need a tie breaker on the name. For example, \n\n```julia\npkg> add OrgName/Package.jl\n```\n\nand it can match that against the repo URL. For sure, that is possible, but what Dilum (and I) are proposing here is a little more robust, while at the same time, not requiring much more effort.\n\nAs a concrete example, the next two packages I would want to register on General are:\n\n- Instruments.jl\n- Positions.jl\n\nI imagine getting pushback on both the names because they are too generic for General, yet are perfectly reasonable for JuliaFinance (and I really do not want to preface the package names with """"Financial***"""".\n\nFrederik, you make a good point. Just because a package can be disamguitated with a namespace shouldn't mean that you can't add it without the namespace if it isn't ambiguous.  In my draft PR, it accomodates both. For example, another package I might register is called [XBRL.jl](https://www.xbrl.org/). There is no other name I would consider for such a package and it is clear within the context of JuliaFinance what it is. Nevertheless, I think it is unlikely anyone outside JuliaFinance would register a package called XBRL, so we should be able to simply do:\n\n```julia\npkg> add XBRL\n``` \n\neven though\n\n```julia\npkg> add JuliaFinance/XBRL\n```\n\nis also fine. I'm onboard with this idea 👍 \n\nIn this way, if there is a clash, instead of having an interactive selection, we can simply suggest something along the lines of:\n\n```julia\nError: The name `FX` is ambiguous. Please add with either:\n\npkg> add Animators/FX\n\nor\n\npkg> add JuliaFinance/FX\n```\n\nWhether we parse the repo URL or add a more robust namespace, I lean toward namespace, but I see that it can be done with a similar amount of (little) effort. It is almost finished already 😊 \n\nI'll try to get a PR up later today and that will make it easier to pick at 🙏 | [DilumAluthge]: So, I tried to register a package named `Literate.jl` and I got the error """"changing UUIDs is not allowed.""""\n\nhttps://github.com/DilumAluthge/Literate.jl/commit/1f2d06300df93e113dcac5795c9a1cba90018f27\n\nSo we currently do not allow you to register a package with the same name as an existing registered package. | [DilumAluthge]: So then how does pattern matching the URLs help anything?\n\nIf someone has registered a package named `EM`, then no one else can register another package named `EM`. | [EricForgy]: > So, I tried to register a package named Literate.jl and I got the error """"changing UUIDs is not allowed.""""\n>\n>DilumAluthge/Literate.jl@1f2d063\n>\n>So we currently do not allow you to register a package with the same name as an existing registered package.\n> \n>So then how does pattern matching the URLs help anything?\n>\n> If someone has registered a package named EM, then no one else can register another package named EM.\n\nThis is a separate issue with Registrator that should be easily resolved. For now, we can just submit PRs directly to General as a temporary stopgap. Pkg itself is fine with multiple packages with the same name. Currently, it will give you a choice of which one you want if you are in the REPL and will error otherwise.\n\nAgain, kind of separate issue, but we might want to rethink the way the folders are organized in General. Instead of `C/Currencies`, we might want `J/JuliaFinance/Currencies` or `E/EricForgy/Pages` otherwise we'd need things like `C/Currencies1`, `C/Currencies2`, which obviously sucks 😅 \n\nEdit: But I also think this could be phased in until the tooling catches up with namespaces. If we are doing manual PRs to general, we can manually create `J/JuliaFinance/Currencies` and Regsitrator would be unaffected.\n\nEdit^2: Btw, I did test the concept by adding a second entry to Registry.toml with the same name and different UUIDs and Pkg handles it fine as expected. | [DilumAluthge]: If we don't get support for namespaces as discussed in this issue, then someone needs to add support for """"multiple packages with the same name"""" to things like:\n- Registrator\n- LocalRegistry (cc @GunnarFarneback)\n- PkgDev (cc @davidanthoff) | [DilumAluthge]: And we need to change the current name scheme in the General registry. `/P/PackageName` no longer works if we have multiple packages with the same name. | [DilumAluthge]: Personally I don't want the General registry to have multiple packages with the same name. I think that is confusing. I would rather have namespaces.\n\nBut if I get outvoted, and we go with """"multiple packages with the same name"""", then we need to commit to that feature, and implement it properly. | [DilumAluthge]: And we need to document it properly. And make it perfectly clear in e.g. the documentation for the README for the General registry that we allow packages with multiple names. | [EricForgy]: > If we don't get support for namespaces as discussed in this issue, then someone needs to add support for """"multiple packages with the same name"""" to things like:\n>\n> Registrator\n> LocalRegistry (cc @GunnarFarneback)\n> PkgDev (cc @davidanthoff)\n> \n> And we need to change the current name scheme in the General registry. /P/PackageName no longer works if we have multiple packages with the same name.\n\nI think even with namespace support, we are going to need these ☝️ \n\nBut I don't think the naming in General needs to change for existing packages. We can simply change the structure for new packages. Pkg is smart enough to figure out the path from Registry.toml. I already tested it 👍 | [DilumAluthge]: Personally, I think it would be SO WEIRD if on Monday, this works:\n```\n] add Flux\n```\n\nAnd then on Tuesday, the exact same command gives an ambiguity message.\n\nIt just seems to me like a weird thing to do. | [DilumAluthge]: Personally, I think if we have namespaces, then we don't need to allow multiple packages with the same name in the General registry. | [DilumAluthge]: How do other programming language ecosystems handle this? Do they allow multiple packages with the same name.\n\nFor example, NPM has namespaces. I don't think that NPM allows multiple packages with the same name. | [EricForgy]: > Personally, I think it would be SO WEIRD if on Monday, this works:\n> \n>] add Flux\n>And then on Tuesday, the exact same command gives an ambiguity message.\n>\n>It just seems to me like a weird thing to do.\n\nTrue. So in the README, they can give instructions to do\n\n```julia\npkg> add FluxML/Flux\n```\n\nif someone else registers a package named """"Flux"""" or the new package could specify in their README to use:\n\n```julia\npkg> add Electromagnetics/Flux\n```\n\nto their README and FluxML would be unaffected. These are good points, but ultimately solveable with some though 👍 | [DilumAluthge]: > > Personally, I think it would be SO WEIRD if on Monday, this works:\n> > ] add Flux\n> > And then on Tuesday, the exact same command gives an ambiguity message.\n> > It just seems to me like a weird thing to do.\n> \n> True. So in the README, they can give instructions to do\n> \n> ```julia\n> pkg> add FluxML/Flux\n> ```\n> \n> if someone else registers a package named """"Flux"""" or the new package could specify in their README to use:\n> \n> ```julia\n> pkg> add Electromagnetics/Flux\n> ```\n> \n> to their README and FLuxML would be unaffected. These are good points, but ultimately solveable with some though 👍\n\nBut that is not correct. If someone registers a package with the name `Flux`, then FluxML will be affected no matter what. As soon as there are two packages with the name `Flux`, then `] add Flux` will never ever work. | [DilumAluthge]: I just don't understand why having two packages with the same name is somehow more desirable than just having proper namespaces. | [EricForgy]: Maybe if someone tries to register a package with the same name as an already registered package, they are required to use namespace and then it is their problem if their users pull the wrong package. They need to specify clear instructions to use namespace when adding.\n\n> I just don't understand why having two packages with the same name is somehow more desirable than just having proper namespaces.\n\nI don't see these as mutually exclusive. You can have both. Best if I can get a PR up. You will see what I mean. | [DilumAluthge]: Think about how many people have something like `Pkg.add(""""Documenter"""")` in their `.travis.yml`.\n\nIf I register my own package with the name `Documenter`, then I will break the CI and docs build for every single one of those packages. | [EricForgy]: > Think about how many people have something like Pkg.add(""""Documenter"""") in their .travis.yml.\n>\n> If I register my own package with the name Documenter, then I will break the CI and docs build for every single one of those packages.\n\nThere is no chance we would allow that to happen 👍 | [DilumAluthge]: > > Think about how many people have something like Pkg.add(""""Documenter"""") in their .travis.yml.\n> > If I register my own package with the name Documenter, then I will break the CI and docs build for every single one of those packages.\n> \n> There is no chance we would allow that to happen 👍\n\nBut if we allow multiple packages with the same name, by definition we would allow that to happen. | [DilumAluthge]: > Maybe if someone tries to register a package with the same name as an already registered package, they are required to use namespace\n\nThis is exactly what I want.\n\nBut that's not the solution that e.g. @fredrikekre is suggesting. | [EricForgy]: > But if we allow multiple packages with the same name, by definition we would allow that to happen.\n\nNot necessarily. I will show you. Be patient 🙏 | [DilumAluthge]: > > But if we allow multiple packages with the same name, by definition we would allow that to happen.\n> \n> Not necessarily. I will show you. Be patient 🙏\n\nAlright, I'll wait for your PR! | [EricForgy]: >> Maybe if someone tries to register a package with the same name as an already registered package, they are required to use namespace\n>\n>This is exactly what I want.\n>\n> But that's not the solution that e.g. @fredrikekre is suggesting.\n\nWe can have both. I agree with both of you 👍 | [GunnarFarneback]: I'm not particularly interested in this subject but since I got dragged into it...\n\n> If we don't get support for namespaces as discussed in this issue, then someone needs to add > support for """"multiple packages with the same name"""" to things like:\n> ...\n> LocalRegistry (cc @GunnarFarneback)\n\nIf people can't organize their own local registries with unique package names, I suspect they have bigger problems than the tooling.\n | [DilumAluthge]: > I'm not particularly interested in this subject but since I got dragged into it...\n> \n> > If we don't get support for namespaces as discussed in this issue, then someone needs to add > support for """"multiple packages with the same name"""" to things like:\n> > ...\n> > LocalRegistry (cc @GunnarFarneback)\n> \n> If people can't organize their own local registries with unique package names, I suspect they have bigger problems than the tooling.\n\nThat's a great point. There isn't any reason we need to have multiple packages with the same name in local (private) registries.\n\nSo I don't think we need to add support for multiple packages with the same name to LocalRegistry.jl. | [fredrikekre]: > So that's fine for the first organization to register the name EM. But what if a second organization comes along and wants to register the name EM. They can't have it because it's taken.\n\nBut thats why we have UUIDs, I don't think we need to add another layer of disambiguation.\n\n> Last I checked, we don't actually allow two packages in the General registry to have the same name. Am I mistaken?\n\nI don't think there are any decisions since this has not come up before.\n\n> As a concrete example, the next two packages I would want to register on General are:\n> \n>     Instruments.jl\n>     Positions.jl\n\n> I imagine getting pushback on both the names because they are too generic for General, yet are perfectly reasonable for JuliaFinance (and I really do not want to preface the package names with """"Financial***"""".\n\nPeople can use whatever names they want -- pushback are usually just suggestions. However, I would argue that naming something `Instruments` is shooting yourself in the foot, and `FinancialInstruments` is 100 times better.\n\n> In this way, if there is a clash, instead of having an interactive selection, we can simply suggest something along the lines of:\n\nYou already get prompted in case of multiple packages.\n\n> So, I tried to register a package named Literate.jl and I got the error """"changing UUIDs is not allowed.""""\n\n> If someone has registered a package named EM, then no one else can register another package named EM.\n\nThat is a limitation/bug of Registrator.\n\n> otherwise we'd need things like C/Currencies1, C/Currencies2, which obviously sucks\n\nWhy does that suck? This is never seen by users.\n\n> Personally I don't want the General registry to have multiple packages with the same name. I think that is confusing. I would rather have namespaces.\n\nIt will be the same level of confusion IMO, there will still be multiple packages with the same name.\n\n> Personally, I think it would be SO WEIRD if on Monday, this works:\n\nWhy? This is an interactive REPL and you will just have to select the package you want.\n\n> So in the README, they can give instructions to do\n\nIf you are worried about this your instructions should be\n\n```\nusing Pkg\nPkg.add(name=""""Literate"""", uuid = """"..."""")\n```\n\n> Think about how many people have something like Pkg.add(""""Documenter"""") in their .travis.yml.\n\nWell, that is not the recommended approach so hopefully people don't do this. It is recommended to use a project file where both name + uuid are already specified so it will not cause any problems.\n\n | [felipenoris]: Just to add my opinion, this feature is quite useful, but does not replace the proposition at #1791. Both propositions could be combined.\n\nThis proposition #1836 would allow for a better organization of packages. Many Julia organizations could file for a NameSpace. This would solve the """"package naming"""" issue, where, for instance, it would be silly to register """"Countries.jl"""" from """"JuliaFinance"""" directly into the general registry. But, all packages inside """"JuliaFinance"""" NameSpace would still need to pass the """"General"""" registry governance: approvals and name conventions (maybe).\n\nIf this gets combined with #1791, a registry repo could be registered into the General registry as a NameSpace. Why this is useful? In one word: Governance. If, for instance, the registry repo at """"JuliaFinance"""" gets registered into General, then we don't need to register every single package under """"JuliaFinance"""" into the """"General"""" registry. Also, """"JuliaFinance"""" owners would be responsible for approvals when updating the """"JuliaFinance"""" registry repo after the NameSpace gets approved by General repo owners. This is the value I see in the proposal at #1791. But this could be done as a second step after this issue #1836. | [EricForgy]: Hi @felipenoris 👋 \n\nThanks for your thoughts on the subject 🙌 \n\n> Just to add my opinion, this feature is quite useful, but does not replace the proposition at #1791. Both propositions could be combined.\n\nI got pulled into some other things that are higher priority at the moment, but yes, the idea I have in mind combines elements of both #1791 and this issue. I am cautiously optimistic, but think having a PR to reference will aid the conversation, but it might take me a few days 🙏 | [StefanKarpinski]: So the idea is to use #1791 to sidestep governance issues? I don’t think that makes sense from any perspective. Technically, it feels a bit silly: do we really need yet another layer of indirection? What’s next? A registry of registries of registries? But from a governance perspective it also doesn’t make sense: if something is visible by default with a standard Julia install, then the Julia project must have governance over it. Having the technical ability to make other registries visible from General is *not* the issue. If we had such a feature, then the maintainers of Julia itself would have the same responsibility to users to make sure that packages in those available-by-default registries meet the same (lightweight) standards as General. So either Julia’s maintainers have enough control over those external registries to ensure it is also reasonably safe and correct — in which case why bother with a separate registry? — or we lack such control and it’s totally irresponsible to delegate a huge portion of the default namespace to external groups without being able to ensure that.\n\nIn short, hard no on #1791.\n\nNamespaces, on the other hand, seem plausible since the argument that you want to have `Instruments` mean something specific in a financial context without having to prefix with “Financial” all the time seems reasonable.\n\nI do, however, think the focus here on how to organize the registry and file names is misplaced. Worry about that last—it doesn’t even matter from Pkg’s perspective. It’s only a problem for the tooling that manages registries. Focus instead on how these namespaces are supposed to work from a UI perspective and figure out a clear semantics for them.\n\nBefore getting general buy in for semantics and UI, doing all the work to implement a PR seems premature. It is, however, a fine way to explore the UI if you’re ok with the possibility that you might need to throw away that work if there isn’t general agreement on the approach. | [EricForgy]: Thanks for chiming in @StefanKarpinski . Your opinion obviously matters so I'm glad you're here.\n\nFirst comment, I think you know Felipe and I both work in finance. Finance is a highly regulated industry. If Felipe and I are talking about registries depending on other registries, rest assured, the reason is not to loosen governance. If anything, it is to have better governance, but that is not the point of this issue. This issue has a much cleaner focus, i.e. have first-class support for namespaces in registries with a focus on `General`.\n\nLike Felipe, I once thought having a separate registry would be good for JuliaFinance and having it play nice with `General` would be a win win, so as an initial step, I implemented a PR with namespaces in #1064. That was pretty trivial. Since we keep an array with all registries in `.julia/registries`, the namespace simply told you which one to use for finding the correct `UUID`. That experience was, unfortunately, a bit unpleasant for me and I haven't registered anything on `General` since then (and had no plans to ever do so again until some others in the community needed some functionality and, for their project, it would be better to have things in `General`) so I'm back trying to be productive.\n\nWith feedback from others (thanks @alecloudenback and @ScottPJones), I've come around and now I want JuliaFinance packages in `General`, but only once we have namespaces for reasons mentioned and I think you understand.\n\nOne thing that is different now is that we have things like [LocalRegistry.jl](https://github.com/GunnarFarneback/LocalRegistry.jl) which seems to make it easier to manage local registries than last time I tried it.\n\n> Before getting general buy in for semantics and UI, doing all the work to implement a PR seems premature. \n\nSure. So my idea starts with @DilumAluthge's idea of introducing a new `namespaces` folder to `General`, but the trick that I am cautiously optimistic about that I think can make this work fairly painlessly is that this folder is actually a folder of complete local registries (contents and all - not just a UUIDs).\n\nWhen `Pkg` updates, it loads `General` from `.julia/registries` but also looks for any additional registries also in `.julia/registries`. The idea is to extend this search by having it also look in `.julia/registries/General/namespaces` and push these to that same vector one by one. At that point, we can use my trick in #1064 to simply use the namespace to select which registry in that vector to use for finding the UUID. The difference is that some of the registeries are actually registered / embedded directly into `General` so that other packages in `General` can depend on them and they are subject to the same governance. I see this as a win win.\n\nThis brings up a related issue. There are already a ton of packages already registered on `General` and these should have priority. So for this, I suggest that registering on `General` is staking claim to that unqualified name. So if I want to register `Flux.jl` for my electromagnetics lab, the unqualified name `Flux` is already claimed by the FluxML organization, so I must qualify it via\n\n```\npkg> add MaxwellLaboratory/Flux\n```\n\nIn other words, I suggest that """"no namespace"""" is a namespace and no two packages can have the same name in the same namespace.\n\nIf \n\n```\npkg> add Flux\n```\n\nworks today, it should work always. If I want to register a new Flux.jl on `General`, I can do that, but anyone who wants to use my `Flux` will need to qualify the name with my registered namespace since `Flux` is already taken in the """"no namespace"""" namespace.\n\n""""Registering"""" a namespace on `General` would then mostly just mean having a full local subregistry under its `namespaces` folder. PRs to any subregistry would be reviewed with the same level of governance as we have today since you control `General`.\n\nAn added benefit of this is that it will play nicely with local private registries. Currently, we support private registeries, but your local registry cannot have a package with the same name as a package registered on `General` (without interaction which won't play nicely with containers, etc.). So if I have a private registry and name my package `Foo` and someone comes along later and registers `Foo` on `General`, I will have some problem. This solves that issue for private registries too because now I can qualify with my private registry name:\n\n```\npkg> add SecretLab/Flux\n```\n\nand it will know to use my private registry (and we can add warnings etc if needed for namesapces taking you out of `General`). I don't want to get too distracted, but this could be completely recursive allowing for things like:\n\n```\npkg> add Microsoft/Azure/AzureFunctions/Containers\n```\n\nwhich could be attractive for large corporations.\n\nI would like to register JuliaFinance stuff on `General`, but I need namespaces for that. I've already worked out a draft PR to grab the namespace from both the Pkg REPL and the Pkg API and it is non-breaking. Next, I would combine that with #1064 , but tell Pkg to look not only in `.julia/registries` but also in `.julia/registries/General/namespaces`.\n\nIf we can get behind this idea of namespaces AND the rule that no two packages can have the same name in the same namespace where the default """"no namespace"""" is considered a namespace, then that can simplify some things in Pkg and I'm happy to do the heavy lifting to get that to work since this is so important to me.\n\nThanks again for your consideration 🙏 | [felipenoris]: @StefanKarpinski, thanks for your reply. I respect your view and I was happy to close #1791 given that the namespace feature got better acceptance. I just would like to point out that it is a strong statement to associate my proposal with """"sidestep governance"""". For me it is more of a delegation, which often occurs when you organize people into groups of interest or domains. We could debate and disagree on whether it is silly or technically inferior to namespacing and I get that. But all ideas we discuss are for the better of this community we care so much about, and not to damage the community. | [StefanKarpinski]: Perhaps I misunderstood when you wrote:\n\n> Why this is useful? In one word: Governance. If, for instance, the registry repo at """"JuliaFinance"""" gets registered into General, then we don't need to register every single package under """"JuliaFinance"""" into the """"General"""" registry. Also, """"JuliaFinance"""" owners would be responsible for approvals when updating the """"JuliaFinance"""" registry repo after the NameSpace gets approved by General repo owners.\n\nTo me that sounds as though, when JuliaFinance is registered with General, General loses governance over its own namespace, ceding control over a portion of it to JuliaFinance. If registries that are registered in General are also managed by the maintainers of the Julia project as a whole, then delegating like this would be ok, since it would have no effect, but having Julia maintainers manage more registries seems like more work, not to mention complexity, to what end?\n\nIf the goal is for checks on JuliaFinance packages to be more stringent than on General, then that's a viable position, but I think that would be better served by having a system where various entities can perform different kinds of checks and vouch for arbitrary subsets of a registry, via some form of trust metadata. In other words, it's an orthogonal concern to splitting up registries. | [EricForgy]: Please 🙏 This proposal has nothing to do with governance. It is about namespaces. I would like to register packages on `General`, but can only do so with names that make sense once we have namespaces so I hope to be proactive to help that become a reality. I felt we had some momentum.\n\nI did spend some time both writing code to make sure it makes sense and explaining it the best I could. I think what I describe is a clean solution to namespaces that leverage recent developments for managing local registries. If you have feedback on the proposal, that would be great and I'm happy to incorporate better ideas and I'm happy to put a PR together. What do you think? Should I drop it? Does this issue have a chance? | [DilumAluthge]: > > Think about how many people have something like Pkg.add(""""Documenter"""") in their .travis.yml.\n> \n> Well, that is not the recommended approach so hopefully people don't do this. It is recommended to use a project file where both name + uuid are already specified so it will not cause any problems.\n\nOkay, how about this: \n```julia\nPkg.add(""""Coverage"""")\n```\n\nEveryone has this in their `.travis.yml` files. Are we really going to tell everyone that they need it change all of their Travis files? | [EricForgy]: In my proposal, no one will need to change any `.travis.yml` files. | [StefanKarpinski]: Yeah, sorry. Didn’t mean to sidetrack this, I was just addressing the part where #1791 got brought into it and then replying to responses. | [EricForgy]: If I could sum up my proposal (TL;DR), I'd say it boils down to:\n\n- Adding `namespace` to `PackageSpec`, which is non-breaking because `PackageSpec` is built with `@kwdef` (done ✔️)\n- Adding some code to splice the command to pull out `namespace` from `add Namespace/Package` (done ✔️)\n- Adding `namespaces` directory to `General` that will house subregistries (not yet done ❌)\n- Adding any registries found in `.julia/registries/General/namespaces` to the existing array of registries obtained from `.julia/registries` (not yet done ❌)\n- Using `namespace` to grab just the corresponding embedded subregistry and use that to find the `UUID` similar in nature to #1064 , but staying with `General` with no external registries (not yet done ❌)\n\nI am thinking we can point LocalRegistry.jl to `.julia/registries/General/namespaces` instead of `.julia/registries` so we can leverage that tool to manage the subregistries until the rest of the tooling catches up. Then submit PRs manually to `General` as a stopgap. | [fredrikekre]: > Currently, we support private registeries, but your local registry cannot have a package with the same name as a package registered on General (without interaction which won't play nicely with containers, etc.). So if I have a private registry and name my package Foo and someone comes along later and registers Foo on General, I will have some problem. \n\nWhat? Then you don't do things correctly.\n\n\n> Okay, how about this:\n>  ```\n> Pkg.add(""""Coverage"""")\n> ```\n> Everyone has this in their .travis.yml files. Are we really going to tell everyone that they need it change all of their Travis files?\n> \n\n[Yes.](https://github.com/fredrikekre/Literate.jl/blob/167b881590bb7b57088f268ec46ce8bfc00224bb/.travis.yml#L16-17)\n\n---\n\nWe already have a way to disambiguate packages, and that is by UUID. I don't understand why we need a second way to """"kinda specify"""" the package when we have an absolute way of doing it.\n\nIn particular, what happens when I want to use the namespace `JuliaFinance`, should we add yet another indirection to disambiguate namespaces? | [EricForgy]: >  I don't understand why we need a second way to """"kinda specify"""" the package when we have an absolute way of doing it.\n\n[Here](https://github.com/JuliaLang/Pkg.jl/issues/1836#issuecomment-633286006), you also asked:\n\n> Why do we need namespaces when we have UUIDs?\n\nDIlum responded [here](https://github.com/JuliaLang/Pkg.jl/issues/1836#issuecomment-633287606):\n\n> I think that ] add Foo/Bar is much more user friendly than adding a package by UUID, right?\n>\n> By that same argument, why do we have package names when we have package UUIDs? For user convenience.\n\nYou [replied](https://github.com/JuliaLang/Pkg.jl/issues/1836#issuecomment-633438100):\n\n> I mean, adding by name is just a key to finding the UUID. We can add user/package as another key to that same UUID without having to mess with namespaces etc.\n\nThen we danced around a bit until Stefan said:\n\n> Namespaces, on the other hand, seem plausible since the argument that you want to have Instruments mean something specific in a financial context without having to prefix with “Financial” all the time seems reasonable.\n\nThis ☝️ is the answer to your question. Please accept this answer 🙏 \n\nI hope we can get past the question of whether namespaces are useful (they are) and start focusing on whether and, if so, how to implement them.\n\nI see two options:\n\n### Option 1\n\nImplement #1071. This allows multiple packages with the same name to be registered in `General` and we disambiguate them based on """"user / org"""" which is already available in the registry.\n\nThis would be ok, but it isn't obvious to me how to protect packages that were already registered that should somehow, I think, be given priority. In my example above, if I register `Flux` under the MaxwellLaboratory organization, now everyone who uses `Flux` for machine learning will suddenly be required to disambiguate. The timing of these breaks would be unpredictable and could conceivably happen during critical times, e.g. right in the middle of someone giving a demo. It also isn't obvious to me that this would be less work to implement than adding first-class support for namespaces.\n\nIf Option 1 is what we want, we can make that work and I'm happy to help implement that.\n\n\n### Option 2\n\nImplement this issue, i.e. first-class support for namespaces.\n\nAs I envision it, this can be implemented almost entirely using existing tools. In this approach, a namespace would be a full subregistry embedded into `General` under a `namespaces` folder. These subregistries could be managed by """"owners"""" using tools such as LocalRegistry.jl today until tools like Registrator can be updated to handle these subregistries. Revisions to subregistries would be submitted as PRs to `General` and reviewed as usual with the same (and possibly more) governance.\n\nImplementing first-class support for namespaces this way comes with multiple advantage. For one, once we have proper first-class namespaces, we can introduce the reasonable rule:\n\n> Package names should be unique within a given namespace.\n\nThis would be a non-breaking rule (since there are currently no duplicate package names in `General`). This would also protect package maintainers who have already registered package names in `General` as it ensures that\n\n```\npkg> add Flux\n```\n\nwill always and forever grab the FluxML version without the need to disambiguate because they are already registered in the default """"no namespace"""" namespace of `General`.\n\nThe rule would also lead to a significant simplification in the implementation of `Pkg`. I can almost guarantee a reduction in lines of code with minimal changes to remaining code.\n\n### Decision needed\n\nThe first thing we need to decide is: \n\n> Do we want namespace?\n\nIf it is a flat out """"No"""", then we can stop the discussion now and I'll try to find another way to proceed with JuliaFinance outside of `General`, which is not the end of the world, but unfortunate (for all of us I think).\n\nIf the answer is a """"Maybe, it depends on the implementation"""", then I am happy to implement a PR for review myself.\n\nThen the question becomes, """"Which option do we want to implement?""""\n\nMy preference would be to implement Option 2: first-class support for namespaces and I am happy to submit a working PR, but I'm also happy to help with Option 1 if we decide to go that way.\n\nFrom a user (and package maintainer) perspective, Option 2 shoud introduce absolutely no change for existing packages in `General`. This would only affect package maintainers who want to register packages in `General` with the same name as existing packages and / or who may prefer namespaces for other reasons such as branding, etc. In these cases, the package maintainer would need to register a namespace (i.e. submit a PR adding a subregistry to the namesapces folder of `General`) and then users of the new package would be required to disambiguate using the namespace to protect the existing package with the same name.\n\n@StefanKarpinski, at the end of the day, I think this is your call, so please consult with anyone you think should have a say on this and let me know what you think. I have some projects going on and need to make some decisions how to proceed 🙏 \n\nEdit: Btw, on Slack, Stefan mentioned the possibility of introducing this as an experimental feature, which would be totally fine with me. More than fine. It would be awesome 👍 | [StefanKarpinski]: Some notes from discussion of this issue on the pkg-dev call today. Namespacing mechanisms are fundamentally about preventing/disambiguating name collisions. However, to a large extent Pkg already handles name collisions gracefully because of UUIDs:\n\n* It's perfectly fine to have packages with the same name in different registries. This already works: if there's an `Instruments` package in `General` that's about music and an `Instruments` package in `JuliaFinance` too and you have both registries added, and you do `pkg> add Instruments` it will prompt you for which one you want to add.\n\n* If you don't want an interactive prompt, you can use a `add Instruments=55efc701-121b-4840-9663-6fa785ef03be` to add a package by its UUID, completely eliminating any ambiguity.\n\nThere are only two places where any kind of further disambiguation might be helpful:\n\n* When doing `add Instruments`, it might be nicer to write `add Finance/Instruments` instead of having to spell out a long, unmemorable UUID.\n\n* Someone could write a project that needs to use both `Finance/Instruments` and `Music/Instruments`, which we currently cannot handle.\n\nOne solution to the second problem might be to implement https://github.com/JuliaLang/julia/issues/33047 and decouple the name that a project refers to a dependency by from its canonical name. Then, when someone tries to add the second `Instruments` package to the project file, they would be prompted for an alternate name for it, or maybe we could add `pkg add Finance/Instruments as FinanceInstruments`. But that's a bit unsatisfying because `Finance/Instruments` is already a good unambiguous name. `using Finance/Instruments` is not a syntax error, but it's unlikely enough to have been used that I think we can use it if we want to.\n\nAnother issue that was discussed was whether disambiguates should be hierarchical (namespaces) or more like tags/labels/keywords/categories. Recently, there was some discussion of whether some packages belonged in the JuliaIO or JuliaData organizations. So there's often some ambiguity in these things. Why not allow both? Some packages may be relevant to both finance and economics. Why not allow installing them by `add Finance/Options` or `add Economics/Options`? Then this would just be a matter of adding support for a `categories` keyword in the registry for packages and allowing packages to be disambiguated by category. At that point, there's really reason not to also allow `add @JuliaFinance/Instruments` and using the GitHub user name as a kind of ad hoc category.\n\nAnother use case would be tagging packages that are useful for CI with the `CI` category and then having a preference system for categories and setting `CI` as the preferred category when running CI jobs. That would allow us to keep old Travis jobs working but running them with the CI category as preferred as long as we categorize all those packages as being in the CI category.\n\nIf we went with a non-hierarchical category system instead of a hierarchical namespace system, then the categories would be ordered with the earlier ones taking precedence. If you install both `Music/Instruments` and `Finance/Instruments` in a single project, the deps section could look like this:\n```toml\n[deps]\n""""Finance/Instruments"""" = """"55efc701-121b-4840-9663-6fa785ef03be""""\n""""Music/Instruments"""" = """"be17f318-eccd-4180-afc1-ec5a11373fef""""\n```\nThe usage would look like `using Finance/Instruments` and `using Music/Instruments`. One issue that comes up then is that while the desired category could be derived from the `add Finance/Instruments` syntax, what if another `Instruments` package had already been installed? Do we prompt the user for what to call it? Maybe we can just leave it as-is since `Finance/Instruments` is distinct from `Instruments`. Or we could automatically prefix it with the first category it belongs to which unambiguously identifies it. | [EricForgy]: Thanks for the update Stefan 👍 \n\nIt sounds like the discussion brought out some good ideas to think about. I appreciate everyone taking the subject seriously and working together to find a solution.\n",66,false,2,2,0,0,0,0,0,0,0
1839,add name of Project.toml file in `read_project_compat` exception,open,ueliwechsler,,,,0,2020-05-26T09:33:50.0,2020-05-26T09:33:50.0,1881,1881,https://github.com/JuliaLang/Pkg.jl/issues/1839,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1839,"Is it possible to add the name of the `Project.toml` file, where the compatibility version could not be parsed, to the exception msg?\nhttps://github.com/JuliaLang/Pkg.jl/blob/6ffff447eff89350ab9b4ed5cfca1ed4ce8d84ff/src/project.jl#L66\n\nThe current error message is unnecessarily troublesome to debug because there is no information where the failure to parse occured.\n```julia\n(v1.3) pkg> up SemHelper\n  Updating registry at `C:\Users\UELIWECH\.julia\registries\General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Updating git-repo  Resolving package versions...\nERROR: Could not parse compatibility version for dependency `DataFrames`\n``` \nIt would be easier to debug if it would be something like\n```julia\nERROR: Could not parse compatibility version for dependency `DataFrames` in Project.toml file of `PackageXYZ`\n```\nI am not sure if this change would already work:\n```julia\n  pkgerror(""""Could not parse compatibility version for dependency `$name` in Project.toml file of `$(project.name)`"""")\n```\n\n",,0,false,0,0,0,0,0,0,0,0,0
1071,allow package to be disambiguated by `@user/package`,open,StefanKarpinski,,enhancement,,14,2019-02-19T20:11:12.0,2020-05-24T05:18:03.0,2342,1883,https://github.com/JuliaLang/Pkg.jl/issues/1071,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1071,"One of the ideas that came out of https://discourse.julialang.org/t/decentralized-package-manager/20931 is that when we have multiple packages with the same name in registries, it would be nice to be able to disambiguate which one you want by writing `pkg> add @user/package` instead of having to do `pkg> add package` and then interactively selecting from different packages by that name. It's a nice qualifier since the info already exists and is well-known: people know that @KristofferC is the author of [Crayons.jl](https://github.com/KristofferC/Crayons.jl) so if someone else comes and creates a package that provides data about all the colors of Crayola Crayons™ and also calls it Crayons.jl then all you need to do to indicate that you want Kristoffer's package is write `pkg> add @KristofferC/Crayons` instead of just `pkg> add Crayons`.","[fredrikekre]: > `pkg> add @KristofferC/Crayons`\n\nCould it not just be `pkg> add KristofferC/Crayons` since `/` is not allowed in package names? | [00vareladavid]: But you can still `add` by path | [fredrikekre]: Yea, but how is that different from\n```\npkg> add Crayons\n```\nthat can also be a path but we fix that ambiguity by treating that as a package, which we can do here too. | [EricForgy]: Question...\n\nIt is not safe to assume that a `package` maps to a unique `uuid`.\n\nIs it safe to assume that a `@user/package` maps to a unique `uuid`? | [00vareladavid]: Its unlikely that a single user will register two packages with the same name. What is the value in making that an explicit restriction? | [EricForgy]: I am not suggesting making it a restriction. It is a question.\n\nI am taking a stab at implementing this and it would make life easier if `@user/package` mapped to a unique `uuid`. If that is not the case, there needs to be additional logic. That's all. | [00vareladavid]: I suppose you can make that assumption for now. That case will eventually need to be checked somewhere though: either the registry or here in the client. | [StefanKarpinski]: I'm not sure why there's any additional logic. Currently, when you do `add package` it selects a set of UUIDs as candidates to install. If there's only one UUID then it just installs that; if there are zero UUIDs then it's an error; if there are two or more UUIDs then you get a prompt to disambiguate. This is no different, `add @user/package` is just a more specific UUID selector—the rest of the logic remains identical. If, for example, the there are two packages registered as `XYZ` with these repos:\n\n* `https://github.com/SomeUser/XYZ1.jl`\n* `https://github.com/SomeUser/XYZ2.jl`\n\nThen if someone writes `add @SomeUser/XYZ` they will get a prompt to pick which package they want.\n\nWhich raises the question: where does the user name come from? Is it just that the system understands GitHub URLs and knows that the `SomeUser` part of `https://github.com/SomeUser/XYZ1.jl` is a user/org name? So the `@user` part acts as an additional filter on candidate packages based on their URL. That seems reasonable enough. That does also mean that if you write `add @SomeUser/YXZ` and there exists an `XYZ` package but it doesn't have a repo URL that we can parse a user name out of or it does but the user name doesn't match, then there will simply be a """"package not found"""" error. | [StefanKarpinski]: > Yea, but how is that different from\n> \n> ```\n> pkg> add Crayons\n> ```\n> that can also be a path but we fix that ambiguity by treating that as a package, which we can do here too.\n\nIt's not fundamentally, but it does mean that we'd be additionally relegating adding by relative path to more of a niche case. Perhaps that's ok, but I feel like `add vendor/SomePkg` is a pretty common use case—more common than having vendored packages in the top-level directory. We could go the other direction and say that people should always write the leading `./` for relative package adds. But I think that `@user` and `@org` are kind of nice since that is how you refer to them on GitHub and elsewhere.\n\nMy concern would be potential clash with using `@1.2.3` for version numbers, but I kind of want to unify version number specification with branch selection in terms of syntax, i.e. maybe use `#1.2.3` for version numbers the same way as we use `#master` to install from the master branch. Also, the `@user/name` pattern is fairly easy to syntactically distinguish from the trailing `@version` syntax. | [EricForgy]: > I'm not sure why there's any additional logic.\n\nYeah. I'm not sure either. I should have said """"might need to be some additional logic"""". \n\n> Which raises the question: where does the user name come from? Is it just that the system understands GitHub URLs and knows that the `SomeUser` part of `https://github.com/SomeUser/XYZ1.jl` is a user/org name? So the `@user` part acts as an additional filter on candidate packages based on their URL. That seems reasonable enough. That does also mean that if you write `add @SomeUser/YXZ` and there exists an `XYZ` package but it doesn't have a repo URL that we can parse a user name out of or it does but the user name doesn't match, then there will simply be a """"package not found"""" error.\n\nI never used `Base.@kwdef` and didn't even know about it until reading through some of the `Pkg` code. The cool thing about it is it seems you can add a `user` field to `Project`  without breaking anything. Then `user` could even be an optional field in `Project.toml`.\n\nIf it isn't in `Project.toml`, then as a last resort you can maybe try to deduce it from the GitHub url, but that seems fragile and maybe not worth it. If someone expects some potential future ambiguity, e.g. in my case I am thinking about `Countries.jl`, `Currencies.jl`, etc, they can just put a `user` in their `Project.toml`.\n\nThen it is a matter of including it in the filtering process like you say.\n\nWould that be something to consider, i.e. adding an optional field to `Project` that can be picked up from `Project.toml`? | [StefanKarpinski]: Having to put a user in the project file eliminates most of what makes this idea appealing to me, i.e. that it cannot be done wrong and starts working immediately. I don't see what's so fragile about pattern matching repo URLs when filtering packages. | [tk3369]: Somewhat off topic. How do you `using` two different packages that have the same name? | [fredrikekre]: You don't. | [DilumAluthge]: If I understand correctly, @StefanKarpinski's proposal in this issue is to do pattern-matching on the package URL to try to figure out the username or organization name.\n\nHere is a different proposal, which suggests explicitly adding namespaces to registries: https://github.com/JuliaLang/Pkg.jl/issues/1836",14,false,3,0,0,0,0,0,3,0,0
1747,"Problem with ""try `Pkg.resolve()`""",open,PetrKryslUCSD,,,,0,2020-04-04T15:36:38.0,2020-04-04T15:36:38.0,1932,1932,https://github.com/JuliaLang/Pkg.jl/issues/1747,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1747,"I ran into the missing dependency problem: [discourse thread](https://discourse.julialang.org/t/printf-as-a-dependency-missing-it-is-there/36998).\n\nThe suggested remedy was to do `Pkg.resolve()`. I have done that multiple times for both packages, but it had no effect.  However, updating the registry was the solution.\n\nIf this is the expected behavior, shouldn't the message say try resolve or update, instead of incorrectly suggesting that resolve will fix it?\n\n",,0,false,0,0,0,0,0,0,0,0,0
1731,support resuming downloads,open,StefanKarpinski,,feature request,,0,2020-03-22T18:49:56.0,2020-03-22T18:50:22.0,1945,1945,https://github.com/JuliaLang/Pkg.jl/issues/1731,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1731,"https://discourse.julialang.org/t/install-binary-package-such-as-openblas-jll-via-very-slow-internet-connection/36335\n\nIt would be a nice feature to allow resuming downloads by saving the partial download somewhere somewhat persistent if the client and server sides both support HTTP range requests. Kind of a fancy feature for the future, but it would be a really nice one for people on lousy connections.",,0,false,2,2,0,0,0,0,0,0,0
1706,Print correct URL in the presence of a `url.a.insteadOf=b` rule,open,goretkin,,,,2,2020-02-28T04:18:43.0,2020-02-28T14:24:32.0,1969,1969,https://github.com/JuliaLang/Pkg.jl/issues/1706,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1706,"The URL printed within:\nhttps://github.com/JuliaLang/Pkg.jl/blob/5345ec0a04fde1d83307982a686b2ecd31e1e8a5/src/GitTools.jl#L149\n\nmight not be the """"effective"""" URL used due to git URL rewriting with `insteadOf`:\nhttps://github.com/libgit2/libgit2/blob/aa4cd778b97d7271aa0ad12a4f9d492c443d5935/src/remote.c#L244-L245\n\nAn example of setting up such a rule within LibGit2:\n\n```julia\nimport LibGit2\nLibGit2.set!(LibGit2.GitConfig(LibGit2.Consts.CONFIG_LEVEL_DEFAULT),\n  """"url.https://gitlab-ci-token:$(ENV[""""CI_JOB_TOKEN""""])@gitlab.com:private_project/.insteadOf"""",\n  """"git@gitlab.com:private_project/"""")\n```","[StefanKarpinski]: Do you have any idea how to get that URL from libgit2? | [goretkin]: I wrote the extent of what I know (not much) in https://github.com/JuliaLang/julia/issues/34911 . \nbut now I've done some digging and here are all the related bits I found.\n\nOn the face of it, this is the most promising API call:\nhttps://libgit2.org/libgit2/#HEAD/group/remote/git_remote_url\n\nBut whether libgit2 applies the `insteadOf` rules is configured by some options (related issue: https://github.com/libgit2/libgit2/issues/4658) to `git_clone`(excerpt below):\nhttps://github.com/libgit2/libgit2/blob/aa4cd778b97d7271aa0ad12a4f9d492c443d5935/src/remote.c#L244-L248\n```c\n\tif (opts->repository && !(opts->flags & GIT_REMOTE_CREATE_SKIP_INSTEADOF)) {\n\t\tremote->url = apply_insteadof(config_ro, canonical_url.ptr, GIT_DIRECTION_FETCH);\n\t} else {\n\t\tremote->url = git__strdup(canonical_url.ptr);\n\t}\n```\n\nSo it would be really great to just access `remote->url` (from that context) directly. I'm guessing it exists in the below context as `(*origin)->url`:\nhttps://github.com/libgit2/libgit2/blob/dfea0713e04fa4f9f129b85c2262e7d0420aaaf3/src/clone.c#L423-L438\n\nSo it is looking like there's no way for libgit2 users to get it without recreating the logic related to `GIT_REMOTE_CREATE_SKIP_INSTEADOF`.",2,false,1,1,0,0,0,0,0,0,0
746,Docs and notion of active packages,open,KristofferC,,documentation,,1,2018-09-15T15:21:17.0,2020-02-28T10:37:00.0,2499,1969,https://github.com/JuliaLang/Pkg.jl/issues/746,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/746,"@mschauer commented on [Sat Sep 15 2018](https://github.com/JuliaLang/julia/issues/29199)\n\nI wanted to give feedback on some hidden assumptions and things unclear to me which might help in writing the docs.\n\n* Does `activate` """"do"""" something or does it only change a status? Does this status only affect `LOAD_PATH` and `Pkg`?\n* Does `activate` have any permanent or global effects, or only affect the current Julia process. \n* Activate's docstring mentions a `home project environment` but that is not in the glossary. There is also a circularity here I do not understand: Quoting """"If no argument is given to activate, activate the home project, which is the one specified by either --project command line when starting julia, or JULIA_PROJECT environment variable."""" What if no project-command is given and no JULIA_PROJECT is defined which is the standard? Similar issue with """"The depot path is controlled by the Julia DEPOT_PATH global variable which is populated at startup based on the value of the JULIA_DEPOT_PATH environment variable"""" This seems to have a default `~/.julia`?\n* """" The active environment is the environment that is\n  modified by executing package commands."""" Confusing, does not apply to `generate` for example.\n* The apparent difference between `current` and `active` project is too subtile, a warning should be added.\n\n\n",[moustachio-belvedere]: Some possible relevant discussion for reference:\n\nhttps://discourse.julialang.org/t/julia-is-missing-the-deactivate-command/22185/12\n\nhttps://discourse.julialang.org/t/how-do-i-re-activate-the-primary-default-environment-pkg3/24933,1,false,2,2,0,0,0,0,0,0,0
1634,Feature Request Registry: Refer to master branch if no version is defined,open,schlichtanders,,,,33,2020-01-26T10:33:50.0,2020-02-20T22:28:31.0,2002,1976,https://github.com/JuliaLang/Pkg.jl/issues/1634,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1634,"Dear Julia developers,\n\nbecause I recently switched my private development environment from Windows to Mac I needed a clean way to make my setup portable. I put everything into private git repositories and then tried to replicate everything on Mac, which turned out to be astonishingly complicated and not straightforward. This feature request is the idea I came up with after trying many different approaches.\n\n## Current ways to replicate a private development environment on another machine currently\n\nThe key problem is best described in https://github.com/JuliaLang/Pkg.jl/issues/1005. Let me quote it here again:\n\nLet's say we have created some local unregistered packages (A, B, C, D) in the following dependency graph:\n```\n    A\n   / \\n  B    C\n /\nD\n```\nIf we want to dev A we need to """"manually"""" resolve the dependency graph by doing:\n```\ndev path/to/D\ndev path/to/B\ndev path/to/C\ndev path/to/A\n```\n\n### Custom Script\nOne way is to write a custom script which installs all nested dependencies IN THE CORRECT ORDER. \n\nThat is not trivial to do and finally replicates what should be the responsibility of Pkg/Registries/or some other julia package infrastructure. Hence, this should be discouraged.\n\n### [Maybe possible in the Future] Using Manifest files\nWhen https://github.com/JuliaLang/Pkg.jl/pull/1088 is merged it gets possible to find nested dependencies by looking into the Manifest file of a package.\n\nThis would make it easy to develop locally on one machine, however when working cross several machines it still has a couple of disadvantages:\n* the Manifest file has to be checked-in into the repository (which is rather discouraged because a Manifest file is a local thing in 99% of the case)\n* locally during development, the Manifest file will still have paths pointing to locally checked-out develop version. I.e. the working Manifest file always differs from the checked in one. And one needs to be very careful not to commit/push a Manifest file with local dependencies as this will break the setup on the other machines\n* each single package needs its own curated Manifest file with correct dependencies, i.e. you have to handle the above complication for as many Manifest files as packages you develop \n\nHence this should not be the recommended option for cross machine replication neither.\n\n### Using a Local Registry\nFinally I experimented with private Registries. The initial setup is not perfectly easy yet, but thanks to https://github.com/GunnarFarneback/LocalRegistry.jl I could manage it.\n\nThe local registry has the advantage that only one central configuration needs to be maintained (namely the private registry) - way better than the X number of Manifest files. Also the registry is independent of Manifest files, so that no Manifest file needs to be checked-in (as usually recommended). Finally, Registries are perfectly supported, so that `add`, `dev` and everything just works.\n\n**The only disadvantage is that the current Registry implementation needs to have at least one version** for every registered package. However there is yet no stable version for the packages, as they are in private development stage for now. What I did is to fix a version onto a specific git hash, however it would be far more intuitive for this stage to fix the master branch instead.\n\n\n## Proposal to refer to master branch when no Version is given\n\nI think registries are the perfect place to share your development state. Whether it is for yourself or for your company, a private registry will be part of your julia infrastructure if you want to deal with your own private packages. Currently this only works well if your packages already reached at least one stable version, however before that you need to constantly maintain a dummy version.\n\n**My proposal is that if no version is given, instead of throwing an error that no version could be found, the package is installed by referring to master branch, just as if you would have installed it manually using ``] add mypackage#master``.**\n\nBenefits:\n* this mimics the behaviour of ``] develop`` which checks-out the repository in master by default\n* with this you no longer need to manually curate the dummy-version to point to the current master, but Pkg update will check master directly and fetch updates if their are any (this is the standard behaviour for packages installed as branch reference)\n* no """"mis-use"""" of Manifest.toml needed to share your development state\n* as the ``Versions.toml`` file is just empty, it is clear for everyone and any machine that the respective package has no stable version yet. In particular there is no need to point a real-version to a branch, which was discussed and discouraged [on discourse](https://discourse.julialang.org/t/can-versions-toml-point-to-git-branch-instead-of-fixed-git-commit/33442/5).\n* you finally have one go-to place to easily and clearly share all your development, even in the state where versions are not stable yet.\n\nIt would be a pleasure for me to implement it myself (it would be my first Julia contribution), in case this feature request gets approved.","[StefanKarpinski]: This issue seems like it should be on the Pkg.jl repo. (Transferred). | [schlichtanders]: @StefanKarpinski Thanks a lot for transferring the issue.\n\nAre others also interested in realising this feature? Any arguments speaking against it?\n\nTo summarize: I think this would simplify package development drastically by having one system (a registry) for all phases of development (no-first-version-yet as well as versioning-already-in-place) | [KristofferC]: If you have a package in the registry with no registered version, wouldn't `add Package#master` just work? | [schlichtanders]: @KristofferC this only works if you have a single package without any further dependencies in development.\n\nAs soon as your packages depend on one another, all dependencies are looked up in the registry (which is good), however then will be installed using the linked dummy version (current workaround as for today you need to add a version) and not with master branch.\n\nHaving the registry pointing to master if no version is registered fixes exactly this | [00vareladavid]: @schlichtanders I think #1628 might close this issue. It seems simpler than changing how registry resolution works | [schlichtanders]: @00vareladavid it is not clear to me how #1628 provides a solution for what I suggested here. \n\nIt speaks about adding a new a `source` config in the current project, which suggests to me that it cannot be maintained by a package developer like me, but each user has to maintain it on their own.\n\nThis feature request for the registry is meant to easily share your current setup without the need of a Manifest file in a clean, simple and intuitive manner. | [00vareladavid]: The `source` table will be automatically maintained by Pkg: it will detect unregistered dependencies and add them to the table.\n\n> One way is to write a custom script which installs all nested dependencies IN THE CORRECT ORDER.\n\nThis will be automatically handled by Pkg as well.\n\nNo need for manifest files or registries, since the `source` table will be in the Project file.\n\n | [rapus95]: Nevertheless the proposal described by @schlichtanders and the solution you propose @00vareladavid are orthogonal. I like the idea proposed by schlichtanders which simply proposes to use #master as the implicit initial version for any registered package. Thus, whenever someone requests to add a package to the registry but doesn't provide a hash & version the registry entry will point to HEAD of master. That way you can check-in a bleeding-edge/nightly package even before considering anything to be settled. Helps resolving dependencies and spreads a package before considering any API to be settled by any means. If i'd open a repo to discuss some new language feature (like a new interface) I'd like the registry to point to the current development state. Once all collaborators and I found common ground for the API of the first test iteration we'd release 0.1 | [fredrikekre]: This would make the registry mutable. | [rapus95]: this rather depends on your perspective, as Pkg#master is resolved by looking up the location on the registry and just going by the master on the found location. That's not fixed either. | [rapus95]: I might reformulate the proposal:\nstore no versions in the registry, just the location, if no hash&version are provided. And if Pkg gets an empty version return on checking with registry, default it to #master. I meant it to be a local only implementation. Not to literally point to and update the master HEAD hash in the registry.\n\nSimply said: If there are no tagged versions, the user probably wants to checkout master. That's the best I can assume in any case.\n\nIt'd also help to discover packages and register package names before subscribing to SemVer | [schlichtanders]: thanks @rapus95 for reformulating. That is exactly what I meant! | [schlichtanders]: To repeat, this proposal does not want to change the registry format at all, all stays the same as before.\nIt only adds the default that if no version is defined in the registry, the master branch of the repository is checked-out when resolved instead of throwing an error (e.g. either directly with `Pkg.add` or indirectly as a dependency of another package)\n\nTo the best of my current understanding, this would only be a minor change of default behaviour | [rapus95]: If that would still be considered a too-large-for-minor feature, it could be added with a flag.\nby for example -masterfallback or -allownoversion though, the latter might be misleading | [fredrikekre]: But that already works with `add Example#master`, and IMO that is much better since it is explicit that you use a fluctuating version. | [schlichtanders]: @fredrikekre ``add Example#master`` works only if ``Example`` has merely properly registered dependencies. That is not the case described here, but here we are concerned with more complex dependencies.\n\nHence for the scenario here, if you use a LocalRegistry with dummy versions, you would have to do ``add Example#master; add ExampleDependency1#master; add ExampleDependency1Dependency1-master; ... add ExampleDependencyNDependencyMDependencyK...#master``.\nWhich is tedious and error-prone, as if you forget to checkout one dependency with ``#master``, it will instead point to the current dummy version, which might rapdily go of sync or you need to maintain them too.\n\nIf you don't use a LocalRegistry, things are even worse, because you have to make sure, you are installing packages in the proper order, from deepest to highest, i.e. ``add ExampleDependencyNDependencyMDependencyK...#master;  add ExampleDependency1Dependency1-master; add ExampleDependency1#master; add Example#master;`` which is even more error-prone. | [fredrikekre]: The trick is to add them all in the same command, then you don't have to worry about ordering or anything.\n | [schlichtanders]: > The trick is to add them all in the same command, then you don't have to worry about ordering or anything.\n\nif this really works, then it improves it slightly, however I still need to construct this possibly giant add expression and keep it updated, if my package dependencies *somewhere* changes. Which stays a maintenance task which I better would like to have solved by a system meant for package maintenance (like Pkg). Also the user experience of installing a package is much more daunting then a simple `add registry ...` `add Example`.\n\nTo add a positive reason for this registry change: Somewhen my packages become stable enough for a version, and then I want registries anyway. | [rapus95]: > But that already works with `add Example#master`, and IMO that is much better since it is explicit that you use a fluctuating version.\n\nWhat do you mean by fluctuating? I thought there is no automatic updating in Julia? And if updating has to be done explicitely, we can't consider it fluctuating as it references the state when it was added. Also, that only works if the package had been registered in the registry. And as I understood it, for that, you need to specify a version. So all this is about, is to enhance usability explorability of yet unversioned but already named packages. Allow registering packages without a version and make versionless packages default to master on client side (if a given flag is provided)\n\n> The trick is to add them all in the same command, then you don't have to worry about ordering or anything.\n\nOnce you get to indirect dependencies this becomes hell if you need to fetch them manually. As an end result one probably will write a crawler macro which does that construct recursively. As opposed to something along the lines of `isempty(returnedversions()) && (version=:master)`. | [StefanKarpinski]: The current way version resolution works is that you can, from the registry alone, decide all of the versions of every package you need to install. What's being proposed would change that model considerably. You would have packages that have no registered versions. That means that you have no idea what they depend on until you've installed them. So maybe we could support that. You install a package with no registered versions and we just install master and look at what's required by the master version. But it's a whole different package resolution/installation strategy that needs to be developed, tested and maintained, not just a minor feature. It would require a total refactoring of how packages get resolved and installed. It also seems like with #1628 it might be possible to just commit a manifest file and have everyone in sync without this change. | [schlichtanders]: changing dependencies is a good point to consider.\n\nAs far as I understood the julia registry, dependencies are maintained in the registry via the Deps.toml file. See e.g. my little LocalRegistry, build with LocalRegistry.jl where the [dependencies of one of my package](https://github.com/schlichtanders/SchlichtandersJuliaRegistry.jl/blob/master/A/ASTParser/Deps.toml) have been tagged by `[0]` automatically. \n\nThe versions are maintained in the Versions.toml file. And for the same package, I already added two dummy versions with the help of LocalRegistry.jl, namely [``[0.1.0]`` and ``[0.1.1]``](https://github.com/schlichtanders/SchlichtandersJuliaRegistry.jl/blob/master/A/ASTParser/Versions.toml). As you see, the are both different than the tag `[0]` in the Deps.toml.\n\n**This looks like that dependencies can be separately maintained from the concrete versions, and hence should also be able to be maintained without versions at all, and without changing the entire package resolution/installation strategy**. \n\nOf course then you still need to maintain the *direct dependencies* for every project, point taken, but this is still much better to maintain and a much better user experience compared to the current solutions with self-crawling all the *nested dependencies* for every project. | [StefanKarpinski]: The keys are patterns which match concrete versions in the `Versions.toml` file. This is done consistently for `Deps.toml` and `Compat.toml`. The actual meaning of these files is that they represent data about each version in `Versions.toml` in a compressed format where each stanza heading is a pattern that matches all the versions to which a stanza applies (which has that set of properties) and not to any others. A header in `Deps.toml` or `Compat.toml` that doesn't match any versions in `Versions.toml` is nonsense—it does not mean anything. We could try to make it mean something, but that feels like a slippery slope that's undermining the well-defined and fairly logical way that these files represent information about package versions.\n\n | [rapus95]: How about designing it as an interactive fallback which holds if resolving doesn't find a version? (Either by version restrictions or due to missing versions at all).\n```julia\n...resolving...\nCouldn't resolve to a version.\nDo you like to install the latest version(#version*)? [y/n]\n```\nwhere `version*` resolves to the latest registered version or #master if there's none. After accepting that there's an explicit entry which can be added to the Manifest.toml. The only other thing we'd need then is an argument option which allows us to `-y` recursively.\n | [schlichtanders]: @StefanKarpinski I see now that it is not an one line change then, unfortunately. Nevertheless I think the main advantage of this feature suggestion is still worth it.\n\nIf I understood it correctly, the current toml-tablenames in Deps.toml fail in that they semantically describe a version. e.g. `[0]` describes the versions 0.0.0 to 0.99.99 kind of, but not no-version-at-all.\n\nFor me it seems best to relax this definition just for ``[0]``, that it also refers to the case where no version at all is given. That slightly breaks the logic, but not much and has the benefit that dependencies defined for no-version will probably be used forward when the first version 0.0.1 is out. | [rapus95]: @schlichtanders the definition for `[0]` is correct as it allows all versions which have a 0 as their major version. So it'd be a `[]` which allows all versions that are tagged if I generalize correctly. By that there indeed is no taggable """"I wan't it even if there are no versions tagged"""". That's very consistent though I'd say. That's why I suggested to make it a option to explicitly fallback to the master in that case. That way we don't change anything about the format and the dependency management. But instead add it as a pure convenience function which needs to be supplied on caller instead of callee | [StefanKarpinski]: You are focusing too much on the syntax. Think about it this way: there is no such thing as the dependencies of a package. Only specific versions of packages have dependencies. The registry records concrete facts about the dependencies and compatibility of specific versions of packages. What yous are suggesting is that we change that so that there is some notion of dependencies and compatibility of a package absent any particular version. What happens when you change the dependencies in your local copy of one of those packages? There's no registration process, so now the actuality of that package is out of sync with what the registry claims about the package as a whole. I'm afraid that's a non-starter. It would be better to allow installing the master version of a registered package without versions and just follow whatever dependencies that version has, although, frankly, that also seems like a nightmare that's unlikely to work well.\n\nAgain, we should see if #1628 doesn't fix the situation without any of this since it will allow sharing manifests for unregistered packages more smoothly. | [schlichtanders]: thanks @StefanKarpinski for you patience with me here. So Deps.toml is no option for a fallback to `master`. I understood that. \n\nSeems like the proposal then would be:\n- allow no-version-at-all\n- fallback to master branch\n- derive dependencies dynamically in this case by first cloning the master and then checking the dependencies\n\nMuch more work than initially thought, but still might be worth it because of the already mentioned reasons. | [schlichtanders]: @rapus95 thank you too for your support. I am not yet sure what is the best way to have a fallback (no-version-at-all, explicit-flag, ...). I prefer the no-version-at-all because it is self-explanatory, but I am open.\nThe dependency-issue however applies to all these different suggestions and hence should be clarified first. Is it reasonably to extend Pkg to allow dynamic dependency lookup for the purpose of this feature-request? | [StefanKarpinski]: > Is it reasonably to extend Pkg to allow dynamic dependency lookup for the purpose of this feature-request?\n\nI think you'll have to come up with a plan for how to do this. You'll probably want to model no-registered packages as having a single version, with the only version being the master one. You'll have to fill in the dependencies of that one version and then follow its graph of dependencies, etc. Note that this means that if anything _might_ depend on one of these packages with no registered versions, you'll have to download it to figure out the potential dependency graph no matter whether you end up needing to use it in the end or not. | [schlichtanders]: Considering naming, I would describe the standard packages as """"registered package with fixed version"""", and the newly proposed packages which fall back to master as """"registered packages without any fixed version"""".\n\nI would only need to download a package to check for dependencies in the following case:\n- it is directly going to be installed or a dependency of something going to be installed\n- and the package has no registered version yet, hence the fallback to clone master\nIn any case, the situation is that I need this package.\n\nLet me sketch what needs to be implemented/done:\n1. we trigger package installation via `Pkg.add(""""mypackage"""")`\n2. we cannot find a registered version, but can grab the repository url from the registry and hence fall back to `Pkg.add(""""mypackagerepositoryurl#master"""")`\n3. the package gets cloned with the important difference that we don't throw an error if a dependency has no registered version yet\n4. instead we recurse to point (1.) such that `Pkg.add(""""mydependency"""")` actually triggers `Pkg.add(""""mydependencyrepositoryurl#master"""")`\n5. Maybe all this has to be done depth first recursively such that if `Pkg.add(""""mypackagerepositoryurl#master"""")` finishes, all sub-dependencies are already installed. However as we know that after the installation everything will be installed, the order of installation may actually be not important at all, we just assume that everything needed will be there\n6. we would need to implement a roll-back mechanism in case somewhere in the dependencies an error happens, like referring to a package that cannot be find in the registry at all. Of course in this case nothing should be installed.\n\nOverall, this looks quite feasible for me. The most complicated part seems to be to have proper roll-back in case of error.\n | [StefanKarpinski]: > * it is directly going to be installed or a dependency of something going to be installed\n\nThe problem is that you need to know what the dependencies of such a package are before you know what's going to be installed. You have to install any of these registered-with-no-version packages if you're even _considering_ installing anything that depends on it. You can't know if you are going to install something until you've built the entire graph of versions that you might potentially install and then done version resolution. For example, you might want to add package A whose most recent version A-1.2.3 depends on your registered-with-no-versions package B, which in turn depends on C which has a conflict with A-1.2.3. The resolution might therefore decide that you have to use an older version of A, say A-1.0.3, which doesn't depend on B at all. So you end up needing to install B to build the dependency graph, but not actually using it.\n\n> Let me sketch what needs to be implemented/done:\n\nYou need to resolve a compatible set of versions first. You can't just try installing things and see what happens. What happens when you pick some version early on, then install one of your semiregistered packages and then find that it has a conflict with something you've already committed to? The whole thing just fails even though there may be a way to install things? I'm afraid that's unacceptable. What you're proposing is trying to solve an NP-hard optimization problem—version resolution—by hoping for the best. I can assure you that doesn't work. | [schlichtanders]: thanks for showing the real complexity of installing packages. Still that might be worth it... but I am not sure any longer\n\nso I agree that it seems better to first wait for #1628 and see whether it is a good enough solution\n\n@StefanKarpinski thanks a lot! | [StefanKarpinski]: It is possible to do it: while building the graph of potentially installable versions, you have to download the master version of any no-version package when you get to it and then continue building the graph of potentially installable versions from there. Then you do normal version resolution. You might end up installing no-version packages that you didn't actually need, but that's not the worst thing in the world and it's at most one version per no-version package. Still, it's a lot of complexity for something that might be handled better by sharing manifests.",33,false,1,0,1,0,0,0,0,0,0
1689,Ability to pass `test_args` when using `] test MyPackage` in the REPL mode [Feature Request],open,DilumAluthge,,,,3,2020-02-19T03:13:56.0,2020-02-19T18:04:37.0,1978,1977,https://github.com/JuliaLang/Pkg.jl/issues/1689,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1689,"I can pass arguments to the test process by using the `test_args` keyword argument to `Pkg.test`. See https://github.com/JuliaLang/Pkg.jl/pull/1226 and https://github.com/JuliaLang/Pkg.jl/pull/1688 for more details.\n\nCurrently, there is no way to pass `test_args` when using the REPL mode, i.e. when doing `] test MyPackage`.\n\nIt would be really convenient to be able to do so.","[DilumAluthge]: cc: @00vareladavid | [DilumAluthge]: @fredrikekre suggested in https://github.com/JuliaLang/Pkg.jl/pull/1226#issuecomment-503426739 that we probably only need to add support for passing `test_args` in the REPL mode, since `julia_args` will not be used very often. | [00vareladavid]: I think it is a good idea. I think Fredrik's proposed syntax `pkg> test Example -- arg1 arg2` is good for this. We will have to adjust the REPL parsing a bit for this to work though",3,false,9,9,0,0,0,0,0,0,0
1687,Feature Request: add flag build = true(default) /verbose/false) to instantiate/add,open,Crown421,,,,0,2020-02-18T22:31:49.0,2020-02-18T22:31:49.0,1978,1978,https://github.com/JuliaLang/Pkg.jl/issues/1687,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1687,"In the last couple of months I have often had a situation where I am playing around with my Project and Manifest files, or set up fresh (containered / CI) environments. \nAs I am learning, I often made mistakes, and then had the problem that because `instantiate` and `add` build by default. In my particular environment this usually took a long time to finish because some packages (MKL.jl, CMake) take a long time. \n\nWould it be possible to add more control to the commands by adding the option to turn of the build, or make it verbose for everything?",,0,false,0,0,0,0,0,0,0,0,0
1676,Change `up --patch` to never update anything that is pre-1.0,open,oxinabox,,,,0,2020-02-14T19:51:33.0,2020-02-14T19:51:33.0,1982,1982,https://github.com/JuliaLang/Pkg.jl/issues/1676,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1676,"A discussion @omus and I were having.\n\nGiven that: \n\n - For pre-1.0 packages: a change to `y` in `0.x.y` does not indicate a **patch** (in the normal sense), but any **nonbreaking** change including a new feature,\n - the presumed goal of `up --patch` is to minimize the number of changes being made to your dependencies that are not just bug-fixes.\n\nIt would make sense not to update a pre-1.0 package, as that might well get you a feature you didn't want.\n\nPlus, in general pre-1.0 packages are unstable and thus more likely to have random errors introduced, so once you have a version of one that is well tested / confirmed to work for your use case, in your Manifest.toml \nyou might want to just leave it alon, except when required to update something else.\n\nRight now therre is no way to do this without changing to tilde versioning in the Project.toml (potentially a good idea, but with its own pros and cons, so lets leave it out of this discussion)\n\n\n---\n\nTo put the suggestion another way:\n\nI propose that we change `up --patch` to only affect packages that have tagged a major release (i.e. have got up to version 1.0 or more)",,0,false,1,1,0,0,0,0,0,0,0
1665,docs: add artifacts to the glossary,open,StefanKarpinski,StefanKarpinski,documentation,,0,2020-02-11T15:30:14.0,2020-02-11T15:30:14.0,1985,1985,https://github.com/JuliaLang/Pkg.jl/issues/1665,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1665,"The [glossary](https://julialang.github.io/Pkg.jl/v1/glossary/) needs to be updated to reflect artifacts. It still lists """"libraries"""" as future work, which is not going to happen since we decided to go with JLLs which are just autogenerated packages.",,0,false,1,1,0,0,0,0,0,0,0
1657,Error on instantiate with invalid artifact,open,KristofferC,staticfloat,artifacts,,4,2020-02-05T15:23:19.0,2020-02-06T06:52:13.0,1991,1991,https://github.com/JuliaLang/Pkg.jl/issues/1657,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1657,"```\n(pkg> instantiate\n┌ Error: Invalid artifacts file at 'Artifacts.toml': platform-specific artifact entrty 'x86_64-w64-mingw32' missing 'arch' key\n└ @ Pkg.Artifacts D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\Artifacts.jl:399\nERROR: MethodError: Cannot `convert` an object of type Nothing to an object of type Pkg.BinaryPlatforms.Platform\nClosest candidates are:\n  convert(::Type{T}, ::T) where T at essentials.jl:168\nStacktrace:\n [1] setindex!(::Dict{Pkg.BinaryPlatforms.Platform,Dict{String,Any}}, ::Dict{String,Any}, ::Nothing) at .\dict.jl:372\n [2] Dict{Pkg.BinaryPlatforms.Platform,Dict{String,Any}}(::Base.Generator{Array{Dict{String,Any},1},Pkg.Artifacts.var""""#21#22""""{String,String}}) at .\dict.jl:103\n [3] #artifact_meta#20(::Pkg.BinaryPlatforms.Platform, ::typeof(Pkg.Artifacts.artifact_meta), ::String, ::Dict{String,Any}, ::String) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\Artifacts.jl:552\n [4] (::Pkg.Artifacts.var""""#kw##artifact_meta"""")(::NamedTuple{(:platform,),Tuple{Pkg.BinaryPlatforms.Windows}}, ::typeof(Pkg.Artifacts.artifact_meta), ::String, ::Dict{String,Any}, ::String) at .\none:0\n [5] #ensure_all_artifacts_installed#43(::Pkg.BinaryPlatforms.Platform, ::Nothing, ::Bool, ::Bool, ::typeof(Pkg.Artifacts.ensure_all_artifacts_installed), ::String) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\Artifacts.jl:908\n [6] #ensure_all_artifacts_installed at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\Operations.jl:0 [inlined]\n [7] #download_artifacts#78(::Pkg.BinaryPlatforms.Windows, ::Bool, ::typeof(Pkg.Operations.download_artifacts), ::Array{String,1}) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\Operations.jl:580\n [8] #download_artifacts at .\none:0 [inlined]\n [9] #instantiate#114(::Nothing, ::Bool, ::Bool, ::Pkg.BinaryPlatforms.Windows, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.instantiate), ::Pkg.Types.Context) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\API.jl:737\n [10] instantiate(::Pkg.Types.Context) at D:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.3\Pkg\src\API.jl:720\n```","[staticfloat]: What do you think it should do here?  With an invalid artifact entry, it can't know what artifact to download in order to instantiate properly. | [StefanKarpinski]: Probably give as clear an error as possible about what the error is. | [fredrikekre]: Probably the `@error` should just be an `error`. Certainly we should not get as far as reaching the `setindex!` with a `nothing` key. | [KristofferC]: Yeah, if it can't handle an invalid artifact file """"cleanly"""" it should probably just hard error with a good error message.",4,false,0,0,0,0,0,0,0,0,0
1644,Introduce a cache for devved packages,open,KristofferC,,,,1,2020-01-29T12:54:04.0,2020-01-29T14:07:46.0,1999,1999,https://github.com/JuliaLang/Pkg.jl/issues/1644,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1644,"For packages that we dev we need the full git repo. Right now we just clone the repo from scratch on `dev`. It should be possible to keep a """"cache repo"""" where the latest version is checked out from. In fact, we used to have such a cache but it was bugged so that old versions were kept in the cached repo which lead to weird inconsistencies and frustrations.",[StefanKarpinski]: It should be possible to use an existing git repo as a reference for objects without cloning from it. I'm not sure if LibGit2 supports it but command-line `git` certainly does. See the `--reference` option for git clone: https://git-scm.com/docs/git-clone.,1,false,1,1,0,0,0,0,0,0,0
1527,Do not offer to autocomplete `] add` with _jll packages,open,cossio,,,,12,2019-12-04T20:57:50.0,2020-01-10T14:00:22.0,2054,2018,https://github.com/JuliaLang/Pkg.jl/issues/1527,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1527,"For example, if I type\n\n```\n] add Cairo\n```\n\nand hit TAB, it offers to autocomplete to both `Cairo` and `Cairo_jll`. Since the later is not intended to be installed by typical users, perhaps it should not be offered as an autocomplete option. The `_jll` options pollute the autocomplete offerings.\n\nIf someone needs to install a `_jll` for some reason, they can always type it out.","[giordano]: Package developers will need to `]add` a JLL package to their projects, removing them from the list of autocompleting packages would be a regression for those users. | [DilumAluthge]: Perhaps make it a configuration option? Certainly sounds like it will be annoying to users to have the JLL packages always come up in autocomplete. Would be simple to have a configuration option, maybe in your Julia startup file, to include JLL packages in the autocomplete lot. | [KristofferC]: I don't think many people will explicitly add jll packages. I think some custom handling for them in the status output and tab completions make sense. | [00vareladavid]: We could do something like `pkg> add --jll Cairo` which would add `Cairo_jll` | [ssfrr]: I don't know, I kind of like the fact that JLL packages are just regular Julia packages. It's cool that any user can easily pull in binary packages and start writing code that `ccall`s into them.\n\n(edit: also it's nice that the same dependency mechanism to pull in dependencies works exactly the same for JLL packages. If they're special-cased in the pkg REPL would they be special-cased in Project.toml files as well?)\n\nI'd suggest waiting it out to see if it's actually a problem in practice. It seems like it would be kind of finicky to decide which packages should be tab-completed, and not worth the confusion when you tab-complete and a package you expected to show up doesn't, because it was decided that it's not user-facing enough. For instance, most of the FooBase packages aren't really intended to be used by end-users, they're meant for other packages to depend on. | [KristofferC]: After using 1.3 for a while, yes, we need to do something about this. Having a huge number of \n\n```\n  [1082639a] + Xorg_libXext_jll v1.3.4+0\n  [ea2f1a96] + Xorg_libXrender_jll v0.9.10+0\n  [14d82f49] + Xorg_libpthread_stubs_jll v0.1.0+0\n  [c7cfdc94] + Xorg_libxcb_jll v1.13.0+0\n  [21e99dc2] + Xorg_renderproto_jll v0.11.1+0\n  [7c09cfe3] + Xorg_util_macros_jll v1.19.2+0\n  [c2e9c405] + Xorg_xcb_proto_jll v1.13.0+0\n  [d13bc2ba] + Xorg_xextproto_jll v7.3.0+0\n```\n\nentries in your status output is frustrating.\n\nThese packages are not normal packages, they are automatically generated and does almost nothing (sets a few env variables and dlopens).\n\nWhen adding a package adds 90 `FooBase` packages, we can talk about those as well | [ssfrr]: Yeah, as this has rolled out and users have been confused or frusturated I'm starting to see the logic of special-casing `jll` packages in the `pkg` REPL prompt. I don't really like the syntax of `pkg> add --jll Cairo` adding `Cairo_jll`, but I could see a `--jll` flag toggling whether `_jll` packages are displayed in output. | [StefanKarpinski]: Would `export JULIA_PKG_SHOW_JLLS=true` or something like that be too rudimentary, defaulting to off? | [fredrikekre]: Why not use `-v/--verbose`? | [StefanKarpinski]: Sure, that may be better. | [KristofferC]: You might want to be in a """"jll mode"""" (when you are developing jll stuff) where you care about jll packages but perhaps don't want everything to be written verbosely. We could try with verbose for now and then add a jll mode if needed. | [rapus95]: I came here when searching for the artifact repl mode (seems like there is none, why?) and now I think as jll packages are always some sort of artifact/binary dependency how about introducing some new repl mode for handling those?\n\nThen we have\n* package mode: new functionality as julia code (jl)\n* registry mode: (new) package lookup capabilities (lookup of jl & jll)\n* binary/artifact mode: julia-external dependencies (jll)\n\nSure that's not an exact distinction since jll packages technically are standard julia packages, but I'd not compare them by capability but purpose. As they mostly consist of some sort of (auto-generated) glue code into some other environment, my understanding is that their purpose is to abstract some of the externals away (hide them behind julia variables/attributes and drag versioning into the Julia domain). Being normal packages just makes them being some sort of pimped externals abstraction in that sense that they can do arbitrary stuff.\n\nTl;Dr:\nRegarding their purpose, artifacts & jll packages feel very similar. FWIW, adding a new artifact/binary repl mode to Pkg.jl where jll dependencies and artifacts can be managed would stop the pollution while grouping the external(=outside julia) dependency management utilities more logically + adding some interactive repl convenience for artifact management.",12,false,3,2,0,0,0,0,1,0,0
1598,Use @test_logs to test for hash errors,open,KristofferC,,,,0,2020-01-08T07:36:35.0,2020-01-08T07:36:35.0,2020,2020,https://github.com/JuliaLang/Pkg.jl/issues/1598,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1598,Right now they are just printed to the test output which makes it look like something is wrong.,,0,false,2,2,0,0,0,0,0,0,0
1593,Pkg API issues,open,00vareladavid,,,,0,2020-01-06T19:09:40.0,2020-01-06T19:09:40.0,2021,2021,https://github.com/JuliaLang/Pkg.jl/issues/1593,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1593,"Some things that bug me in the current API:\n- `free` should only change unregistered packages to registered packages. `unpin` should be a second command. There should be no overlapping functionality between the two.\n- `add`/`dev` should  decide whether to store relative paths or absolute paths based on an explicit flag/option, not on `isabspath`. The difference is way too subtle, even for the REPL.\n- `activate` should only `activate` a `dev` package with an explicit flag e.g. `activate --dep SomeDep`\n- `dev --local` should be the default option. We should default to using local state and only load global state if that really is the intention of the user.\n\nI would be very happy to change all of these, but it would technically be breaking. Some of them are subtle enough that I doubt people are relying on the specific behavior.",,0,false,0,0,0,0,0,0,0,0,0
1574,error logging,open,00vareladavid,,enhancement; speculative,,2,2019-12-31T03:06:44.0,2020-01-03T01:34:39.0,2028,2025,https://github.com/JuliaLang/Pkg.jl/issues/1574,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1574,"Not sure how practical it would be, but errors like #1570 make me think we could have some kind of error logging. If Pkg hits an error, we could write thing like the active TOML files to some log so that we have a better chance of reproducing errors in the future. Its frustrating seeing bugs in the wild and not being able to reproduce them.\n\nWould this be worth the effort? What kind of things should be logged? Any prior work for inspiration?","[StefanKarpinski]: Definitely a good idea! We should definitely record these when there's an error. How about `env = joinpath(expanduser(""""~/.julia/logs/pkg_errors/environments/""""), randstring(10))`, copy `Project.toml` and `Manifest.toml` into that directory, and record an entry like this:\n```\n[$env]\ncommand = """"add Foo""""\ntimestamp = 2020-01-02T18:39:44.609Z\n```\nAnd maybe whatever else we'd want to record. | [StefanKarpinski]: We'd also want to hook these into GC and retire them after a month or something like that.",2,false,2,2,0,0,0,0,0,0,0
1542,Add `update --all` flag to also update lower stacked environments,open,ssfrr,,,,0,2019-12-11T18:02:34.0,2019-12-11T18:02:34.0,2047,2047,https://github.com/JuliaLang/Pkg.jl/issues/1542,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1542,"I'm usually inside a per-project environment, and running `] up`  doesn't touch my base environment, so I often forget to update my dev tools (Juno, Revise, etc.) for a long time. I see the trade-off and I don't think it's necessarily best to update all nesting environments by default, but maybe an `]up --all` switch?",,0,false,1,1,0,0,0,0,0,0,0
687,Better error message for`Pkg.add()` when url is wrong.,open,KristofferC,,error handling,,3,2018-08-23T10:18:15.0,2019-11-20T18:00:45.0,2523,2068,https://github.com/JuliaLang/Pkg.jl/issues/687,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/687,"@jakebolewski commented on [Mon Aug 22 2016](https://github.com/JuliaLang/julia/issues/18185)\n\nIt currently just dumps out the LibGit HTTP status code error with no explanation.\n\n```\njulia> Pkg.clone(""""https://github.com/JuliaLang/wrong"""")\nINFO: Cloning wrong from https://github.com/JuliaLang/wrong\nUsername for 'https://github.com':jakebolewski\nPassword for 'https://jakebolewski@github.com':\nERROR: GitError(Code:ERROR, Class:Net, Unexpected HTTP status code: 404)\n in macro expansion at ./libgit2/error.jl:99 [inlined]\n in clone(::String, ::SubString{String}, ::Base.LibGit2.CloneOptions) at ./libgit2/repository.jl:191\n in #clone#109(::String, ::Bool, ::Ptr{Void}, ::Nullable{Base.LibGit2.AbstractCredentials}, ::Function, ::String, ::SubString{String}) at ./libgit2/libgit2.jl:327\n in clone(::String, ::SubString{String}) at ./pkg/entry.jl:195\n in clone(::String) at ./pkg/entry.jl:221\n in (::Base.Pkg.Dir.##2#3{Array{Any,1},Base.Pkg.Entry.#clone,Tuple{String}})() at ./pkg/dir.jl:31\n in cd(::Base.Pkg.Dir.##2#3{Array{Any,1},Base.Pkg.Entry.#clone,Tuple{String}}, ::String) at ./file.jl:59\n in #cd#1(::Array{Any,1}, ::Function, ::Function, ::String, ::Vararg{Any,N}) at ./pkg/dir.jl:31\n in clone(::String) at ./pkg/pkg.jl:151\n```\n\n\n---\n\n@citisolo commented on [Sun Sep 18 2016](https://github.com/JuliaLang/julia/issues/18185#issuecomment-247847353)\n\nWhat kind of information would be appropriate for the error?\n\n\n---\n\n@kshyatt commented on [Wed Sep 21 2016](https://github.com/JuliaLang/julia/issues/18185#issuecomment-248502978)\n\n@citisolo something like `Provided url $url is invalid`, maybe?\n\n\n","[00vareladavid]: Obviated by #1356 | [KristofferC]: ```\njulia> Pkg.add(PackageSpec(url=""""https://github.com/JuliaLang/wrong""""))\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Cloning git-repo `https://github.com/JuliaLang/wrong`\nERROR: failed to clone from https://github.com/JuliaLang/wrong, error: GitError(Code:ERROR, Class:Net, unexpected HTTP status code: 404)\nStacktrace:\n [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:113\n [2] #clone#4(::Nothing, ::Base.Iterators.Pairs{Symbol,Any,Tuple{Symbol,Symbol},NamedTuple{(:isbare, :credentials),Tuple{Bool,LibGit2.CachedCredentials}}}, ::typeof(Pkg.GitTools.clone), ::String, ::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/GitTools.jl:131\n [3] shred!(::Pkg.Types.var""""#73#75""""{String,String}, ::LibGit2.CachedCredentials) at ./none:0\n [4] clone_path! at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:636 [inlined]\n [5] resolve_repo_add!(::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:716\n [6] handle_repo_add!(::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:732\n [7] handle_repos_add!(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:751\n [8] #add#25(::Bool, ::Pkg.BinaryPlatforms.Linux, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.add), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:90\n [9] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:72\n [10] #add#24 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:69 [inlined]\n [11] add at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:69 [inlined]\n [12] #add#20 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:66 [inlined]\n [13] add(::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:66\n [14] top-level scope at REPL[2]:1\ncaused by [exception 1]\nGitError(Code:ERROR, Class:Net, unexpected HTTP status code: 404)\nStacktrace:\n [1] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/LibGit2/src/error.jl:101 [inlined]\n [2] clone(::String, ::String, ::LibGit2.CloneOptions) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/LibGit2/src/repository.jl:459\n [3] #clone#131(::String, ::Bool, ::Ptr{Nothing}, ::LibGit2.CachedCredentials, ::Dict{Symbol,Tuple{Ptr{Nothing},Any}}, ::typeof(LibGit2.clone), ::String, ::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/LibGit2/src/LibGit2.jl:580\n [4] #clone at ./none:0 [inlined]\n [5] #clone#4(::Nothing, ::Base.Iterators.Pairs{Symbol,Any,Tuple{Symbol,Symbol},NamedTuple{(:isbare, :credentials),Tuple{Bool,LibGit2.CachedCredentials}}}, ::typeof(Pkg.GitTools.clone), ::String, ::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/GitTools.jl:123\n [6] shred!(::Pkg.Types.var""""#73#75""""{String,String}, ::LibGit2.CachedCredentials) at ./none:0\n [7] clone_path! at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:636 [inlined]\n [8] resolve_repo_add!(::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:716\n [9] handle_repo_add!(::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:732\n [10] handle_repos_add!(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Types.jl:751\n [11] #add#25(::Bool, ::Pkg.BinaryPlatforms.Linux, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.add), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:90\n [12] add(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:72\n [13] #add#24 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:69 [inlined]\n [14] add at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:69 [inlined]\n [15] #add#20 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:66 [inlined]\n [16] add(::Pkg.Types.PackageSpec) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/API.jl:66\n [17] top-level scope at REPL[2]:1\n``` | [00vareladavid]: Ah, I should have known `Pkg.add` triggers this too. Thanks for correcting",3,false,0,0,0,0,0,0,0,0,0
837,"dev should also check for ""MyPackage.jl"" directory (and not just ""MyPackage"")",open,cossio,,feature request,,4,2018-10-16T18:16:46.0,2019-10-30T12:31:13.0,2468,2090,https://github.com/JuliaLang/Pkg.jl/issues/837,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/837,"When `pkg> dev MyPackage` finds a directory named `MyPackage` inside my dev directory, it emits a message like:\n\n> [ Info: Path `.julia_depot/dev/MyPackage` exists and looks like the correct package, using existing path instead of cloning\n\nBut if there is a directory named `.julia_depot/dev/MyPackage.jl` instead of `.julia_depot/dev/MyPackage` (as usually happens when I clone using git directly), Pkg will not detect it and proceed to clone a fresh copy into `MyPackage`, ignoring `MyPackage.jl`. \n\nI think it would be nicer that Pkg detected both directory names `MyPackage` and `MyPackage.jl` under `dev`.","[StefanKarpinski]: Or maybe we should just standardize on using the `.jl` version for dev'd packages? Otherwise you end up with weird stuff like the possibility of having both and having to decide which takes precedence. | [cossio]: In that case `generate` also needs to be changed for consistency (currently it generates a `MyPackage` dir, not a `MyPackage.jl` dir) | [fredrikekre]: If you have cloned it you can with advantage just `dev` the path instead. Personally I like the folders without `.jl`. | [rfourquet]: So I run into this issue, I will reiterate what I said in the closed duplicate #1478 :  it's not only a matter of convenience. Sure if you are aware of the poblem, """"you can with advantage just dev the path instead"""" (which is inconvenient, and I'm not sure about the """"with advantage""""). But otherwise, if you know that you have a package in your dev folder, it's *really* confusing to have `pkg> dev MyPackage` followed by `julia> using MyPackage` not use the git repository """"MyPackage.jl"""" you had and possibly were working with. \n\nThe workaround is to always remember to give an explicit destination name to git-clone, e.g. `$ git clone git@github.com:JuliaLang/Pkg.jl.git Pkg` (but I would prefer my system to take care of this for me).\n\n> you end up with weird stuff like the possibility of having both and having to decide which takes precedence\n\nThe current behavior leads to getting both in your dev folder, and the user has to decide which to use... If Pkg was checking for both before cloning, you can still end up with both if the user clones manually after having had Pkg clone it via `dev`ing. I believe this is more unlikely.\n\nI would vote for Pkg erroring when the two names are found, as it's probably the symptom of a problem the user is not aware of, and that should be resolved before proceeding.",4,false,3,2,1,0,0,0,0,0,0
1467,Document automatic unpacking of artifacts,open,KristofferC,,documentation; artifacts,,0,2019-10-22T14:00:43.0,2019-10-22T14:00:43.0,2098,2098,https://github.com/JuliaLang/Pkg.jl/issues/1467,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1467,There are some hints that says that things will be unpacked. But it doesn't say when this happens (is it based on the extension of the file in the URL)? Or in the resulting filename?\n\nI have a file that ends in `.exe` (an installer) but that I still want 7z to unpack. Do I need to repack it into a `tar.gz` even though `7z` on Windows can unpack it straight up?,,0,false,0,0,0,0,0,0,0,0,0
1465,Better error message when failing to find an artifact due to missmatching os / libc,open,KristofferC,,error handling; artifacts,,0,2019-10-22T13:24:17.0,2019-10-22T13:24:17.0,2098,2098,https://github.com/JuliaLang/Pkg.jl/issues/1465,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1465,"```\njulia> ensure_artifact_installed(""""c_simple"""", """"Artifacts.toml"""")\nERROR: Cannot locate artifact 'c_simple' in 'Artifacts.toml'\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] #ensure_artifact_installed#41(::Pkg.BinaryPlatforms.Linux, ::Nothing, ::Bool, ::typeof(ensure_artifact_installed), ::String, ::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Artifacts.jl:784\n [3] ensure_artifact_installed(::String, ::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Pkg/src/Artifacts.jl:782\n [4] top-level scope at REPL[7]:1\n\njulia> haskey(Pkg.TOML.parsefile(""""Artifacts.toml""""),""""c_simple"""")\ntrue\n```\n\nThe problem here was that `c_simple` has a `libc = musl` which I guess didn't match my installation but perhaps the error message could be changed to say that the artifact name was found but didn't match.",,0,false,1,1,0,0,0,0,0,0,0
1439,Vendoring Python Wheels as Artifacts,open,staticfloat,,speculative,,2,2019-10-10T01:36:41.0,2019-10-17T00:10:08.0,2110,2103,https://github.com/JuliaLang/Pkg.jl/issues/1439,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1439,"We have a pretty good python interop story, but it lacks many of the reproducibility guarantees that Pkg3 has; in particular, when using python packages from the system, or even from `Conda.jl`, because the python dependencies are managed separately from the Julia dependencies, it is possible for Julia and python packages to get out of sync and break.  To resolve this, I propose a technique for creating python """"virtual environments"""" for more fully controlled python installations.\n\nSystem design constraints:\n\n* `pkg> instantiate` should """"just work"""".  No matter how much time has passed, you must be able to get back the same python packages as you had before, so that PyCall, IJulia, etc... can all """"just work"""" far off into the future, no matter how much breaking progress the python ecosystem experiences.\n\n* Upgrading Python packages should be simple.  Not via `pkg> upgrade`, but through some relatively simple mechanism.\n\n* Isolation from the system.  System python packages should not interfere or aid in these packages at all.\n\nReading this list of design constraints, you might think that this sounds an awful lot like what I've been working on towards JLL packages/Pkg Artifacts, and you would be correct.  At least I'm consistent in the kinds of ideas I come up with.  Since Artifacts are the 'marteau du jour', as it were, let's recklessly apply them here and see what kind of a system we can create:\n\n* Bundle a python interpreter as an artifact, e.g. `Python_jll`.  Not too difficult.\n\n* Translate python packages into artifacts.  something like `translate_py_pkg(name::String, version = nothing)` would hit [`PyPI`'s JSON API](https://warehouse.readthedocs.io/api-reference/json/) for a listing of versions, generate an `Artifacts.toml` entry for that python package by downloading, extracting and tree-hashing the python package.\n  * Pure-source python packages are usually tarballs\n  * Wheels are zipballs (we'll need `.zip` support for this....)\n  * Explicitly do not support any kind of python package that is not pure-source and is not a wheel.  Anything else probably requires arbitrary code execution upon download.\n\n* Once python packages are being downloaded as artifacts, we set `PYTHONPATH` appropriately before loading `libPython` or invoking `python`, so that these packages are being found properly.\n\n* Future invocations of the Julia package manager will see these binary blobs that are attached to the current project, and will properly re-instantiate them from PyPI.\n\nThere's some subtlety here related to [the implicit Python compiler ABI](https://packaging.python.org/guides/packaging-binary-extensions/#binary-extensions-for-windows).  In particular, on Windows, they assume usage of MSVC, which is _fine_, except when you start compiling C++ code.  It's highly unlikely that Python wheels that contain C++ code will link properly to Julia.  This has never and probably will never worked though, so we don't lose that much here.  C and FORTRAN code should work together just fine, so we should be okay in 95% of what we want to do, and if you want to do something more complicated, you can always just spin up a Python interpreter compiled properly and communicate over a socket.","[kdheepak]: This is very interesting and could be extremely useful in ensuring that we have reproducible scientific code when using Python. \n\nHave you considered using conda in addition to wheels? There are numerous conda packages that do not have not had a wheel equivalent. Historically at least, conda has better supported scientific computing packages compared to PyPi. However, wheels have made this a lot better for users in the recent years. Conda appears to have a similar [API](https://docs.conda.io/projects/conda/en/latest/api/api.html) as well, but I'm not sure if you need to bundle a `CondaPython_jll` instead.\n\nAlso, I'm not sure how exactly wheels deal with non Python dependencies. My understanding is that they vendor all dependencies in the wheel itself. So in a situation where, say in Julia one wanted to interface with a Python package that uses the C API to interface with native libraries depend on Boost or ZeroMQ or other non Python libraries; are you suggesting building those non Python dependencies as separate `dependency_jll` files or downloading them from the wheel directly? | [tkf]: Note that a subset of """"System design constraints"""" is already possible with combination of `pipenv` and `PYCALL_JL_RUNTIME_PYTHON`: https://github.com/JuliaPy/PyCall.jl/pull/578.  However, this does not let us change or record the exact version of `libpython`.\n\nFor PyCall and its downstreams, a fundamental building block we need is the package options to configure `libpython` for each Julia environment: https://github.com/JuliaLang/Pkg.jl/issues/458, https://github.com/JuliaLang/Juleps/issues/38 (see also my proof-of-concept implementation here: https://github.com/JuliaLang/Pkg.jl/issues/1378).\n\n> * Translate python packages into artifacts.\n\n`pip` does a very good job of caching wheels across different environments.  IIUC it is using content-addressable storage just like Artifacts.  It'd be unfortunate that `pip` and Julia duplicate the cache and waste download time.  Why not just use `pip download` API?\n\n> * Once python packages are being downloaded as artifacts, we set `PYTHONPATH` appropriately\n\nWhy not use [`venv`](https://docs.python.org/3/library/venv.html)?  Tweaking `PYTHONPATH` is not a good practice.\n\nAlso, I think one step missing is resolution of Python package dependencies.  Dependency resolution for Python packages is a hard problem because (IIRC) there is no central repository recording the entire dependency graph; you have to download the package to figure out its dependency.  Re-implementing this sounds like a lot of duplicated effort.\n\nI think installing Python with `Python_jll` is a good idea. But, IMHO, a better direction for Python _packages_ would be an integration with a Python package manager like Pipenv and Poetry which have a very similar interface as Pkg.jl.  Adding some kind of hooks to Pkg.jl operations sounds like a better solution.  See also: [Structured, Exchangeable lock file format (requirements.txt 2.0?) - Packaging - Discussions on Python.org](https://discuss.python.org/t/structured-exchangeable-lock-file-format-requirements-txt-2-0/876)\n",2,false,6,6,0,0,0,0,0,0,0
1436,Restrict OS? / Add to docs,open,dlfivefifty,,,,2,2019-10-09T09:53:52.0,2019-10-09T09:56:55.0,2111,2111,https://github.com/JuliaLang/Pkg.jl/issues/1436,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1436,"I want to tag a new version of FastTransforms.jl that doesn't (yet) support Windows. Is this possible?\n\nIf so, it should be added to the docs.",[fredrikekre]: It is not. You can do that yourself though by e.g. checking the running OS in `__init__`. | [dlfivefifty]: Oh no ☹️ I want Windows users to be able to continue using the previous tagged version until it's updated...\n,2,false,0,0,0,0,0,0,0,0,0
1430,Instantiating with dirty registry can get bad error message,open,KristofferC,,,,0,2019-10-03T15:45:18.0,2019-10-03T15:45:18.0,2116,2116,https://github.com/JuliaLang/Pkg.jl/issues/1430,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1430,"```\n(NewPkgEval) pkg> instantiate\n  Updating registry at `~/.julia/registries/General`\n┌ Warning: Some registries failed to update:\n│     — `~/.julia/registries/General` — registry dirty\n└ @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Types.jl:1269\nERROR: AssertionError: haskey(hashes, uuid)\nStacktrace:\n [1] version_data!(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:426\n```\n\nProbably because the tree hash cannot be found in the registry?",,0,false,0,0,0,0,0,0,0,0,0
1342,Package Spec Idea,open,mileslucas,,speculative; Discussion,,7,2019-09-02T05:40:52.0,2019-09-23T11:36:32.0,2148,2127,https://github.com/JuliaLang/Pkg.jl/issues/1342,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1342,"Hi, I have some ideas for what I'd like to see incorporated into Pkg `project.toml`, especially regarding compatibilies. Most of these ideas stem from [python's poetry](https://poetry.eustace.io/) packaging ideas.\n\nIn poetry (which uses a `.toml` file for configuration) there are some nice ways of listing dependencies\n\n## Ideas\n### 1. Normal Dependency with semvar:\n```toml\n[dependencies]\nUnitful = { """"^0.16"""", uuid=""""1986cc42-f94f-5a68-af5c-568840ba703d"""" }\n```\nThis is great because it keeps the all the information about the dependency in one location, instead of split between the `dependencies` and `compat` sections.\n\n### 2. Github dependency\n```toml\n[dependencies]\nFastConv = { \n    git=""""https://github.com/aamini/FastConv.jl"""", \n    branch=""""master"""", \n    uuid=""""d7899f00-a588-5e12-9855-37624a64ff9a"""" \n}\n```\n\n### 3. Local dependency\n```toml\n[dependencies]\nP_equals_NP_solution = { \n   path = """"~/dev/P_equals_NP_solution"""",\n   uuid=""""d7899f00-a588-5e12-9855-37624a64ff9a""""\n}\n```\n\n### 4. Multiple versions\n```toml\n[dependencies]\nUnitful =[\n   { """"^0.16"""", julia=""""1.0.0"""", uuid=""""1986cc42-f94f-5a68-af5c-568840ba703d"""" },\n   { git=""""https://github.com/painterqubits/Unitful.jl"""", julia=""""^1.2.0"""", uuid=""""1986cc42-f94f-5a68-af5c-568840ba703d"""" },\n]\n```\n\n### 5. Julia Versioning\nPut this in the base `Project.toml` as a semvar instead of under `compat`\n\n### Other\nDeprecate the `compat` section.\n\nIt might be interesting to see how this would affect propagating dependencies. Instead of having a separate project.toml for tests, it would be easy to pin test dependencies under something like ```[test.dependencies]``` since all the relevant package info is in the single line for the package. \n\nBy default I think all dependencies should have some from of versioning restriction. Using semvar rules (and again, following poetry's example) we could automatically add a caret restriction for super-`1.0.0` releases and use a range for sub-`1.0.0` releases. E.g. if I add the package `Documenter.jl` the corresponding entry would automatically have compatibility for `≥ 0.23.0, < 1.0.0` but the package `DifferentialEquations.jl` would automatically have `6.6.0` (or `^6.6.0`).\n\n----\nI'm not familiar with how Pkg.jl actually works, but I definitely care about the packaging ecosystem. One of the largest problems I have with Python is its packaging nightmare. I'd be open to helping implement some of these issues but I'm not certain how successful I would be. Any discussion is also welcome!","[mileslucas]: For an alternative, we could list dependenices like this, too-\n```toml\n[[deps]] # looks through package registry\nname=""""Unitful""""\nversion=""""0.16.0""""\nuuid=""""1986cc42-f94f-5a68-af5c-568840ba703d""""\n\n[[deps]] # uses github repo directly\nname=""""FastConv""""\nversion=""""0.3.0""""\nuuid=""""d7899f00-a588-5e12-9855-37624a64ff9a""""\ngit=""""https://github.com/aamini/FastConv.jl""""\nbranch=""""master""""\n\n[[deps]] # local code\nname=""""P_equals_NP_solution""""\nuuid=""""981f0a88-7173-41d4-b16d-2f51b1d5c44a""""\npath=""""~/dev/P_equals_NP_solution""""\n```\n\nwhich may lead to longer `project.toml` files, but I think has potential to be much more readable/interpretable than the inline-tables method above. | [00vareladavid]: I don't think the existing `Project.toml` format is likely to change until 2.0, which does not seem to be near | [mileslucas]: That doesn't mean we can't talk about it. Since Julia `1.0.0` The ecosystem has grown tremendously, and I think it's important for users to have input in the packaging scene considering it'd a bundled part of the Julia language. \n\nWithout proper input I fear Julia may fall the way python has with its extremely scattered packaging ecosystem, where each new author thinks they have the solution that ought to be the standard, but at this point there's too many for python to ever settle on a standard without forming a schism in the community. | [00vareladavid]: > That doesn't mean we can't talk about it.\n\nYes, I did not deny this.\n\n>  I think it's important for users to have input in the packaging scene\n\nAgree 100%. I'm glad people care enough to give feedback.\n | [StefanKarpinski]: What is better about these proposals than what we currently do? | [mileslucas]: **1. All packages have versioning (and its the default)**\n\nThis is more of a personal opinion, but I think it is a good one- every package *needs* a version spec. This has been discussed at https://github.com/JuliaRegistries/Registrator.jl/issues/204, too. By default adding a package should add a version specifier, like restricting to the current major version (eg `^1.0.0`). If every package *has* to have a version spec, then why separate the specifier into a `[compat]` section when it's intrinsic to the dependencies themselves.\n\n**2. Non package registry dependencies**\n\nCurrently, I can't pin any kind of version requirement unless the package and that version exist on the general registry. I think the most common occurrence of this causing issues is the following: say I'm working on project B but I discover a bug in one of its dependencies- project A. I fork and fix the bug in project A and complete a pull request. Let's say project A's maintainers don't want to release a new version yet (or they do but it gets stuck in the package registry's pull requests since they're still being manually merged). \n\nNow in my project, I can't pin a version of project A to its github repo. Sure, I can manually add like `pkg> add https://github.com/projectdevs/projectA#master` or `pkg> add projectA#master` but this only affects the `Manifest.toml` file, so any CI or other devs will need to manually do the above to get a working version. With the above spec, I would be able to pin a version to a github branch (or perhaps any URL hosting a package). | [KristofferC]: > Currently, I can't pin any kind of version requirement unless the package and that version exist on the general registry.\n\nThere is some discussion about that here: https://github.com/JuliaLang/Pkg.jl/issues/492",7,false,0,0,0,0,0,0,0,0,0
1395,document `instantiate --project`,open,00vareladavid,,documentation,,0,2019-09-18T01:43:32.0,2019-09-18T01:43:32.0,2132,2132,https://github.com/JuliaLang/Pkg.jl/issues/1395,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1395,we do not have this documented yet,,0,false,2,2,0,0,0,0,0,0,0
52,levels of incompatibility,open,StefanKarpinski,,speculative; feature,,0,2017-11-28T16:23:38.0,2019-09-10T21:44:16.0,2790,2139,https://github.com/JuliaLang/Pkg.jl/issues/52,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/52,"Problem: We've had a recent situation where JuliaPro ships with a fixed set of package versions which were compatible at the time it was released, but a subsequent update to METADATA (https://github.com/JuliaLang/METADATA.jl/pull/12106, see discussion in https://github.com/JuliaLang/METADATA.jl/pull/12264) caused that set of versions to become incompatible. Unfortunately, this means that doing almost anything with that set of packages causes the resolver to say that the operation is not allowed because it leads to an incompatible (""""infeasible"""") set of package versions.\n\nPotential solution: In general, it would be good to allow operations that don't make the current situation any worse, and in general to afford users the option to pick their poison in situations where no fully compatible resolution exists. This seems to lead to a notion of """"levels of incompatibility"""" for sets of versions rather than the current black-and-white notion of compatible or not. If you're already at a level of incompatibility, then an operation which doesn't make that level worse should be allowed without warning. If there are no solutions which don't make the situation worse, then it would be ideal to prompt the user with the best options for resolving the situation as well as possible.",,0,false,0,0,0,0,0,0,0,0,0
744,Feature request: `dev` time dependencies,open,oxinabox,,sandbox; feature,,10,2018-09-15T02:36:13.0,2019-09-10T20:18:46.0,2500,2139,https://github.com/JuliaLang/Pkg.jl/issues/744,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/744,"Similar to #727\n\nThis idea has been thrown around a few times on Discourse and Slack.\nSo  I thought I would write it up, or at least start to\n\nConsider the case where your active enviroment is a project you have `] dev`ed.\nThis is kinda as I understand it an intended way to do package development.\nIt lets you do `] test` to test the project and `]add` adds deps to the project.\n\nThis means you do not have your  normal enviroment.\nSo the idea of a `dev` time dependency is a set of packages that are installed when you run `dev`.\n\nThere exist packages you want to be using as a developer.\nWith `Revise.jl` now being the most common way to interactive editting,\none really wants it at dev time.\n\nBelow is a list of packages that exist to be used at Dev time.\nI break them into two categories.\n**user-dev**: for packages that the use of depends on the preference of the developer.\nI.e. you can develop the package without them, and different developers may want to use them or not.\n**project-dev**: for packages that you actually can't develop the project without,\nbecause they do some part that is required for the dev process, like generating code.\n(You can develop parts of the project with out them, but there are some parts that you really shouldn't touch).\n\n## user-dev packages:\n\n - Revise.jl\n - Rebugger.jl\n - OhMyREPL.jl\n - OhMyLog.jl\n\n## project-dev packages\n\n - Documentor.jl\n - Literate.jl\n - ReferenceTests.jl * \n - DataDepsGenerators.jl\n \nFurther to this list, just about any package can be a **project-dev** package,  if you have some development scripting that needs it, like JSON.jl perhaps.\n\n* ReferenceTests.jl is perhaps an odd one, it is a Dev time and Test time dep, because you need it to edit/author your test files; and of course the check them.\nBut it might be, that it is best if **all** test time dependencies were installed at dev time,\nsince that makes it easier to mess around with the tests manually/interactively.","[KristofferC]: You can still load packages in a lower environment in LOAD_PATH in the REPL. So if you install Revise.jl in the v1.0 environment, activate a dev environment, you can still do `using Revise´ in the REPL (or a script). | [oxinabox]: That does mostly solve it, for **user-dev** packages,\nI think leaving this open because deploying **project-dev** packages to new contributors is still a problem. | [KristofferC]: > I think leaving this open because deploying project-dev packages to new contributors is still a problem.\n\nI would have thought that would just be\n\n```\ngit clone .../MyProject.jl.git\njulia --project=MyProject\n``` | [StefanKarpinski]: I think having a way to ask target environments in general would be useful. Then you could imagine having this:\n```toml\n[extras]\nTestPkgA = """"<uuid>""""\nTestPkgB = """"<uuid>""""\nDevToolA = """"<uuid>""""\nDevToolB = """"<uuid>""""\n\n[targets]\ndev = [""""DevToolA"""", """"DevToolB""""]\ntest = [""""TestPkgA"""", """"TestPkgB"""", """"DevToolA""""]\n```\nIn the manifest, one would have\n```toml\n[[DevToolA]]\ntargets = [""""dev"""", """"test""""]\n```\nWhich would let the system know that the package should _only_ be loadable in the `dev` and `test` target environments.\n\nIn the mean time, you can just have a git repo called `DevTools.jl` that has a project and manifest with dev tools in it.\n | [ExpandingMan]: Note that this has suddenly become a lot more significant now that `Debugger` has a release.  You can always just go ahead and use `Revise` or `OhMyREPL` all by themselves in whatever environment and you won't even get any warnings.  Debugger, however, requires a `using Debugger` in the package itself in order to set breakpoints.  The current behavior is that you get a single warning for doing this.  It's not a big deal, since it's only one warning when the package loads, but it would be nice to have a way around it. | [oxinabox]: I do not think my original idea is good anymore,\nbecuase if anything we want to be pushing away from `[extras]` and `[targets]` (including test),\nand moving more towards having seperate Project.tomls, \nlike is done for Documenter.\nbut perhaps there is scope for `[targets]` to reference secondary Project.toml,\nthis  I think might require more thought.\nWhich someone other than me might have done. | [ExpandingMan]: The simplest solution I think of would be to simply have a `[dev]` or `[optional]` section which silences warnings if the package is imported and nothing else.  Again, the only case which I can think of in which this would be a good idea is debuggers, but that seems like a fairly important use case. | [KristofferC]: > Debugger, however, requires a using Debugger in the package itself in order to set breakpoints.\n\nOnly for in source code breakpoints and we could come up with a way to do this without having Debugger loaded in the package. It just needs to be something unique in the code that we know marks a breakpoint. | [ExpandingMan]: > Only for in source code breakpoints and we could come up with a way to do this without having Debugger loaded in the package. It just needs to be something unique in the code that we know marks a breakpoint.\n\nWhat do you have in mind?  Adding a `@bp` to `Base` that only does anything if the debugger sees it? | [oxinabox]: Take this to another issue?",10,false,1,1,0,0,0,0,0,0,0
1072,allow registries to depend on other registries,open,StefanKarpinski,,Discussion,,0,2019-02-19T20:21:44.0,2019-09-10T20:08:59.0,2342,2139,https://github.com/JuliaLang/Pkg.jl/issues/1072,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1072,"Alternative to https://github.com/JuliaLang/Pkg.jl/issues/1067 that came up in the discussion of https://discourse.julialang.org/t/decentralized-package-manager/20931 was to allow registries to depend on other registries. General would be standalone, but especially private registries will often not be self-contained and implicitly depend on packages from General, for example. It would be a nice user experience if adding a registry that depends on other registries made sure those were available instead of just not working when trying to resolve versions. Or it could at least intelligently prompt you that you're missing dependency registries.\n\nThere are some complexities, however. It's not uncommon to have forks of public registries. For example, JuliaPro maintains a forked subset of General that contains only vetted packages and versions. Does this count as an alternative to General? How does one indicate that.\n\nProbably too early for this, but I thought I'd open an issue for future discussion.",,0,false,5,0,0,0,0,0,5,0,0
1089,Blacklist compat specifier,open,oxinabox,,feature,,7,2019-02-26T10:27:38.0,2019-09-10T20:08:38.0,2336,2139,https://github.com/JuliaLang/Pkg.jl/issues/1089,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1089,"It would be good to be able to specify versions of a package that are Not to be installed.\nE.g. MbedTLS 0.6.7 is broken.\nLets say that MbedTLS 0.6.8 has been released which fixed it.\n\nAnd lets also say we already rule like `^0.5, ^0.6`\nThe rule one wants is to say """"please do not install 0.6.7"""".\nRight now the way we can't express that the allowed version is \n`0.5.0 <= v <=0.6.6 || 0.6.8 <= v <0.7.0`\n\nI can imagine having a `!` rule that comes after all other  rules, seperated  say by a  semicolon,\nwhich could allow us to write the  above as\n`^0.5, ^0.6; !0.6.7`\n\nI guess allowing this kind of rule make solving  the  constraints a bit more fiddly.\n\nBy SemVer 2 rules, one can not fix a broken release and republish it as the same  version number.\nI think we are in general handling this kind of thing at the registry level, by untagging that release, but it should be handle-able at the Pkg level also.\n","[fredrikekre]: https://github.com/JuliaLang/Pkg.jl/pull/726 | [KristofferC]: > I think we are in general handling this kind of thing at the registry level, by untagging that release, but it should be handle-able at the Pkg level also.\n\nYeah, I think this should still be handled on the registry level since if the release is broken then it is broken for anyone. They yanking in #726 allows to do this while keeping existing manifests working. | [oxinabox]: Yes,  I think handling it in the registry  is definitely desirable.\nBut the Pkg level we want also.\nWe want both.\nSince various things may prevent the registry being updated.\nIncluding  but not  limitted  to:\n\n - Prolonged argument  as to  if the thing is  actually broken.\n - Working from a registry snapshot,\n - Working from a registry that is poorly maintained.\n - the need to do this **immediately**  (I feel like you've made  other mistakes if you end up in  that situtation, but still) | [fredrikekre]: Putting this in `Project.toml` would only work for in-development packages or projects though, since it won't be reflected in the version bounds for already released versions of the package. At that point, isn't it easier to just not install the version you know are broken instead putting this in a constraint and then resolve? | [oxinabox]: Because working out  by hand what is an allowed version can be hard.\nThat is why we have package managers.\n\nFor something like MbedTLS it can be particularly hard.\nFrom given project using my package Foo.jl, might use say:\n \n   - Foo --> MbedTLS\n   - AWSCore --> HTTP --> MbedTLS,\n   - DataDeps --> HTTP --> MbedTLS\n   - HTTP --> MbedTLS\n   - CloudWatchLogs --> MbedTLS\n\nSo if I just set a partiocular version of MbedTLS in Foo.jl,\nI  might well make it hard for this project with its 5 seperate dependency chains to MbedTLS to resolve.\nFoo itself might similarly have those other 4 paths,\nand the same point applies. | [fredrikekre]: I don't understand, why can't you just `pkg> add MbedTLS@$(WORKINGVERSION)`? | [oxinabox]: Because I don't know what version is working and is going to be compatible both with all my current dependencies and with the dependencies i might add or change tomorrow.\nAnd this applies both to my package and to projects using my package.\n\nIt working out a possible version for everything was easy we wouldn't need the resolver part of the package manager.",7,false,2,2,0,0,0,0,0,0,0
1092,A richer REPL experience for sub-environments,open,00vareladavid,,REPL; sandbox; feature,,1,2019-02-27T22:52:45.0,2019-09-10T20:08:14.0,2334,2139,https://github.com/JuliaLang/Pkg.jl/issues/1092,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1092,"#1051 provides a convenient way to navigate sub-environments. I think it is necessary, but not sufficient, for a good UX.\n\n`activate +test` (as opposed to `activate test`) also shows the *intention* of a user to use an environment as a subenv of the active environment. We can leverage this information to display better feedback to users.\n\nFor example: after running `activate test`, the user is shown `(test) pkg>`. You know that a test environment is activated, but you don't know what environment that test environment applies to.\nWe can change this feedback to something like `(Foo:test) pkg>`.\n\n`+` subenv syntax is more general than testing. If #1085 is implemented, I can image a workflow along these lines:\n```\n(Foo) pkg> activate +feature/A\n(Foo:A) pkg> add Bar\n(Foo:A) pkg> test\n(Foo:A) pkg> activate -\n(Foo) pkg>\n```\n\nDon't mean to get ahead of myself :grin:. Just something to consider if/when we get to that point.\n\n","[StefanKarpinski]: Nice idea. It would be nice if the `+` and `:` could be unified, it's kind of weird to use different characters.",1,false,1,1,0,0,0,0,0,0,0
1253,Feature request: testing and building a non-package project,open,Datseris,,feature,,2,2019-07-15T12:50:26.0,2019-09-10T20:04:14.0,2197,2139,https://github.com/JuliaLang/Pkg.jl/issues/1253,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1253,"The FR here follows from https://github.com/JuliaDynamics/DrWatson.jl/issues/67 (and https://github.com/JuliaDynamics/DrWatson.jl/issues/61 )\nIt seems that at the moment it is not possible to run `pkg> build` or `pkg> test` for a Julia *project* but only for a Julia *package*. (the project doesn't have a UUID or a `src/PackageName.jl` file, but only a `Project.toml`).\n\nConceptually I don't see a reason why this shouldn't be possible.","[fredrikekre]: `pkg> build` already has a meaning, do you suggest that we also run `build/deps.jl` as a final step? And `pkg> test` should just be `include(""""test/runtests.jl"""")` or also allow test deps etc? | [KristofferC]: I think it should still allow test deps and yes, also run the local `build/deps.jl` even if the current project is not a package.",2,false,8,6,0,0,0,0,0,0,2
1254,Getting user's working dir from Pkg.build,open,iblislin,,enhancement,,0,2019-07-18T03:48:07.0,2019-09-10T20:03:12.0,2194,2139,https://github.com/JuliaLang/Pkg.jl/issues/1254,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1254,"For example, the `build.jl` of `MyPkg`:\n```julia\nusing Libdl\ndlopen(ENV[""""FOO""""])  # this will fail, if the FOO is a relative path.\n```\n\nIf user run `Pkg.build` in REPL, the relative path issue is popped up.\n```julia\nusing Pkg\nwithenv(""""FOO"""" => """"./mylib/libfoo.so"""") do \n        Pkg.build(""""MyPkg"""")\nend\n```\n\nMaybe Pkg.build should hold the original PWD in other env var?",,0,false,0,0,0,0,0,0,0,0,0
1263,Method to print valid range of a version specifier,open,CameronBieganek,,feature,,0,2019-07-25T20:01:13.0,2019-09-10T20:00:52.0,2186,2139,https://github.com/JuliaLang/Pkg.jl/issues/1263,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1263,"It would be handy if there was a method exported in **Pkg** that would take a version specifier and print the range of valid versions. In other words, it should work as follows:\n\n```julia\njulia> versionrange(""""^1.2"""")\n[1.2.0, 2.0.0)\n\njulia> versionrange(""""~1.2"""")\n[1.2.0, 1.3.0)\n```",,0,false,1,1,0,0,0,0,0,0,0
1268,Official docs on package registration process,open,felipenoris,StefanKarpinski,help wanted; documentation,,2,2019-07-27T03:04:43.0,2019-09-09T00:10:11.0,2185,2141,https://github.com/JuliaLang/Pkg.jl/issues/1268,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1268,"Pkg.jl docs should cover package registration process. Looks like the only source of information on this is still a discourse thread (https://discourse.julialang.org/t/switching-package-registration-systems-soon/22677) and the Registrator README (https://github.com/JuliaRegistries/Registrator.jl/blob/master/README.md). Both sources are not liked to any official doc. (julia docs link to Pkg.jl docs on https://docs.julialang.org/en/v1/stdlib/Pkg/, but Registrator.jl is not linked to any docs, AFAIK).\n\nRef: https://github.com/JuliaRegistries/General/issues/1626","[StefanKarpinski]: Yes, the discoverability of the documentation for this is terrible—I didn't realize quite how bad until @madeleineudell pointed it out to me along with several other very helpful bits of feedback (thanks, Madeleine!). Here are some of the notes I took.\n\n---\n\nImprovements:\n- Add info about how to register package in the manual section for Pkg\n- Manual Pkg section needs to link to the main Pkg.jl docs\n- Pkg.jl docs don’t even include docs for registration process\n- Pkg.jl repo doesn’t clearly indicate that the doc link is to docs\n- Include example workflows like https://medium.com/@Jernfrost/my-new-workflow-with-julia-1-0-99711103d97c but for various processes\n- The actual useful docs are at https://github.com/JuliaRegistries/Registrator.jl\n\nGoogle search terms that should ideally work:\n\n- julia packages dev\n- julia package development\n- julia register package \n- julia general registry\n- julia register new version\n\n | [holgerteichgraeber]: Adding to the list of additional documentation: How to rename a package",2,false,1,1,0,0,0,0,0,0,0
1288,Feature request: full semver support(pre-release version and build metadata),open,Gnimuc,,enhancement,,3,2019-08-08T02:26:58.0,2019-09-09T00:07:59.0,2173,2141,https://github.com/JuliaLang/Pkg.jl/issues/1288,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1288,"See https://github.com/JuliaLang/Pkg.jl/issues/1288#issuecomment-519344339\n\n<strike>It would be great if Pkg could provide another degree of freedom for semver.\n\nFor wrapper packages, the 4-th number can be used to indicate the bugfixes on the wrapper side, for example, [Vulkan suggests to use a `sdk-<semver>.<patch>` version tagging scheme](https://github.com/KhronosGroup/Vulkan-Headers#version-tagging-scheme ). \n\nFor non-wrapper packages, the 4-th number can also be use for pre-release and build metadata.</strike>","[StefanKarpinski]: We didn't just make SemVer up, it's an [actual standard](https://semver.org/) and it does not have a 4th version number. You are welcome to open an issue on the [semver](https://github.com/semver/semver) repo to request such a change to the standard. | [Gnimuc]: or could Julia registry support [semver extensions](https://semver.org/#spec-item-11)? support `<major>.<minor>.<patch>-<pre-release identifier>` instead of `<major>.<minor>.<patch>.<non-standard 4th number>` | [StefanKarpinski]: Yes, that's more of a possibility.",3,false,1,0,1,0,0,0,0,0,0
1001,Verify permissions before modifying filesystem,open,00vareladavid,,enhancement,,0,2019-01-19T23:50:27.0,2019-09-07T21:02:19.0,2373,2142,https://github.com/JuliaLang/Pkg.jl/issues/1001,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1001,"I've seen something similar happen twice: https://discourse.julialang.org/t/problem-installing-juliapro/19307.\n\nIn terms of debugging, I think wrapping the `touch` call in a try/catch and erroring with the problematic file name would be an improvement.",,0,false,1,1,0,0,0,0,0,0,0
1308,Idea: automatic artifact & package deduplication,open,StefanKarpinski,,enhancement,,1,2019-08-20T19:35:17.0,2019-09-07T20:41:13.0,2160,2142,https://github.com/JuliaLang/Pkg.jl/issues/1308,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1308,"This idea came up on today's #pkg-dev call. I'm going to describe it for artifacts, but it applies equally well to packages too. We have a script that a sysadmin can run, say nightly as a cron job, that goes through user depots and looks at their artifacts, i.e. for each `user`, everything in `~user/.julia/artifacts`. If more than some number `N`—which could be 1 or 2 or 5 or 10—of users has the same artifact installed, then we create a system-wide copy of that artifact in `/usr/local/julia/artifacts`. From then on, when any other user wants that artifact, if they're using the standard `DEPOT_PATH`, they don't need to download and install the artifact, they'll just use the system copy.\n\nSo far we've avoided installing extra copies. Next for the deduplication part. We need to modify `gc` so that if there are multiple copies of an artifact (or package) in the depot path, only the last one is kept and the earlier ones are added to the orphans set and eventually deleted if they remain in the orphanage for long enough (this is a _really_ dark metaphor 😬). That way after an artifact has been copied to the system depot for long enough (the default grace period is 30 days), it will be removed from the user's depot and will only remain in the system depot.\n\nThis scheme creates a completely automated system whereby users install whatever packages they want, which in turn installs various artifacts. Whatever packages and artifacts are popular—by the criterion of """"used by more than `N` users—will be installed in a shared system location and eventually deduplicated. This is as opposed to the sysadmin having to guess what people will want to use and continually having to update that set of packages and versions. This system could be started with a completely empty set of system packages and it would just maintain itself indefinitely, based on what users actually use. From the user perspective, they get magically fast package & artifact installs since most of the time anything they want is already installed.\n\nDetails:\n* We'll want to verify artifact and package integrity when doing this; I'm not sure what to do if an artifact or package has been modified and doesn't match its own tree hash.\n* We may not want to do the gc all but the last thing for mutable packages with a `deps/build.jl` script since the user version may end up working differently from the system one. But maybe it's fine so long as the system version seems to install correctly?\n* The same exact system works for packages, the only difference being that we need to look at `~user/.julia/packages/$name/$slug` and then we'll need to make sure that we don't get `$name/$slug` collisions.\n* Maybe we need to allow looking for packages at `$depot/packages/$uuid/$hash` in addition to `$depot/packages/$name/$slug` and use that naming scheme for the system packages. A collision only has a 50% chance if there are 30k different versions with the same package name, so maybe we don't need that even on large systems.\n",[StefanKarpinski]: Another thought: the shared system area may have a storage limit. We could arrange that only the most popular artifacts and packages up to the allowed storage limit are kept. That way the sysadmin wouldn't get a page at 3 am that the file system is full because there are too many different popular shared Julia artifacts or packages. So the two knobs might be:\n* minimum copy threshold\n* maximum disk usage.\n,1,false,1,0,0,0,0,0,1,0,0
1310,Add link back to documentation for Julia,open,MrBobot,,documentation,,2,2019-08-21T06:27:38.0,2019-09-07T20:40:54.0,2160,2142,https://github.com/JuliaLang/Pkg.jl/issues/1310,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1310,Hi \n\nWould it be possible to add a link from the [Pkg docs](https://julialang.github.io/Pkg.jl/v1/) back to main [Julia documentation](https://docs.julialang.org)\n\nThanks,"[fredrikekre]: Sure. Where would you think it would fit? | [MrBobot]: Good question, perhaps somewhere prominent like a header/footer on individual help pages or on the left contents panel ?",2,false,0,0,0,0,0,0,0,0,0
1280,Documentation: What to do in case of version downgrades,open,asinghvi17,,documentation,,0,2019-08-02T06:51:23.0,2019-09-07T20:11:39.0,2179,2142,https://github.com/JuliaLang/Pkg.jl/issues/1280,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1280,"- If you see a version downgrade that you weren't expecting, try to pin the downgraded package to the latest version (`pin pkg@version`) and look at the error log to see which packages are constraining it.\n- Then, see if the constraint is fixed on master (if you want to add master), or dev it and git reset to the latest tag. (Could there be a better API for this?  Maybe `dev --latest-tag pkg`?)\n- If you don't want to add master, and the constraint is explicit in the Project.toml of the package (is this too much to ask?), consider opening an issue asking for support of the package version on the parent repo.\n\nI'm opening this as an issue here, so the steps can go through some refinement before being added to the docs.  Feedback is appreciated.",,0,false,0,0,0,0,0,0,0,0,0
766,`]up` and its behavior on `dev` packages,open,ChrisRackauckas,,enhancement,,8,2018-09-19T21:16:30.0,2019-09-07T01:38:02.0,2495,2143,https://github.com/JuliaLang/Pkg.jl/issues/766,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/766,"Currently, `]up` doesn't do anything to `dev` packages. I have found this a little odd since I do happen to end up with a lot of `dev` packages, sometimes with some of them not being actively developed right now, but since I haven't gone in to manually update them these packages no longer track master. \n\nThere's a few things to mention here. One thing you can do is `]add MyPackage#master` and it will track master, and that should be done if you don't develop the package at all. When you're working in a small project setup where other people are merging to master, you do want to stay updated with master as much as possible while sometimes developing it. \n\nOne thing that you could do in this case is `dev`, then develop/push/PR, `free`, `add ...#master` to go back. The issue here is that this is not fault-tolerant and is silent: if you accidentally didn't `free` then the only indication that your package may be old is that when you call `]up` it shows up as a `dev` package. This makes it very easy to fall behind and be using older code and makes the collaboration a little bit jittery.\n\nOne solution is to use environments. This is really good for if you plan on changing a few things in a bunch of dependencies just to see what happens. This looks like:\n\n- `activate --shared MyEnv`\n- `add PackageIWantToOverride`\n- Muck around\n- `activate` to go back to the main environment\n- Sometime later, """"gc the environment"""" by deleting the folder (currently there is no command for that, but there possibly could be?)\n\nUsing environments is a good way to keep your main environment clean, and you get a pretty prominent indicator as to what environment you're in inside of the Pkg REPL. This mitigates the problem by decreasing the number of packages you `dev`, but doesn't get rid of it completely.\n\nThere are some legitimate concerns about handling of dirty packages, but there are a few things that could be done. @StefanKarpinski mentioned that it could fast-forward packages which have no changes (the """"forgot to free"""" dev packages). Another thing that could be done is a colored warning can be given in during the `]up`, a big indicator that you may want to check for updates in your `dev` package. \n\nBoth of these solutions would `fetch` upstream changes, which IMO is nice because either way this means that `]up` is all you need to locally get all of the information to work on your local repositories. Pkg2 might've been a little strong handed with `Pkg.update()`, but with Pkg3 I've been finding that it's hard to remember to fetch updates to everything I want to work on before a flight. Anything that auto-fetches and gives some kind of indicators means that `]up` is all you need and you can work it out from there.","[simonbyrne]: > it could fast-forward packages which have no changes\n\nEven if it isn't the default, it could also be an option, e.g. `]up -d/-dev`. | [fredrikekre]: I very much like the guarantee that Pkg will not touch packages that are tracking a path, it is IMO a very useful property.\n\nI would also like to point out that we have the `--local` option to `dev`. So another useful workflow is something like:\n - Activate a new env\n - `dev --local` all the stuff you need\n - Push/PR/merge\n - Remove the folder. | [StefanKarpinski]: Any reason not to give the option of updating dev packages at least? | [fredrikekre]: Does it solve anything? In the example in the OP, wouldn't you just end up with a up-to-date version of the `bugfix` branch that you worked on? Or should `Pkg` also switch branches and stuff? | [StefanKarpinski]: It solves the well-known """"I want the latest version of all my dev'd packages"""" problem. I don't see why there's so much pushback against this feature. It worked well in Pkg2, people liked it, it never lead to data loss and we already have the code to implement it. I didn't omit it from Pkg3 for any principled reason, it just wasn't implemented initially. I have yet to hear a principled argument why we shouldn't have this feature. | [simonbyrne]: Since we keep a copy of the repo in `.julia/clones/`, it could make sense to have a way to refresh those. | [ChrisRackauckas]: Users could also do something locally if that's what they want for now. I tried making something in my startup but didn't know how to finish. Maybe someone with some LibGit2 knowledge could finish this:\n\n```julia\nimport LibGit2\n\nfunction update_devs()\n  devpath = joinpath(first(DEPOT_PATH),""""dev"""")\n  repopaths = joinpath.(devpath,readdir(devpath))\n  for pkg in joinpath(first(DEPOT_PATH),""""dev"""")\n    repo = LibGit2.GitRepo(pkg)\n    if !LibGit2.isdirty(repo)\n     # GitAnnotated(repo,LibGit2.fetch(repo)) ?\n      ffmerge!(\n    end\n  end\nend\n``` | [KristofferC]: Here's something else just using `git`\n\n```jl \nimport Pkg\nfunction update_devs()\n    for (pkg, _) in Pkg.installed()\n        pkgpath = abspath(joinpath(dirname(Base.find_package(pkg)), """"..""""))\n        if """".git"""" in readdir(pkgpath)\n            cd(pkgpath) do\n                ok = success(`git pull`)\n                if ok\n                    @info """"Pulled $pkgpath""""\n                else\n                    @error """"Failed to pull from $pkgpath""""\n                end\n            end\n        end\n    end\nend\n```",8,false,6,3,0,0,0,0,3,0,0
1239,document pin,open,mschauer,,documentation,,0,2019-06-26T14:35:13.0,2019-08-22T21:15:03.0,2216,2158,https://github.com/JuliaLang/Pkg.jl/issues/1239,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1239,"The docstring of `pin` (and also https://julialang.github.io/Pkg.jl/v1/managing-packages/#Pinning-a-package-1) is not particular helpful on how to pin to a specific version.\n\n```\n(v1.1) pkg> ?pin\n  pin pkg[=uuid] ...\n\n  Pin packages to given versions, or the current version if no version is\n  specified...\n```\n\nAn example\n```\npin Example@0.1.0\n```\nwould help a lot. It should perhaps say what `add Example@0.1.0` would do differently.",,0,false,1,1,0,0,0,0,0,0,0
1311,Incorporate feedback into docs,open,00vareladavid,,documentation,,1,2019-08-21T19:39:11.0,2019-08-21T19:57:51.0,2159,2159,https://github.com/JuliaLang/Pkg.jl/issues/1311,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1311,There seems to be plenty of good feedback here: https://discourse.julialang.org/t/package-manager-documentation/27351.\n\nJust making sure that discussion doesn't get lost.,"[StefanKarpinski]: Yes, I've had that bookmarked and open in my browser since last week. Definitely excellent feedback to incorporate.",1,false,5,5,0,0,0,0,0,0,0
318,status --tree,open,StefanKarpinski,,feature request,,1,2018-05-29T18:56:36.0,2019-07-20T19:04:42.0,2608,2191,https://github.com/JuliaLang/Pkg.jl/issues/318,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/318,Nice feature idea from [discourse](https://discourse.julialang.org/t/some-more-observations-on-working-with-pkg-3/11234/17): `status --tree` mode that prints a tree of dependencies. It's unclear how to deal with the dependency graph being a DAG rather than a tree (i.e. repeat dependencies); perhaps print the subtree only the first time? We could also have some kind of fancy Unicode DAG drawing mode.,[KristofferC]: I feel like this could be outsourced to a package that can output `.dot` files from a Manifest.,1,false,4,4,0,0,0,0,0,0,0
1231,Name of dependency does not get updated in Project.toml if it changes name,open,KristofferC,,bug,,6,2019-06-17T14:04:00.0,2019-07-16T19:33:44.0,2225,2195,https://github.com/JuliaLang/Pkg.jl/issues/1231,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1231,"To repro, add e.g Crayons:\n\n```\n(TestRename) pkg> add Crayons\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `~/TestRename/Project.toml`\n  [a8cc5b0e] + Crayons v4.0.0\n  Updating `~/TestRename/Manifest.toml`\n  [a8cc5b0e] + Crayons v4.0.0\n  [2a0f44e3] + Base64 \n  [8ba89e20] + Distributed \n  [b77e0a4c] + InteractiveUtils \n  [56ddb016] + Logging \n  [d6f4376e] + Markdown \n  [9a3f8284] + Random \n  [9e88b42a] + Serialization \n  [6462fe0b] + Sockets \n  [8dfed614] + Test \n```\n\nNow, change the `name` field of Crayons in the registry and do `up`:\n\n```\n(TestRename) pkg> up\n Resolving package versions...\n Installed Crayons_foo ─ v4.0.0\n  Updating `~/TestRename/Project.toml`\n  [a8cc5b0e] - Crayons v4.0.0\n  [a8cc5b0e] + Crayons_foo v4.0.0\n  Updating `~/TestRename/Manifest.toml`\n  [a8cc5b0e] - Crayons v4.0.0\n  [a8cc5b0e] + Crayons_foo v4.0.0\n\n(TestRename) pkg> st\n    Status `~/TestRename/Project.toml`\n→ [a8cc5b0e] Crayons_foo v4.0.0\n┌ Warning: Some packages (indicated with a red arrow) are not downloaded, use `instantiate` to instantiate the current environment\n└ @ Pkg.Display /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Display.jl:220\n\nshell> cat Project.toml\n[deps]\nCrayons = """"a8cc5b0e-0ffa-5ad4-8c14-923d3ee1735f""""\n```\n\nThe `dep` in Project.toml is still called `Crayons` and the package can not be loaded with either the new or the old name.","[StefanKarpinski]: When you've done an `up` this should definitely change to use the new name of the package. | [StefanKarpinski]: I’m actually not 100% sure this is a bug. I think the name to load a package by needs to be derived from the name in the package at the version that is resolved. If the package and repo gets renamed but your manifest still uses an order version from before the rename, then we should use the old name. | [KristofferC]: The package at the resolved state does have the new name. And in fact, the Manifest updates to the new name (as is seen by the status output). It's just the project file that doesn't get updated (presumably because some left over uuid to name cache). | [StefanKarpinski]: Ok, so the thing to potentially change here is:\n\nWhen a package in the project file is upgraded to a version where it has a different name than the one that is present in the project file (as determined by the `name` entry in the package's project file at that version), the name in the project file should be automatically changed to reflect the project's new name.\n\nI have a few questions/issues:\n\n* Are we really comfortable with automatically modifying the project file when upgrading/downgrading packages? Normally that only affects the manifest file. This would be the first situation where upgrade/downgrade operations can change a project file in any way.\n\n* The end user still needs to change their code to reflect the new package name. They won't be able to keep using the old name, so just upgrading/downgrading is not really sufficient. You need to also: (1) modify the project file and (2) modify the usage of the renamed package. At least in the case of named environments there is no project code so this second step doesn't matter.\n\n* Does doing one but not the other make sense? Should we instead consider that a name mismatch with a new version of a package indicates an implicit incompatibility? So the user would have to explicitly `] rm $old_name` and `] add $new_name` or maybe we could prompt the user when a rename happens and ask them if they also want help fixing their code?\n\n* Should we instead try to make it possible to support using a package by both its own and new name? Then there can be a smoother transition period, but at some point, one presumably still wants to drop support for the old name and force people to change the name they use a package by, at which point we face the exact same situation, so it's unclear if this is really worth it. | [KristofferC]: > This would be the first situation where upgrade/downgrade operations can change a project file in any way.\n\nGood point, perhaps that is why the name in the Project file doesn't update.\n\n> The end user still needs to change their code to reflect the new package name.\n\nThat is true but also true for any potential breaking change so I don't see this as very different.\n\n> Should we instead try to make it possible to support using a package by both its own and new name?\n\nThis is one reason when checking the installed version of a package makes sense. To support the old name you could do:\n\n```jl\nif version_of_pkg_with_uuid(""""$uuid_for_pkg_with_changed_name"""") < VERSION_WHERE_NAME_CHANGED\n    using OldName\n    const NewName = OldName\nelse\n    using NewName\nend\n```\n\nI don't think there is much worth in trying to allow older packages to use the new package with the new name and still have that work. Changing the name is effectively a breaking change then. | [StefanKarpinski]: I guess one argument for changing the name in the project file is that then when someone tries to test the code, they get a fairly clear error about """"Unknown package OldName"""", as opposed to the probably more confusing error they'll get if the name in the project file and the manifest file don't match. Although, arguably, we could also detect the name mismatch and at that point print an error message with the search and replace that someone needs to do to fix it everywhere.",6,false,0,0,0,0,0,0,0,0,0
1246,Should compat `~0.y.z` be the same as `=0.y.z`?,open,nickrobinson251,,,,9,2019-07-05T10:15:03.0,2019-07-05T23:15:29.0,2207,2206,https://github.com/JuliaLang/Pkg.jl/issues/1246,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1246,"Currently `~0.y.z` is the same as `^0.y.z`, but I think this might not be such useful behaviour, and perhaps for `0.y.z` versions it would be more useful to have `~0.y.z` be the same as `=0.y.z`.\n\nThis would allow `^` and `~` to mean the same no matter the major version:\n- `^` means """"only allow SemVer compatible versions"""" i.e. """"allow backwards-compatible new features""""\n- `~` means """"only allow bug-fixes"""" i.e """"do not allow new features""""\n\nThis is what they currently mean for versions x.y.z when x > 0\n\nBut for versions or 0.y.z, where SemVer doesn't say anything, I believe """"Julia SemVer"""" as encoded in Pkg says 0.1 and 0.2 can contain breaking changes, and 0.1.1 and 0.1.2 can contain new backwards-compatible features, and there is no way to encode """"this just has a bug-fix"""" in 0.y.z versions. E.g. 0.1.1 -> 0.1.2 may contain only a bug-fix, but may contain a new non-breaking feature.\n\nSo I think it is more consistent to have\n```\n# no change to ^ behaviour\nPkgA = """"^0.2.3""""  # [0.2.3, 0.3.0) \nPkgB = """"^0.0.3""""  # [0.0.3, 0.0.4)\n```\n```\n# proposed change to ~ behaviour for 0.y.z versions\nPkgA = """"~0.2.3""""  # [0.2.3, 0.2.3)\nPkgB = """"~0.0.3""""  # [0.0.3, 0.0.3)\n```\n\nThe gain here is that there is consistent syntax `^` for """"only non-breaking features"""", and `~` for """"no new features"""" no matter the major version.","[fredrikekre]: If you mean `=`, then why not use `=`?\n\n> The gain here is that there is consistent syntax ^ for """"only non-breaking features"""", and ~ for """"no new features"""" no matter the major version.\n\n`~` will now also mean """"no bugfixes"""". | [nickrobinson251]: The problem is that I need to pay attention to what the major version is to get """"no new features"""" behaviour. I suggest `~` should mean """"no new features only bug-fixes"""", which is what it means for x.y.z with x>0 but currently not for x=0\n\ni.e. i want consistent behaviour no matter the major version, but currently i have to use inconsistent syntax for that. I do not want `=` in all cases, I want """"no new features"""", which means writing `~` for x>0, but `=` for x=0. \n\nNote that there is no way for `~` to mean """"only bug-fixes"""" becuase in `0.y.z` there is no way to encode in the version number that the release contains only bug-fixes. | [nickrobinson251]: Obviously in 0.y.z land, only 2 interesting things can happen: y changes or only z changes. But we have 3 pieces of syntax to play with: `^`, `~`, `=`. So 2 out of 3 will end up signifying the same thing. \n\nCurrently `^` and `~` mean the same thing. I propose that it is more useful for `~` and `=` to mean the same thing. The benefit is a consistent syntax for """"no new features"""" no matter the major version. (Or more generally, `^` and `~` having the same meaning no matter the major version). | [StefanKarpinski]: If we interpret `~x.y.z` to mean """"only bug fixes"""" in the Julia convention then it should do the following:\n* `~1.2.3 = [1.2.3, 1.3.0)`\n* `~0.1.2 = [0.1.2, 0.2.0)`\n* `~0.0.1 = [0.0.1, 0.0.2)`\n\nI think that's what you meant, @nickrobinson251, but there may have been a typo since both of the closed/open version ranges you wrote are empty: `[0.2.3, 0.2.3)` and `[0.0.3, 0.0.3)`. | [nickrobinson251]: Actually that's exactly what I am disputing 😆 \n\nI understand """"only bug-fixes"""" to be a thing that cannot be represented by a version with a lead 0 (in Julia SemVer world).\n\n0.1 goes to 0.2 if a breaking change is included, else it goes to 0.1.1. So 0.1.1 may contain only bug-fixes, or it may contain backwards-compatible new features, meaning there is no way to ensure we only get bug-fixes. | [StefanKarpinski]: > I understand """"only bug-fixes"""" to be a thing that cannot be represented by a version with a lead 0 (in Julia SemVer world).\n\n> So 0.1.1 may contain only bug-fixes, or it may contain backwards-compatible new features\n\nThat's not how Julia itself used SemVer in the pre-1.0 world, e.g. `0.4.1` was a bugfix-only release. So before 1.0 there were only bugfix releases and breaking releases—there were no non-breaking feature releases. I've been meaning to write a blog post about this, perhaps today is a good day for that. | [nickrobinson251]: > before 1.0 there were only bugfix releases and breaking releases—there were no non-breaking feature releases.\n\nHmmm, interesting! FWIW, in the 0.y.z world, i think breaking versus non-breaking is a more useful distinction than feature versus bug-fix, at least for packages -- perhaps for projects on the scale of Julia itself it's different, or perhaps I am wrong :) | [StefanKarpinski]: The reasoning is pretty simple: if your project is mature enough to have non-breaking feature-adding releases, then its API is pretty stable and it's mature enough to have a non-zero major version number. | [nickrobinson251]: I think maybe the issue i'm running into is that adopting a """"breaking v non-breaking"""" distinction is easier / more useful, partly becuase supporting multiple """"breaking""""-but-not-actually-breaking changes whenever a new feature or default changed is added is annoying for 2 reasons:\n1. currently we have to list every version: `0.2.1, 0.3, 0.4, 0.5, 0.6, ...` (https://github.com/JuliaLang/Pkg.jl/issues/843 would help here)\n2. When the main package changes, it's not easy to check if some of these dependency versions should be removed from the compat list (https://github.com/JuliaLang/Pkg.jl/issues/1062 would help here)\n\nContext is an ecosystem of 10s of packages, some of which have are adding many new features, as part of figuring out the right API.",9,false,0,0,0,0,0,0,0,0,0
1245,Feature request: activate environment on top of current stack,open,nickrobinson251,,,,5,2019-07-04T12:36:03.0,2019-07-04T16:57:12.0,2208,2207,https://github.com/JuliaLang/Pkg.jl/issues/1245,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1245,"Sometimes it is useful to create a new environment stacked on the current environment \n(where the current environment is not the """"base"""" `v1.x` environment)\n\ne.g. Have both """"Level1"""" and """"Level2"""" packages available by doing something like this\n\n```julia\n(v1.1) pkg> activate Level1\n[ Info: activating new environment at ~/Level1.\n\n(Level1) pkg> add Example\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `~/Level1/Project.toml`\n  [7876af07] + Example v0.5.1\n  Updating `~/Level1/Manifest.toml`\n  [7876af07] + Example v0.5.1\n  ...\n\n(Level1) pkg> activate Level2\n[ Info: activating new environment at ~/Level2.\n\njulia> using Example\nERROR: ArgumentError: Package Example not found in current path:\n- Run `import Pkg; Pkg.add(""""Example"""")` to install the Example package.\n\nStacktrace:\n [1] require(::Module, ::Symbol) at ./loading.jl:823\n\njulia> LOAD_PATH\n3-element Array{String,1}:\n """"@""""\n """"@v#.#""""\n """"@stdlib""""\n```\n^ This doesn't stack Level2 on Level1\n\nThe workaround is to `pushfirst!(LOAD_PATH, """"path/to/Level1"""")` (Thanks @fredrikekre for pointing this out).\n\ne.g.\n```julia\njulia> pushfirst!(Base.LOAD_PATH, """"/Users/nick/Level1"""")\n6-element Array{String,1}:\n """"/Users/nick/Level1""""\n """"@""""\n """"@v#.#""""\n """"@stdlib""""\n\n(Level2) pkg> status\n    Status `~/Level2/Project.toml`\n  (empty environment)\n\njulia> using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n```\n\nPerhaps this can be an argument to `activate`? e.g. `activate --stack Level2`, to first add the current environment to the `LOAD_PATH` before activating the new one?\n\n(I think this has some relation to #1233 ...and maybe #621)","[fredrikekre]: See also https://github.com/JuliaLang/Pkg.jl/pull/1051 | [KristofferC]: > Sometimes it is useful to create a new environment stacked on the current environment\n\nWhen is this? Something solved by https://github.com/JuliaLang/Pkg.jl/issues/1233? | [nickrobinson251]: One example is developing tests for a package:  `instantiate` a Project, `add` some test-only dependencies while working, they get added to `deps`, but you do not want them in deps. (Even if these test-only dependencies already exist in `extras`, they will be ignored by `instantiated`, and you need to `add` them and they get added to `deps`.)\n\nSimilar thing goes for developing a new feature, where you're experimenting with some new dependencies.\n\nSeems like an example of a """"sub-project"""", but #1233 is maybe trying to solve some more complicated cases than this too :) | [fredrikekre]: > One example is developing tests for a package: instantiate a Project, add some test-only dependencies while working, they get added to deps, but you do not want them in deps. (Even if these test-only dependencies already exist in extras, they will be ignored by instantiated, and you need to add them and they get added to deps.)\n\nThis is basically #1233, and is essentially already working in Julia 1.2.\n\n> Similar thing goes for developing a new feature, where you're experimenting with some new dependencies.\n\nIsn't this why we use git? | [nickrobinson251]: I think this could be solved without solving #1233 :)\n\n(But hopefully solving #1233 hopefully solves this -- i feel like that's a good, more ambitious goal, and here i'm suggesting a nicer interface for a thing i thought was already possible i.e. stacking environments... maybe i'm wrong).\n\n> is essentially already working in Julia 1.2\n\ni've not used Julia 1.2 yet, and do not know what's different, sorry. Are you saying #1233  is resolved in 1.2?\n\n> Isn't this why we use git?\n\nGit can help me fix the unintended changes. \n\nAccess to different dependencies is why we use a package manager. I would like to have fixed list of """"level1"""" packages that are accessible from a """"level2"""" environment. This is already possible when """"level1"""" is """"v1.x"""", but not otherwise.",5,false,0,0,0,0,0,0,0,0,0
1236,"If add fails due to resolve error, a subsequent add will complete without build",open,aviks,,,,1,2019-06-20T21:26:11.0,2019-06-21T10:25:58.0,2221,2221,https://github.com/JuliaLang/Pkg.jl/issues/1236,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1236,"```julia\n(v1.1) pkg> st\n    Status `C:\Users\avik\.julia\environments\v1.1\Project.toml`\n  [c52e3926] Atom v0.7.14\n  [e5e0dc1b] Juno v0.5.4\n\n(v1.1) pkg> add XGBoost#master\n  Updating registry at `C:\Users\avik\.julia\registries\General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n   Cloning git-repo `https://github.com/dmlc/XGBoost.jl.git`\n  Updating git-repo `https://github.com/dmlc/XGBoost.jl.git`\n Resolving package versions...\nERROR: Unsatisfiable requirements detected for package ASTInterpreter2 [e6d88f4b]:\n ASTInterpreter2 [e6d88f4b] log:\n ├─possible versions are: 0.1.0-0.1.1 or uninstalled\n ├─restricted by julia compatibility requirements to versions: uninstalled\n └─restricted by compatibility requirements with Atom [c52e3926] to versions: 0.1.0-0.1.1 — no versions left\n   └─Atom [c52e3926] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0-0.2.1, 0.3.0, 0.4.0-0.4.6, 0.5.0-0.5.10, 0.6.0-0.6.17, 0.7.0-0.7.15, 0.8.0-0.8.7] or uninstalled\n     └─restricted to versions 0.7.14 by an explicit requirement, leaving only versions 0.7.14\n\n(v1.1) pkg> up\n  Updating registry at `C:\Users\avik\.julia\registries\General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n Installed Juno ─────────────── v0.7.0\n Installed OrderedCollections ─ v1.1.0\n Installed StringDistances ──── v0.3.2\n Installed Widgets ──────────── v0.6.1\n Installed CSTParser ────────── v0.6.0\n Installed Atom ─────────────── v0.8.7\n Installed ColorTypes ───────── v0.8.0\n Installed Colors ───────────── v0.9.5\n Installed Distances ────────── v0.8.0\n Installed Compat ───────────── v2.1.0\n Installed Tokenize ─────────── v0.5.4\n Installed WebSockets ───────── v1.5.2\n Installed MacroTools ───────── v0.5.0\n Installed HTTP ─────────────── v0.8.2\n Installed FixedPointNumbers ── v0.6.1\n Installed Cassette ─────────── v0.2.3\n Installed Traceur ──────────── v0.3.0\n Installed CodeTracking ─────── v0.5.7\n Installed MbedTLS ──────────── v0.6.8\n Installed BinaryProvider ───── v0.5.4\n Installed DataStructures ───── v0.15.0\n Installed WebIO ────────────── v0.8.5\n Installed JuliaInterpreter ─── v0.6.0\n  Updating `C:\Users\avik\.julia\environments\v1.1\Project.toml`\n  [c52e3926] ↑ Atom v0.7.14 ⇒ v0.8.7\n  [e5e0dc1b] ↑ Juno v0.5.4 ⇒ v0.7.0\n  Updating `C:\Users\avik\.julia\environments\v1.1\Manifest.toml`\n  [e6d88f4b] - ASTInterpreter2 v0.1.1\n  [c52e3926] ↑ Atom v0.7.14 ⇒ v0.8.7\n  [b99e7846] ↑ BinaryProvider v0.5.3 ⇒ v0.5.4\n  [00ebfdb7] + CSTParser v0.6.0\n  [7057c7e9] ↑ Cassette v0.2.2 ⇒ v0.2.3\n  [da1fd8a2] + CodeTracking v0.5.7\n  [3da002f7] + ColorTypes v0.8.0\n  [5ae59095] + Colors v0.9.5\n  [34da2185] ↑ Compat v1.4.0 ⇒ v2.1.0\n  [864edb3b] + DataStructures v0.15.0\n  [67417a49] - DebuggerFramework v0.1.2\n  [b4f34e82] ↑ Distances v0.7.4 ⇒ v0.8.0\n  [53c48c17] + FixedPointNumbers v0.6.1\n  [cd3eb016] ↑ HTTP v0.7.1 ⇒ v0.8.2\n  [aa1ae85d] + JuliaInterpreter v0.6.0\n  [e5e0dc1b] ↑ Juno v0.5.4 ⇒ v0.7.0\n  [1914dd2f] ↑ MacroTools v0.4.4 ⇒ v0.5.0\n  [739be429] ↑ MbedTLS v0.6.7 ⇒ v0.6.8\n  [bac558e1] ↑ OrderedCollections v1.0.2 ⇒ v1.1.0\n  [88034a9c] ↑ StringDistances v0.3.1 ⇒ v0.3.2\n  [0796e94c] ↑ Tokenize v0.5.3 ⇒ v0.5.4\n  [37b6cedf] ↑ Traceur v0.2.1 ⇒ v0.3.0\n  [0f1e0344] ↑ WebIO v0.7.0 ⇒ v0.8.5\n  [104b5d7c] ↑ WebSockets v1.2.0 ⇒ v1.5.2\n  [cc8bc4a8] ↑ Widgets v0.4.4 ⇒ v0.6.1\n  Building MbedTLS → `C:\Users\avik\.julia\packages\MbedTLS\X4xar\deps\build.log`\n  Building WebIO ──→ `C:\Users\avik\.julia\packages\WebIO\nNJPv\deps\build.log`\n\n(v1.1) pkg>\n\n(v1.1) pkg> add XGBoost#master\n  Updating git-repo `https://github.com/dmlc/XGBoost.jl.git`\n Resolving package versions...\n  Updating `C:\Users\avik\.julia\environments\v1.1\Project.toml`\n  [009559a3] + XGBoost v0.4.0 #master (https://github.com/dmlc/XGBoost.jl.git)\n  Updating `C:\Users\avik\.julia\environments\v1.1\Manifest.toml`\n  [009559a3] + XGBoost v0.4.0 #master (https://github.com/dmlc/XGBoost.jl.git)\n\n(v1.1) pkg> test XGBoost\n   Testing XGBoost\n Resolving package versions...\n    Status `C:\Users\avik\AppData\Local\Temp\jl_3C51.tmp\Manifest.toml`\n  [b99e7846] BinaryProvider v0.5.4\n  [009559a3] XGBoost v0.4.0 #master (https://github.com/dmlc/XGBoost.jl.git)\n  [2a0f44e3] Base64  [`@stdlib/Base64`]\n  [8ba89e20] Distributed  [`@stdlib/Distributed`]\n  [b77e0a4c] InteractiveUtils  [`@stdlib/InteractiveUtils`]\n  [8f399da3] Libdl  [`@stdlib/Libdl`]\n  [37e2e46d] LinearAlgebra  [`@stdlib/LinearAlgebra`]\n  [56ddb016] Logging  [`@stdlib/Logging`]\n  [d6f4376e] Markdown  [`@stdlib/Markdown`]\n  [de0858da] Printf  [`@stdlib/Printf`]\n  [9a3f8284] Random  [`@stdlib/Random`]\n  [ea8e919c] SHA  [`@stdlib/SHA`]\n  [9e88b42a] Serialization  [`@stdlib/Serialization`]\n  [6462fe0b] Sockets  [`@stdlib/Sockets`]\n  [2f01184e] SparseArrays  [`@stdlib/SparseArrays`]\n  [10745b16] Statistics  [`@stdlib/Statistics`]\n  [8dfed614] Test  [`@stdlib/Test`]\n  [4ec0a83e] Unicode  [`@stdlib/Unicode`]\nERROR: LoadError: could not open file C:\Users\avik\.julia\packages\XGBoost\yANpD\deps\deps.jl\nStacktrace:\n [1] include at .\boot.jl:326 [inlined]\n [2] include_relative(::Module, ::String) at .\loading.jl:1038\n [3] include at .\sysimg.jl:29 [inlined]\n [4] include(::String) at C:\Users\avik\.julia\packages\XGBoost\yANpD\src\XGBoost.jl:1\n [5] top-level scope at none:0\n [6] include at .\boot.jl:326 [inlined]\n [7] include_relative(::Module, ::String) at .\loading.jl:1038\n [8] include(::Module, ::String) at .\sysimg.jl:29\n [9] top-level scope at none:2\n [10] eval at .\boot.jl:328 [inlined]\n [11] eval(::Expr) at .\client.jl:404\n [12] top-level scope at .\none:3\nin expression starting at C:\Users\avik\.julia\packages\XGBoost\yANpD\src\XGBoost.jl:13\nERROR: LoadError: Failed to precompile XGBoost [009559a3-9522-5dbb-924b-0b6ed2b22bb9] to C:\Users\avik\.julia\compiled\v1.1\XGBoost\rSeEh.ji.\nStacktrace:\n [1] error(::String) at .\error.jl:33\n [2] compilecache(::Base.PkgId, ::String) at .\loading.jl:1197\n [3] _require(::Base.PkgId) at .\loading.jl:960\n [4] require(::Base.PkgId) at .\loading.jl:858\n [5] require(::Module, ::Symbol) at .\loading.jl:853\n [6] include at .\boot.jl:326 [inlined]\n [7] include_relative(::Module, ::String) at .\loading.jl:1038\n [8] include(::Module, ::String) at .\sysimg.jl:29\n [9] include(::String) at .\client.jl:403\n [10] top-level scope at none:0\nin expression starting at C:\Users\avik\.julia\packages\XGBoost\yANpD\test\runtests.jl:1\nERROR: Package XGBoost errored during testing\n\n(v1.1) pkg> build XGBoost\n  Building XGBoost → `C:\Users\avik\.julia\packages\XGBoost\yANpD\deps\build.log`\n\n(v1.1) pkg> test XGBoost\n   Testing XGBoost\n Resolving package versions...\n    Status `C:\Users\avik\AppData\Local\Temp\jl_8A8.tmp\Manifest.toml`\n  [b99e7846] BinaryProvider v0.5.4\n  [009559a3] XGBoost v0.4.0 #master (https://github.com/dmlc/XGBoost.jl.git)\n  [2a0f44e3] Base64  [`@stdlib/Base64`]\n  [8ba89e20] Distributed  [`@stdlib/Distributed`]\n  [b77e0a4c] InteractiveUtils  [`@stdlib/InteractiveUtils`]\n  [8f399da3] Libdl  [`@stdlib/Libdl`]\n  [37e2e46d] LinearAlgebra  [`@stdlib/LinearAlgebra`]\n  [56ddb016] Logging  [`@stdlib/Logging`]\n  [d6f4376e] Markdown  [`@stdlib/Markdown`]\n  [de0858da] Printf  [`@stdlib/Printf`]\n  [9a3f8284] Random  [`@stdlib/Random`]\n  [ea8e919c] SHA  [`@stdlib/SHA`]\n  [9e88b42a] Serialization  [`@stdlib/Serialization`]\n  [6462fe0b] Sockets  [`@stdlib/Sockets`]\n  [2f01184e] SparseArrays  [`@stdlib/SparseArrays`]\n  [10745b16] Statistics  [`@stdlib/Statistics`]\n  [8dfed614] Test  [`@stdlib/Test`]\n  [4ec0a83e] Unicode  [`@stdlib/Unicode`]\n[22:22:55] 6513x126 matrix with 143286 entries loaded from ../data/agaricus.txt.train\n...\n...\nTest Summary: | Pass  Total\nXGBoost       |   10     10\n   Testing XGBoost tests passed\n\n(v1.1) pkg>\n```",[KristofferC]: I think this is only true for packages added by url or a branch.,1,false,0,0,0,0,0,0,0,0,0
1208,"[docs] clarify meaning of ""project"" earlier",open,RossBoylan,,documentation,,2,2019-05-25T02:51:21.0,2019-06-10T20:05:48.0,2248,2231,https://github.com/JuliaLang/Pkg.jl/issues/1208,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1208,"Section 2, which also appears to be the only documentation for Pkg in the main julia documentation, refers to """"your project directory"""".  In context, I read this as """"your  working directory."""" So I inferred, incorrectly, that `dev --local` would be putting stuff in that directory (see https://discourse.julialang.org/t/recommendations-for-how-to-browse-source-code/24303 for more background). Section 3 also makes passing reference to """"project"""", but it is not until section 4 projects are discussed.\n\nThe intro explicitly states \n\n> Pkg is designed around “environments”: independent sets of packages that can be local to an individual project or shared and selected by name.\n\nbut it turns out some (many?) of the operations described actually are operating on projects.\n\nI suggest discussing projects at least briefly before dropping the term in the documentation.  It might even be appropriate to discuss projects first, i.e., section 4 becomes section 2.\n\n Packages, Projects, Environments and the Pkg manager form an overlapping and interrelated set of concepts in a way that does not seem to me well-factored.  But, baring a redesign, it would be good to explain it more clearly.  Even with a basic awareness of the different concepts it's hard to track.\n\nFor example, the discussion of Projects is in section 4, whose nominal subject is Environments.  But projects are closely related to packages, and the intro emphasized that packages and environments were different things.  The intro also talks about the possibility of chaining environments, but the pkg manager doesn't obviously provide any way to view or manipulate such chaining.  I suppose import and using do so in  a way, but those are for packages and environments are not packages:copyright:.","[00vareladavid]: We changed the """"Getting Started"""" section recently: #1023. I think it addresses your concerns. You can see the latest version here: https://julialang.github.io/Pkg.jl/dev/getting-started/. It doesn't mention the """"project directory"""" anymore, but instead offers a more concrete explanation of what an """"environment"""" is.\n\nPerhaps we could do a better job of distinguishing between a project and an environment in the glossary? Do you still see the same weaknesses in the new version?\n\nThe purpose of the """"Getting Started"""" section is to quickly orient new users to the general concepts, they can then learn more details in the subsequent sections. | [RossBoylan]: Regarding projects and directories, the new version is clear that a project and a working directory are different.\n\nHowever, it doesn't provide any info on how activate decides where to put  the directory, if that location can be controlled, or even  whether you need to have created the directory in the file system first.\n\nIt also uses """"registered packages"""" with no explanation.\n\nThe new wording seems to imply a different relation between packages and environments than the old intro  to the Pkg manual.  There one environment can contain many packages (still true), and can be shared between multiple  projects.  But the new language indicates that  an environment has a project, which is different.\n\nThere are a number of topics that  occurred to me right away when reading the description; arguably they are more advanced and so could be kept out of the intro.  What about using a project already on your local filesystem?  Does the url based syntax work with develop?  And my original question that inspired this particular issue: how do I browse the source?",2,false,0,0,0,0,0,0,0,0,0
1218,Pkg.build errors when depot is read-only,open,simonbyrne,,,,3,2019-06-05T16:04:49.0,2019-06-05T16:40:57.0,2236,2236,https://github.com/JuliaLang/Pkg.jl/issues/1218,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1218,"Part of making making system-provided depots useable (#763, #669). `Pkg.build()` will attempt to rebuild packages in _all_ depots, and error if any of them are read-only.\n\nExample from https://github.com/JuliaLang/Pkg.jl/pull/733#issuecomment-498941123:\n\n```julia\nusing Pkg\n\nenvdir = mktempdir()\n\ndepot1 = mktempdir()\ndepot2 = mktempdir()\n\nPkg.activate(envdir)\n\nresize!(DEPOT_PATH, 1)\nDEPOT_PATH[1] = depot2\nPkg.add(""""Arpack"""") # add Arpack to depot2\n\nresize!(DEPOT_PATH, 2)\nDEPOT_PATH[1] = depot1\nDEPOT_PATH[2] = depot2\nPkg.add(""""Rmath"""") # add Rmath to depot1\n\nPkg.build() # this works\n\nrun(`chmod -R ugo-w $depot2`) # make depot2 read-only\n\nPkg.build() # this fails\n```\n\n```\n\njulia> Pkg.build() # this fails\n  Building Arpack → `/var/folders/50/q7_qvjks4c5dj_51zd0cp4cw0000gn/T/tmpkcDoqm/packages/Arpack/cu5By/deps/build.log`\nERROR: SystemError: opening file """"/var/folders/50/q7_qvjks4c5dj_51zd0cp4cw0000gn/T/tmpkcDoqm/packages/Arpack/cu5By/deps/build.log"""": Permission denied\nStacktrace:\n [1] #systemerror#43(::Nothing, ::Function, ::String, ::Bool) at ./error.jl:134\n [2] systemerror at ./error.jl:134 [inlined]\n [3] #open#309(::Nothing, ::Nothing, ::Nothing, ::Bool, ::Nothing, ::Function, ::String) at ./iostream.jl:283\n [4] #open at ./none:0 [inlined]\n [5] open(::String, ::String) at ./iostream.jl:339\n [6] #open#310(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::getfield(Pkg.Operations, Symbol(""""##52#57"""")){Bool,Cmd}, ::String, ::Vararg{String,N} where N) at ./iostream.jl:367\n [7] open at ./iostream.jl:367 [inlined]\n [8] (::getfield(Pkg.Operations, Symbol(""""##51#56"""")){Bool,String,Cmd,String})() at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1060\n [9] #53 at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1080 [inlined]\n [10] #41 at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:898 [inlined]\n [11] withenv(::getfield(Pkg.Operations, Symbol(""""##41#46"""")){getfield(Pkg.Operations, Symbol(""""##53#58"""")){getfield(Pkg.Operations, Symbol(""""##51#56"""")){Bool,String,Cmd,String}},Pkg.Types.Context}, ::Pair{String,String}, ::Vararg{Pair{String,B} where B,N} where N) at ./env.jl:148\n [12] (::getfield(Pkg.Operations, Symbol(""""##40#44"""")){Bool,getfield(Pkg.Operations, Symbol(""""##53#58"""")){getfield(Pkg.Operations, Symbol(""""##51#56"""")){Bool,String,Cmd,String}},Pkg.Types.Context,Pkg.Types.PackageSpec,Pkg.Types.Context})(::String) at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:897\n [13] mktempdir(::getfield(Pkg.Operations, Symbol(""""##40#44"""")){Bool,getfield(Pkg.Operations, Symbol(""""##53#58"""")){getfield(Pkg.Operations, Symbol(""""##51#56"""")){Bool,String,Cmd,String}},Pkg.Types.Context,Pkg.Types.PackageSpec,Pkg.Types.Context}, ::String) at ./file.jl:581\n [14] mktempdir at ./file.jl:579 [inlined]\n [15] #with_dependencies_loadable_at_toplevel#38(::Bool, ::Function, ::getfield(Pkg.Operations, Symbol(""""##53#58"""")){getfield(Pkg.Operations, Symbol(""""##51#56"""")){Bool,String,Cmd,String}}, ::Pkg.Types.Context, ::Pkg.Types.PackageSpec) at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:853\n [16] #with_dependencies_loadable_at_toplevel at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Types.jl:0 [inlined]\n [17] #build_versions#48(::Bool, ::Bool, ::Function, ::Pkg.Types.Context, ::Array{Base.UUID,1}) at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1078\n [18] #build_versions at ./none:0 [inlined]\n [19] #build#59(::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:377\n [20] build at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:352 [inlined]\n [21] #build#58 at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:350 [inlined]\n [22] build at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:350 [inlined]\n [23] #build#55 at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:347 [inlined]\n [24] build() at /Users/osx/buildbot/slave/package_osx64/build/usr/share/julia/stdlib/v1.1/Pkg/src/API.jl:347\n [25] top-level scope at none:0\n```","[KristofferC]: Do you have a suggestion of what would be a better experience? | [simonbyrne]: I'm not sure. Maybe `build` should only operate on packages in the first depot by default? You could provide a `-depot=n` option to specify which depot to build, or `-all` to rebuild all? | [KristofferC]: Yeah, I see we only update registries in first deport entry so is perhaps sensible to do the same for build.",3,false,0,0,0,0,0,0,0,0,0
1212,`instantiate` does not update registry sometimes?,open,nickrobinson251,,,,2,2019-05-29T13:42:21.0,2019-05-29T17:00:11.0,2244,2243,https://github.com/JuliaLang/Pkg.jl/issues/1212,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/1212,"I _think_ `instantiate` does not update registries correctly?\n\nI cloned a package Bar.jl with a dependency on a package Foo, but Foo.jl was only registered since I last `update`d, and when I ran `instantiate` Foo did not get installed. It require me specifically running `update`:\n\n```\n(Bar) pkg> instantiate\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Updating registry at `~/.julia/registries/Company`\n  Updating git-repo `git@gitlab.company.ca:company/PrivateRegistry.git`\n\njulia> using Foo\nERROR: ArgumentError: Package Foo [f7bf1965-0170-51b9-8c5f-a992d46b9575] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\n(Bar) pkg> up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Updating registry at `~/.julia/registries/Company`\n  Updating git-repo `git@gitlab.company.ca:company/PrivateRegistry.git`\n Resolving package versions...\n Installed Foo ────── v0.1.1\n  Updating `~/Documents/code/Bar.jl/Project.toml`\n  [f7bf1965] + Foo v0.1.1\n\n(Bar) pkg> instantiate\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Updating registry at `~/.julia/registries/Company`\n  Updating git-repo `git@gitlab.company.ca:company/PrivateRegistry.git`\n\njulia> using Foo\n[ Info: Precompiling Foo [f7bf1965-0170-51b9-8c5f-a992d46b9575]```\n```\nJulia v1.1.1\n\nPerhaps this is realted to starting Julia with the `Bar` env instantiated - I ran `julia --project=@.`, and there was only a Project.toml (no Manifest.toml) - maybe that does not update the registries, and then `instantiate` is a no-op (that claims to be updating the registries?)","[StefanKarpinski]: You can look in `~/.julia/registries/General` and `~/.julia/registries/Company` and see if they are up-to-date or not. It says it's updating them, why do you think it isn't? | [nickrobinson251]: Seems like a `resolve`-related thing :) Quoting from julialang slack:\n\n> Kristoffer Carlsson [3:53 PM]\n> If there was no manifest it should have resolved\n> But that didn't happen",2,false,1,1,0,0,0,0,0,0,0
860,Suboptimal error message for un-instantiated package,open,Keno,,,,1,2018-10-28T19:39:19.0,2019-02-18T13:29:40.0,2456,2344,https://github.com/JuliaLang/Pkg.jl/issues/860,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/860,"I pulled in a git update to a manifest. The TensorFlow package was previously `dev`'ed, in that manifest, but not pointed to a branch (via `add`). I got the following error message:\n```\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  Updating git-repo `https://github.com/FluxML/Flux.jl.git`\n Resolving package versions...\nERROR: path /home/keno/.julia/packages/TensorFlow/kl0uH for package TensorFlow no longer exists. Remove the package or `develop` it at a new path\n```\nWhich is not the correct resolution (the correct resolution is to `instantiate`).",[KristofferC]: This error message should only happen when the package is devved.,1,false,0,0,0,0,0,0,0,0,0
562,Should `up` also just ignore unknown packages?,open,fredrikekre,,enhancement,,1,2018-08-02T07:12:58.0,2019-02-05T23:54:53.0,2544,2356,https://github.com/JuliaLang/Pkg.jl/issues/562,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/562,"Currently there is a bit of an inconsistency when Pkg throws. For example, `pkg> rm Foo` only warns, but `pkg> up Foo` errors when `Foo` is not in the project. Should both just warn? Or maybe both throw?\n```\njulia> pkg""""rm FooBar""""\n┌ Warning: `FooBar` not in project, ignoring\n└ @ Pkg.Operations ~/julia-master/usr/share/julia/stdlib/v0.7/Pkg/src/Operations.jl:1120\n[ Info: No changes\n\njulia> pkg""""up FooBar""""\nERROR: The following package names could not be resolved:\n * FooBar (not found in project or manifest)\nPlease specify by known `name=uuid`.\nStacktrace:\n```","[StefanKarpinski]: Yes, that seems like a big improvement.",1,false,2,2,0,0,0,0,0,0,0
677,Support relative paths in registries,open,cstjean,,enhancement; registries,,0,2018-08-20T16:18:13.0,2019-02-05T23:42:16.0,2525,2356,https://github.com/JuliaLang/Pkg.jl/issues/677,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/677,"Since registries and local packages often live together, it would be nice if relative paths were supported (eg. `repo = """"../MyPackage.git""""`). At the moment, that yields `ERROR: failed to clone from ../MyPackage.git, error: GitError(Code:ERROR, Class:Net, unsupported URL protocol)`\n\nAt my company, we have packages on a shared drive, and would like to have a registry, but because the mount point is different on different machines, absolute paths do not work.",,0,false,3,3,0,0,0,0,0,0,0
928,support for PSA through Pkg client?,open,00vareladavid,,feature request; REPL,,1,2018-11-27T04:44:36.0,2019-02-05T22:58:07.0,2427,2356,https://github.com/JuliaLang/Pkg.jl/issues/928,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/928,"Crazy idea inspired by the npm issues and our recent issue with the """"dirty registry"""".\n\nIf something bad happens and we need to alert users we could have some """"PSA.md"""" file that Pkg would regularly update and should users if it was ever non-empty. We could even shove this in the `General` registry so we could piggyback off the registry updates.\n\nJust some food for thought, it could come in handy in the case of an emergency. But I haven't thought too hard about it","[StefanKarpinski]: Seems like an excellent idea. People are already using an ad hoc way to display messages to users, I forget the details.",1,false,1,1,0,0,0,0,0,0,0
274,Print diff when a tracked branch changes,open,fredrikekre,,enhancement; help wanted; display and printing,,1,2018-05-03T10:07:23.0,2019-02-05T03:14:27.0,2635,2357,https://github.com/JuliaLang/Pkg.jl/issues/274,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/274,"I think it would be useful to print a diff when a tracked branch is updated. Current behaviour:\n```\npkg> add BenchmarkTools#master\n\n# change the master branch\n\npkg> up\n[...]\n  Updating `~/.julia/environments/v0.7/Project.toml`\n [6e4b80f9] ~ BenchmarkTools v0.2.5+ #master\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\n [6e4b80f9] ~  BenchmarkTools v0.2.5+ #master\n```\n\nwhich IMO would be better as\n\n```\npkg> up\n[...]\n  Updating `~/.julia/environments/v0.7/Project.toml`\n [6e4b80f9] ↑ BenchmarkTools v0.2.5+ #master(commit1) ⇒ v0.2.5+ #master(commit2)\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\n [6e4b80f9] ↑ BenchmarkTools v0.2.5+ #master(commit1) ⇒ v0.2.5+ #master(commit2)\n```\n\nAdditionally, perhaps we should always print the commit hash for tracked branches, e.g. `st` would change from\n```\n(v0.7) pkg> st\nStatus `~/.julia/environments/v0.7/Project.toml`\n [6e4b80f9] BenchmarkTools v0.2.5+ #master\n```\nto\n```\n(v0.7) pkg> st\nStatus `~/.julia/environments/v0.7/Project.toml`\n [6e4b80f9] BenchmarkTools v0.2.5+ #master(commit)\n```",[KristofferC]: We actually don't store the commit SHA (only the tree sha) for tracked branches. We could though.,1,false,2,2,0,0,0,0,0,0,0
710,`] add` skips the `build` step,open,orswan,,build,,12,2018-09-03T16:47:25.0,2019-02-04T09:11:15.0,2511,2358,https://github.com/JuliaLang/Pkg.jl/issues/710,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/710,"I'm on Windows 7, and after downloading Julia I immediately tried to add Plots, but it failed.  I filed a bug report for plots.jl, but it turns out the problem seems to be more with pkg.jl.  Doing `] add Plots` was skipping the `build` step.  After running `build` separately on Plots and GR, everything worked. \n\nYou can see the previous bug and how it was resolved here: [link](https://github.com/JuliaPlots/Plots.jl/issues/1716)","[KristofferC]: Could it be that you had installed Plots before? The automatic build step is only performed when the package is first downloaded and installed. | [orswan]: I previously had Julia 0.5.0 with Plots installed.  Would that do it? | [KristofferC]: Hm, no, that shouldn't have mattered. | [00vareladavid]: I think the best thing do here is same as #862: info that we are skiping the build step. | [fredrikekre]: For `add` I think that is too much, we should be able to assume that the build was succesful the first time. And if a user detects that is not the case they could just `build Package` to force a re-build. | [00vareladavid]: You have a point. This might be too verbose to be useful.\n\nI think the root issue is we lack a standard way of communicating a successful build.\n\nFor example: we can have a `build_result` file that well behaving programs can write to. We can relay this result in `status`:\n\n```\n  [d6f4376e]  Markdown [FAILED BUILD]\n  [de0858da]  Printf \n  [3fa0cd96]  REPL \n``` | [fredrikekre]: But there is feedback when the build fails (at installation time). If the user ignores that, then :man_shrugging: | [00vareladavid]: What about when using a new environment? The resolver resolves an indirect dep to a version which is already installed and just uses the existing path. The user will have no indication that something is wrong.\n\nThe problem is that there is no way to query for bad state. | [00vareladavid]: This is also an issue with shared depots. The user who initially `add`s a package may not be the one who ends up having that package in their dependency graph. | [KristofferC]: Typically packages say something like run `Pkg.build(""""Foo"""")` if they notice it hasn't been built correctly. | [00vareladavid]: This specific issue is about someone who did not have an indication of a failed build. | [00vareladavid]: Anyway, its just something to consider. There's probably more urgent matters to deal with first.",12,false,0,0,0,0,0,0,0,0,0
479,warn about invalid/unexpected sections in Project.toml,open,tpapp,,feature request,,2,2018-07-09T08:36:21.0,2019-02-04T05:05:03.0,2568,2358,https://github.com/JuliaLang/Pkg.jl/issues/479,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/479,I mispelled `[targets.test.deps]` as `[target.test.deps]` (note lack of `s` after `target`); a warning would have helped me locate the problem quicker.,"[fredrikekre]: (You might not have misspelled, I did had the same problem, but that was because I copied from the docs; https://github.com/JuliaLang/Pkg.jl/pull/474) | [tpapp]: That may have been the case, I don't remember exactly. But in any case, a warning would be useful for unrecognized sections.",2,false,0,0,0,0,0,0,0,0,0
533,Improve behavior when multiple overlapping registry entries exist?,open,,,registries,,4,2018-07-26T06:31:06.0,2019-02-04T05:03:17.0,2551,2358,https://github.com/JuliaLang/Pkg.jl/issues/533,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/533,"At the moment, when two registries have the same uuid registered, they produce a request call to pick the appropriate package. \n\nhttps://github.com/JuliaLang/Pkg.jl/blob/master/src/Types.jl#L988\n\nWould it be possible to opt into different behavior? For example, I like the idea of being able to have layered registries, and accept the Uuid mapping defined by the topmost layered registry. That way you could use a package repository that replaced all common uuid mappings with entries that mirror repositories to bitbucket. \n\nAdditionally: the order of multiple registries in a depot is determined by a `readdir` call. Is the ordering of that call across other systems the same? would it be possible to opt into an alternative ordering?","[KristofferC]: Exactly how multiple registries should work together is not completely worked out yet. In some cases, you want a simple merge, with no registry being more important, and in some cases, you want a hierarchy. For now, the order the registries are read in should not matter but we know there is a want to be able to """"override"""" the default registry. Right now, the focus is on finishing up the things needed for the 0.7 release though. | [unknown]: That's fine, it was something I stumbled onto and wanted to file an issue. \nWould we expect work on multiple registries to happen post v0.7 release or post v1.0 release? | [StefanKarpinski]: Yes, this would be a post-1.0 thing. | [unknown]: I think we can make a small refactoring to allow people to experiment with multiple overlapping registries until Real Serious Design Work is done on the problem. \n\nRegistry order can already be controlled by supplying new implementations for the `registries` command.  \n\nIf we extract Types.jl:994-998 https://github.com/JuliaLang/Pkg.jl/blob/master/src/Types.jl#L994 to a function, an alternative implementation can be substituted by consumers that just selects the top entry in the `choices_cache`, which mostly solves my use case for now.",4,false,0,0,0,0,0,0,0,0,0
198,Fetching all branches is a bit unnecessary when developing or updating a branch tracking package,open,KristofferC,,enhancement,,0,2018-03-14T15:16:07.0,2019-02-04T04:53:08.0,2685,2358,https://github.com/JuliaLang/Pkg.jl/issues/198,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/198,Enough to fetch the branch we want,,0,false,1,1,0,0,0,0,0,0,0
286,Introduce flag to run tests in virgin environment,open,KristofferC,,enhancement,,0,2018-05-14T10:24:44.0,2019-02-04T04:48:44.0,2624,2358,https://github.com/JuliaLang/Pkg.jl/issues/286,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/286,"In other words ignore the current manifest for tests. `test --manifest JSON` vs `test --project JSON`, default to `--manifest`.",,0,false,0,0,0,0,0,0,0,0,0
511,"Improve ""Please specify by known `name=uuid`"" error message",open,marius311,,error handling,,2,2018-07-18T10:20:23.0,2019-02-02T05:24:29.0,2559,2360,https://github.com/JuliaLang/Pkg.jl/issues/511,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/511,"I'm getting the following error message:\n\n```\njulia> Pkg.resolve()\n Resolving package versions...\nERROR: The following package names could not be resolved:\n * TreeViews=0cdf7f9c-6f0a-11e8-33c6-7b5c10fffe5f (not found in project, manifest or registry)\nPlease specify by known `name=uuid`.\n```\n\nMy exact problem I don't think is too relevant to this Issue (I think the source of this is that a branch of Atom.jl that I'm using depends on an unregistered TreeViews, which I've added directly via `add github.com/.../TreeViews.jl`, but then something broke) \n\nMy main suggestion is that something better than `Please specify by known name=uuid` should be printed. As a user, I have 1) no idea who is supposed to specify `name=uuid`, is it me or some package maintainer? and 2) if it is me, I have no idea where I'm supposed to do this, in some command I typed, or in a file somewhere? These are real questions I have, not being yet that familiar with Pkg3; it seems a slightly better message here could be really helpful. \n\n","[KristofferC]: Yeah, I think the original error message was designed to show up only when you did\n\n```\nadd Foo\n```\n\nwhich then had the solution to instead do\n\n```\nadd Foo=abcde...\n```\n\nbut it should indeed be improved for this type of situations. | [marius311]: Ah I see, yea, in that case it would have been more obvious.",2,false,1,1,0,0,0,0,0,0,0
727,Feature request: build dependencies,open,eschnett,,sandbox,,2,2018-09-07T15:59:55.0,2019-02-01T07:10:08.0,2507,2361,https://github.com/JuliaLang/Pkg.jl/issues/727,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/727,"I have a package that uses `Conda.jl`, but only during building (i.e. from `deps/build.jl`). It would be nice if I could declare `Conda` as a build-only dependency, similar to the way I can declare test-only dependencies.",[fredrikekre]: Your build script can instantiate a custom Project.toml with any dependencies you want. | [fredrikekre]: > Your build script can instantiate a custom Project.toml with any dependencies you want.\n\nToy implementation: https://github.com/fredrikekre/Sandbox.jl,2,false,2,2,0,0,0,0,0,0,0
878,Project package not isolated,open,SrAceves,,,,9,2018-11-02T17:08:51.0,2018-11-06T03:33:21.0,2451,2448,https://github.com/JuliaLang/Pkg.jl/issues/878,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/878,"I have a private project package (i.e. with a`Project.toml` file). Instantiating the package, `pkg`\nworks as expected: installs all the necessary dependencies. However, when calling `using` in the REPL,\nit only loads the package when the project is activated in `pkg`; otherwise, it throws an error during the\nprecompilation process:\n\n```julia\nERROR: LoadError: ArgumentError: Package Distributions [31c24e10-a181-5473-b8eb-7969acd0382f] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n```\n\nthis even though I instantiated the package correctly. I checked that manually the `Distributions`\npackage slug directory is there (which it is); yet the error keeps appearing.\n\nOddly --as it is not what I understand per the code loading section of the docs-- the code is loaded\nafter I add `Distributions` to the base environment (i.e. `(v1.0) pkg>`).\n\nIs this behaviour expected? As per the documentation, `Project.toml` is there to allow replication\nby isolating a package's dependencies, correct?\n\nI'm not sure this is a bug, but I tried looking for this in the docs/Pkg issues/discourse and found\nnothing related.","[00vareladavid]: To be clear:\n(say the Project.toml is at `SomePackage/Project.toml`)\n```\npkg> activate SomePackage\npkg> add Distributions\npkg> instantiate\npkg> activate\npkg> add ./SomePackage\njulia> using SomePackage\n# Error occurs here\n```\nIs that how you reproduce? | [SrAceves]: Sort of; more like this:\n```julia\npkg> activate """"/path/to/SomePackage"""" # to be clear, yes the Project.toml file is in this  directory\n(SomePackage) pkg> instantiate\n# all the installation happens here\njulia> using SomePackage # This one works because SomePackage is activated in pkg\n```\nError occurs when you start a new session of julia (when `SomePackage` is not activated in `pkg`):\n\n```julia\n$ julia\njulia> using SomePackage\n# error happens here\n``` | [00vareladavid]: What version Julia are you running? If I understand what you are doing, that is unexpected behavior. But I was not able to reproduce the behavior.\n\nHere is what I did:\n```\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.0.1 (2018-09-29)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(v1.0) pkg> generate Ex\nGenerating project Ex:\n    Ex/Project.toml\n    Ex/src/Ex.jl\n\n(v1.0) pkg> activate Ex\n\n(Ex) pkg> add Distributions\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `/tmp/Ex/Project.toml`\n  [31c24e10] + Distributions v0.16.4\n  Updating `/tmp/Ex/Manifest.toml`\n  [7d9fca2a] + Arpack v0.3.0\n  [9e28174c] + BinDeps v0.8.10\n  [b99e7846] + BinaryProvider v0.5.2\n  [34da2185] + Compat v1.3.0\n  [864edb3b] + DataStructures v0.14.0\n  [31c24e10] + Distributions v0.16.4\n  [e1d29d7a] + Missings v0.3.1\n  [bac558e1] + OrderedCollections v1.0.2\n  [90014a1f] + PDMats v0.9.5\n  [1fd47b50] + QuadGK v2.0.2\n  [79098fc4] + Rmath v0.5.0\n  [a2af1166] + SortingAlgorithms v0.3.1\n  [276daf66] + SpecialFunctions v0.7.2\n  [2913bbd2] + StatsBase v0.25.0\n  [4c63d2b9] + StatsFuns v0.7.0\n  [30578b45] + URIParser v0.4.0\n  [2a0f44e3] + Base64 \n  [ade2ca70] + Dates \n  [8bb1440f] + DelimitedFiles \n  [8ba89e20] + Distributed \n  [b77e0a4c] + InteractiveUtils \n  [76f85450] + LibGit2 \n  [8f399da3] + Libdl \n  [37e2e46d] + LinearAlgebra \n  [56ddb016] + Logging \n  [d6f4376e] + Markdown \n  [a63ad114] + Mmap \n  [44cfe95a] + Pkg \n  [de0858da] + Printf \n  [3fa0cd96] + REPL \n  [9a3f8284] + Random \n  [ea8e919c] + SHA \n  [9e88b42a] + Serialization \n  [1a1011a3] + SharedArrays \n  [6462fe0b] + Sockets \n  [2f01184e] + SparseArrays \n  [10745b16] + Statistics \n  [4607b0f0] + SuiteSparse \n  [8dfed614] + Test \n  [cf7118a7] + UUIDs \n  [4ec0a83e] + Unicode \n\n(Ex) pkg> instantiate\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n\n(Ex) pkg> activate\n\n(v1.0) pkg> dev /tmp/Ex\n Resolving package versions...\n Installed ColorTypes ─ v0.7.5\n Installed PlotUtils ── v0.5.5\n Installed Colors ───── v0.9.5\n Installed GR ───────── v0.35.0\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [5918d57e] + Ex v0.1.0 [`/tmp/Ex`]\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7d9fca2a] + Arpack v0.3.0\n  [9e28174c] + BinDeps v0.8.10\n  [b99e7846] + BinaryProvider v0.5.2\n  [3da002f7] ↑ ColorTypes v0.7.4 ⇒ v0.7.5\n  [5ae59095] ↑ Colors v0.9.4 ⇒ v0.9.5\n  [34da2185] ↑ Compat v1.1.0 ⇒ v1.3.0\n  [864edb3b] ↑ DataStructures v0.12.0 ⇒ v0.14.0\n  [31c24e10] + Distributions v0.16.4\n  [5918d57e] + Ex v0.1.0 [`/tmp/Ex`]\n  [28b8d3ca] ↑ GR v0.34.1 ⇒ v0.35.0\n  [e1d29d7a] ↑ Missings v0.3.0 ⇒ v0.3.1\n  [bac558e1] ↑ OrderedCollections v1.0.0 ⇒ v1.0.2\n  [90014a1f] + PDMats v0.9.5\n  [995b91a9] ↑ PlotUtils v0.5.4 ⇒ v0.5.5\n  [1fd47b50] + QuadGK v2.0.2\n  [79098fc4] + Rmath v0.5.0\n  [276daf66] + SpecialFunctions v0.7.2\n  [4c63d2b9] + StatsFuns v0.7.0\n  [30578b45] + URIParser v0.4.0\n  [4607b0f0] + SuiteSparse \n  Building GR → `~/.julia/packages/GR/k8wwU/deps/build.log`\n\njulia> using Ex\n[ Info: Precompiling Ex [5918d57e-df02-11e8-1324-bf0f1d4b5cd9]\n\njulia> exit()\n  29.89s user 6.65s system 3% cpu 19:32.36 total                                                                                           \n█▓▒░nur0n@blue█▓▒░ Fri Nov 02 06:09:30pm $\n/tmp/ julia --startup-file=no                                                                                   \n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.0.1 (2018-09-29)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(v1.0) pkg> st\n    Status `~/.julia/environments/v1.0/Project.toml`\n  [5918d57e] Ex v0.1.0 [`/tmp/Ex`]\n  [5fb14364] OhMyREPL v0.3.0\n  [91a5bcdd] Plots v0.20.2\n  [ee283ea6] Rebugger v0.1.4\n  [295af30f] Revise v0.7.10\n\njulia> using Ex\n[ Info: Recompiling stale cache file /home/nur0n/.julia/compiled/v1.0/Ex/6forq.ji for Ex [5918d57e-df02-11e8-1324-bf0f1d4b5cd9]\n\njulia> \n``` | [SrAceves]: I'm running Julia 1.0.1.\n\nThis replicates the error (I'll be verbose):\n\nCreate a package `SomePackage` in one of the `LOAD_PATH` directories with the standard `SomePackage/src/SomePackage.jl` package file and the `SomePackage/Project.toml` file. In `Project.toml` add some `uuid`and the `Distributions` dependency (though I suppose this error should occur with any other package dependency) so that it looks like this:\n\n```toml\nuuid = """"a42cf77f-973b-4287-857d-7ea21a6c4525""""\n\n[deps]\nDistributions = """"31c24e10-a181-5473-b8eb-7969acd0382f""""\n```\nThen, in `SomePackage.jl` write:\n\n```julia\nmodule SomePackage\n\nusing Distributions\n\nend\n```\nThen, turn to the julia REPL and run:\n\n```julia\n(v1.0) pkg> activate """"path/to/SomePackage""""\n(SomePackage) pkg> instantiate\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Installed Rmath ────────────── v0.5.0\n Installed SortingAlgorithms ── v0.3.1\n Installed Missings ─────────── v0.3.1\n Installed PDMats ───────────── v0.9.5\n Installed Arpack ───────────── v0.3.0\n Installed OrderedCollections ─ v1.0.2\n Installed BinaryProvider ───── v0.5.2\n Installed Distributions ────── v0.16.4\n Installed QuadGK ───────────── v2.0.2\n Installed Compat ───────────── v1.3.0\n Installed BinDeps ──────────── v0.8.10\n Installed StatsFuns ────────── v0.7.0\n Installed SpecialFunctions ─── v0.7.2\n Installed StatsBase ────────── v0.25.0\n Installed URIParser ────────── v0.4.0\n Installed DataStructures ───── v0.14.0\n  Building Rmath ───────────→ `~/.julia/packages/Rmath/Py9gH/deps/build.log`\n  Building Arpack ──────────→ `~/.julia/packages/Arpack/UiiMc/deps/build.log`\n  Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`\n```\nThen --in the same julia session-- load the package in the the REPL (remember, `SomePackage` is still active in `pkg`):\n\n```julia\njulia> using SomePackage\n[ Info: Precompiling SomePackage [a42cf77f-973b-4287-857d-7ea21a6c4525]\n\njulia>\n```\nThis works: no errors here!\n\nNow if you start a fresh new julia session (i.e. with the default `(v1.0) pkg>` active) and try loading `SomePackage`, *then* you get the error:\n\n```julia\n $ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type """"?"""" for help, """"]?"""" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.0.1 (2018-09-29)\n _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> using SomePackage\n[ Info: Recompiling stale cache file /home/dmct/.julia/compiled/v1.0/SomePackage/SizpO.ji for SomePackage [a42cf77f-973b-4287-857d-7ea21a6c4525]\nERROR: LoadError: ArgumentError: Package Distributions [31c24e10-a181-5473-b8eb-7969acd0382f] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n\nStacktrace:\n [1] _require(::Base.PkgId) at ./loading.jl:926\n [2] require(::Base.PkgId) at ./loading.jl:855\n [3] macro expansion at ./logging.jl:311 [inlined]\n [4] require(::Module, ::Symbol) at ./loading.jl:837\n [5] include at ./boot.jl:317 [inlined]\n [6] include_relative(::Module, ::String) at ./loading.jl:1041\n [7] include(::Module, ::String) at ./sysimg.jl:29\n [8] top-level scope at none:2\n [9] eval at ./boot.jl:319 [inlined]\n [10] eval(::Expr) at ./client.jl:389\n [11] top-level scope at ./none:3\nin expression starting at /home/dmct/Proyectos/julia/Paquetes/SomePackage/src/SomePackage.jl:3\nERROR: Failed to precompile SomePackage [a42cf77f-973b-4287-857d-7ea21a6c4525] to /home/dmct/.julia/compiled/v1.0/SomePackage/SizpO.ji.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] macro expansion at ./logging.jl:313 [inlined]\n [3] compilecache(::Base.PkgId, ::String) at ./loading.jl:1187\n [4] _require(::Base.PkgId) at ./logging.jl:311\n [5] require(::Base.PkgId) at ./loading.jl:855\n [6] macro expansion at ./logging.jl:311 [inlined]\n [7] require(::Module, ::Symbol) at ./loading.jl:837\n```\nThis should replicate the error. | [00vareladavid]: Ok, thanks for the feedback. That does seem like a bug.\n\nI need one more important piece of information.  When you restart Julia, `SomePackage` is still not `add`ed to the base environment, correct? What feedback do you see when you run `(v1.0) pkg> add /path/to/SomePackage`?\n\nYou should see something like this:\n```\n(v1.0) pkg> dev /tmp/SomePackage\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [5918d57e] + SomePackage v0.1.0 [`/tmp/SomePackage`]\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7d9fca2a] + Arpack v0.3.0\n  [9e28174c] + BinDeps v0.8.10\n  [b99e7846] + BinaryProvider v0.5.2\n  [31c24e10] + Distributions v0.16.4\n  [5918d57e] + SomePackage v0.1.0 [`/tmp/SomePackage`]\n  [90014a1f] + PDMats v0.9.5\n  [1fd47b50] + QuadGK v2.0.2\n  [79098fc4] + Rmath v0.5.0\n  [276daf66] + SpecialFunctions v0.7.2\n  [4c63d2b9] + StatsFuns v0.7.0\n  [30578b45] + URIParser v0.4.0\n  [4607b0f0] + SuiteSparse \n``` | [SrAceves]: > When you restart Julia, `SomePackage` is still not added to the base environment, correct?\n\nCorrect, but is it relevant? are packages in the `LOAD_PATH` directories treated differently than the base environment packages?\n\n> What feedback do you see when you run `(v1.0) pkg> add /path/to/SomePackage`?\n\nAn error -- it's not a git-repo, so it can't clone it; this is the output for both `(v1.0) pkg> add ...` and `(v1.0) pkg> dev ...`:\n\n```julia\n(v1.0) pkg> add path/to/SomePackage\n   Cloning git-repo `path/to/SomePackage`\nERROR: failed to clone from path/to/SomePackage, error: GitError(Code:ERROR, Class:Net, unsupported URL protocol)\n```\n\n | [00vareladavid]: `develop` doesn't require a git repo, it uses the directory tree at some path directly. See my example above where I `dev /tmp/SomePackage`.\n\n> are packages in the LOAD_PATH directories treated differently than the base environment packages?\n\nNo, the """"base"""" environment is just an environment specified in `LOAD_PATH` by default.\n\nAre you modifying `LOAD_PATH` manually? If so, how? An are you sure you made the change persistent across julia sessions? FWIW, I think most people just either activate the package they want to use directly or `add`/`dev` the package to the base environment. | [SrAceves]: Hmm, I tried `dev`ing as in your example before and it threw the cloning error; I just did it again now and, oddly, it worked. Here's the output:\n\n```julia\n(v1.0) pkg> dev /home/dmct/Proyectos/julia/Paquetes/SomePackage\n Resolving package versions...\n Installed SortingAlgorithms ─ v0.3.1\n Installed Rmath ───────────── v0.5.0\n Installed QuadGK ──────────── v2.0.2\n Installed BinDeps ─────────── v0.8.10\n Installed Missings ────────── v0.3.1\n Installed StatsFuns ───────── v0.7.0\n Installed PDMats ──────────── v0.9.5\n Installed Arpack ──────────── v0.3.0\n Installed SpecialFunctions ── v0.7.2\n Installed StatsBase ───────── v0.25.0\n Installed Distributions ───── v0.16.4\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [a42cf77f] + SomePackage v0.0.0 [`~/Proyectos/julia/Paquetes/SomePackage`]\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7d9fca2a] + Arpack v0.3.0\n  [9e28174c] + BinDeps v0.8.10\n  [b99e7846] + BinaryProvider v0.5.2\n  [34da2185] + Compat v1.3.0\n  [864edb3b] + DataStructures v0.14.0\n  [31c24e10] + Distributions v0.16.4\n  [e1d29d7a] + Missings v0.3.1\n  [bac558e1] + OrderedCollections v1.0.2\n  [90014a1f] + PDMats v0.9.5\n  [1fd47b50] + QuadGK v2.0.2\n  [79098fc4] + Rmath v0.5.0\n  [a42cf77f] + SomePackage v0.0.0 [`~/Proyectos/julia/Paquetes/SomePackage`]\n  [a2af1166] + SortingAlgorithms v0.3.1\n  [276daf66] + SpecialFunctions v0.7.2\n  [2913bbd2] + StatsBase v0.25.0\n  [4c63d2b9] + StatsFuns v0.7.0\n  [30578b45] + URIParser v0.4.0\n  [2a0f44e3] + Base64 \n  [ade2ca70] + Dates \n  [8bb1440f] + DelimitedFiles \n  [8ba89e20] + Distributed \n  [b77e0a4c] + InteractiveUtils \n  [76f85450] + LibGit2 \n  [8f399da3] + Libdl \n  [37e2e46d] + LinearAlgebra \n  [56ddb016] + Logging \n  [d6f4376e] + Markdown \n  [a63ad114] + Mmap \n  [44cfe95a] + Pkg \n  [de0858da] + Printf \n  [3fa0cd96] + REPL \n  [9a3f8284] + Random \n  [ea8e919c] + SHA \n  [9e88b42a] + Serialization \n  [1a1011a3] + SharedArrays \n  [6462fe0b] + Sockets \n  [2f01184e] + SparseArrays \n  [10745b16] + Statistics \n  [4607b0f0] + SuiteSparse \n  [8dfed614] + Test \n  [cf7118a7] + UUIDs \n  [4ec0a83e] + Unicode \n  Building Arpack ──────────→ `~/.julia/packages/Arpack/UiiMc/deps/build.log`\n  Building Rmath ───────────→ `~/.julia/packages/Rmath/Py9gH/deps/build.log`\n  Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`\n```\n\n> Are you modifying LOAD_PATH manually? If so, how?\n\nYes, I'm modifying `LOAD_PATH` manually by adding new entries with `append!`.\n\n>  An are you sure you made the change persistent across julia sessions?\n\nYes, they're persistent across julia sessions. | [SrAceves]: Sorry, closed the issue by accident.",9,false,0,0,0,0,0,0,0,0,0
811,A workflow for convieniently starting (unstacked) projects,open,jannefiluren,,documentation,,0,2018-10-10T18:11:16.0,2018-10-15T15:36:47.0,2474,2469,https://github.com/JuliaLang/Pkg.jl/issues/811,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/811,"I just wanted to shortly write about a workflow that seems to work fine for me, and maybe can be improved or documented properly if it can be helpful for others. If not, please just close this issue. \n\nI wanted a way to convieniently start julia in different projects, including """"unstacked"""" environments so that I do not by mistake forget to add dependencies when working on important projects (e.g. code for scientific papers). I also wanted to see which project is active all the time to lower the risk of manipulating the wrong environment by accident. Below is an example for the """"unstacked"""" case.\n\nOn Linux:\n\n1) Create a user-defined environment somewhere (e.g. `/path/to/myproj`) and add some dependencies\n\n2) Write a shell script that sets the `LOAD_PATH` and starts julia:\n\n```\n#!/bin/bash\nexport JULIA_LOAD_PATH=@:/path/to/myproj:@stdlib\njulia\n```\n3) Create an alias to this shell script.\n\nOn Windows:\n\n1) Same as on Linux\n\n2) Create a bat-file with the following content:\n\n```\nset JULIA_LOAD_PATH=@;C:\\path\\to\\myproj;@stdlib\njulia\n```\n3) Put the bat-file on the desktop\n\nI have also added this piece of code to my `startup.jl` file so that I always can see which project I am working in:\n\n```julia\nimport REPL\nimport Pkg\n\natreplinit() do repl\n    if !isdefined(repl, :interface)\n        repl.interface = REPL.setup_interface(repl)\n    end\n    Base.active_repl.interface.modes[1].prompt = () -> string(Pkg.REPLMode.promptf()[1:end-6], """" jl> """")\n\nend\n```\n\nAs said, if this feedback on pkg doesn´t seem helpful, is already documented or completly obvious for anyone, sorry for the disturbance. Anyways, thanks for the tips Kristoffer, Fredrik and Stefan that helped me setup this workflow. I am very happy with pkg now; I can quickly switch between projects, I always know """"where"""" I am, and I cannot miss to add dependencies for important projects.\n\nA few related issues: https://github.com/JuliaLang/Pkg.jl/issues/623 https://github.com/JuliaLang/Pkg.jl/issues/624",,0,false,1,1,0,0,0,0,0,0,0
808,Provide a tutorial for sysadmins for setting up shared packages,open,KristofferC,,documentation,,6,2018-10-10T00:45:21.0,2018-10-10T17:00:10.0,2475,2474,https://github.com/JuliaLang/Pkg.jl/issues/808,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/808,,"[arnavs]: Thanks @KristofferC for opening this. I could take a stab at this since we've been wrangling with it. And maybe if @jlperla thinks it's OK, we could link to the VSE Syzygy docker as an example. | [KristofferC]: That would be great! | [jlperla]: Definetely work taking the time to do a succinct write-up of the setup.  But I am a little concerned about making links to the VSE syzygy setup... who knows how it might be merged or mutate with the other syzygy stuff.  But quote whatever you want from it, and llink away to it on discourse, etc. where people don't expect permanence. | [arnavs]: No problem, we can take snippets or I can give a static fork. I just really want to make sure there’s code here for this. | [jlperla]: Try snippets.  There might also be weird setup stuff for syzygy stuff that wouldn't apply to a normal jupyterhub installation.  Neither of us have the docker chops to know, but I would worry that providing the whole thing might be more confusing that helpful. | [arnavs]: Something like this? \n\n# Creating Layered Environments\n\nThis is a brief tutorial for using Pkg3 in the context of a _layered environment_, or a situation where we provide a group of users with a common, immutable backend (say, a set of pre-installed packages), and allow them to make local changes as they see fit. \n\n## Install Julia \n\nTo do this programmatically, first make a directory where you want Julia to live (usually `/opt/julia` or `/usr/bin/julia/`, and then grab and unpack the Julia binary:\n\n```\ncurl -s -L https://julialang-s3.julialang.org/bin/linux/x64/1.0/julia-1.0.0-linux-x86_64.tar.gz | \\n     tar -C /opt/julia-1.0.0 -x -z --strip-components=1 -f -\n```\n\nThis is happening as `root` in a Dockerfile.\n\n## Set up Shared User \n\nFirst, we instantiate a shared user (here, `jovyan`), and give it a home directory. (The following are commands from a Dockerfile used to create this setup). \n\n```\nENV NB_USER=jovyan\nENV HOME=/home/$NB_USER\nUSER $NB_USER\n```\n\nInstantiate that user's primary depot: \n\n```\nRUN mkdir -p $HOME/.julia/environments/v1.0 \n```\n\n(Note: A """"depot"""" is something like a `~/.julia` directory, or a directory with a `packages/`, `registries/`, `environments/`, `compiled/`, etc.)\n\nNow, we want to install a set of packages. The cleanest way to do this is to grab TOML from online, and then use `Pkg` to instantiate. \n\n```\nRUN cd $HOME/.julia/environments/v1.0 \\n# Grab the online TOML. \n&& wget -q https://raw.githubusercontent.com/QuantEcon/lecture-source-jl/master/notebooks/Manifest.toml -O Manifest.toml \\n&& wget -q https://raw.githubusercontent.com/QuantEcon/lecture-source-jl/master/notebooks/Project.toml -O Project.toml\n\n# Set up our environment. \nRUN julia -e """"using Pkg; pkg\""""build\""""; pkg\""""instantiate\""""; pkg\""""precompile\""""""""\n```\n\n## Clean Shared Environment \n\nTo avoid conflicts with resources in the individual user's home directory, it's important to scrub the shared backend of some objects: \n\n* **Registries:** Registries aren't traversed in `DEPOT_PATH` order, but rather are merged and searched. There's also a [known bug]( https://github.com/JuliaLang/Pkg.jl/issues/711) about multiple registries. So, we need to destroy the registry that came with our Julia install (`rm -rf /opt/julia-1.0.0/local/share/julia/registries`), and also the one that we cloned when installing our shared packages (`rm -rf $HOME/.julia/registries`).\n\n* **Environments:** The only TOML should be living in the end user's directory, since we ideally treat the shared depot as simply a source of packages. To that end, we want to `rm -rf $HOME/.Julia/environments`. ⚠️ It's useful sometimes to """"pre-seed"""" the end user with the Project and Manifest from the shared environment (so that their package names will automatically point to resources in the shared depot). If you want this, see the setup below:\n\n```\n  && rm -rf $HOME/.local \ \n  # Nuke the registry that came with Julia. \n  && rm -rf /opt/julia-1.0.0/local/share/julia/registries \ \n  # Nuke the registry that Jovyan uses. \n  && rm -rf $HOME/.julia/registries \ \n  && mkdir -p /home/jupyter/.julia/ \ \n  # Copy over the environments. \n  && cp -r $HOME/.julia/environments /home/jupyter/.julia/ \\n  # Nuke the jovyan environment. \n  && rm -rf $HOME/.julia/environments \n``` \n\n⚠️ Make sure the end user has read/execute permissions on the shared environment; e.g.\n\n```\nRUN chmod -R go+rx /home/jovyan/.julia\n```\n\n## Pre-Seeding \n\nAs above, if you want to initially seed the end user's TOML with the Project and Manifest from the shared depot (_after_ all build steps), simply copy over the `environments/` directory as above before destroying the shared environment. \n\n## Set the end user's DEPOT_PATH\n\nRunning something like the following\n\n```\nENV JULIA_DEPOT_PATH=""""/home/jupyter/.julia:/home/jovyan/.julia:/opt/julia""""\n```\n\nwill ensure that the end user looks to the local directory for reading/writing/cloning new packages, but will search the shared environment before grabbing packages from the internet. The last entry `/opt/julia` is where we installed Julia itself. \n",6,false,1,1,0,0,0,0,0,0,0
763,Errors when registry is on a read-only file system,open,Keno,,,,5,2018-09-19T19:00:45.0,2018-09-19T19:36:43.0,2495,2495,https://github.com/JuliaLang/Pkg.jl/issues/763,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/763,"```\nERROR: SystemError: opening file /root/.julia/registries/General/.git/config: Read-only file system\nStacktrace:\n [1] #systemerror#39(::Nothing, ::Function, ::String, ::Bool) at ./error.jl:106\n [2] systemerror at ./error.jl:106 [inlined]\n [3] #open#293(::Nothing, ::Nothing, ::Nothing, ::Bool, ::Nothing, ::Function, ::String) at ./iostream.jl:283\n [4] #open at ./none:0 [inlined]\n [5] open(::String, ::String) at ./iostream.jl:339\n [6] #open#294(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::getfield(Base, Symbol(""""##254#255"""")){String,Tuple{}}, ::String, ::Vararg{String,N} where N) at ./iostream.jl:367\n [7] open at ./iostream.jl:367 [inlined]\n [8] write at ./io.jl:278 [inlined]\n [9] #registries#49(::Bool, ::Function) at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/Types.jl:917\n [10] registries at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/Types.jl:907 [inlined]\n [11] macro expansion at ./logging.jl:307 [inlined]\n [12] update_registry(::Pkg.Types.Context) at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:96\n [13] #handle_repos_add!#31(::Bool, ::Nothing, ::Function, ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/Types.jl:593\n [14] #handle_repos_add! at ./none:0 [inlined]\n [15] #add_or_develop#13(::Symbol, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:54\n [16] #add_or_develop at ./none:0 [inlined]\n [17] #add_or_develop#12 at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:29 [inlined]\n [18] #add_or_develop at ./none:0 [inlined]\n [19] #add_or_develop#11(::Base.Iterators.Pairs{Symbol,Symbol,Tuple{Symbol},NamedTuple{(:mode,),Tuple{Symbol}}}, ::Function, ::Array{String,1}) at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:28\n [20] #add_or_develop at ./none:0 [inlined]\n [21] #add_or_develop#10 at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:27 [inlined]\n [22] #add_or_develop at ./none:0 [inlined]\n [23] #add#18 at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:69 [inlined]\n [24] add(::String) at /workspace/usr/share/julia/stdlib/v1.0/Pkg/src/API.jl:69\n [25] top-level scope at none:22\n [26] eval at ./boot.jl:319 [inlined]\n [27] eval(::Expr) at ./client.jl:389\n [28] top-level scope at none:0\nChild Process exited, exit code 1\n```","[fredrikekre]: Looks like it is when updating the registry, so something like https://github.com/JuliaLang/Pkg.jl/pull/733#issuecomment-420811091 seems like a good solution? | [Keno]: No, there's no mutable registry on this system at all (this is in PkgEval). Ideally just check whether the file system is writable and if not, don't try to update it. | [StefanKarpinski]: That's exactly what I was saying: if you only try to update writable registries, then it would be fine. If you want to be able to install packages or do anything else, `DEPOT_PATH[1]` needs to be writable, but that doesn't really have anything to do with registry updates. | [Keno]: `DEPOT_PATH[1]` is writable just fine, but `DEPOT_PATH[1]/registries` is not because it's shared between parallel runs. | [StefanKarpinski]: Ok, all the more reason to choose which registries to update based on writability.",5,false,0,0,0,0,0,0,0,0,0
623,request more extensive docs on how to develop application projects,open,StephenVavasis,,documentation,,6,2018-08-11T18:02:37.0,2018-08-28T15:51:10.0,2534,2517,https://github.com/JuliaLang/Pkg.jl/issues/623,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/623,"The description of how to develop an application project (as opposed to a package) in the latest release of the 1.0 docs is too brief. I'm referring specifically to the section """"Creating your own projects"""" in the chapter entitled """"Pkg"""" of the manual section entitled """"Standard library"""". This section tells you how to get started with the `activate` command, but it is missing: (1) that you need to make a `src` subdirectory, and that the main entrypoint needs to go in that subdirectory and needs to be named the same as the project (and maybe needs to have its module named same as the project? not sure about that). (2) that you need a `Project.toml` file. Is `generate` the correct way to make this file? The doc says that `generate` is for packages, not application projects. Please refer to:\n\nhttps://discourse.julialang.org/t/workflow-for-developing-application-in-new-pkg-manager/13051\n\nfor some discussion about this matter that reveals uncertainty among us users.\n\nNote: resubmission of https://github.com/JuliaLang/julia/issues/28601","[StephenVavasis]: ...and since I'm making requests, I'll add another.  I would also be interested to read an operational explanation of how the loader works.  In other words, a step-by-step explanation of what happens to an `import` or `using` command would help me and perhaps other users build a mental model of how all of this is supposed to work. | [StefanKarpinski]: Code loading is part of the language itself, not the package manager and is described in detail [here](https://docs.julialang.org/en/stable/manual/code-loading/index.html). There's still some missing stuff about how `LOAD_PATH` gets set and expanded and about the role of `DEPOT_PATH`. There's not much to write about application development at this point since all we have is a concept. It will become clear over time as people actually develop applications in the new framework. | [StephenVavasis]: I exchanged some messages last night (https://github.com/JuliaCollections/DataStructures.jl/issues/432) with a user having trouble with `DataStructures.jl`.  It turns out that the trouble was not the package per se, but the loader.  We did not pinpoint the cause of the problem.  The user apparently had some cruft from some other Julia build that was interfering with the package manager or loader.  The problem was resolved by making a very clean build.  \n\nThis experience, plus my own difficulties, make me think that it would be very useful if the `using` and `import` statements had a verbose mode (`@verbose using DataStructures`) that would produce a log showing each step of what the loader is doing.  This would enable more users to sort out their own problems as well as giving users a better operational understanding of how the package manager and loader work.\n | [StefanKarpinski]: There is a `JULIA_DEBUG=loading` [mechanism](https://github.com/JuliaLang/julia/blob/3fe2d08c1546c41ade0459122905016527efa03f/base/logging.jl#L418-L454), someone just needs to put the debug logging statements back in the loading code (it got deleted in the various changes since 0.6). | [mebrunet]: I just want to pipe in to say I am also confused/unsatisfied with the documentation on how to use to """"project environments"""" and Pkg3 for application development.\n\nMy use case is both simple and typical. I want to release code along with a scientific paper, and I want that code to have a easy way for the user to install the project dependencies. In python it is simple (and hacky):\n1) I create a virtual environment and install all dependencies in it (git ignored).\n2) I create/include a """"requirements.txt"""" file via `pip freeze` in the repository\n3) The user clones my code, creates a virtual environment, and points pip to the requirements file, installing the dependencies. (I can even give them a shell script that does all this for them).\n4) My source code can now be run in the correct python environment by either:\n    a) activating the virtual environment before calling the python scripts, or \n    b) specifying the python binary which should be used, e.g., `venv/bin/python src/mycode.py`\n\nBoth 4a and 4b are useful: a) when the user wants to run my code in a REPL, add new packages, edit things, etc., and b) when I want to include a shell script (e.g. `run.sh`) that calls python (and the dependencies I specified).\n\nCan someone clarify how I do this in Julia 0.7.0 / 1.0.0? Preferably going over the Julia equivalent of each step I mentioned? I seem to have found a cumbersome way of achieving 4a, but 4b is still eluding me. | [mebrunet]: Okay I think I figured it out:\n1. In the project directory (e.g. `MyApp`) run `] activate .`, then add any dependencies via `(MyApp) pkg> add SomeDep`.\n2. Include the `Project.toml` and optionally the `Manifest.toml` in the repository (these live in the root of the project dir).\n3. The user clones my code, then either runs `] activate .` and `(MyApp) pkg> instantiate`, OR `julia --project -e """"import Pkg; Pkg.instantiate()""""` (where the latter can be put into a setup script).\n4. a & b) the user / shell script simply adds the `--project` command line option when calling Julia.\n\nIs this the best practice for my use case?\n\nIf so, what I was missing (and what is missing in the docs) is the `--project` option. Note it doesn't even show up with `julia --help`. (I'm on Version 0.7.0 (2018-08-08 06:46 UTC) x86_64-apple-darwin14.5.0)\n",6,false,0,0,0,0,0,0,0,0,0
461,Packages removed from the Project (but are still left in the Manifest) should be freed?,open,KristofferC,,,,0,2018-07-03T15:22:26.0,2018-07-03T15:22:26.0,2573,2573,https://github.com/JuliaLang/Pkg.jl/issues/461,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/461,Perhaps it is only things that are in the project that should be able to track paths or repos?,,0,false,0,0,0,0,0,0,0,0,0
127,allow registries to specify per-julia-version branches,open,StefanKarpinski,,enhancement,,0,2018-02-11T21:08:10.0,2018-03-03T15:43:39.0,2715,2695,https://github.com/JuliaLang/Pkg.jl/issues/127,https://api.github.com/repos/JuliaLang/Pkg.jl/issues/127,"In Pkg2 we checkout `metadata-v2` instead of `master`. The idea was that if we made an incompatible change to the metadata format, old versions of Julia would continue to use the `metadata-v2` branch which would still have the old format, whereas a newer branch – presumably `metadata-v3` – would use the new, incompatible format.\n\nInstead of using a strange branch name on Pkg3, we can get the same future-proofing effect by allowing an optional `[branches]` section in the `registry.toml` file:\n```toml\nname = """"Uncurated""""\nuuid = """"c2463f1f-d711-5ace-9c99-4f745c283c7e""""\nrepo = """"https://github.com/JuliaRegistries/Uncurated.git""""\n\ndescription = """"""""""""\nOfficial uncurated Julia package registry where people can\nregister any package they want without too much debate about\nnaming and without enforced standards on documentation or\ntesting. We nevertheless encourage documentation, testing and\nsome amount of consideration when choosing package names.\n""""""""""""\n\n[branches]\n""""1.0-1.3"""" = """"release-1.3""""\n""""1.4-1.5"""" = """"release-1.5""""\n\n```\nJulia's `Base.VERSION` is matched against the version spec of each entry in the `[branches]` section and if there is a match, the branch name (or commit) on the right is checked out instead of the default branch. If the `[branches]` section doesn't exist or `VERSION` doesn't match any of the patterns, then the default branch `master` is used.",,0,false,0,0,0,0,0,0,0,0,0
