<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5. Creating Packages · Pkg.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://julialang.github.io/Pkg.jl/v1/creating-packages/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Pkg.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pkg.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../"><strong>1.</strong> Introduction</a></li><li><a class="tocitem" href="../getting-started/"><strong>2.</strong> Getting Started</a></li><li><a class="tocitem" href="../managing-packages/"><strong>3.</strong> Managing Packages</a></li><li><a class="tocitem" href="../environments/"><strong>4.</strong> Working with Environment</a></li><li class="is-active"><a class="tocitem" href><strong>5.</strong> Creating Packages</a><ul class="internal"><li><a class="tocitem" href="#Generating-files-for-a-package"><span>Generating files for a package</span></a></li><li><a class="tocitem" href="#Adding-dependencies-to-the-project"><span>Adding dependencies to the project</span></a></li><li><a class="tocitem" href="#Adding-a-build-step-to-the-package"><span>Adding a build step to the package</span></a></li><li><a class="tocitem" href="#Adding-tests-to-the-package"><span>Adding tests to the package</span></a></li><li><a class="tocitem" href="#Compatibility-on-dependencies"><span>Compatibility on dependencies</span></a></li><li><a class="tocitem" href="#Weak-dependencies"><span>Weak dependencies</span></a></li><li><a class="tocitem" href="#Conditional-loading-of-code-in-packages-(Extensions)"><span>Conditional loading of code in packages (Extensions)</span></a></li><li><a class="tocitem" href="#Package-naming-guidelines"><span>Package naming guidelines</span></a></li><li><a class="tocitem" href="#Registering-packages"><span>Registering packages</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li></ul></li><li><a class="tocitem" href="../compatibility/"><strong>6.</strong> Compatibility</a></li><li><a class="tocitem" href="../registries/"><strong>7.</strong> Registries</a></li><li><a class="tocitem" href="../artifacts/"><strong>8.</strong> Artifacts</a></li><li><a class="tocitem" href="../glossary/"><strong>9.</strong> Glossary</a></li><li><a class="tocitem" href="../toml-files/"><strong>10.</strong> <code>Project.toml</code> and <code>Manifest.toml</code></a></li><li><a class="tocitem" href="../repl/"><strong>11.</strong> REPL Mode Reference</a></li><li><a class="tocitem" href="../api/"><strong>12.</strong> API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><strong>5.</strong> Creating Packages</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><strong>5.</strong> Creating Packages</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/creating-packages.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="**5.**-Creating-Packages"><a class="docs-heading-anchor" href="#**5.**-Creating-Packages"><strong>5.</strong> Creating Packages</a><a id="**5.**-Creating-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#**5.**-Creating-Packages" title="Permalink"></a></h1><h2 id="Generating-files-for-a-package"><a class="docs-heading-anchor" href="#Generating-files-for-a-package">Generating files for a package</a><a id="Generating-files-for-a-package-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-files-for-a-package" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates</a> package offers an easy, repeatable, and customizable way to generate the files for a new package. It can also generate files needed for Documentation, CI, etc. We recommend that you use PkgTemplates for creating new packages instead of using the minimal <code>pkg&gt; generate</code> functionality described below.</p></div></div><p>To generate the bare minimum files for a new package, use <code>pkg&gt; generate</code>.</p><pre><code class="language-julia-repl hljs">(@v1.8) pkg&gt; generate HelloWorld</code></pre><p>This creates a new project <code>HelloWorld</code> in a subdirectory by the same name, with the following files (visualized with the external <a href="https://linux.die.net/man/1/tree"><code>tree</code> command</a>):</p><pre><code class="language-julia-repl hljs">shell&gt; tree HelloWorld/
HelloWorld/
├── Project.toml
└── src
    └── HelloWorld.jl

2 directories, 2 files</code></pre><p>The <code>Project.toml</code> file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:</p><pre><code class="language-toml hljs">name = &quot;HelloWorld&quot;
uuid = &quot;b4cd1eb8-1e24-11e8-3319-93036a3eb9f3&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Some One &lt;someone@email.com&gt;&quot;]

[deps]</code></pre><p>The content of <code>src/HelloWorld.jl</code> is:</p><pre><code class="language-julia hljs">module HelloWorld

greet() = print(&quot;Hello World!&quot;)

end # module</code></pre><p>We can now activate the project by using the path to the directory where it is installed, and load the package:</p><pre><code class="language-julia-repl hljs">pkg&gt; activate ./HelloWorld

julia&gt; import HelloWorld

julia&gt; HelloWorld.greet()
Hello World!</code></pre><p>For the rest of the tutorial we enter inside the directory of the project, for convenience:</p><pre><code class="language-julia-repl hljs">julia&gt; cd(&quot;HelloWorld&quot;)</code></pre><h2 id="Adding-dependencies-to-the-project"><a class="docs-heading-anchor" href="#Adding-dependencies-to-the-project">Adding dependencies to the project</a><a id="Adding-dependencies-to-the-project-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-dependencies-to-the-project" title="Permalink"></a></h2><p>Let’s say we want to use the standard library package <code>Random</code> and the registered package <code>JSON</code> in our project. We simply <code>add</code> these packages (note how the prompt now shows the name of the newly generated project, since we <code>activate</code>d it):</p><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; add Random JSON
   Resolving package versions...
    Updating `~/HelloWorld/Project.toml`
  [682c06a0] + JSON v0.21.3
  [9a3f8284] + Random
    Updating `~/HelloWorld/Manifest.toml`
  [682c06a0] + JSON v0.21.3
  [69de0a69] + Parsers v2.4.0
  [ade2ca70] + Dates
 ...</code></pre><p>Both <code>Random</code> and <code>JSON</code> got added to the project’s <code>Project.toml</code> file, and the resulting dependencies got added to the <code>Manifest.toml</code> file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies.</p><p>We can now use both <code>Random</code> and <code>JSON</code> in our project. Changing <code>src/HelloWorld.jl</code> to</p><pre><code class="language-julia hljs">module HelloWorld

import Random
import JSON

greet() = print(&quot;Hello World!&quot;)
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>and reloading the package, the new <code>greet_alien</code> function that uses <code>Random</code> can be called:</p><pre><code class="language-julia-repl hljs">julia&gt; HelloWorld.greet_alien()
Hello aT157rHV</code></pre><h2 id="Adding-a-build-step-to-the-package"><a class="docs-heading-anchor" href="#Adding-a-build-step-to-the-package">Adding a build step to the package</a><a id="Adding-a-build-step-to-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-build-step-to-the-package" title="Permalink"></a></h2><p>The build step is executed the first time a package is installed or when explicitly invoked with <code>build</code>. A package is built by executing the file <code>deps/build.jl</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; mkpath(&quot;deps&quot;);

julia&gt; write(&quot;deps/build.jl&quot;,
             &quot;&quot;&quot;
             println(&quot;I am being built...&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

julia&gt; print(readchomp(&quot;deps/build.log&quot;))
I am being built...</code></pre><p>If the build step fails, the output of the build step is printed to the console</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;deps/build.jl&quot;,
             &quot;&quot;&quot;
             error(&quot;Ooops&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; build
    Building HelloWorld → `~/HelloWorld/deps/build.log`
ERROR: Error building `HelloWorld`:
ERROR: LoadError: Ooops
Stacktrace:
 [1] error(s::String)
   @ Base ./error.jl:35
 [2] top-level scope
   @ ~/HelloWorld/deps/build.jl:1
 [3] include(fname::String)
   @ Base.MainInclude ./client.jl:476
 [4] top-level scope
   @ none:5
in expression starting at /home/kc/HelloWorld/deps/build.jl:1</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>A build step should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the <a href="https://github.com/JuliaPackaging/Scratch.jl">Scratch.jl</a> package.</p></div></div><h2 id="Adding-tests-to-the-package"><a class="docs-heading-anchor" href="#Adding-tests-to-the-package">Adding tests to the package</a><a id="Adding-tests-to-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-tests-to-the-package" title="Permalink"></a></h2><p>When a package is tested the file <code>test/runtests.jl</code> is executed:</p><pre><code class="language-julia-repl hljs">julia&gt; mkpath(&quot;test&quot;);

julia&gt; write(&quot;test/runtests.jl&quot;,
             &quot;&quot;&quot;
             println(&quot;Testing...&quot;)
             &quot;&quot;&quot;);

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed</code></pre><p>Tests are run in a new Julia process, where the package itself, and any test-specific dependencies, are available, see below.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Tests should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the <a href="https://github.com/JuliaPackaging/Scratch.jl">Scratch.jl</a> package.</p></div></div><h3 id="Test-specific-dependencies"><a class="docs-heading-anchor" href="#Test-specific-dependencies">Test-specific dependencies</a><a id="Test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Test-specific-dependencies" title="Permalink"></a></h3><p>There are two ways of adding test-specific dependencies (dependencies that are not dependencies of the package but will still be available to load when the package is tested).</p><h4 id="target-based-test-specific-dependencies"><a class="docs-heading-anchor" href="#target-based-test-specific-dependencies"><code>target</code> based test specific dependencies</a><a id="target-based-test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#target-based-test-specific-dependencies" title="Permalink"></a></h4><p>Using this method of adding test-specific dependencies, the packages are added under an <code>[extras]</code> section and to a test target, e.g. to add <code>Markdown</code> and <code>Test</code> as test dependencies, add the following to the <code>Project.toml</code> file:</p><pre><code class="language-toml hljs">[extras]
Markdown = &quot;d6f4376e-aef5-505a-96c1-9c027394607a&quot;
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Markdown&quot;, &quot;Test&quot;]</code></pre><p>Note that the only supported targets are <code>test</code> and <code>build</code>, the latter of which (not recommended) can be used for any <code>deps/build.jl</code> scripts.</p><h4 id="Alternative-approach:-test/Project.toml-file-test-specific-dependencies"><a class="docs-heading-anchor" href="#Alternative-approach:-test/Project.toml-file-test-specific-dependencies">Alternative approach: <code>test/Project.toml</code> file test specific dependencies</a><a id="Alternative-approach:-test/Project.toml-file-test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-approach:-test/Project.toml-file-test-specific-dependencies" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The exact interaction between <code>Project.toml</code>, <code>test/Project.toml</code> and their corresponding <code>Manifest.toml</code>s are not fully worked out and may be subject to change in future versions. The older method of adding test-specific dependencies, described in the previous section, will therefore be supported throughout all Julia 1.X releases.</p></div></div><p>In Julia 1.2 and later test dependencies can be declared in <code>test/Project.toml</code>. When running tests, Pkg will automatically merge this and the package Projects to create the test environment.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If no <code>test/Project.toml</code> exists Pkg will use the <code>target</code> based test specific dependencies.</p></div></div><p>To add a test-specific dependency, i.e. a dependency that is available only when testing, it is thus enough to add this dependency to the <code>test/Project.toml</code> project. This can be done from the Pkg REPL by activating this environment, and then use <code>add</code> as one normally does. Let&#39;s add the <code>Test</code> standard library as a test dependency:</p><pre><code class="language-julia-repl hljs">(HelloWorld) pkg&gt; activate ./test
[ Info: activating environment at `~/HelloWorld/test/Project.toml`.

(test) pkg&gt; add Test
 Resolving package versions...
  Updating `~/HelloWorld/test/Project.toml`
  [8dfed614] + Test
  Updating `~/HelloWorld/test/Manifest.toml`
  [...]</code></pre><p>We can now use <code>Test</code> in the test script and we can see that it gets installed when testing:</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;test/runtests.jl&quot;,
             &quot;&quot;&quot;
             using Test
             @test 1 == 1
             &quot;&quot;&quot;);

(test) pkg&gt; activate .

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```</code></pre><h2 id="Compatibility-on-dependencies"><a class="docs-heading-anchor" href="#Compatibility-on-dependencies">Compatibility on dependencies</a><a id="Compatibility-on-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility-on-dependencies" title="Permalink"></a></h2><p>Every dependency should in general have a compatibility constraint on it. This is an important topic so there is a separate chapter about it: <a href="../compatibility/#Compatibility">Compatibility</a>.</p><h2 id="Weak-dependencies"><a class="docs-heading-anchor" href="#Weak-dependencies">Weak dependencies</a><a id="Weak-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-dependencies" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>The described feature requires Julia 1.9+.</p></div></div><p>A weak dependency is a dependency that will not automatically install when the package is installed but you can still control what versions of that package are allowed to be installed by setting compatibility on it. These are listed in the project file under the <code>[weakdeps]</code> section:</p><pre><code class="language-toml hljs">[weakdeps]
SomePackage = &quot;b3785f31-9d33-4cdf-bc73-f646780f1739&quot;

[compat]
SomePackage = &quot;1.2&quot;</code></pre><p>The current usage of this is almost solely limited to &quot;extensions&quot; which is described in the next section.</p><h2 id="Conditional-loading-of-code-in-packages-(Extensions)"><a class="docs-heading-anchor" href="#Conditional-loading-of-code-in-packages-(Extensions)">Conditional loading of code in packages (Extensions)</a><a id="Conditional-loading-of-code-in-packages-(Extensions)-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-loading-of-code-in-packages-(Extensions)" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>The described feature requires Julia 1.9+.</p></div></div><p>Sometimes one wants to make two or more packages work well together, but may be reluctant (perhaps due to increased load times) to make one an unconditional dependency of the other. A package <em>extension</em> is a module in a file (similar to a package) that is automatically loaded when <em>some other set of packages</em> are loaded into the Julia session. This is very similar to functionality that the external package <a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a> provides, but which is now available directly through Julia, and provides added benefits such as being able to precompile the extension.</p><p>A useful application of extensions could be for a plotting package that should be able to plot objects from a wide variety of different Julia packages. Adding all those different Julia packages as dependencies of the plotting package could be expensive since they would end up getting loaded even if they were never used. Instead, the code required to plot objects for specific packages can be put into separate files (extensions) and these are loaded only when the packages that define the type(s) we want to plot are loaded.</p><p>Below is an example of how the code can be structured for a use case in which a <code>Plotting</code> package wants to be able to display objects defined in the external package <code>Contour</code>. The file and folder structure shown below is found in the <code>Plotting</code> package.</p><p><code>Project.toml</code>:</p><pre><code class="language-toml hljs">name = &quot;Plotting&quot;
version = &quot;0.1.0&quot;
uuid = &quot;...&quot;

[weakdeps]
Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot;

[extensions]
# name of extension to the left
# extension dependencies required to load the extension to the right
# use a list for multiple extension dependencies
PlottingContourExt = &quot;Contour&quot;

[compat]
Contour = &quot;0.6.2&quot;</code></pre><p><code>src/Plotting.jl</code>:</p><pre><code class="language-julia hljs">module Plotting

function plot(x::Vector)
    # Some functionality for plotting a vector here
end

end # module</code></pre><p><code>ext/PlottingContourExt.jl</code> (can also be in <code>ext/PlottingContourExt/PlottingContourExt.jl</code>):</p><pre><code class="language-julia hljs">module PlottingContourExt # Should be same name as the file (just like a normal package)

using Plotting, Contour

function Plotting.plot(c::Contour.ContourCollection)
    # Some functionality for plotting a contour here
end

end # module</code></pre><p>Extensions can have any arbitrary name (here <code>PlottingContourExt</code>), but using something similar to the format of this example that makes the extended functionality and dependency of the extension clear is likely a good idea.</p><p>A user that depends only on <code>Plotting</code> will not pay the cost of the &quot;extension&quot; inside the <code>PlottingContourExt</code> module. It is only when the <code>Contour</code> package actually gets loaded that the <code>PlottingContourExt</code> extension is loaded and provides the new functionality.</p><p>If one considers <code>PlottingContourExt</code> as a completely separate package, it could be argued that defining <code>Plotting.plot(c::Contour.ContourCollection)</code> is <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">type piracy</a> since <code>PlottingContourExt</code> <em>owns</em> neither the method <code>Plotting.plot</code> nor the type <code>Contour.ContourCollection</code>. However, for extensions, it is ok to assume that the extension owns the methods in its parent package. In fact, this form of type piracy is one of the most standard use cases for extensions.</p><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>Often you will put the extension dependencies into the <code>test</code> target so they are loaded when running e.g. <code>Pkg.test()</code>. On earlier Julia versions this requires you to also put the package in the <code>[extras]</code> section. This is unfortunate but the project verifier on older Julia versions will complain if this is not done.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you use a manifest generated by a Julia version that does not know about extensions with a Julia version that does know about them, the extensions will not load. This is because the manifest lacks some information that tells Julia when it should load these packages. So make sure you use a manifest generated at least the Julia version you are using.</p></div></div><h3 id="Backwards-compatibility"><a class="docs-heading-anchor" href="#Backwards-compatibility">Backwards compatibility</a><a id="Backwards-compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Backwards-compatibility" title="Permalink"></a></h3><p>This section discusses various methods for using extensions on Julia versions that support them, while simultaneously providing similar functionality on older Julia versions.</p><h4 id="Requires.jl"><a class="docs-heading-anchor" href="#Requires.jl">Requires.jl</a><a id="Requires.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Requires.jl" title="Permalink"></a></h4><p>This section is relevant if you are currently using Requires.jl but want to transition to using extensions (while still having Requires be used on Julia versions that do not support extensions). This is done by making the following changes (using the example above):</p><ul><li><p>Add the following to the package file. This makes it so that Requires.jl loads and inserts the callback only when extensions are not supported</p><pre><code class="language-julia hljs"># This symbol is only defined on Julia versions that support extensions
if !isdefined(Base, :get_extension)
using Requires
end

@static if !isdefined(Base, :get_extension)
function __init__()
    @require Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot; include(&quot;../ext/PlottingContourExt.jl&quot;)
end
end</code></pre><p>or if you have other things in your <code>__init__()</code> function:</p><pre><code class="language-julia hljs">if !isdefined(Base, :get_extension)
using Requires
end

function __init__()
    # Other init functionality here

    @static if !isdefined(Base, :get_extension)
        @require Contour = &quot;d38c429a-6771-53c6-b99e-75d170b6e991&quot; include(&quot;../ext/PlottingContourExt.jl&quot;)
    end
end</code></pre></li><li><p>Make the following change in the conditionally-loaded code:</p><pre><code class="language-julia hljs">isdefined(Base, :get_extension) ? (using Contour) : (using ..Contour)</code></pre></li></ul><p>The package should now work with Requires.jl on Julia versions before extensions were introduced and with extensions on more recent Julia versions.</p><h4 id="Transition-from-normal-dependency-to-extension"><a class="docs-heading-anchor" href="#Transition-from-normal-dependency-to-extension">Transition from normal dependency to extension</a><a id="Transition-from-normal-dependency-to-extension-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-from-normal-dependency-to-extension" title="Permalink"></a></h4><p>This section is relevant if you have a normal dependency that you want to transition be an extension (while still having the dependency be a normal dependency on Julia versions that do not support extensions). This is done by making the following changes (using the example above):</p><ul><li>Make sure that the package is <strong>both</strong> in the <code>[deps]</code> and <code>[weakdeps]</code> section. Newer Julia versions will ignore dependencies in <code>[deps]</code> that are also in <code>[weakdeps]</code>.</li><li>Add the following to your main package file (typically at the bottom):<pre><code class="language-julia hljs">if !isdefined(Base, :get_extension)
  include(&quot;../ext/PlottingContourExt.jl&quot;)
end</code></pre></li></ul><h4 id="Using-an-extension-while-supporting-older-Julia-versions"><a class="docs-heading-anchor" href="#Using-an-extension-while-supporting-older-Julia-versions">Using an extension while supporting older Julia versions</a><a id="Using-an-extension-while-supporting-older-Julia-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Using-an-extension-while-supporting-older-Julia-versions" title="Permalink"></a></h4><p>In the case where one wants to use an extension (without worrying about the feature of the extension begin available on older Julia versions) while still supporting older Julia versions the packages under <code>[weakdeps]</code> should be duplicated into <code>[extras]</code>. This is an unfortunate duplication, but without doing this the project verifier under older Julia versions will throw an error if it finds packages under <code>[compat]</code> that is not listed in <code>[extras]</code>.</p><h2 id="Package-naming-guidelines"><a class="docs-heading-anchor" href="#Package-naming-guidelines">Package naming guidelines</a><a id="Package-naming-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Package-naming-guidelines" title="Permalink"></a></h2><p>Package names should be sensible to most Julia users, <em>even to those who are not domain experts</em>. The following guidelines apply to the <code>General</code> registry but may be useful for other package registries as well.</p><p>Since the <code>General</code> registry belongs to the entire community, people may have opinions about your package name when you publish it, especially if it&#39;s ambiguous or can be confused with something other than what it is. Usually, you will then get suggestions for a new name that may fit your package better.</p><ol><li><p>Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.</p><ul><li>It&#39;s ok to say <code>USA</code> if you&#39;re talking about the USA.</li><li>It&#39;s not ok to say <code>PMA</code>, even if you&#39;re talking about positive mental attitude.</li></ul></li><li><p>Avoid using <code>Julia</code> in your package name or prefixing it with <code>Ju</code>.</p><ul><li>It is usually clear from context and to your users that the package is a Julia package.</li><li>Package names already have a <code>.jl</code> extension, which communicates to users that <code>Package.jl</code> is a Julia package.</li><li>Having Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.</li></ul></li><li><p>Packages that provide most of their functionality in association with a new type should have pluralized names.</p><ul><li><code>DataFrames</code> provides the <code>DataFrame</code> type.</li><li><code>BloomFilters</code> provides the <code>BloomFilter</code> type.</li><li>In contrast, <code>JuliaParser</code> provides no new type, but instead new functionality in the <code>JuliaParser.parse()</code> function.</li></ul></li><li><p>Err on the side of clarity, even if clarity seems long-winded to you.</p><ul><li><code>RandomMatrices</code> is a less ambiguous name than <code>RndMat</code> or <code>RMT</code>, even though the latter are shorter.</li></ul></li><li><p>A less systematic name may suit a package that implements one of several possible approaches to its domain.</p><ul><li>Julia does not have a single comprehensive plotting package. Instead, <code>Gadfly</code>, <code>PyPlot</code>, <code>Winston</code> and other packages each implement a unique approach based on a particular design philosophy.</li><li>In contrast, <code>SortingAlgorithms</code> provides a consistent interface to use many well-established sorting algorithms.</li></ul></li><li><p>Packages that wrap external libraries or programs should be named after those libraries or programs.</p><ul><li><code>CPLEX.jl</code> wraps the <code>CPLEX</code> library, which can be identified easily in a web search.</li><li><code>MATLAB.jl</code> provides an interface to call the MATLAB engine from within Julia.</li></ul></li><li><p>Avoid naming a package closely to an existing package</p><ul><li><code>Websocket</code> is too close to <code>WebSockets</code> and can be confusing to users. Rather use a new name such as <code>SimpleWebsockets</code>.</li></ul></li></ol><h2 id="Registering-packages"><a class="docs-heading-anchor" href="#Registering-packages">Registering packages</a><a id="Registering-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Registering-packages" title="Permalink"></a></h2><p>Once a package is ready it can be registered with the <a href="https://github.com/JuliaRegistries/General#registering-a-package-in-general">General Registry</a> (see also the <a href="https://github.com/JuliaRegistries/General#faq">FAQ</a>). Currently, packages are submitted via <a href="https://juliaregistrator.github.io/"><code>Registrator</code></a>. In addition to <code>Registrator</code>, <a href="https://github.com/marketplace/actions/julia-tagbot"><code>TagBot</code></a> helps manage the process of tagging releases.</p><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><p>Packages should avoid mutating their own state (writing to files within their package directory). Packages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a>). To support the various use cases in the Julia package ecosystem, the Pkg developers have created a number of auxiliary packages and techniques to help package authors create self-contained, immutable, and relocatable packages:</p><ul><li><p><a href="https://pkgdocs.julialang.org/v1/artifacts/"><code>Artifacts</code></a> can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand. Prefer artifacts over attempting to open a file via a path such as <code>joinpath(@__DIR__, &quot;data&quot;, &quot;my_dataset.csv&quot;)</code> as this is non-relocatable. Once your package has been precompiled, the result of <code>@__DIR__</code> will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location. Artifacts can be bundled and accessed easily using the <code>artifact&quot;name&quot;</code> string macro.</p></li><li><p><a href="https://github.com/JuliaPackaging/Scratch.jl"><code>Scratch.jl</code></a> provides the notion of &quot;scratch spaces&quot;, mutable containers of data for packages. Scratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled. For important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg.</p></li><li><p><a href="https://github.com/JuliaPackaging/Preferences.jl"><code>Preferences.jl</code></a> allows packages to read and write preferences to the top-level <code>Project.toml</code>. These preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior. Packages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that <code>Preferences</code> is available.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environments/">« <strong>4.</strong> Working with Environment</a><a class="docs-footer-nextpage" href="../compatibility/"><strong>6.</strong> Compatibility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 18 November 2024 21:21">Monday 18 November 2024</span>. Using Julia version 1.10.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
