<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>12. API Reference · Pkg.jl</title><link href="https://julialang.github.io/Pkg.jl/v1/api/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="Pkg.jl logo" src="../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">Pkg.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../"><strong>1.</strong> Introduction</a></li><li><a class="tocitem" href="../getting-started/"><strong>2.</strong> Getting Started</a></li><li><a class="tocitem" href="../managing-packages/"><strong>3.</strong> Managing Packages</a></li><li><a class="tocitem" href="../environments/"><strong>4.</strong> Working with Environments</a></li><li><a class="tocitem" href="../creating-packages/"><strong>5.</strong> Creating Packages</a></li><li><a class="tocitem" href="../compatibility/"><strong>6.</strong> Compatibility</a></li><li><a class="tocitem" href="../registries/"><strong>7.</strong> Registries</a></li><li><a class="tocitem" href="../artifacts/"><strong>8.</strong> Artifacts</a></li><li><a class="tocitem" href="../glossary/"><strong>9.</strong> Glossary</a></li><li><a class="tocitem" href="../toml-files/"><strong>10.</strong><code>Project.toml</code> and <code>Manifest.toml</code></a></li><li><a class="tocitem" href="../repl/"><strong>11.</strong> REPL Mode Reference</a></li><li class="is-active"><a class="tocitem" href=""><strong>12.</strong> API Reference</a><ul class="internal"><li><a class="tocitem" href="#General-API-Reference"><span>General API Reference</span></a></li><li><a class="tocitem" href="#Package-API-Reference"><span>Package API Reference</span></a></li><li><a class="tocitem" href="#Registry-API-Reference"><span>Registry API Reference</span></a></li><li><a class="tocitem" href="#Artifacts-Reference"><span>Artifacts API Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href=""><strong>12.</strong> API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href=""><strong>12.</strong> API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference"><strong>12.</strong> API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This section describes the function interface, or "API mode", for interacting with Pkg.jl. The function API is recommended for non-interactive usage, for example in scripts.</p><h2 id="General-API-Reference"><a class="docs-heading-anchor" href="#General-API-Reference">General API Reference</a><a id="General-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#General-API-Reference" title="Permalink"></a></h2><p>Certain options are generally useful and can be specified in any API call. You can specify these options by setting keyword arguments.</p><h3 id="Redirecting-output"><a class="docs-heading-anchor" href="#Redirecting-output">Redirecting output</a><a id="Redirecting-output-1"></a><a class="docs-heading-anchor-permalink" href="#Redirecting-output" title="Permalink"></a></h3><p>Use the <code>io::IOBuffer</code> keyword argument to redirect Pkg output. For example, <code>Pkg.add("Example"; io=devnull)</code> will discard any output produced by the <code>add</code> call.</p><h2 id="Package-API-Reference"><a class="docs-heading-anchor" href="#Package-API-Reference">Package API Reference</a><a id="Package-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Package-API-Reference" title="Permalink"></a></h2><p>In the REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings, for example <code>"Package#master"</code>,<code>"Package@v0.1"</code>, <code>"www.mypkg.com/MyPkg#my/feature"</code>.</p><p>In the API mode, it is possible to use strings as arguments for simple commands (like <code>Pkg.add(["PackageA", "PackageB"])</code>, but more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings. This is done by creating an instance of <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> which is passed in to functions.</p><article class="docstring"><header><a class="docstring-binding" href="#Pkg.PackageSpec" id="Pkg.PackageSpec"><code>Pkg.PackageSpec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PackageSpec(name::String, [uuid::UUID, version::VersionNumber])
PackageSpec(; name, url, path, subdir, rev, version, mode, level)</code></pre><p>A <code>PackageSpec</code> is a representation of a package with various metadata. This includes:</p><ul><li>The <code>name</code> of the package.</li><li>The package's unique <code>uuid</code>.</li><li>A <code>version</code> (for example when adding a package). When upgrading, can also be an instance of</li></ul><p>the enum <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p><ul><li>A <code>url</code> and an optional git <code>rev</code>ision. <code>rev</code> can be a branch name or a git commit SHA1.</li><li>A local <code>path</code>. This is equivalent to using the <code>url</code> argument but can be more descriptive.</li><li>A <code>subdir</code> which can be used when adding a package that is not in the root of a repository.</li><li>A <code>mode</code>, which is an instance of the enum <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, with possible values <code>PKGMODE_PROJECT</code></li></ul><p>(the default) or <code>PKGMODE_MANIFEST</code>. Used in e.g. <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p><p>Most functions in Pkg take a <code>Vector</code> of <code>PackageSpec</code> and do the operation on all the packages in the vector.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Many functions that take a <code>PackageSpec</code> or a <code>Vector{PackageSpec}</code> can be called with a more concise notation with <code>NamedTuple</code>s. For example, <code>Pkg.add</code> can be called either as the explicit or concise versions as: | Explicit                                                            | Concise |:––––––––––––––––––––––––––––––––––|:–––––––––––––––––––––––-| | <code>Pkg.add(PackageSpec(name="Package))</code>                               | <code>Pkg.add(name = "Package")</code>                    | | <code>Pkg.add(PackageSpec(url="www.myhost.com/MyPkg")))</code>                 | <code>Pkg.add(name = "Package")</code>                    | |<code>Pkg.add([PackageSpec(name="Package"), PackageSpec(path="/MyPkg"])</code> | <code>Pkg.add([(;name="Package"), (;path="MyPkg")])</code>|</p></div></div><p>Below is a comparison between the REPL version and the API version:</p><table><tbody><tr><th style="text-align: left"><code>REPL</code></th><th style="text-align: left"><code>API</code></th></tr><tr><td style="text-align: left"><code>Package</code></td><td style="text-align: left"><code>PackageSpec("Package")</code></td></tr><tr><td style="text-align: left"><code>Package@0.2</code></td><td style="text-align: left"><code>PackageSpec(name="Package", version="0.2")</code></td></tr><tr><td style="text-align: left"><code>Package=a67d...</code></td><td style="text-align: left"><code>PackageSpec(name="Package", uuid="a67d...")</code></td></tr><tr><td style="text-align: left"><code>Package#master</code></td><td style="text-align: left"><code>PackageSpec(name="Package", rev="master")</code></td></tr><tr><td style="text-align: left"><code>local/path#feature</code></td><td style="text-align: left"><code>PackageSpec(path="local/path"; rev="feature")</code></td></tr><tr><td style="text-align: left"><code>www.mypkg.com</code></td><td style="text-align: left"><code>PackageSpec(url="www.mypkg.com")</code></td></tr><tr><td style="text-align: left"><code>--manifest Package</code></td><td style="text-align: left"><code>PackageSpec(name="Package", mode=PKGSPEC_MANIFEST)</code></td></tr><tr><td style="text-align: left"><code>--major Package</code></td><td style="text-align: left"><code>PackageSpec(name="Package", version=PKGLEVEL_MAJOR)</code></td></tr></tbody></table></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L426-L468" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.PackageMode" id="Pkg.PackageMode"><code>Pkg.PackageMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PackageMode</code></pre><p>An enum with the instances</p><ul><li><code>PKGMODE_MANIFEST</code></li><li><code>PKGMODE_PROJECT</code></li></ul><p>Determines if operations should be made on a project or manifest level. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L60-L70" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.UpgradeLevel" id="Pkg.UpgradeLevel"><code>Pkg.UpgradeLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UpgradeLevel</code></pre><p>An enum with the instances</p><ul><li><code>UPLEVEL_FIXED</code></li><li><code>UPLEVEL_PATCH</code></li><li><code>UPLEVEL_MINOR</code></li><li><code>UPLEVEL_MAJOR</code></li></ul><p>Determines how much a package is allowed to be updated. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.update"><code>Pkg.update</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L74-L86" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.add" id="Pkg.add"><code>Pkg.add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED)
Pkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED)</code></pre><p>Add a package to the current project. This package will be available by using the <code>import</code> and <code>using</code> keywords in the Julia REPL, and if the current project is a package, also inside that package.</p><p><strong>Resolution Tiers</strong></p><p><code>Pkg</code> resolves the set of packages in your environment using a tiered algorithm. The <code>preserve</code> keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for <code>preserve</code> (in order of strictness):</p><table><tbody><tr><th style="text-align: left">Value</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>PRESERVE_ALL</code></td><td style="text-align: left">Preserve the state of all existing dependencies (including recursive dependencies)</td></tr><tr><td style="text-align: left"><code>PRESERVE_DIRECT</code></td><td style="text-align: left">Preserve the state of all existing direct dependencies</td></tr><tr><td style="text-align: left"><code>PRESERVE_SEMVER</code></td><td style="text-align: left">Preserve semver-compatible versions of direct dependencies</td></tr><tr><td style="text-align: left"><code>PRESERVE_NONE</code></td><td style="text-align: left">Do not attempt to preserve any version information</td></tr><tr><td style="text-align: left"><code>PRESERVE_TIERED</code></td><td style="text-align: left">Use the tier which will preserve the most version information (this is the default)</td></tr></tbody></table><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.add("Example") # Add a package from registry
Pkg.add("Example"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and preserve existing dependencies
Pkg.add(name="Example", version="0.3") # Specify version; latest release in the 0.3 series
Pkg.add(name="Example", version="0.3.1") # Specify version; exact release
Pkg.add(url="https://github.com/JuliaLang/Example.jl", rev="master") # From url to remote gitrepo
Pkg.add(url="/remote/mycompany/juliapackages/OurPackage") # From path to local gitrepo
Pkg.add(url="https://github.com/Company/MonoRepo", subdir="juliapkgs/Package.jl)") # With subdir</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L92-L125" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.develop" id="Pkg.develop"><code>Pkg.develop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.develop(pkg::Union{String, Vector{String}})
Pkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}})</code></pre><p>Make a package available for development by tracking it by path. If <code>pkg</code> is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable <code>JULIA_PKG_DEVDIR</code>, with <code>.julia/dev</code> as the default.</p><p>If <code>pkg</code> is given as a local path, the package at that path will be tracked.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># By name
Pkg.develop("Example")

# By url
Pkg.develop(url="https://github.com/JuliaLang/Compat.jl")

# By path
Pkg.develop(path="MyJuliaPackages/Package.jl")</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L264-L289" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.activate" id="Pkg.activate"><code>Pkg.activate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.activate([s::String]; shared::Bool=false)</code></pre><p>Activate the environment at <code>s</code>. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:</p><ul><li>If <code>shared</code> is <code>true</code>, the first existing environment named <code>s</code> from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.</li><li>If <code>s</code> is an existing path, then activate the environment at that path.</li><li>If <code>s</code> is a package in the current project and <code>s</code> is tracking a path, then activate the environment at the tracked path.</li><li>Otherwise, <code>s</code> is interpreted as a non-existing path, which is then activated.</li></ul><p>If no argument is given to <code>activate</code>, then activate the home project. The home project is specified by either the <code>--project</code> command line option to the julia executable, or the <code>JULIA_PROJECT</code> environment variable.</p><p><strong>Examples</strong></p><pre><code class="language-none">Pkg.activate()
Pkg.activate("local/path")
Pkg.activate("MyDependency")</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L381-L406" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.rm" id="Pkg.rm"><code>Pkg.rm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.rm(pkg::Union{String, Vector{String}})
Pkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Remove a package from the current project. If the <code>mode</code> of <code>pkg</code> is <code>PKGMODE_MANIFEST</code> also remove it from the manifest including all recursive dependencies of <code>pkg</code>.</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L144-L153" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.update" id="Pkg.update"><code>Pkg.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)
Pkg.update(pkg::Union{String, Vector{String}})
Pkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Update a package <code>pkg</code>. If no posistional argument is given, update all packages in the manifest if <code>mode</code> is <code>PKGMODE_MANIFEST</code> and packages in both manifest and project if <code>mode</code> is <code>PKGMODE_PROJECT</code>. If no positional argument is given, <code>level</code> can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L156-L165" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.test" id="Pkg.test"><code>Pkg.test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.test(; kwargs...)
Pkg.test(pkg::Union{String, Vector{String}; kwargs...)
Pkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>coverage::Bool=false</code>: enable or disable generation of coverage statistics.</li><li><code>julia_args::Union{Cmd, Vector{String}}</code>: options to be passed the test process.</li><li><code>test_args::Union{Cmd, Vector{String}}</code>: test arguments (<code>ARGS</code>) available in the test process.</li></ul><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p><code>julia_args</code> and <code>test_args</code> requires at least Julia 1.3.</p></div></div><p>Run the tests for package <code>pkg</code>, or for the current project (which thus needs to be a package) if no positional argument is given to <code>Pkg.test</code>. A package is tested by running its <code>test/runtests.jl</code> file.</p><p>The tests are run by generating a temporary environment with only <code>pkg</code> and its (recursive) dependencies in it. If a manifest exists, the versions in that manifest are used, otherwise a feasible set of packages is resolved and installed.</p><p>During the tests, test-specific dependencies are active, which are given in the project file as e.g.</p><pre><code class="language-none">[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]</code></pre><p>The tests are executed in a new process with <code>check-bounds=yes</code> and by default <code>startup-file=no</code>. If using the startup file (<code>~/.julia/config/startup.jl</code>) is desired, start julia with <code>--startup-file=yes</code>. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with <code>--inline=no</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L168-L204" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.build" id="Pkg.build"><code>Pkg.build</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.build(; verbose = false)
Pkg.build(pkg::Union{String, Vector{String}}; verbose = false)
Pkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false)</code></pre><p>Run the build script in <code>deps/build.jl</code> for <code>pkg</code> and all of its dependencies in depth-first recursive order. If no argument is given to <code>build</code>, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. <code>verbose = true</code> prints the build output to <code>stdout</code>/<code>stderr</code> instead of redirecting to the <code>build.log</code> file.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L217-L230" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.pin" id="Pkg.pin"><code>Pkg.pin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.pin(pkg::Union{String, Vector{String}})
Pkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Pin a package to the current version (or the one given in the <code>PackageSpec</code>) or to a certain git revision. A pinned package is never updated.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.pin("Example")
Pkg.pin(name="Example", version="0.3.1")</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L233-L245" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.free" id="Pkg.free"><code>Pkg.free</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.free(pkg::Union{String, Vector{String}})
Pkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>If <code>pkg</code> is pinned, remove the pin. If <code>pkg</code> is tracking a path, e.g. after <a href="#Pkg.develop"><code>Pkg.develop</code></a>, go back to tracking registered versions.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.free("Package")</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L248-L260" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.instantiate" id="Pkg.instantiate"><code>Pkg.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.instantiate(; verbose = false)</code></pre><p>If a <code>Manifest.toml</code> file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the <code>Project.toml</code> files and install them. <code>verbose = true</code> prints the build output to <code>stdout</code>/<code>stderr</code> instead of redirecting to the <code>build.log</code> file. If no <code>Project.toml</code> exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L338-L349" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.resolve" id="Pkg.resolve"><code>Pkg.resolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.resolve()</code></pre><p>Update the current manifest with potential changes to the dependency graph from packages that are tracking a path.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L352-L357" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.gc" id="Pkg.gc"><code>Pkg.gc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.gc()</code></pre><p>Garbage collect packages that are no longer reachable from any project. Only packages that are tracked by version are deleted, so no packages that might contain local changes are touched.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L207-L213" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.status" id="Pkg.status"><code>Pkg.status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.status([pkgs...]; mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false)</code></pre><p>Print out the status of the project/manifest. If <code>mode</code> is <code>PKGMODE_PROJECT</code>, print out status only about the packages that are in the project (explicitly added). If <code>mode</code> is <code>PKGMODE_MANIFEST</code>, print status also about those in the manifest (recursive dependencies). If there are any packages listed as arguments, the output will be limited to those packages. Setting <code>diff=true</code> will, if the environment is in a git repository, limit the output to the difference as compared to the last git commit.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>Pkg.status</code> with package arguments requires at least Julia 1.1.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The <code>diff</code> keyword argument requires Julia 1.3. In earlier versions <code>diff=true</code> is the default for environments in git repositories.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L360-L377" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.precompile" id="Pkg.precompile"><code>Pkg.precompile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.precompile()</code></pre><p>Precompile all the dependencies of the project.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3. On earlier versions you can use <code>Pkg.API.precompile()</code> or the <code>precompile</code> Pkg REPL command.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.precompile()</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L128-L141" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.setprotocol!" id="Pkg.setprotocol!"><code>Pkg.setprotocol!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setprotocol!(;
    domain::AbstractString = "github.com",
    protocol::Union{Nothing, AbstractString}=nothing
)</code></pre><p>Set the protocol used to access hosted packages when <code>add</code>ing a url or <code>develop</code>ing a package. Defaults to delegating the choice to the package developer (<code>protocol === nothing</code>). Other choices for <code>protocol</code> are <code>"https"</code> or <code>"git"</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Pkg.setprotocol!(domain = "github.com", protocol = "ssh")

julia&gt; Pkg.setprotocol!(domain = "gitlab.mycompany.com")</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L471-L487" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.dependencies" id="Pkg.dependencies"><code>Pkg.dependencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.dependencies()::Dict{UUID, PackageInfo}</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>This feature requires Julia 1.4, and is considered experimental.</p></div></div><p>Query the dependency graph. The result is a <code>Dict</code> that maps a package UUID to a <code>PackageInfo</code> struct representing the dependency (a package).</p><p><strong><code>PackageInfo</code> fields</strong></p><table><tbody><tr><th style="text-align: left">Field</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">The name of the package</td></tr><tr><td style="text-align: left"><code>version</code></td><td style="text-align: left">The version of the package (this is <code>Nothing</code> for stdlibs)</td></tr><tr><td style="text-align: left"><code>is_direct_dep</code></td><td style="text-align: left">The package is a direct dependency</td></tr><tr><td style="text-align: left"><code>is_tracking_path</code></td><td style="text-align: left">Whether a package is directly tracking a directory</td></tr><tr><td style="text-align: left"><code>is_pinned</code></td><td style="text-align: left">Whether a package is pinned</td></tr><tr><td style="text-align: left"><code>source</code></td><td style="text-align: left">The directory containing the source code for that package</td></tr><tr><td style="text-align: left"><code>dependencies</code></td><td style="text-align: left">The dependencies of that package as a vector of UUIDs</td></tr></tbody></table></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L295-L315" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.project" id="Pkg.project"><code>Pkg.project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.project()::ProjectInfo</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>This feature requires Julia 1.4, and is considered experimental.</p></div></div><p>Request a <code>ProjectInfo</code> struct which contains information about the active project.</p><p><strong><code>ProjectInfo</code> fields</strong></p><table><tbody><tr><th style="text-align: left">Field</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">name</td><td style="text-align: left">The project's name</td></tr><tr><td style="text-align: left">uuid</td><td style="text-align: left">The project's UUID</td></tr><tr><td style="text-align: left">version</td><td style="text-align: left">The project's version</td></tr><tr><td style="text-align: left">dependencies</td><td style="text-align: left">The project's direct dependencies as a <code>Dict</code> which maps dependency name to dependency UUID</td></tr><tr><td style="text-align: left">path</td><td style="text-align: left">The location of the project file which defines the active project</td></tr></tbody></table></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L318-L335" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.undo" id="Pkg.undo"><code>Pkg.undo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">undo()</code></pre><p>Undoes the latest change to the active project. Only states in the current session are stored, up to a maximum of 50 states.</p><p>See also: <a href="#Pkg.redo"><code>redo</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L490-L497" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.redo" id="Pkg.redo"><code>Pkg.redo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">redo()</code></pre><p>Redoes the changes from the latest <a href="#Pkg.undo"><code>undo</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L500-L504" target="_blank">source</a></section></article><h2 id="Registry-API-Reference"><a class="docs-heading-anchor" href="#Registry-API-Reference">Registry API Reference</a><a id="Registry-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Registry-API-Reference" title="Permalink"></a></h2><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Pkg's registry handling requires at least Julia 1.1.</p></div></div><p>The function API for registries uses <a href="#Pkg.RegistrySpec"><code>RegistrySpec</code></a>s, similar to <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#Pkg.RegistrySpec" id="Pkg.RegistrySpec"><code>Pkg.RegistrySpec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegistrySpec(name::String)
RegistrySpec(; name, url, path)</code></pre><p>A <code>RegistrySpec</code> is a representation of a registry with various metadata, much like <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p><p>Most registry functions in Pkg take a <code>Vector</code> of <code>RegistrySpec</code> and do the operation on all the registries in the vector.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Pkg's registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><p>Below is a comparison between the REPL version and the API version:</p><table><tbody><tr><th style="text-align: left"><code>REPL</code></th><th style="text-align: left"><code>API</code></th></tr><tr><td style="text-align: left"><code>Registry</code></td><td style="text-align: left"><code>RegistrySpec("Registry")</code></td></tr><tr><td style="text-align: left"><code>Registry=a67d...</code></td><td style="text-align: left"><code>RegistrySpec(name="Registry", uuid="a67d...")</code></td></tr><tr><td style="text-align: left"><code>local/path</code></td><td style="text-align: left"><code>RegistrySpec(path="local/path")</code></td></tr><tr><td style="text-align: left"><code>www.myregistry.com</code></td><td style="text-align: left"><code>RegistrySpec(url="www.myregistry.com")</code></td></tr></tbody></table></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Pkg.jl#L507-L530" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Registry.add" id="Pkg.Registry.add"><code>Pkg.Registry.add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.Registry.add(url::String)
Pkg.Registry.add(registry::RegistrySpec)</code></pre><p>Add new package registries.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Pkg's registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.add("General")
Pkg.Registry.add(RegistrySpec(uuid = "23338594-aafe-5451-b93e-139f81909106"))
Pkg.Registry.add(RegistrySpec(url = "https://github.com/JuliaRegistries/General.git"))</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Registry.jl#L8-L23" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Registry.rm" id="Pkg.Registry.rm"><code>Pkg.Registry.rm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.Registry.rm(registry::String)
Pkg.Registry.rm(registry::RegistrySpec)</code></pre><p>Remove registries.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Pkg's registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.rm("General")
Pkg.Registry.rm(RegistrySpec(uuid = "23338594-aafe-5451-b93e-139f81909106"))</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Registry.jl#L36-L50" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Registry.update" id="Pkg.Registry.update"><code>Pkg.Registry.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.Registry.update()
Pkg.Registry.update(registry::RegistrySpec)
Pkg.Registry.update(registry::Vector{RegistrySpec})</code></pre><p>Update registries. If no registries are given, update all available registries.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Pkg's registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.update()
Pkg.Registry.update("General")
Pkg.Registry.update(RegistrySpec(uuid = "23338594-aafe-5451-b93e-139f81909106"))</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Registry.jl#L59-L76" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Registry.status" id="Pkg.Registry.status"><code>Pkg.Registry.status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.Registry.status()</code></pre><p>Display information about available registries.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Pkg's registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.status()</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Registry.jl#L89-L101" target="_blank">source</a></section></article><h2 id="Artifacts-Reference"><a class="docs-heading-anchor" href="#Artifacts-Reference">Artifacts API Reference</a><a id="Artifacts-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Artifacts-Reference" title="Permalink"></a></h2><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>Pkg's artifacts API requires at least Julia 1.3.</p></div></div><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.create_artifact" id="Pkg.Artifacts.create_artifact"><code>Pkg.Artifacts.create_artifact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_artifact(f::Function)</code></pre><p>Creates a new artifact by running <code>f(artifact_path)</code>, hashing the result, and moving it to the artifact store (<code>~/.julia/artifacts</code> on a typical installation).  Returns the identifying tree hash of this artifact.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L194-L203" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.artifact_exists" id="Pkg.Artifacts.artifact_exists"><code>Pkg.Artifacts.artifact_exists</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">artifact_exists(hash::SHA1; honor_overrides::Bool=true)</code></pre><p>Returns whether or not the given artifact (identified by its sha1 git tree hash) exists on-disk.  Note that it is possible that the given artifact exists in multiple locations (e.g. within multiple depots).</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L284-L293" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.artifact_path" id="Pkg.Artifacts.artifact_path"><code>Pkg.Artifacts.artifact_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">artifact_path(hash::SHA1; honor_overrides::Bool=true)</code></pre><p>Given an artifact (identified by SHA1 git tree hash), return its installation path.  If the artifact does not exist, returns the location it would be installed to.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L260-L268" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.remove_artifact" id="Pkg.Artifacts.remove_artifact"><code>Pkg.Artifacts.remove_artifact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_artifact(hash::SHA1; honor_overrides::Bool=false)</code></pre><p>Removes the given artifact (identified by its SHA1 git tree hash) from disk.  Note that if an artifact is installed in multiple depots, it will be removed from all of them.  If an overridden artifact is requested for removal, it will be silently ignored; this method will never attempt to remove an overridden artifact.</p><p>In general, we recommend that you use <code>Pkg.gc()</code> to manage artifact installations and do not use <code>remove_artifact()</code> directly, as it can be difficult to know if an artifact is being used by another package.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L298-L312" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.verify_artifact" id="Pkg.Artifacts.verify_artifact"><code>Pkg.Artifacts.verify_artifact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">verify_artifact(hash::SHA1; honor_overrides::Bool=false)</code></pre><p>Verifies that the given artifact (identified by its SHA1 git tree hash) is installed on- disk, and retains its integrity.  If the given artifact is overridden, skips the verification unless <code>honor_overrides</code> is set to <code>true</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L328-L337" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.artifact_meta" id="Pkg.Artifacts.artifact_meta"><code>Pkg.Artifacts.artifact_meta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">artifact_meta(name::String, artifacts_toml::String;
              platform::Platform = platform_key_abi(),
              pkg_uuid::Union{Base.UUID,Nothing}=nothing)</code></pre><p>Get metadata about a given artifact (identified by name) stored within the given <code>(Julia)Artifacts.toml</code> file.  If the artifact is platform-specific, use <code>platform</code> to choose the most appropriate mapping.  If none is found, return <code>nothing</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L519-L530" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.artifact_hash" id="Pkg.Artifacts.artifact_hash"><code>Pkg.Artifacts.artifact_hash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">artifact_hash(name::String, artifacts_toml::String; platform::Platform = platform_key_abi())</code></pre><p>Thin wrapper around <code>artifact_meta()</code> to return the hash of the specified, platform- collapsed artifact.  Returns <code>nothing</code> if no mapping can be found.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L572-L580" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.bind_artifact!" id="Pkg.Artifacts.bind_artifact!"><code>Pkg.Artifacts.bind_artifact!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bind_artifact!(artifacts_toml::String, name::String, hash::SHA1;
               platform::Union{Platform,Nothing} = nothing,
               download_info::Union{Vector{Tuple},Nothing} = nothing,
               lazy::Bool = false,
               force::Bool = false)</code></pre><p>Writes a mapping of <code>name</code> -&gt; <code>hash</code> within the given <code>(Julia)Artifacts.toml</code> file. If <code>platform</code> is not <code>nothing</code>, this artifact is marked as platform-specific, and will be a multi-mapping.  It is valid to bind multiple artifacts with the same name, but different <code>platform</code>s and <code>hash</code>'es within the same <code>artifacts_toml</code>.  If <code>force</code> is set to <code>true</code>, this will overwrite a pre-existant mapping, otherwise an error is raised.</p><p><code>download_info</code> is an optional vector that contains tuples of URLs and a hash.  These URLs will be listed as possible locations where this artifact can be obtained.  If <code>lazy</code> is set to <code>true</code>, even if download information is available, this artifact will not be downloaded until it is accessed via the <code>artifact"name"</code> syntax, or <code>ensure_artifact_installed()</code> is called upon it.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L593-L614" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.unbind_artifact!" id="Pkg.Artifacts.unbind_artifact!"><code>Pkg.Artifacts.unbind_artifact!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unbind_artifact!(artifacts_toml::String, name::String; platform = nothing)</code></pre><p>Unbind the given <code>name</code> from an <code>(Julia)Artifacts.toml</code> file. Silently fails if no such binding exists within the file.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L689-L697" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.download_artifact" id="Pkg.Artifacts.download_artifact"><code>Pkg.Artifacts.download_artifact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">download_artifact(tree_hash::SHA1, tarball_url::String, tarball_hash::String;
                  verbose::Bool = false)</code></pre><p>Download/install an artifact into the artifact store.  Returns <code>true</code> on success.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L720-L728" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.find_artifacts_toml" id="Pkg.Artifacts.find_artifacts_toml"><code>Pkg.Artifacts.find_artifacts_toml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_artifacts_toml(path::String)</code></pre><p>Given the path to a <code>.jl</code> file, (such as the one returned by <code>__source__.file</code> in a macro context), find the <code>(Julia)Artifacts.toml</code> that is contained within the containing project (if it exists), otherwise return <code>nothing</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L799-L808" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.ensure_artifact_installed" id="Pkg.Artifacts.ensure_artifact_installed"><code>Pkg.Artifacts.ensure_artifact_installed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ensure_artifact_installed(name::String, artifacts_toml::String;
                          platform::Platform = platform_key_abi(),
                          pkg_uuid::Union{Base.UUID,Nothing}=nothing)</code></pre><p>Ensures an artifact is installed, downloading it via the download information stored in <code>artifacts_toml</code> if necessary.  Throws an error if unable to install.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L840-L850" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.ensure_all_artifacts_installed" id="Pkg.Artifacts.ensure_all_artifacts_installed"><code>Pkg.Artifacts.ensure_all_artifacts_installed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ensure_all_artifacts_installed(artifacts_toml::String;
                               platform = platform_key_abi(),
                               pkg_uuid = nothing,
                               include_lazy = false,
                               verbose = false,
                               quiet_download = false)</code></pre><p>Installs all non-lazy artifacts from a given <code>(Julia)Artifacts.toml</code> file. <code>package_uuid</code> must be provided to properly support overrides from <code>Overrides.toml</code> entries in depots.</p><p>If <code>include_lazy</code> is set to <code>true</code>, then lazy packages will be installed as well.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L922-L937" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.@artifact_str" id="Pkg.Artifacts.@artifact_str"><code>Pkg.Artifacts.@artifact_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro artifact_str(name)</code></pre><p>Macro that is used to automatically ensure an artifact is installed, and return its location on-disk.  Automatically looks the artifact up by name in the project's <code>(Julia)Artifacts.toml</code> file.  Throws an error on inability to install the requested artifact. If run in the REPL, searches for the toml file starting in the current directory, see <code>find_artifacts_toml()</code> for more.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This macro requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L1031-L1042" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Pkg.Artifacts.archive_artifact" id="Pkg.Artifacts.archive_artifact"><code>Pkg.Artifacts.archive_artifact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">archive_artifact(hash::SHA1, tarball_path::String; honor_overrides::Bool=false)</code></pre><p>Archive an artifact into a tarball stored at <code>tarball_path</code>, returns the SHA256 of the resultant tarball as a hexidecimal string. Throws an error if the artifact does not exist.  If the artifact is overridden, throws an error unless <code>honor_overrides</code> is set.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/Pkg.jl/blob/0c3ccb119efd8b3182c114599abe78bc4f89dd4c/src/Artifacts.jl#L355-L364" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../repl/">« <strong>11.</strong> REPL Mode Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 11 November 2020 13:01">Wednesday 11 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>