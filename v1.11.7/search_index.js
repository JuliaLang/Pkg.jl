var documenterSearchIndex = {"docs":
[{"location":"basedocs/#Pkg","page":"Pkg","title":"Pkg","text":"Pkg is Julia's builtin package manager, and handles operations such as installing, updating and removing packages.\n\nnote: Note\nWhat follows is a very brief introduction to Pkg. For more information on Project.toml files, Manifest.toml files, package version compatibility ([compat]), environments, registries, etc., it is highly recommended to read the full manual, which is available here: https://pkgdocs.julialang.org.\n\nimport Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" => \"[API Reference](https://pkgdocs.julialang.org/v1/api/)\")\nstr = replace(str, \"(@ref Working-with-Environments)\" => \"(https://pkgdocs.julialang.org/v1/environments/)\")\nstr = replace(str, \"(@ref Managing-Packages)\" => \"(https://pkgdocs.julialang.org/v1/managing-packages/)\")\nMarkdown.parse(str)","category":"section"},{"location":"artifacts/#Artifacts","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg can install and manage containers of data that are not Julia packages.  These containers can contain platform-specific binaries, datasets, text, or any other kind of data that would be convenient to place within an immutable, life-cycled datastore. These containers, (called \"Artifacts\") can be created locally, hosted anywhere, and automatically downloaded and unpacked upon installation of your Julia package. This mechanism is also used to provide the binary dependencies for packages built with BinaryBuilder.jl.","category":"section"},{"location":"artifacts/#Basic-Usage","page":"8. Artifacts","title":"Basic Usage","text":"Pkg artifacts are declared in an Artifacts.toml file, which can be placed in your current directory or in the root of your package. Currently, Pkg supports downloading of tarfiles (which can be compressed) from a URL. Following is a minimal Artifacts.toml file which will permit the downloading of a socrates.tar.gz file from github.com. In this example, a single artifact, given the name socrates, is defined.\n\n# a simple Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\nIf this Artifacts.toml file is placed in your current directory, then socrates.tar.gz can be downloaded, unpacked and used with artifact\"socrates\". Since this tarball contains a folder bin, and a text file named socrates within that folder, we could access the content of that file as follows.\n\nusing Pkg.Artifacts\n\nrootpath = artifact\"socrates\"\nopen(joinpath(rootpath, \"bin\", \"socrates\")) do file\n    println(read(file, String))\nend\n\nIf you have an existing tarball that is accessible via a url, it could also be accessed in this manner. To create the Artifacts.toml you must compute two hashes: the sha256 hash of the download file, and the git-tree-sha1 of the unpacked content. These can be computed as follows.\n\nusing Tar, Inflate, SHA\n\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))\n\nTo access this artifact from within a package you create, place the Artifacts.toml at the root of your package, adjacent to Project.toml. Then, make sure to add Pkg in your deps and set julia = \"1.3\" or higher in your compat section.","category":"section"},{"location":"artifacts/#Artifacts.toml-files","page":"8. Artifacts","title":"Artifacts.toml files","text":"Pkg provides an API for working with artifacts, as well as a TOML file format for recording artifact usage in your packages, and to automate downloading of artifacts at package install time. Artifacts can always be referred to by content hash, but are typically accessed by a name that is bound to a content hash in an Artifacts.toml file that lives in a project's source tree.\n\nnote: Note\nIt is possible to use the alternate name JuliaArtifacts.toml, similar to how it is possible to use JuliaProject.toml and JuliaManifest.toml instead of Project.toml and Manifest.toml, respectively.\n\nAn example Artifacts.toml file is shown here:\n\n# Example Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\nlazy = true\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2\"\n    sha256 = \"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"4bdf4556050cb55b67b211d4e78009aaec378cbc\"\nlibc = \"musl\"\nos = \"linux\"\n\n    [[c_simple.download]]\n    sha256 = \"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"51264dbc770cd38aeb15f93536c29dc38c727e4c\"\nos = \"macos\"\n\n    [[c_simple.download]]\n    sha256 = \"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz\"\n\n[processed_output]\ngit-tree-sha1 = \"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200\"\n\nThis Artifacts.toml binds three artifacts; one named socrates, one named c_simple and one named processed_output. The single required piece of information for an artifact is its git-tree-sha1. Because artifacts are addressed only by their content hash, the purpose of an Artifacts.toml file is to provide metadata about these artifacts, such as binding a human-readable name to a content hash, providing information about where an artifact may be downloaded from, or even binding a single name to multiple hashes, keyed by platform-specific constraints such as operating system or libgfortran version.","category":"section"},{"location":"artifacts/#Artifact-types-and-properties","page":"8. Artifacts","title":"Artifact types and properties","text":"In the above example, the socrates artifact showcases a platform-independent artifact with multiple download locations. When downloading and installing the socrates artifact, URLs will be attempted in order until one succeeds. The socrates artifact is marked as lazy, which means that it will not be automatically downloaded when the containing package is installed, but rather will be downloaded on-demand when the package first attempts to use it.\n\nThe c_simple artifact showcases a platform-dependent artifact, where each entry in the c_simple array contains keys that help the calling package choose the appropriate download based on the particulars of the host machine. Note that each artifact contains both a git-tree-sha1 and a sha256 for each download entry.  This is to ensure that the downloaded tarball is secure before attempting to unpack it, as well as enforcing that all tarballs must expand to the same overall tree hash.\n\nThe processed_output artifact contains no download stanza, and so cannot be installed. An artifact such as this would be the result of code that was previously run, generating a new artifact and binding the resultant hash to a name within this project.","category":"section"},{"location":"artifacts/#Using-Artifacts","page":"8. Artifacts","title":"Using Artifacts","text":"Artifacts can be manipulated using convenient APIs exposed from the Pkg.Artifacts namespace. As a motivating example, let us imagine that we are writing a package that needs to load the Iris machine learning dataset. While we could just download the dataset during a build step into the package directory, and many packages currently do precisely this, that has some significant drawbacks:\n\nFirst, it modifies the package directory, making package installation stateful, which we want to avoid. In the future, we would like to reach the point where packages can be installed completely read-only, instead of being able to modify themselves after installation.\nSecond, the downloaded data is not shared across different versions of our package. If we have three different versions of the package installed for use by various projects, then we need three different copies of the data, even if it hasn't changed between those versions. Moreover, each time we upgrade or downgrade the package unless we do something clever (and probably brittle), we have to download the data again.\n\nWith artifacts, we will instead check to see if our iris artifact already exists on-disk and only if it doesn't will we download and install it, after which we can bind the result into our Artifacts.toml file:\n\nusing Pkg.Artifacts\n\n# This is the path to the Artifacts.toml we will manipulate\nartifact_toml = joinpath(@__DIR__, \"Artifacts.toml\")\n\n# Query the `Artifacts.toml` file for the hash bound to the name \"iris\"\n# (returns `nothing` if no such binding exists)\niris_hash = artifact_hash(\"iris\", artifact_toml)\n\n# If the name was not bound, or the hash it was bound to does not exist, create it!\nif iris_hash == nothing || !artifact_exists(iris_hash)\n    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n    iris_hash = create_artifact() do artifact_dir\n        # We create the artifact by simply downloading a few files into the new artifact directory\n        iris_url_base = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris\"\n        download(\"$(iris_url_base)/iris.data\", joinpath(artifact_dir, \"iris.csv\"))\n        download(\"$(iris_url_base)/bezdekIris.data\", joinpath(artifact_dir, \"bezdekIris.csv\"))\n        download(\"$(iris_url_base)/iris.names\", joinpath(artifact_dir, \"iris.names\"))\n    end\n\n    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n    # the content hash to change, so this should not cause unnecessary version control churn.\n    bind_artifact!(artifact_toml, \"iris\", iris_hash)\nend\n\n# Get the path of the iris dataset, either newly created or previously generated.\n# this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`\niris_dataset_path = artifact_path(iris_hash)\n\nFor the specific use case of using artifacts that were previously bound, we have the shorthand notation artifact\"name\" which will automatically search for the Artifacts.toml file contained within the current package, look up the given artifact by name, install it if it is not yet installed, then return the path to that given artifact. An example of this shorthand notation is given below:\n\nusing Pkg.Artifacts\n\n# For this to work, an `Artifacts.toml` file must be in the current working directory\n# (or in the root of the current package) and must define a mapping for the \"iris\"\n# artifact.  If it does not exist on-disk, it will be downloaded.\niris_dataset_path = artifact\"iris\"","category":"section"},{"location":"artifacts/#The-Pkg.Artifacts-API","page":"8. Artifacts","title":"The Pkg.Artifacts API","text":"The Artifacts API is broken up into three levels: hash-aware functions, name-aware functions and utility functions.\n\nHash-aware functions deal with content-hashes and essentially nothing else. These methods allow you to query whether an artifact exists, what its path is, verify that an artifact satisfies its content hash on-disk, etc.  Hash-aware functions include: artifact_exists(), artifact_path(), remove_artifact(), verify_artifact() and archive_artifact().  Note that in general you should not use remove_artifact() and should instead use Pkg.gc() to cleanup artifact installations.\nName-aware functions deal with bound names within an Artifacts.toml file, and as such, typically require both a path to an Artifacts.toml file as well as the artifact name.  Name-aware functions include: artifact_meta(), artifact_hash(), bind_artifact!(), unbind_artifact!(), download_artifact() and ensure_artifact_installed().\nUtility functions deal with miscellaneous aspects of artifact life, such as create_artifact(), ensure_all_artifacts_installed(), and even the @artifact_str string macro.\n\nFor a full listing of docstrings and methods, see the Artifacts Reference section.","category":"section"},{"location":"artifacts/#Overriding-artifact-locations","page":"8. Artifacts","title":"Overriding artifact locations","text":"It is occasionally necessary to be able to override the location and content of an artifact. A common use case is a computing environment where certain versions of a binary dependency must be used, regardless of what version of this dependency a package was published with. While a typical Julia configuration would download, unpack and link against a generic library, a system administrator may wish to disable this and instead use a library already installed on the local machine. To enable this, Pkg supports a per-depot Overrides.toml file placed within the artifacts depot directory (e.g. ~/.julia/artifacts/Overrides.toml for the default user depot) that can override the location of an artifact either by content-hash or by package UUID and bound artifact name. Additionally, the destination location can be either an absolute path, or a replacement artifact content hash. This allows sysadmins to create their own artifacts which they can then use by overriding other packages to use the new artifact.\n\n# Override single hash to an absolute path\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/replacement\"\n\n# Override single hash to new artifact content-hash\n683942669b4639019be7631caa28c38f3e1924fe = \"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3\"\n\n# Override package bindings by specifying the package UUID and bound artifact name\n# For demonstration purposes we assume this package is called `Foo`\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"/path/to/libfoo\"\nlibbar = \"683942669b4639019be7631caa28c38f3e1924fe\"\n\nDue to the layered nature of Pkg depots, multiple Overrides.toml files may be in effect at once. This allows the \"inner\" Overrides.toml files to override the overrides placed within the \"outer\" Overrides.toml files. To remove an override and re-enable default location logic for an artifact, insert an entry mapping to the empty string:\n\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/new/replacement\"\n683942669b4639019be7631caa28c38f3e1924fe = \"\"\n\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"\"\n\nIf the two Overrides.toml snippets as given above are layered on top of each other, the end result will be mapping the content-hash 78f35e74ff113f02274ce60dab6e92b4546ef806 to \"/path/to/new/replacement\", and mapping Foo.libbar to the artifact identified by the content-hash 683942669b4639019be7631caa28c38f3e1924fe. Note that while that hash was previously overridden, it is no longer, and therefore Foo.libbar will look directly at locations such as ~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe.\n\nMost methods that are affected by overrides can ignore overrides by setting honor_overrides=false as a keyword argument within them. For UUID/name-based overrides to work, Artifacts.toml files must be loaded with the knowledge of the UUID of the loading package. This is deduced automatically by the artifacts\"\" string macro, however, if you are for some reason manually using the Pkg.Artifacts API within your package and you wish to honor overrides, you must provide the package UUID to API calls like artifact_meta() and ensure_artifact_installed() via the pkg_uuid keyword argument.","category":"section"},{"location":"artifacts/#Extending-Platform-Selection","page":"8. Artifacts","title":"Extending Platform Selection","text":"compat: Julia 1.7\nPkg's extended platform selection requires at least Julia 1.7, and is considered experimental.\n\nNew in Julia 1.6, Platform objects can have extended attributes applied to them, allowing artifacts to be tagged with things such as CUDA driver version compatibility, microarchitectural compatibility, julia version compatibility and more! Note that this feature is considered experimental and may change in the future. If you as a package developer find yourself needing this feature, please get in contact with us so it can evolve for the benefit of the whole ecosystem. In order to support artifact selection at Pkg.add() time, Pkg will run the specially-named file <project_root>/.pkg/select_artifacts.jl, passing the current platform triplet as the first argument. This artifact selection script should print a TOML-serialized dictionary representing the artifacts that this package needs according to the given platform, and perform any inspection of the system as necessary to auto-detect platform capabilities if they are not explicitly provided by the given platform triplet. The format of the dictionary should match that returned from Artifacts.select_downloadable_artifacts(), and indeed most packages should simply call that function with an augmented Platform object. An example artifact selection hook definition might look like the following, split across two files:\n\n# .pkg/platform_augmentation.jl\nusing Libdl, Base.BinaryPlatforms\nfunction augment_platform!(p::Platform)\n    # If this platform object already has a `cuda` tag set, don't augment\n    if haskey(p, \"cuda\")\n        return p\n    end\n\n    # Open libcuda explicitly, so it gets `dlclose()`'ed after we're done\n    dlopen(\"libcuda\") do lib\n        # find symbol to ask for driver version; if we can't find it, just silently continue\n        cuDriverGetVersion = dlsym(lib, \"cuDriverGetVersion\"; throw_error=false)\n        if cuDriverGetVersion !== nothing\n            # Interrogate CUDA driver for driver version:\n            driverVersion = Ref{Cint}()\n            ccall(cuDriverGetVersion, UInt32, (Ptr{Cint},), driverVersion)\n\n            # Store only the major version\n            p[\"cuda\"] = div(driverVersion, 1000)\n        end\n    end\n\n    # Return possibly-altered `Platform` object\n    return p\nend\n\nusing TOML, Artifacts, Base.BinaryPlatforms\ninclude(\"./platform_augmentation.jl\")\nartifacts_toml = joinpath(dirname(@__DIR__), \"Artifacts.toml\")\n\n# Get \"target triplet\" from ARGS, if given (defaulting to the host triplet otherwise)\ntarget_triplet = get(ARGS, 1, Base.BinaryPlatforms.host_triplet())\n\n# Augment this platform object with any special tags we require\nplatform = augment_platform!(HostPlatform(parse(Platform, target_triplet)))\n\n# Select all downloadable artifacts that match that platform\nartifacts = select_downloadable_artifacts(artifacts_toml; platform)\n\n# Output the result to `stdout` as a TOML dictionary\nTOML.print(stdout, artifacts)\n\nIn this hook definition, our platform augmentation routine opens a system library (libcuda), searches it for a symbol to give us the CUDA driver version, then embeds the major version of that version number into the cuda property of the Platform object we are augmenting. While it is not critical for this code to actually attempt to close the loaded library (as it will most likely be opened again by the CUDA package immediately after the package operations are completed) it is best practice to make hooks as lightweight and transparent as possible, as they may be used by other Pkg utilities in the future. In your own package, you should also use augmented platform objects when using the @artifact_str macro, as follows:\n\ninclude(\"../.pkg/platform_augmentation.jl\")\n\nfunction __init__()\n    p = augment_platform!(HostPlatform())\n    global my_artifact_dir = @artifact_str(\"MyArtifact\", p)\nend\n\nThis ensures that the same artifact is used by your code as Pkg attempted to install.\n\nArtifact selection hooks are only allowed to use Base, Artifacts, Libdl, and TOML. They are not allowed to use any other standard libraries, and they are not allowed to use any packages (including the package to which they belong).","category":"section"},{"location":"toml-files/#Project-and-Manifest","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Two files that are central to Pkg are Project.toml and Manifest.toml. Project.toml and Manifest.toml are written in TOML (hence the .toml extension) and include information about dependencies, versions, package names, UUIDs etc.\n\nnote: Note\nThe Project.toml and Manifest.toml files are not only used by the package manager; they are also used by Julia's code loading, and determine e.g. what using Example should do. For more details see the section about Code Loading in the Julia manual.","category":"section"},{"location":"toml-files/#Project.toml","page":"10. Project.toml and Manifest.toml","title":"Project.toml","text":"The project file describes the project on a high level, for example, the package/project dependencies and compatibility constraints are listed in the project file. The file entries are described below.","category":"section"},{"location":"toml-files/#The-authors-field","page":"10. Project.toml and Manifest.toml","title":"The authors field","text":"For a package, the optional authors field is a list of strings describing the package authors, in the form NAME <EMAIL>. For example:\n\nauthors = [\"Some One <someone@email.com>\",\n           \"Foo Bar <foo@bar.com>\"]","category":"section"},{"location":"toml-files/#The-name-field","page":"10. Project.toml and Manifest.toml","title":"The name field","text":"The name of the package/project is determined by the name field, for example:\n\nname = \"Example\"\n\nThe name must be a valid identifier (a sequence of Unicode characters that does not start with a number and is neither true nor false). For packages, it is recommended to follow the package naming rules. The name field is mandatory for packages.","category":"section"},{"location":"toml-files/#The-uuid-field","page":"10. Project.toml and Manifest.toml","title":"The uuid field","text":"uuid is a string with a universally unique identifier for the package/project, for example:\n\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\nThe uuid field is mandatory for packages.\n\nnote: Note\nIt is recommended that UUIDs.uuid4() is used to generate random UUIDs.","category":"section"},{"location":"toml-files/#The-version-field","page":"10. Project.toml and Manifest.toml","title":"The version field","text":"version is a string with the version number for the package/project. It should consist of three numbers, major version, minor version, and patch number, separated with a ., for example:\n\nversion = \"1.2.5\"\n\nJulia uses Semantic Versioning (SemVer) and the version field should follow SemVer. The basic rules are:\n\nBefore 1.0.0, anything goes, but when you make breaking changes the minor version should be incremented.\nAfter 1.0.0 only make breaking changes when incrementing the major version.\nAfter 1.0.0 no new public API should be added without incrementing the minor version. This includes, in particular, new types, functions, methods, and method overloads, from Base or other packages.\n\nSee also the section on Compatibility.\n\nNote that Pkg.jl deviates from the SemVer specification when it comes to versions pre-1.0.0. See the section on pre-1.0 behavior for more details.","category":"section"},{"location":"toml-files/#The-[deps]-section","page":"10. Project.toml and Manifest.toml","title":"The [deps] section","text":"All dependencies of the package/project are listed in the [deps] section. Each dependency is listed as a name-uuid pair, for example:\n\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\nTypically it is not needed to manually add entries to the [deps] section; this is instead handled by Pkg operations such as add.","category":"section"},{"location":"toml-files/#The-[sources]-section","page":"10. Project.toml and Manifest.toml","title":"The [sources] section","text":"Specifiying a path or repo (+ branch) for a dependency is done in the [sources] section. These are especially useful for controlling unregistered dependencies without having to bundle a corresponding manifest file.\n\n[sources]\nExample = {url = \"https://github.com/JuliaLang/Example.jl\", rev = \"custom_branch\"}\nWithinMonorepo = {url = \"https://github.org/author/BigProject\", subdir = \"SubPackage\"}\nSomeDependency = {path = \"deps/SomeDependency.jl\"}\n\nNote that this information is only used when this environment is active, i.e. it is not used if this project is a package that is being used as a dependency.","category":"section"},{"location":"toml-files/#The-[compat]-section","page":"10. Project.toml and Manifest.toml","title":"The [compat] section","text":"Compatibility constraints for the dependencies listed under [deps] can be listed in the [compat] section. Example:\n\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]\nExample = \"1.2\"\n\nThe Compatibility section describes the different possible compatibility constraints in detail. It is also possible to list constraints on julia itself, although julia is not listed as a dependency in the [deps] section:\n\n[compat]\njulia = \"1.1\"","category":"section"},{"location":"toml-files/#Manifest.toml","page":"10. Project.toml and Manifest.toml","title":"Manifest.toml","text":"The manifest file is an absolute record of the state of the packages in the environment. It includes exact information about (direct and indirect) dependencies of the project. Given a Project.toml + Manifest.toml pair, it is possible to instantiate the exact same package environment, which is very useful for reproducibility. For the details, see Pkg.instantiate.\n\nnote: Note\nThe Manifest.toml file is generated and maintained by Pkg and, in general, this file should never be modified manually.","category":"section"},{"location":"toml-files/#Different-Manifests-for-Different-Julia-versions","page":"10. Project.toml and Manifest.toml","title":"Different Manifests for Different Julia versions","text":"Starting from Julia v1.10.8, there is an option to name manifest files in the format Manifest-v{major}.{minor}.toml. Julia will then preferentially use the version-specific manifest file if available. For example, if both Manifest-v1.11.toml and Manifest.toml exist, Julia 1.11 will prioritize using Manifest-v1.11.toml. However, Julia versions 1.10, 1.12, and all others will default to using Manifest.toml. This feature allows for easier management of different instantiated versions of dependencies for various Julia versions. Note that there can only be one Project.toml file. While Manifest-v{major}.{minor}.toml files are not automatically created by Pkg, users can manually rename a Manifest.toml file to match the versioned format, and Pkg will subsequently maintain it through its operations.","category":"section"},{"location":"toml-files/#Manifest.toml-entries","page":"10. Project.toml and Manifest.toml","title":"Manifest.toml entries","text":"There are three top-level entries in the manifest which could look like this:\n\njulia_version = \"1.8.2\"\nmanifest_format = \"2.0\"\nproject_hash = \"4d9d5b552a1236d3c1171abf88d59da3aaac328a\"\n\nThis shows the Julia version the manifest was created on, the \"format\" of the manifest and a hash of the project file, so that it is possible to see when the manifest is stale compared to the project file.\n\nEach dependency has its own section in the manifest file, and its content varies depending on how the dependency was added to the environment. Every dependency section includes a combination of the following entries:\n\nuuid: the UUID for the dependency, for example uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\".\ndeps: a vector listing the dependencies of the dependency, for example deps = [\"Example\", \"JSON\"].\nversion: a version number, for example version = \"1.2.6\".\npath: a file path to the source code, for example path = /home/user/Example.\nrepo-url: a URL to the repository where the source code was found, for example repo-url = \"https://github.com/JuliaLang/Example.jl.git\".\nrepo-rev: a git revision, for example a branch repo-rev = \"master\" or a commit repo-rev = \"66607a62a83cb07ab18c0b35c038fcd62987c9b1\".\ngit-tree-sha1: a content hash of the source tree, for example git-tree-sha1 = \"ca3820cc4e66f473467d912c4b2b3ae5dc968444\".","category":"section"},{"location":"toml-files/#Added-package","page":"10. Project.toml and Manifest.toml","title":"Added package","text":"When a package is added from a package registry, for example by invoking pkg> add Example or with a specific version pkg> add Example@1.2, the resulting Manifest.toml entry looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.3\"\n\nNote, in particular, that no repo-url is present, since that information is included in the registry where this package was found.","category":"section"},{"location":"toml-files/#Added-package-by-branch","page":"10. Project.toml and Manifest.toml","title":"Added package by branch","text":"The resulting dependency section when adding a package specified by a branch, e.g. pkg> add Example#master or pkg> add https://github.com/JuliaLang/Example.jl.git, looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"master\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nNote that both the branch we are tracking (master) and the remote repository url (\"https://github.com/JuliaLang/Example.jl.git\") are stored in the manifest.","category":"section"},{"location":"toml-files/#Added-package-by-commit","page":"10. Project.toml and Manifest.toml","title":"Added package by commit","text":"The resulting dependency section when adding a package specified by a commit, e.g. pkg> add Example#cf6ba6cc0be0bb5f56840188563579d67048be34, looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"cf6ba6cc0be0bb5f56840188563579d67048be34\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nThe only difference from tracking a branch is the content of repo-rev.","category":"section"},{"location":"toml-files/#Developed-package","page":"10. Project.toml and Manifest.toml","title":"Developed package","text":"The resulting dependency section when adding a package with develop, e.g. pkg> develop Example or pkg> develop /path/to/local/folder/Example, looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\npath = \"/home/user/.julia/dev/Example/\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nNote that the path to the source code is included, and changes made to that source tree is directly reflected.","category":"section"},{"location":"toml-files/#Pinned-package","page":"10. Project.toml and Manifest.toml","title":"Pinned package","text":"Pinned packages are also recorded in the manifest file; the resulting dependency section e.g. pkg> add Example; pin Example looks like:\n\n[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\npinned = true\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n\nThe only difference is the addition of the pinned = true entry.","category":"section"},{"location":"toml-files/#Multiple-packages-with-the-same-name","page":"10. Project.toml and Manifest.toml","title":"Multiple packages with the same name","text":"Julia differentiates packages based on UUID, which means that the name alone is not enough to identify a package. It is possible to have multiple packages in the same environment with the same name, but with different UUID. In such a situation the Manifest.toml file looks a bit different. Consider for example the situation where you have added A and B to your environment, and the Project.toml file looks as follows:\n\n[deps]\nA = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\nB = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"\n\nIf A now depends on B = \"f41f7b98-334e-11e9-1257-49272045fb24\", i.e. another package named B there will be two different B packages in the Manifest.toml file. In this case, the full Manifest.toml file, with git-tree-sha1 and version fields removed for clarity, looks like this:\n\n[[deps.A]]\nuuid = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\n\n    [deps.A.deps]\n    B = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n\n[[deps.B]]\nuuid = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n[[deps.B]]\nuuid = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"\n\nThere is now an array of the two B packages, and the [deps] section for A has been expanded to be explicit about which B package A depends on.","category":"section"},{"location":"compatibility/#Compatibility","page":"6. Compatibility","title":"6. Compatibility","text":"Compatibility refers to the ability to restrict the versions of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.\n\nCompatibility for a dependency is entered in the Project.toml file as for example:\n\n[compat]\njulia = \"1.6\"\nExample = \"0.5\"\n\nAfter a compatibility entry is put into the project file, up can be used to apply it.\n\nThe format of the version specifier is described in detail below.\n\ninfo: Info\nUse the command compat to edit the compat entries in the Pkg REPL, or manually edit the project file.\n\ninfo: Info\nThe rules below apply to the Project.toml file; for registries, see Registry Compat.toml.\n\ninfo: Info\nNote that registration into Julia's General Registry requires each dependency to have a [compat] entry with an upper bound.","category":"section"},{"location":"compatibility/#Version-specifier-format","page":"6. Compatibility","title":"Version specifier format","text":"Similar to other package managers, the Julia package manager respects semantic versioning (semver), with an exception for leading zeros. As an example, a version specifier given as e.g. 1.2.3 is therefore assumed to be compatible with the versions [1.2.3 - 2.0.0) where ) is a non-inclusive upper bound. More specifically, a version specifier is either given as a caret specifier, e.g. ^1.2.3  or as a tilde specifier, e.g. ~1.2.3. Caret specifiers are the default and hence 1.2.3 == ^1.2.3. The difference between a caret and tilde is described in the next section. The union of multiple version specifiers can be formed by comma separating individual version specifiers, e.g.\n\n[compat]\nExample = \"1.2, 2\"\n\nwill result in [1.2.0, 3.0.0).  Note leading zeros are treated differently, e.g. Example = \"0.2, 1\" would only result in [0.2.0 - 0.3.0) ∪ [1.0.0 - 2.0.0). See the next section for more information on versions with leading zeros.","category":"section"},{"location":"compatibility/#compat-pre-1.0","page":"6. Compatibility","title":"Behavior of versions with leading zeros (0.0.x and 0.x.y)","text":"While the semver specification says that all versions with a major version of 0 (versions before 1.0.0) are incompatible with each other, we have decided to only apply that for when both the major and minor versions are zero. In other words, 0.0.1 and 0.0.2 are considered incompatible. A pre-1.0 version with non-zero minor version (0.a.b with a != 0) is considered compatible with versions with the same minor version and smaller or equal patch versions (0.a.c with c <= b); i.e., the versions 0.2.2 and 0.2.3 are compatible with 0.2.1 and 0.2.0. Versions with a major version of 0 and different minor versions are not considered compatible, so the version 0.3.0 might have breaking changes from 0.2.0. To that end, the [compat] entry:\n\n[compat]\nExample = \"0.0.1\"\n\nresults in a versionbound on Example as [0.0.1, 0.0.2) (which is equivalent to only the version 0.0.1), while the [compat] entry:\n\n[compat]\nExample = \"0.2.1\"\n\nresults in a versionbound on Example as [0.2.1, 0.3.0).\n\nIn particular, a package may set version = \"0.2.4\" when it has feature additions compared to 0.2.3 as long as it remains backward compatible with 0.2.0.  See also The version field.","category":"section"},{"location":"compatibility/#Caret-specifiers","page":"6. Compatibility","title":"Caret specifiers","text":"A caret (^) specifier allows upgrade that would be compatible according to semver. This is the default behavior if no specifier is used. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.\n\nSome examples are shown below.\n\n[compat]\nPkgA = \"^1.2.3\" # [1.2.3, 2.0.0)\nPkgB = \"^1.2\"   # [1.2.0, 2.0.0)\nPkgC = \"^1\"     # [1.0.0, 2.0.0)\nPkgD = \"^0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"^0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"^0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"^0\"     # [0.0.0, 1.0.0)","category":"section"},{"location":"compatibility/#Tilde-specifiers","page":"6. Compatibility","title":"Tilde specifiers","text":"A tilde specifier provides more limited upgrade possibilities. When specifying major, minor and patch versions, or when specifying major and minor versions, only the patch version is allowed to change. If you only specify a major version, then both minor and patch versions are allowed to be upgraded (~1 is thus equivalent to ^1). For example:\n\n[compat]\nPkgA = \"~1.2.3\" # [1.2.3, 1.3.0)\nPkgB = \"~1.2\"   # [1.2.0, 1.3.0)\nPkgC = \"~1\"     # [1.0.0, 2.0.0)\nPkgD = \"~0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"~0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"~0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"~0\"     # [0.0.0, 1.0.0)\n\nFor all versions with a major version of 0 the tilde and caret specifiers are equivalent.","category":"section"},{"location":"compatibility/#Equality-specifier","page":"6. Compatibility","title":"Equality specifier","text":"Equality can be used to specify exact versions:\n\n[compat]\nPkgA = \"=1.2.3\"           # [1.2.3, 1.2.3]\nPkgA = \"=0.10.1, =0.10.3\" # 0.10.1 or 0.10.3","category":"section"},{"location":"compatibility/#Inequality-specifiers","page":"6. Compatibility","title":"Inequality specifiers","text":"Inequalities can also be used to specify version ranges:\n\n[compat]\nPkgB = \">= 1.2.3\" # [1.2.3,  ∞)\nPkgC = \"≥ 1.2.3\"  # [1.2.3,  ∞)\nPkgD = \"< 1.2.3\"  # [0.0.0, 1.2.3) = [0.0.0, 1.2.2]","category":"section"},{"location":"compatibility/#Hyphen-specifiers","page":"6. Compatibility","title":"Hyphen specifiers","text":"Hyphen syntax can also be used to specify version ranges. Make sure that you have a space on both sides of the hyphen.\n\n[compat]\nPkgA = \"1.2.3 - 4.5.6\" # [1.2.3, 4.5.6]\nPkgA = \"0.2.3 - 4.5.6\" # [0.2.3, 4.5.6]\n\nAny unspecified trailing numbers in the first end-point are considered to be zero:\n\n[compat]\nPkgA = \"1.2 - 4.5.6\"   # [1.2.0, 4.5.6]\nPkgA = \"1 - 4.5.6\"     # [1.0.0, 4.5.6]\nPkgA = \"0.2 - 4.5.6\"   # [0.2.0, 4.5.6]\nPkgA = \"0.2 - 0.5.6\"   # [0.2.0, 0.5.6]\n\nAny unspecified trailing numbers in the second end-point will be considered to be wildcards:\n\n[compat]\nPkgA = \"1.2.3 - 4.5\"   # 1.2.3 - 4.5.* = [1.2.3, 4.6.0)\nPkgA = \"1.2.3 - 4\"     # 1.2.3 - 4.*.* = [1.2.3, 5.0.0)\nPkgA = \"1.2 - 4.5\"     # 1.2.0 - 4.5.* = [1.2.0, 4.6.0)\nPkgA = \"1.2 - 4\"       # 1.2.0 - 4.*.* = [1.2.0, 5.0.0)\nPkgA = \"1 - 4.5\"       # 1.0.0 - 4.5.* = [1.0.0, 4.6.0)\nPkgA = \"1 - 4\"         # 1.0.0 - 4.*.* = [1.0.0, 5.0.0)\nPkgA = \"0.2.3 - 4.5\"   # 0.2.3 - 4.5.* = [0.2.3, 4.6.0)\nPkgA = \"0.2.3 - 4\"     # 0.2.3 - 4.*.* = [0.2.3, 5.0.0)\nPkgA = \"0.2 - 4.5\"     # 0.2.0 - 4.5.* = [0.2.0, 4.6.0)\nPkgA = \"0.2 - 4\"       # 0.2.0 - 4.*.* = [0.2.0, 5.0.0)\nPkgA = \"0.2 - 0.5\"     # 0.2.0 - 0.5.* = [0.2.0, 0.6.0)\nPkgA = \"0.2 - 0\"       # 0.2.0 - 0.*.* = [0.2.0, 1.0.0)","category":"section"},{"location":"compatibility/#Fixing-conflicts","page":"6. Compatibility","title":"Fixing conflicts","text":"Version conflicts were introduced previously with an example of a conflict arising in a package D used by two other packages, B and C. Our analysis of the error message revealed that B is using an outdated version of D. To fix it, the first thing to try is to pkg> dev B so that you can modify B and its compatibility requirements. If you open its Project.toml file in an editor, you would probably notice something like\n\n[compat]\nD = \"0.1\"\n\nUsually the first step is to modify this to something like\n\n[compat]\nD = \"0.1, 0.2\"\n\nThis indicates that B is compatible with both versions 0.1 and version 0.2; if you pkg> up this would fix the package error. However, there is one major concern you need to address first: perhaps there was an incompatible change in v0.2 of D that breaks B. Before proceeding further, you should update all packages and then run B's tests, scanning the output of pkg> test B to be sure that v0.2 of D is in fact being used. (It is possible that an additional dependency of D pins it to v0.1, and you wouldn't want to be misled into thinking that you had tested B on the newer version.) If the new version was used and the tests still pass, you can assume that B didn't need any further updating to accommodate v0.2 of D; you can safely submit this change as a pull request to B so that a new release is made. If instead an error is thrown, it indicates that B requires more extensive updates to be compatible with the latest version of D; those updates will need to be completed before it becomes possible to use both A and B simultaneously. You can, though, continue to use them independently of one another.","category":"section"},{"location":"getting-started/#**2.**-Getting-Started","page":"2. Getting Started","title":"2. Getting Started","text":"What follows is a quick overview of the basic features of Pkg. It should help new users become familiar with basic Pkg features such as adding and removing packages and working with environments.\n\nnote: Note\nSome Pkg output is omitted in this section in order to keep this basic guide focused. This will help maintain a good pace and not get bogged down in details. If you require more details, refer to subsequent sections of the Pkg manual.\n\nnote: Note\nThis guide uses the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the API Reference section of the Pkg documentation.","category":"section"},{"location":"getting-started/#Basic-Usage","page":"2. Getting Started","title":"Basic Usage","text":"Pkg comes with a REPL. Enter the Pkg REPL by pressing ] from the Julia REPL. To get back to the Julia REPL, press Ctrl+C or backspace (when the REPL cursor is at the beginning of the input).\n\nUpon entering the Pkg REPL, you should see the following prompt:\n\n(@v1.9) pkg>\n\nTo add a package, use add:\n\n(@v1.9) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/.julia/environments/v1.9/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\nAfter the package is installed, it can be loaded into the Julia session:\n\njulia> import Example\n\njulia> Example.hello(\"friend\")\n\"Hello, friend\"\n\nWe can also specify multiple packages at once to install:\n\n(@v1.9) pkg> add JSON StaticArrays\n\nThe status command (or the shorter st command) can be used to see installed packages.\n\n(@v1.9) pkg> st\nStatus `~/.julia/environments/v1.6/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n  [90137ffa] StaticArrays v1.5.9\n\nnote: Note\nSome Pkg REPL commands have a short and a long version of the command, for example status and st.\n\nTo remove packages, use rm (or remove):\n\n(@v1.9) pkg> rm JSON StaticArrays\n\nUse up (or update) to update the installed packages\n\n(@v1.9) pkg> up\n\nIf you have been following this guide it is likely that the packages installed are at the latest version so up will not do anything. Below we show the status output in the case where we deliberately have installed an old version of the Example package and then upgrade it:\n\n(@v1.9) pkg> st\nStatus `~/.julia/environments/v1.9/Project.toml`\n⌃ [7876af07] Example v0.5.1\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.9) pkg> up\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [7876af07] ↑ Example v0.5.1 ⇒ v0.5.3\n\nWe can see that the status output tells us that there is a newer version available and that up upgrades the package.\n\nFor more information about managing packages, see the Managing Packages section of the documentation.","category":"section"},{"location":"getting-started/#Getting-Started-with-Environments","page":"2. Getting Started","title":"Getting Started with Environments","text":"Up to this point, we have covered basic package management: adding, updating, and removing packages.\n\nYou may have noticed the (@v1.9) in the REPL prompt. This lets us know that v1.9 is the active environment. Different environments can have different totally different packages and versions installed from another environment. The active environment is the environment that will be modified by Pkg commands such as add, rm and update.\n\nLet's set up a new environment so we may experiment. To set the active environment, use activate:\n\n(@v1.9) pkg> activate tutorial\n[ Info: activating new environment at `~/tutorial/Project.toml`.\n\nPkg lets us know we are creating a new environment and that this environment will be stored in the ~/tutorial directory. The path to the environment is created relative to the current working directory of the REPL.\n\nPkg has also updated the REPL prompt in order to reflect the new active environment:\n\n(tutorial) pkg>\n\nWe can ask for information about the active environment by using status:\n\n(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n   (empty environment)\n\n~/tutorial/Project.toml is the location of the active environment's project file. A project file is a TOML file where Pkg stores the packages that have been explicitly installed. Notice this new environment is empty. Let us add some packages and observe:\n\n(tutorial) pkg> add Example JSON\n...\n\n(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n\nWe can see that the tutorial environment now contains Example and JSON.\n\nnote: Note\nIf you have the same package (at the same version) installed in multiple environments, the package will only be downloaded and stored on the hard drive once. This makes environments very lightweight and effectively free to create. Using only the default environment with a huge number of packages in it is a common beginners mistake in Julia. Learning how to use environments effectively will improve your experience with Julia packages.\n\nFor more information about environments, see the Working with Environments section of the documentation.","category":"section"},{"location":"getting-started/#Asking-for-Help","page":"2. Getting Started","title":"Asking for Help","text":"If you are ever stuck, you can ask Pkg for help:\n\n(@v1.9) pkg> ?\n\nYou should see a list of available commands along with short descriptions. You can ask for more detailed help by specifying a command:\n\n(@v1.9) pkg> ?develop\n\nThis guide should help you get started with Pkg. Pkg has much more to offer in terms of powerful package management, read the full manual to learn more!","category":"section"},{"location":"registries/#**7.**-Registries","page":"7. Registries","title":"7. Registries","text":"Registries contain information about packages, such as available releases and dependencies, and where they can be downloaded. The General registry is the default one, and is installed automatically if there are no other registries installed.","category":"section"},{"location":"registries/#Managing-registries","page":"7. Registries","title":"Managing registries","text":"Registries can be added, removed and updated from either the Pkg REPL or by using the functional API. In this section we will describe the REPL interface. The registry API is documented in the Registry API Reference section.","category":"section"},{"location":"registries/#Adding-registries","page":"7. Registries","title":"Adding registries","text":"A custom registry can be added with the registry add command from the Pkg REPL. Usually this will be done with a URL to the registry.\n\nIf a custom registry has been installed causing the General registry to not be automatically installed, it is easy to add it manually: be added automatically. In that case, we can simply add the General\n\npkg> registry add General\n\nand now all the packages registered in General are available for e.g. adding. To see which registries are currently installed you can use the registry status (or registry st) command\n\npkg> registry st\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)\n\nRegistries are always added to the user depot, which is the first entry in DEPOT_PATH (cf. the Glossary section).\n\nnote: Registries from a package server\nIt is possible for a package server to be advertising additional available package registries. When Pkg runs with a clean Julia depot (e.g. after a fresh install), with a custom package server configured with JULIA_PKG_SERVER, it will automatically add all such available registries. If the depot already has some registries installed (e.g. General), the additional ones can easily be installed with the no-argument registry add command.","category":"section"},{"location":"registries/#Removing-registries","page":"7. Registries","title":"Removing registries","text":"Registries can be removed with the registry remove (or registry rm) command. Here we remove the General registry\n\npkg> registry rm General\n  Removing registry `General` from ~/.julia/registries/General\n\npkg> registry st\nRegistry Status\n  (no registries found)\n\nIn case there are multiple registries named General installed you have to disambiguate with the uuid, just as when manipulating packages, e.g.\n\npkg> registry rm General=23338594-aafe-5451-b93e-139f81909106\n  Removing registry `General` from ~/.julia/registries/General","category":"section"},{"location":"registries/#Updating-registries","page":"7. Registries","title":"Updating registries","text":"The registry update (or registry up) command is available to update registries. Here we update the General registry:\n\npkg> registry up General\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`\n\nand to update all installed registries just do:\n\npkg> registry up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`\n\nRegistries automatically update once per session when a package operation is performed so it rarely has to be done manually.","category":"section"},{"location":"registries/#Registry-format","page":"7. Registries","title":"Registry format","text":"In a registry, each package gets its own directory; in that directory are the following files: Compat.toml, Deps.toml, Package.toml, and Versions.toml. The formats of these files are described below.","category":"section"},{"location":"registries/#Registry-Compat.toml","page":"7. Registries","title":"Registry Compat.toml","text":"The Compat.toml file has a series of blocks specifying version numbers, with a set of dependencies listed below. For example, part of such a file might look like this:\n\n[\"0.8-0.8.3\"]\nDependencyA = \"0.4-0.5\"\nDependencyB = \"0.3-0.5\"\n\n[\"0.8.2-0.8.5\"]\nDependencyC = \"0.7-0\"\n\nDependencies that are unchanged across a range of versions are grouped together in these blocks. The interpretation of these ranges is given by the comment after each line below:\n\n\"0.7-0.8\"  # [0.7.0, 0.9.0)\n\"0.7-0\"    # [0.7.0, 1.0.0)\n\"0.8.6-0\"  # [0.8.6, 1.0.0)\n\"0.7-*\"    # [0.7.0, ∞)\n\nSo for this package, versions [0.8.0, 0.8.3] depend on versions [0.4.0, 0.6.0) of DependencyA and version [0.3.0, 0.6.0) of DependencyB. Meanwhile, it is also true that versions [0.8.2, 0.8.5] require specific versions of DependencyC (so that all three are required for versions 0.8.2 and 0.8.3).","category":"section"},{"location":"registries/#Registry-flavors","page":"7. Registries","title":"Registry flavors","text":"The default Pkg Server (pkg.julialang.org) offers two different \"flavors\" of registry.\n\ncompat: Julia 1.8\nRegistry flavors are only available starting with Julia 1.8.\n\nconservative: suitable for most users; all packages and artifacts in this registry flavor are available from the Pkg Server, with no need to download from other sources\neager: this registry offers the latest versions of packages, even if the Pkg and Storage Servers have not finished processing them; thus, some packages and artifacts may not be available from the Pkg Server, and thus may need to be downloaded from other sources (such as GitHub)\n\nThe default registry flavor is conservative. We recommend that most users stick to the conservative flavor unless they know that they need to use the eager flavor.\n\nTo select the eager flavor:\n\nENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"eager\"\n\nimport Pkg\n\nPkg.Registry.update()\n\nTo select the conservative flavor:\n\nENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"conservative\"\n\nimport Pkg\n\nPkg.Registry.update()","category":"section"},{"location":"registries/#Creating-and-maintaining-registries","page":"7. Registries","title":"Creating and maintaining registries","text":"Pkg only provides client facilities for registries, rather than functionality to create or maintain them. However, Registrator.jl and LocalRegistry.jl provide ways to create and update registries, and RegistryCI.jl provides automated testing and merging functionality for maintaining a registry.","category":"section"},{"location":"glossary/#Glossary","page":"9. Glossary","title":"9. Glossary","text":"Project: a source tree with a standard layout, including a src directory for the main body of Julia code, a test directory for testing the project, a docs directory for documentation files, and optionally a deps directory for a build script and its outputs. A project will typically also have a project file and may optionally have a manifest file:\n\nProject file: a file in the root directory of a project, named Project.toml (or JuliaProject.toml), describing metadata about the project, including its name, UUID (for packages), authors, license, and the names and UUIDs of packages and libraries that it depends on.\nManifest file: a file in the root directory of a project, named Manifest.toml (or JuliaManifest.toml), describing a complete dependency graph and exact versions of each package and library used by a project. The file name may also be suffixed by -v{major}.{minor}.toml which julia will prefer if the version matches VERSION, allowing multiple environments to be maintained for different julia versions.\n\nPackage: a project which provides reusable functionality that can be used by other Julia projects via import X or using X. A package should have a project file with a uuid entry giving its package UUID. This UUID is used to identify the package in projects that depend on it.\n\nnote: Note\nFor legacy reasons, it is possible to load a package without a project file or UUID from the REPL or the top-level of a script. It is not possible, however, to load a package without a project file or UUID from a project with them. Once you've loaded from a project file, everything needs a project file and UUID.\n\nApplication: a project which provides standalone functionality not intended to be reused by other Julia projects. For example a web application or a command-line utility, or simulation/analytics code accompanying a scientific paper. An application may have a UUID but does not need one. An application may also set and change the global configurations of packages it depends on. Packages, on the other hand, may not change the global state of their dependencies since that could conflict with the configuration of the main application.\n\nnote: Note\nProjects vs. Packages vs. Applications:Project is an umbrella term: packages and applications are kinds of projects.\nPackages should have UUIDs, applications can have UUIDs but don't need them.\nApplications can provide global configuration, whereas packages cannot.\n\nEnvironment: the combination of the top-level name map provided by a project file combined with the dependency graph and map from packages to their entry points provided by a manifest file. For more detail see the manual section on code loading.\n\nExplicit environment: an environment in the form of an explicit project file and an optional corresponding manifest file together in a directory. If the manifest file is absent then the implied dependency graph and location maps are empty.\nImplicit environment: an environment provided as a directory (without a project file or manifest file) containing packages with entry points of the form X.jl, X.jl/src/X.jl or X/src/X.jl. The top-level name map is implied by these entry points. The dependency graph is implied by the existence of project files inside of these package directories, e.g. X.jl/Project.toml or X/Project.toml. The dependencies of the X package are the dependencies in the corresponding project file if there is one. The location map is implied by the entry points themselves.\n\nRegistry: a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:\n\nname – e.g. DataFrames\nUUID – e.g. a93c6f00-e57d-5684-b7b6-d8193f3e46c0\nrepository – e.g. https://github.com/JuliaData/DataFrames.jl.git\nversions – a list of all registered version tags\n\nFor each registered version of a package, the following information is provided:\n\nits semantic version number – e.g. v1.2.3\nits git tree SHA-1 hash – e.g. 7ffb18ea3245ef98e368b02b81e8a86543a11103\na map from names to UUIDs of dependencies\nwhich versions of other packages it is compatible/incompatible with\n\nDependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.\n\nDepot: a directory on a system where various package-related resources live, including:\n\nenvironments: shared named environments (e.g. v1.0, devtools)\nclones: bare clones of package repositories\ncompiled: cached compiled package images (.ji files)\nconfig: global configuration files (e.g. startup.jl)\ndev: default directory for package development\nlogs: log files (e.g. manifest_usage.toml, repl_history.jl)\npackages: installed package versions\nregistries: clones of registries (e.g. General)\n\nLoad path: a stack of environments where package identities, their dependencies, and entry points are searched for. The load path is controlled in Julia by the LOAD_PATH global variable which is populated at startup based on the value of the JULIA_LOAD_PATH environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.\n\nDepot path: a stack of depot locations where the package manager, as well as Julia's code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia DEPOT_PATH global variable which is populated at startup based on the value of the JULIA_DEPOT_PATH environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repositories are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.","category":"section"},{"location":"api/#API-Reference","page":"12. API Reference","title":"12. API Reference","text":"This section describes the functional API for interacting with Pkg.jl. It is recommended to use the functional API, rather than the Pkg REPL mode, for non-interactive usage, for example in scripts.","category":"section"},{"location":"api/#General-API-Reference","page":"12. API Reference","title":"General API Reference","text":"Certain options are generally useful and can be specified in any API call. You can specify these options by setting keyword arguments.","category":"section"},{"location":"api/#Redirecting-output","page":"12. API Reference","title":"Redirecting output","text":"Use the io::IOBuffer keyword argument to redirect Pkg output. For example, Pkg.add(\"Example\"; io=devnull) will discard any output produced by the add call.","category":"section"},{"location":"api/#Package-API-Reference","page":"12. API Reference","title":"Package API Reference","text":"In the Pkg REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings, for example \"Package#master\",\"Package@v0.1\", \"www.mypkg.com/MyPkg#my/feature\".\n\nIn the functional API, it is possible to use strings as arguments for simple commands (like Pkg.add([\"PackageA\", \"PackageB\"]), but more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings. This is done by creating an instance of PackageSpec which is passed in to functions.","category":"section"},{"location":"api/#Registry-API-Reference","page":"12. API Reference","title":"Registry API Reference","text":"The functional API for registries uses RegistrySpecs, similar to PackageSpec.","category":"section"},{"location":"api/#Artifacts-Reference","page":"12. API Reference","title":"Artifacts API Reference","text":"","category":"section"},{"location":"api/#Pkg.add","page":"12. API Reference","title":"Pkg.add","text":"Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED, target::Symbol=:deps)\nPkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED, target::Symbol=:deps)\n\nAdd a package to the current project. This package will be available by using the import and using keywords in the Julia REPL, and if the current project is a package, also inside that package.\n\nIf the active environment is a package (the Project has both name and uuid fields) compat entries will be added automatically with a lower bound of the added version.\n\nTo add as a weak dependency (in the [weakdeps] field) set the kwarg target=:weakdeps. To add as an extra dep (in the [extras] field) set target=:extras.\n\nResolution Tiers\n\nPkg resolves the set of packages in your environment using a tiered algorithm. The preserve keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for preserve (in order of strictness):\n\nValue Description\nPRESERVE_ALL_INSTALLED Like PRESERVE_ALL and only add those already installed\nPRESERVE_ALL Preserve the state of all existing dependencies (including recursive dependencies)\nPRESERVE_DIRECT Preserve the state of all existing direct dependencies\nPRESERVE_SEMVER Preserve semver-compatible versions of direct dependencies\nPRESERVE_NONE Do not attempt to preserve any version information\nPRESERVE_TIERED_INSTALLED Like PRESERVE_TIERED except PRESERVE_ALL_INSTALLED is tried first\nPRESERVE_TIERED Use the tier that will preserve the most version information while\n allowing version resolution to succeed (this is the default)\n\nnote: Note\nTo change the default strategy to PRESERVE_TIERED_INSTALLED set the env var JULIA_PKG_PRESERVE_TIERED_INSTALLED to true.\n\nAfter the installation of new packages the project will be precompiled. For more information see pkg> ?precompile.\n\nWith the PRESERVE_ALL_INSTALLED strategy the newly added packages will likely already be precompiled, but if not this may be because either the combination of package versions resolved in this environment has not been resolved and precompiled before, or the precompile cache has been deleted by the LRU cache storage (see JULIA_MAX_NUM_PRECOMPILE_FILES).\n\ncompat: Julia 1.9\nThe PRESERVE_TIERED_INSTALLED and PRESERVE_ALL_INSTALLED strategies requires at least Julia 1.9.\n\ncompat: Julia 1.11\nThe target kwarg requires at least Julia 1.11.\n\nExamples\n\nPkg.add(\"Example\") # Add a package from registry\nPkg.add(\"Example\", target=:weakdeps) # Add a package as a weak dependency\nPkg.add(\"Example\", target=:extras) # Add a package to the `[extras]` list\nPkg.add(\"Example\"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and strictly preserve existing dependencies\nPkg.add(name=\"Example\", version=\"0.3\") # Specify version; latest release in the 0.3 series\nPkg.add(name=\"Example\", version=\"0.3.1\") # Specify version; exact release\nPkg.add(url=\"https://github.com/JuliaLang/Example.jl\", rev=\"master\") # From url to remote gitrepo\nPkg.add(url=\"/remote/mycompany/juliapackages/OurPackage\") # From path to local gitrepo\nPkg.add(url=\"https://github.com/Company/MonoRepo\", subdir=\"juliapkgs/Package.jl)\") # With subdir\n\nAfter the installation of new packages the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, Pkg.develop.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.develop","page":"12. API Reference","title":"Pkg.develop","text":"Pkg.develop(pkg::Union{String, Vector{String}}; io::IO=stderr, preserve=PRESERVE_TIERED, installed=false)\nPkg.develop(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, preserve=PRESERVE_TIERED, installed=false)\n\nMake a package available for development by tracking it by path. If pkg is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable JULIA_PKG_DEVDIR, with joinpath(DEPOT_PATH[1],\"dev\") being the default.\n\nIf pkg is given as a local path, the package at that path will be tracked.\n\nThe preserve strategies offered by Pkg.add are also available via the preserve kwarg. See Pkg.add for more information.\n\nExamples\n\n# By name\nPkg.develop(\"Example\")\n\n# By url\nPkg.develop(url=\"https://github.com/JuliaLang/Compat.jl\")\n\n# By path\nPkg.develop(path=\"MyJuliaPackages/Package.jl\")\n\nSee also PackageSpec, Pkg.add.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.activate","page":"12. API Reference","title":"Pkg.activate","text":"Pkg.activate([s::String]; shared::Bool=false, io::IO=stderr)\nPkg.activate(; temp::Bool=false, shared::Bool=false, io::IO=stderr)\n\nActivate the environment at s. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:\n\nIf shared is true, the first existing environment named s from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.\nIf temp is true this will create and activate a temporary environment which will be deleted when the julia process is exited.\nIf s is an existing path, then activate the environment at that path.\nIf s is a package in the current project and s is tracking a path, then activate the environment at the tracked path.\nOtherwise, s is interpreted as a non-existing path, which is then activated.\n\nIf no argument is given to activate, then use the first project found in LOAD_PATH (ignoring \"@\"). For the default value of LOAD_PATH, the result is to activate the @v#.# environment.\n\nExamples\n\nPkg.activate()\nPkg.activate(\"local/path\")\nPkg.activate(\"MyDependency\")\nPkg.activate(; temp=true)\n\nSee also LOAD_PATH.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.rm","page":"12. API Reference","title":"Pkg.rm","text":"Pkg.rm(pkg::Union{String, Vector{String}}; mode::PackageMode = PKGMODE_PROJECT)\nPkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}}; mode::PackageMode = PKGMODE_PROJECT)\n\nRemove a package from the current project. If mode is equal to PKGMODE_MANIFEST also remove it from the manifest including all recursive dependencies of pkg.\n\nSee also PackageSpec, PackageMode.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.update","page":"12. API Reference","title":"Pkg.update","text":"Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT, preserve::PreserveLevel)\nPkg.update(pkg::Union{String, Vector{String}})\nPkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nIf no positional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT. If no positional argument is given, level can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).\n\nIf packages are given as positional arguments, the preserve argument can be used to control what other packages are allowed to update:\n\nPRESERVE_ALL (default): Only allow pkg to update.\nPRESERVE_DIRECT: Only allow pkg and indirect dependencies that are not a direct dependency in the project to update.\nPRESERVE_NONE: Allow pkg and all its indirect dependencies to update.\n\nAfter any package updates the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, PackageMode, UpgradeLevel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.test","page":"12. API Reference","title":"Pkg.test","text":"Pkg.test(; kwargs...)\nPkg.test(pkg::Union{String, Vector{String}; kwargs...)\nPkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)\n\nKeyword arguments:\n\ncoverage::Union{Bool,String}=false: enable or disable generation of coverage statistics for the tested package. If a string is passed it is passed directly to --code-coverage in the test process so e.g. \"user\" will test all user code.\nallow_reresolve::Bool=true: allow Pkg to reresolve the package versions in the test environment\njulia_args::Union{Cmd, Vector{String}}: options to be passed the test process.\ntest_args::Union{Cmd, Vector{String}}: test arguments (ARGS) available in the test process.\n\ncompat: Julia 1.9\nallow_reresolve requires at least Julia 1.9.\n\ncompat: Julia 1.9\nPassing a string to coverage requires at least Julia 1.9.\n\nRun the tests for package pkg, or for the current project (which thus needs to be a package) if no positional argument is given to Pkg.test. A package is tested by running its test/runtests.jl file.\n\nThe tests are run by generating a temporary environment with only the pkg package and its (recursive) dependencies in it. If a manifest file exists and the allow_reresolve keyword argument is set to false, the versions in the manifest file are used. Otherwise a feasible set of packages is resolved and installed.\n\nDuring the tests, test-specific dependencies are active, which are given in the project file as e.g.\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\n\nThe tests are executed in a new process with check-bounds=yes and by default startup-file=no. If using the startup file (~/.julia/config/startup.jl) is desired, start julia with --startup-file=yes. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with --inline=no. The tests can be run as if different command line arguments were passed to julia by passing the arguments instead to the julia_args keyword argument, e.g.\n\nPkg.test(\"foo\"; julia_args=[\"--inline\"])\n\nTo pass some command line arguments to be used in the tests themselves, pass the arguments to the test_args keyword argument. These could be used to control the code being tested, or to control the tests in some way. For example, the tests could have optional additional tests:\n\nif \"--extended\" in ARGS\n    @test some_function()\nend\n\nwhich could be enabled by testing with\n\nPkg.test(\"foo\"; test_args=[\"--extended\"])\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.build","page":"12. API Reference","title":"Pkg.build","text":"Pkg.build(; verbose = false, io::IO=stderr)\nPkg.build(pkg::Union{String, Vector{String}}; verbose = false, io::IO=stderr)\nPkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false, io::IO=stderr)\n\nRun the build script in deps/build.jl for pkg and all of its dependencies in depth-first recursive order. If no argument is given to build, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.pin","page":"12. API Reference","title":"Pkg.pin","text":"Pkg.pin(pkg::Union{String, Vector{String}}; io::IO=stderr, all_pkgs::Bool=false)\nPkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, all_pkgs::Bool=false)\n\nPin a package to the current version (or the one given in the PackageSpec) or to a certain git revision. A pinned package is never automatically updated: if pkg is tracking a path, or a repository, those remain tracked but will not update. To get updates from the origin path or remote repository the package must first be freed.\n\ncompat: Julia 1.7\nThe all_pkgs kwarg was introduced in julia 1.7.\n\nExamples\n\nPkg.pin(\"Example\")\nPkg.pin(name=\"Example\", version=\"0.3.1\")\nPkg.pin(all_pkgs = true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.free","page":"12. API Reference","title":"Pkg.free","text":"Pkg.free(pkg::Union{String, Vector{String}}; io::IO=stderr, all_pkgs::Bool=false)\nPkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr, all_pkgs::Bool=false)\n\nIf pkg is pinned, remove the pin. If pkg is tracking a path, e.g. after Pkg.develop, go back to tracking registered versions. To free all dependencies set all_pkgs=true.\n\ncompat: Julia 1.7\nThe all_pkgs kwarg was introduced in julia 1.7.\n\nExamples\n\nPkg.free(\"Package\")\nPkg.free(all_pkgs = true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.instantiate","page":"12. API Reference","title":"Pkg.instantiate","text":"Pkg.instantiate(; verbose = false, io::IO=stderr)\n\nIf a Manifest.toml file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the Project.toml files and install them. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file. If no Project.toml exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.\n\nAfter packages have been installed the project will be precompiled. See more at Environment Precompilation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.resolve","page":"12. API Reference","title":"Pkg.resolve","text":"Pkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.gc","page":"12. API Reference","title":"Pkg.gc","text":"Pkg.gc(; collect_delay::Period=Day(7), io::IO=stderr)\n\nGarbage-collect package and artifact installations by sweeping over all known Manifest.toml and Artifacts.toml files, noting those that have been deleted, and then finding artifacts and packages that are thereafter not used by any other projects, marking them as \"orphaned\".  This method will only remove orphaned objects (package versions, artifacts, and scratch spaces) that have been continually un-used for a period of collect_delay; which defaults to seven days.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.status","page":"12. API Reference","title":"Pkg.status","text":"Pkg.status([pkgs...]; outdated::Bool=false, mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false, compat::Bool=false, extensions::Bool=false, io::IO=stdout)\n\nPrint out the status of the project/manifest.\n\nPackages marked with ⌃ have new versions that can be installed, e.g. via Pkg.update. Those marked with ⌅ have new versions available, but cannot be installed due to compatibility conflicts with other packages. To see why, set the keyword argument outdated=true.\n\nSetting outdated=true will only show packages that are not on the latest version, their maximum version and why they are not on the latest version (either due to other packages holding them back due to compatibility constraints, or due to compatibility in the project file). As an example, a status output like:\n\npkg> Pkg.status(; outdated=true)\nStatus `Manifest.toml`\n⌃ [a8cc5b0e] Crayons v2.0.0 [<v3.0.0], (<v4.0.4)\n⌅ [b8a86587] NearestNeighbors v0.4.8 (<v0.4.9) [compat]\n⌅ [2ab3a3ac] LogExpFunctions v0.2.5 (<v0.3.0): SpecialFunctions\n\nmeans that the latest version of Crayons is 4.0.4 but the latest version compatible with the [compat] section in the current project is 3.0.0. The latest version of NearestNeighbors is 0.4.9 but due to compat constrains in the project it is held back to 0.4.8. The latest version of LogExpFunctions is 0.3.0 but SpecialFunctions is holding it back to 0.2.5.\n\nIf mode is PKGMODE_PROJECT, print out status only about the packages that are in the project (explicitly added). If mode is PKGMODE_MANIFEST, print status also about those in the manifest (recursive dependencies). If there are any packages listed as arguments, the output will be limited to those packages.\n\nSetting ext=true will show dependencies with extensions and what extension dependencies of those that are currently loaded.\n\nSetting diff=true will, if the environment is in a git repository, limit the output to the difference as compared to the last git commit.\n\nSee Pkg.project and Pkg.dependencies to get the project/manifest status as a Julia object instead of printing it.\n\ncompat: Julia 1.8\nThe ⌃ and ⌅ indicators were added in Julia 1.8. The outdated keyword argument requires at least Julia 1.8.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.compat","page":"12. API Reference","title":"Pkg.compat","text":"Pkg.compat()\n\nInteractively edit the [compat] entries within the current Project.\n\nPkg.compat(pkg::String, compat::String)\n\nSet the [compat] string for the given package within the current Project.\n\nSee Compatibility for more information on the project [compat] section.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.precompile","page":"12. API Reference","title":"Pkg.precompile","text":"Pkg.precompile(; strict::Bool=false, timing::Bool=false)\nPkg.precompile(pkg; strict::Bool=false, timing::Bool=false)\nPkg.precompile(pkgs; strict::Bool=false, timing::Bool=false)\n\nPrecompile all or specific dependencies of the project in parallel.\n\nSet timing=true to show the duration of the precompilation of each dependency.\n\nnote: Note\nErrors will only throw when precompiling the top-level dependencies, given that not all manifest dependencies may be loaded by the top-level dependencies on the given system. This can be overridden to make errors in all dependencies throw by setting the kwarg strict to true\n\nnote: Note\nThis method is called automatically after any Pkg action that changes the manifest. Any packages that have previously errored during precompilation won't be retried in auto mode until they have changed. To disable automatic precompilation set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0. To manually control the number of tasks used set ENV[\"JULIA_NUM_PRECOMPILE_TASKS\"].\n\ncompat: Julia 1.8\nSpecifying packages to precompile requires at least Julia 1.8.\n\ncompat: Julia 1.9\nTiming mode requires at least Julia 1.9.\n\nExamples\n\nPkg.precompile()\nPkg.precompile(\"Foo\")\nPkg.precompile([\"Foo\", \"Bar\"])\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.offline","page":"12. API Reference","title":"Pkg.offline","text":"Pkg.offline(b::Bool=true)\n\nEnable (b=true) or disable (b=false) offline mode.\n\nIn offline mode Pkg tries to do as much as possible without connecting to internet. For example, when adding a package Pkg only considers versions that are already downloaded in version resolution.\n\nTo work in offline mode across Julia sessions you can set the environment variable JULIA_PKG_OFFLINE to \"true\".\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.why","page":"12. API Reference","title":"Pkg.why","text":"Pkg.why(pkg::Union{String, Vector{String}})\nPkg.why(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nShow the reason why this package is in the manifest. The output is all the different ways to reach the package through the dependency graph starting from the dependencies.\n\ncompat: Julia 1.9\nThis function requires at least Julia 1.9.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.dependencies","page":"12. API Reference","title":"Pkg.dependencies","text":"Pkg.dependencies()::Dict{UUID, PackageInfo}\n\nThis feature is considered experimental.\n\nQuery the dependency graph of the active project. The result is a Dict that maps a package UUID to a PackageInfo struct representing the dependency (a package).\n\nPackageInfo fields\n\nField Description\nname The name of the package\nversion The version of the package (this is Nothing for stdlibs)\ntree_hash A file hash of the package directory tree\nis_direct_dep The package is a direct dependency\nis_pinned Whether a package is pinned\nis_tracking_path Whether a package is tracking a path\nis_tracking_repo Whether a package is tracking a repository\nis_tracking_registry Whether a package is being tracked by registry i.e. not by path nor by repository\ngit_revision The git revision when tracking by repository\ngit_source The git source when tracking by repository\nsource The directory containing the source code for that package\ndependencies The dependencies of that package as a vector of UUIDs\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.respect_sysimage_versions","page":"12. API Reference","title":"Pkg.respect_sysimage_versions","text":"Pkg.respect_sysimage_versions(b::Bool=true)\n\nEnable (b=true) or disable (b=false) respecting versions that are in the sysimage (enabled by default).\n\nIf this option is enabled, Pkg will only install packages that have been put into the sysimage (e.g. via PackageCompiler) at the version of the package in the sysimage. Also, trying to add a package at a URL or develop a package that is in the sysimage will error.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.project","page":"12. API Reference","title":"Pkg.project","text":"Pkg.project()::ProjectInfo\n\nThis feature is considered experimental.\n\nRequest a ProjectInfo struct which contains information about the active project.\n\nProjectInfo fields\n\nField Description\nname The project's name\nuuid The project's UUID\nversion The project's version\nispackage Whether the project is a package (has a name and uuid)\ndependencies The project's direct dependencies as a Dict which maps dependency name to dependency UUID\npath The location of the project file which defines the active project\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.undo","page":"12. API Reference","title":"Pkg.undo","text":"undo()\n\nUndoes the latest change to the active project. Only states in the current session are stored, up to a maximum of 50 states.\n\nSee also: redo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.redo","page":"12. API Reference","title":"Pkg.redo","text":"redo()\n\nRedoes the changes from the latest undo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.setprotocol!","page":"12. API Reference","title":"Pkg.setprotocol!","text":"setprotocol!(;\n    domain::AbstractString = \"github.com\",\n    protocol::Union{Nothing, AbstractString}=nothing\n)\n\nSet the protocol used to access hosted packages when adding a url or developing a package. Defaults to delegating the choice to the package developer (protocol === nothing). Other choices for protocol are \"https\" or \"git\".\n\nExamples\n\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"ssh\")\n\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.PackageSpec","page":"12. API Reference","title":"Pkg.PackageSpec","text":"PackageSpec(name::String, [uuid::UUID, version::VersionNumber])\nPackageSpec(; name, url, path, subdir, rev, version, mode, level)\n\nA PackageSpec is a representation of a package with various metadata. This includes:\n\nThe name of the package.\nThe package's unique uuid.\nA version (for example when adding a package). When upgrading, can also be an instance of the enum UpgradeLevel. If the version is given as a String this means that unspecified versions are \"free\", for example version=\"0.5\" allows any version 0.5.x to be installed. If given as a VersionNumber, the exact version is used, for example version=v\"0.5.3\".\nA url and an optional git revision. rev can be a branch name or a git commit SHA1.\nA local path. This is equivalent to using the url argument but can be more descriptive.\nA subdir which can be used when adding a package that is not in the root of a repository.\n\nMost functions in Pkg take a Vector of PackageSpec and do the operation on all the packages in the vector.\n\nMany functions that take a PackageSpec or a Vector{PackageSpec} can be called with a more concise notation with NamedTuples. For example, Pkg.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.add(PackageSpec(name=\"Package\")) Pkg.add(name = \"Package\")\nPkg.add(PackageSpec(url=\"www.myhost.com/MyPkg\"))) Pkg.add(url=\"www.myhost.com/MyPkg\")\nPkg.add([PackageSpec(name=\"Package\"), PackageSpec(path=\"/MyPkg\"]) Pkg.add([(;name=\"Package\"), (;path=\"/MyPkg\")])\n\nBelow is a comparison between the REPL mode and the functional API:\n\nREPL API\nPackage PackageSpec(\"Package\")\nPackage@0.2 PackageSpec(name=\"Package\", version=\"0.2\")\n- PackageSpec(name=\"Package\", version=v\"0.2.1\")\nPackage=a67d... PackageSpec(name=\"Package\", uuid=\"a67d...\")\nPackage#master PackageSpec(name=\"Package\", rev=\"master\")\nlocal/path#feature PackageSpec(path=\"local/path\"; rev=\"feature\")\nwww.mypkg.com PackageSpec(url=\"www.mypkg.com\")\n--major Package PackageSpec(name=\"Package\", version=UPLEVEL_MAJOR)\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.PackageMode","page":"12. API Reference","title":"Pkg.PackageMode","text":"PackageMode\n\nAn enum with the instances\n\nPKGMODE_MANIFEST\nPKGMODE_PROJECT\n\nDetermines if operations should be made on a project or manifest level. Used as an argument to Pkg.rm, Pkg.update and Pkg.status.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.UpgradeLevel","page":"12. API Reference","title":"Pkg.UpgradeLevel","text":"UpgradeLevel\n\nAn enum with the instances\n\nUPLEVEL_FIXED\nUPLEVEL_PATCH\nUPLEVEL_MINOR\nUPLEVEL_MAJOR\n\nDetermines how much a package is allowed to be updated. Used as an argument to  PackageSpec or as an argument to Pkg.update.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.RegistrySpec","page":"12. API Reference","title":"Pkg.RegistrySpec","text":"RegistrySpec(name::String)\nRegistrySpec(; name, uuid, url, path)\n\nA RegistrySpec is a representation of a registry with various metadata, much like PackageSpec. This includes:\n\nThe name of the registry.\nThe registry's unique uuid.\nThe url to the registry.\nA local path.\n\nMost registry functions in Pkg take a Vector of RegistrySpec and do the operation on all the registries in the vector.\n\nMany functions that take a RegistrySpec can be called with a more concise notation with keyword arguments. For example, Pkg.Registry.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.Registry.add(RegistrySpec(name=\"General\")) Pkg.Registry.add(name = \"General\")\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/JuliaRegistries/General.git\"))) Pkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")\n\nBelow is a comparison between the REPL mode and the functional API::\n\nREPL API\nMyRegistry RegistrySpec(\"MyRegistry\")\nMyRegistry=a67d... RegistrySpec(name=\"MyRegistry\", uuid=\"a67d...\")\nlocal/path RegistrySpec(path=\"local/path\")\nwww.myregistry.com RegistrySpec(url=\"www.myregistry.com\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.Registry.add","page":"12. API Reference","title":"Pkg.Registry.add","text":"Pkg.Registry.add(registry::RegistrySpec)\n\nAdd new package registries.\n\nThe no-argument Pkg.Registry.add() will install the default registries.\n\nExamples\n\nPkg.Registry.add(\"General\")\nPkg.Registry.add(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\nPkg.Registry.add(url = \"https://github.com/JuliaRegistries/General.git\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.rm","page":"12. API Reference","title":"Pkg.Registry.rm","text":"Pkg.Registry.rm(registry::String)\nPkg.Registry.rm(registry::RegistrySpec)\n\nRemove registries.\n\nExamples\n\nPkg.Registry.rm(\"General\")\nPkg.Registry.rm(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.update","page":"12. API Reference","title":"Pkg.Registry.update","text":"Pkg.Registry.update()\nPkg.Registry.update(registry::RegistrySpec)\nPkg.Registry.update(registry::Vector{RegistrySpec})\n\nUpdate registries. If no registries are given, update all available registries.\n\nExamples\n\nPkg.Registry.update()\nPkg.Registry.update(\"General\")\nPkg.Registry.update(uuid = \"23338594-aafe-5451-b93e-139f81909106\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.status","page":"12. API Reference","title":"Pkg.Registry.status","text":"Pkg.Registry.status()\n\nDisplay information about available registries.\n\nExamples\n\nPkg.Registry.status()\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.create_artifact","page":"12. API Reference","title":"Pkg.Artifacts.create_artifact","text":"create_artifact(f::Function)\n\nCreates a new artifact by running f(artifact_path), hashing the result, and moving it to the artifact store (~/.julia/artifacts on a typical installation).  Returns the identifying tree hash of this artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.remove_artifact","page":"12. API Reference","title":"Pkg.Artifacts.remove_artifact","text":"remove_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nRemoves the given artifact (identified by its SHA1 git tree hash) from disk.  Note that if an artifact is installed in multiple depots, it will be removed from all of them.  If an overridden artifact is requested for removal, it will be silently ignored; this method will never attempt to remove an overridden artifact.\n\nIn general, we recommend that you use Pkg.gc() to manage artifact installations and do not use remove_artifact() directly, as it can be difficult to know if an artifact is being used by another package.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.verify_artifact","page":"12. API Reference","title":"Pkg.Artifacts.verify_artifact","text":"verify_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nVerifies that the given artifact (identified by its SHA1 git tree hash) is installed on- disk, and retains its integrity.  If the given artifact is overridden, skips the verification unless honor_overrides is set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.bind_artifact!","page":"12. API Reference","title":"Pkg.Artifacts.bind_artifact!","text":"bind_artifact!(artifacts_toml::String, name::String, hash::SHA1;\n               platform::Union{AbstractPlatform,Nothing} = nothing,\n               download_info::Union{Vector{Tuple},Nothing} = nothing,\n               lazy::Bool = false,\n               force::Bool = false)\n\nWrites a mapping of name -> hash within the given (Julia)Artifacts.toml file. If platform is not nothing, this artifact is marked as platform-specific, and will be a multi-mapping.  It is valid to bind multiple artifacts with the same name, but different platforms and hash'es within the same artifacts_toml.  If force is set to true, this will overwrite a pre-existant mapping, otherwise an error is raised.\n\ndownload_info is an optional vector that contains tuples of URLs and a hash.  These URLs will be listed as possible locations where this artifact can be obtained.  If lazy is set to true, even if download information is available, this artifact will not be downloaded until it is accessed via the artifact\"name\" syntax, or ensure_artifact_installed() is called upon it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.unbind_artifact!","page":"12. API Reference","title":"Pkg.Artifacts.unbind_artifact!","text":"unbind_artifact!(artifacts_toml::String, name::String; platform = nothing)\n\nUnbind the given name from an (Julia)Artifacts.toml file. Silently fails if no such binding exists within the file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.download_artifact","page":"12. API Reference","title":"Pkg.Artifacts.download_artifact","text":"download_artifact(tree_hash::SHA1, tarball_url::String, tarball_hash::String;\n                  verbose::Bool = false, io::IO=stderr)\n\nDownload/install an artifact into the artifact store.  Returns true on success, returns an error object on failure.\n\ncompat: Julia 1.8\nAs of Julia 1.8 this function returns the error object rather than false when failure occurs\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.ensure_artifact_installed","page":"12. API Reference","title":"Pkg.Artifacts.ensure_artifact_installed","text":"ensure_artifact_installed(name::String, artifacts_toml::String;\n                          platform::AbstractPlatform = HostPlatform(),\n                          pkg_uuid::Union{Base.UUID,Nothing}=nothing,\n                          verbose::Bool = false,\n                          quiet_download::Bool = false,\n                          io::IO=stderr)\n\nEnsures an artifact is installed, downloading it via the download information stored in artifacts_toml if necessary.  Throws an error if unable to install.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.ensure_all_artifacts_installed","page":"12. API Reference","title":"Pkg.Artifacts.ensure_all_artifacts_installed","text":"ensure_all_artifacts_installed(artifacts_toml::String;\n                               platform = HostPlatform(),\n                               pkg_uuid = nothing,\n                               include_lazy = false,\n                               verbose = false,\n                               quiet_download = false,\n                               io::IO=stderr)\n\nInstalls all non-lazy artifacts from a given (Julia)Artifacts.toml file. package_uuid must be provided to properly support overrides from Overrides.toml entries in depots.\n\nIf include_lazy is set to true, then lazy packages will be installed as well.\n\nThis function is deprecated and should be replaced with the following snippet:\n\nartifacts = select_downloadable_artifacts(artifacts_toml; platform, include_lazy)\nfor name in keys(artifacts)\n    ensure_artifact_installed(name, artifacts[name], artifacts_toml; platform=platform)\nend\n\nwarning: Warning\nThis function is deprecated in Julia 1.6 and will be removed in a future version. Use select_downloadable_artifacts() and ensure_artifact_installed() instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.archive_artifact","page":"12. API Reference","title":"Pkg.Artifacts.archive_artifact","text":"archive_artifact(hash::SHA1, tarball_path::String; honor_overrides::Bool=false)\n\nArchive an artifact into a tarball stored at tarball_path, returns the SHA256 of the resultant tarball as a hexadecimal string. Throws an error if the artifact does not exist.  If the artifact is overridden, throws an error unless honor_overrides is set.\n\n\n\n\n\n","category":"function"},{"location":"managing-packages/#Managing-Packages","page":"3. Managing Packages","title":"3. Managing Packages","text":"","category":"section"},{"location":"managing-packages/#Adding-packages","page":"3. Managing Packages","title":"Adding packages","text":"There are two ways of adding packages, either using the add command or the dev command. The most frequently used is add and its usage is described first.","category":"section"},{"location":"managing-packages/#Adding-registered-packages","page":"3. Managing Packages","title":"Adding registered packages","text":"In the Pkg REPL, packages can be added with the add command followed by the name of the package, for example:\n\n(@v1.8) pkg> add JSON\n  Installing known registries into `~/`\n   Resolving package versions...\n   Installed Parsers ─ v2.4.0\n   Installed JSON ──── v0.21.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [682c06a0] + JSON v0.21.3\n    Updating `~/environments/v1.9/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\nPrecompiling environment...\n  2 dependencies successfully precompiled in 2 seconds\n\nHere we added the package JSON to the current environment (which is the default @v1.8 environment). In this example, we are using a fresh Julia installation, and this is our first time adding a package using Pkg. By default, Pkg installs the General registry and uses this registry to look up packages requested for inclusion in the current environment. The status update shows a short form of the package UUID to the left, then the package name, and the version. Finally, the newly installed packages are \"precompiled\".\n\nIt is possible to add multiple packages in one command as pkg> add A B C.\n\nThe status output contains the packages you have added yourself, in this case, JSON:\n\n(@v1.11) pkg> st\n    Status `~/.julia/environments/v1.8/Project.toml`\n  [682c06a0] JSON v0.21.3\n\nThe manifest status shows all the packages in the environment, including recursive dependencies:\n\n(@v1.11) pkg> st -m\nStatus `~/environments/v1.9/Manifest.toml`\n  [682c06a0] JSON v0.21.3\n  [69de0a69] Parsers v2.4.0\n  [ade2ca70] Dates\n  [a63ad114] Mmap\n  [de0858da] Printf\n  [4ec0a83e] Unicode\n\nSince standard libraries (e.g. Dates) are shipped with Julia, they do not have a version.\n\nTo specify that you want a particular version (or set of versions) of a package, use the compat command. For example, to require any patch release of the v0.21 series of JSON after v0.21.4, call compat JSON 0.21.4:\n\n(@1.11) pkg> compat JSON 0.21.4\n      Compat entry set:\n  JSON = \"0.21.4\"\n     Resolve checking for compliance with the new compat rules...\n       Error empty intersection between JSON@0.21.3 and project compatibility 0.21.4 - 0.21\n  Suggestion Call `update` to attempt to meet the compatibility requirements.\n\n(@1.11) pkg> update\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/.julia/environments/1.11/Project.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\n    Updating `~/.julia/environments/1.11/Manifest.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\n\nSee the section on Compatibility for more on using the compat system.\n\nAfter a package is added to the project, it can be loaded in Julia:\n\njulia> using JSON\n\njulia> JSON.json(Dict(\"foo\" => [1, \"bar\"])) |> print\n{\"foo\":[1,\"bar\"]}\n\nnote: Note\nOnly packages that have been added with add can be loaded (which are packages that are shown when using st in the Pkg REPL). Packages that are pulled in only as dependencies (for example the Parsers package above) can not be loaded.\n\nA specific version of a package can be installed by appending a version after a @ symbol to the package name:\n\n(@v1.8) pkg> add JSON@0.21.1\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n⌃ [682c06a0] + JSON v0.21.1\n    Updating `~/environments/v1.9/Manifest.toml`\n⌃ [682c06a0] + JSON v0.21.1\n⌅ [69de0a69] + Parsers v1.1.2\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`\n\nAs seen above, Pkg gives some information when a package is not installed at its latest version.\n\nIf not all three numbers are given for the version, for example, 0.21, then the latest registered version of 0.21.x would be installed.\n\nIf a branch (or a certain commit) of Example has a hotfix that is not yet included in a registered version, we can explicitly track that branch (or commit) by appending #branchname (or #commitSHA1) to the package name:\n\n(@v1.8) pkg> add Example#master\n     Cloning git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n    Updating `~/environments/v1.9/Manifest.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n\nThe status output now shows that we are tracking the master branch of Example. When updating packages, updates are pulled from that branch.\n\nnote: Note\nIf we would specify a commit id instead of a branch name, e.g. add Example#025cf7e, then we would effectively \"pin\" the package to that commit. This is because the commit id always points to the same thing unlike a branch, which may be updated.\n\nTo go back to tracking the registry version of Example, the command free is used:\n\n(@v1.8) pkg> free Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n    Updating `~/environments/v1.9/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3","category":"section"},{"location":"managing-packages/#Adding-unregistered-packages","page":"3. Managing Packages","title":"Adding unregistered packages","text":"If a package is not in a registry, it can be added by specifying a URL to the Git repository:\n\n(@v1.8) pkg> add https://github.com/fredrikekre/ImportMacros.jl\n     Cloning git-repo `https://github.com/fredrikekre/ImportMacros.jl`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n    Updating `~/environments/v1.9/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n\nThe dependencies of the unregistered package (here MacroTools) got installed. For unregistered packages, we could have given a branch name (or commit SHA1) to track using #, just like for registered packages.\n\nIf you want to add a package using the SSH-based git protocol, you have to use quotes because the URL contains a @. For example,\n\n(@v1.8) pkg> add \"git@github.com:fredrikekre/ImportMacros.jl.git\"\n    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nUpdating `~/.julia/environments/v1/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\nUpdating `~/.julia/environments/v1/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`","category":"section"},{"location":"managing-packages/#Adding-a-package-in-a-subdirectory-of-a-repository","page":"3. Managing Packages","title":"Adding a package in a subdirectory of a repository","text":"If the package you want to add by URL is not in the root of the repository, then you need pass that subdirectory using :. For instance, to add the SnoopCompileCore package in the SnoopCompile repository:\n\npkg> add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore\n    Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n  [9e88b42a] + Serialization","category":"section"},{"location":"managing-packages/#Adding-a-local-package","page":"3. Managing Packages","title":"Adding a local package","text":"Instead of giving a URL of a git repo to add we could instead have given a local path to a git repo. This works similar to adding a URL. The local repository will be tracked (at some branch) and updates from that local repo are pulled when packages are updated.\n\nwarning: Warning\nNote that tracking a package through add is distinct from develop (which is described in the next section). When using add on a local git repository, changes to files in the local package repository will not immediately be reflected when loading that package. The changes would have to be committed and the packages updated in order to pull in the changes. In the majority of cases, you want to use develop on a local path, not add.","category":"section"},{"location":"managing-packages/#developing","page":"3. Managing Packages","title":"Developing packages","text":"By only using add your environment always has a \"reproducible state\", in other words, as long as the repositories and registries used are still accessible it is possible to retrieve the exact state of all the dependencies in the environment. This has the advantage that you can send your environment (Project.toml and Manifest.toml) to someone else and they can Pkg.instantiate that environment in the same state as you had it locally. However, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the dev command exists.\n\nLet's try to dev a registered package:\n\n(@v1.8) pkg> dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n\nThe dev command fetches a full clone of the package to ~/.julia/dev/ (the path can be changed by setting the environment variable JULIA_PKG_DEVDIR, the default being joinpath(DEPOT_PATH[1],\"dev\")). When importing Example julia will now import it from ~/.julia/dev/Example and whatever local changes have been made to the files in that path are consequently reflected in the code loaded. When we used add we said that we tracked the package repository; we here say that we track the path itself. Note the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches, etc. If we try to dev a package at some branch that already exists at ~/.julia/dev/ the package manager will simply re-use the existing path. If dev is used on a local path, that path to that package is recorded and used when loading that package. The path will be recorded relative to the project file, unless it is given as an absolute path.\n\nLet's try modify the file at  ~/.julia/dev/Example/src/Example.jl and add a simple function:\n\nplusone(x::Int) = x + 1\n\nNow we can go back to the Julia REPL and load the package and run the new function:\n\njulia> import Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\njulia> Example.plusone(1)\n2\n\nwarning: Warning\nA package can only be loaded once per Julia session. If you have run import Example in the current Julia session, you will have to restart Julia to see the changes to Example. Revise.jl can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.\n\nTo stop tracking a path and use the registered version again, use free:\n\n(@v1.8) pkg> free Example\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n\nIt should be pointed out that by using dev your project is now inherently stateful. Its state depends on the current content of the files at the path and the manifest cannot be \"instantiated\" by someone else without knowing the exact content of all the packages that are tracking a path.\n\nNote that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To synchronize the Manifest, use the REPL command resolve.\n\nIn addition to absolute paths, add and dev can accept relative paths to packages. In this case, the relative path from the active project to the package is stored. This approach is useful when the relative location of tracked dependencies is more important than their absolute location. For example, the tracked dependencies can be stored inside of the active project directory. The whole directory can be moved and Pkg will still be able to find the dependencies because their path relative to the active project is preserved even though their absolute path has changed.","category":"section"},{"location":"managing-packages/#Removing-packages","page":"3. Managing Packages","title":"Removing packages","text":"Packages can be removed from the current project by using pkg> rm Package. This will only remove packages that exist in the project; to remove a package that only exists as a dependency use pkg> rm --manifest DepPackage. Note that this will remove all packages that (recursively) depend on DepPackage.","category":"section"},{"location":"managing-packages/#updating","page":"3. Managing Packages","title":"Updating packages","text":"When new versions of packages are released, it is a good idea to update. Simply calling up will try to update all the dependencies of the project to the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to up, e.g:\n\n(@v1.8) pkg> up Example\n\nThis will only allow Example do upgrade. If you also want to allow dependencies of Example to upgrade (with the exception of packages that are in the project) you can pass the --preserve=direct flag.\n\n(@v1.8) pkg> up --preserve=direct Example\n\nAnd if you also want to allow dependencies of Example that are also in the project to upgrade, you can use --preserve=none:\n\n(@v1.8) pkg> up --preserve=none Example","category":"section"},{"location":"managing-packages/#Pinning-a-package","page":"3. Managing Packages","title":"Pinning a package","text":"A pinned package will never be updated. A package can be pinned using pin, for example:\n\n(@v1.8) pkg> pin Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n\nNote the pin symbol ⚲ showing that the package is pinned. Removing the pin is done using free\n\n(@v1.8) pkg> free Example\n  Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3","category":"section"},{"location":"managing-packages/#Testing-packages","page":"3. Managing Packages","title":"Testing packages","text":"The tests for a package can be run using test command:\n\n(@v1.8) pkg> test Example\n...\n   Testing Example\n   Testing Example tests passed","category":"section"},{"location":"managing-packages/#Building-packages","page":"3. Managing Packages","title":"Building packages","text":"The build step of a package is automatically run when a package is first installed. The output of the build process is directed to a file. To explicitly run the build step for a package, the build command is used:\n\n(@v1.8) pkg> build IJulia\n    Building Conda ─→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/6e47d11ea2776bc5627421d59cdcc1296c058071/build.log`\n    Building IJulia → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log`\n\njulia> print(read(joinpath(homedir(), \".julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log\"), String))\n[ Info: Installing Julia kernelspec in /home/kc/.local/share/jupyter/kernels/julia-1.8","category":"section"},{"location":"managing-packages/#conflicts","page":"3. Managing Packages","title":"Interpreting and resolving version conflicts","text":"An environment consists of a set of mutually-compatible packages. Sometimes, you can find yourself in a situation in which two packages you'd like to use simultaneously have incompatible requirements. In such cases you'll get an \"Unsatisfiable requirements\" error:\n\nprint(\"pkg> add A\\n\", try resolve_tst(deps_data, reqs_data) catch e sprint(showerror, e) end)   # hide\n\nThis message means that a package named D has a version conflict. Even if you have never added D directly, this kind of error can arise if D is required by other packages that you are trying to use.\n\nnote: Note\nWhen tackling these conflicts, first consider that the bigger a project gets, the more likely this is to happen. Using targeted projects for a given task is highly recommended, and removing unused dependencies is a good first step when hitting these issues. For instance, a common pitfall is having more than a few packages in your default (i.e. (@1.8)) environment, and using that as an environment for all tasks you're using julia for. It's better to create a dedicated project for the task you're working on, and keep the dependencies there minimal. To read more see Working with Environments\n\nThe error message has a lot of crucial information. It may be easiest to interpret piecewise:\n\nUnsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled\n\nmeans that D has three released versions, v0.1.0, v0.2.0, and v0.2.1. You also have the option of not having it installed at all. Each of these options might have different implications for the set of other packages that can be installed.\n\nCrucially, notice the stroke characters (vertical and horizontal lines) and their indentation. Together, these connect messages to specific packages. For instance the right stroke of ├─ indicates that the message to its right (possible versions...) is connected to the package pointed to by its vertical stroke (D). This same principle applies to the next line:\n\n ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0\n\nThe vertical stroke here is also aligned under D, and thus this message is in reference to D. Specifically, there's some other package B that depends on version v0.1.0 of D. Notice that this is not the newest version of D.\n\nNext comes some information about B:\n\n │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0\n\nThe two lines below the first have a vertical stroke that aligns with B, and thus they provide information about B. They tell you that B has just one release, v1.0.0. You've not specified a particular version of B (restricted to versions * means that any version will do), but the explicit requirement means that you've asked for B to be part of your environment, for example by pkg> add B. You might have asked for B previously, and the requirement is still active.\n\nThe conflict becomes clear with the line\n\n└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left\n\nHere again, the vertical stroke aligns with D: this means that D is also required by another package, C. C requires v0.2.0 of D, and this conflicts with B's need for v0.1.0 of D. This explains the conflict.\n\nBut wait, you might ask, what is C and why do I need it at all? The next few lines introduce the problem:\n\n   └─C [c99a7cb2] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0\n\nThese provide more information about C, revealing that it has 3 released versions: v0.1.0, v0.1.1, and v0.2.0. Moreover, C is required by another package A. Indeed, A's requirements are such that we need v0.2.0 of C. A's origin is revealed on the next lines:\n\n       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0\n\nSo we can see that A was explicitly required, and in this case, it's because we were trying to add it to our environment.\n\nIn summary, we explicitly asked to use A and B, but this gave a conflict for D. The reason was that B and C require conflicting versions of D. Even though C isn't something we asked for explicitly, it was needed by A.\n\nTo fix such errors, you have a number of options:\n\ntry updating your packages. It's possible the developers of these packages have recently released new versions that are mutually compatible.\nremove either A or B from your environment. Perhaps B is left over from something you were previously working on, and you don't need it anymore. If you don't need A and B at the same time, this is the easiest way to fix the problem.\ntry reporting your conflict. In this case, we were able to deduce that B requires an outdated version of D. You could thus report an issue in the development repository of B.jl asking for an updated version.\ntry fixing the problem yourself. This becomes easier once you understand Project.toml files and how they declare their compatibility requirements. We'll return to this example in Fixing conflicts.","category":"section"},{"location":"managing-packages/#Garbage-collecting-old,-unused-packages","page":"3. Managing Packages","title":"Garbage collecting old, unused packages","text":"As packages are updated and projects are deleted, installed package versions and artifacts that were once used will inevitably become old and not used from any existing project. Pkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist and what packages/artifacts those projects used. If a package or artifact is not marked as used by any project, it is added to a list of orphaned packages. Packages and artifacts that are in the orphan list for 30 days without being used again are deleted from the system on the next garbage collection. This timing is configurable via the collect_delay keyword argument to Pkg.gc(). A value of 0 will cause anything currently not in use to be collected immediately, skipping the orphans list entirely; If you are short on disk space and want to clean out as many unused packages and artifacts as possible, you may want to try this, but if you need these versions again, you will have to download them again. To run a typical garbage collection with default arguments, simply use the gc command at the pkg> REPL:\n\n(@v1.8) pkg> gc\n    Active manifests at:\n        `~/BinaryProvider/Manifest.toml`\n        ...\n        `~/Compat.jl/Manifest.toml`\n    Active artifacts:\n        `~/src/MyProject/Artifacts.toml`\n\n    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\n    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB\n   ...\n   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)\n   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)\n\n   Deleted 36 package installations (113.205 MiB)\n   Deleted 15 artifact installations (20.759 GiB)\n\nNote that only packages in ~/.julia/packages are deleted.","category":"section"},{"location":"managing-packages/#Offline-Mode","page":"3. Managing Packages","title":"Offline Mode","text":"In offline mode, Pkg tries to do as much as possible without connecting to internet. For example, when adding a package Pkg only considers versions that are already downloaded in version resolution.\n\nTo work in offline mode use import Pkg; Pkg.offline(true) or set the environment variable JULIA_PKG_OFFLINE to \"true\".","category":"section"},{"location":"managing-packages/#Pkg-client/server","page":"3. Managing Packages","title":"Pkg client/server","text":"When you add a new registered package, usually three things would happen:\n\nupdate registries,\ndownload the source code of the package,\nif not available, download artifacts required by the package.\n\nThe General registry and most packages in it are developed on GitHub, while the artifacts data are hosted on various platforms. When the network connection to GitHub and AWS S3 is not stable, it is usually not a good experience to install or update packages. Fortunately, the pkg client/server feature improves the experience in the sense that:\n\nIf set, the pkg client would first try to download data from the pkg server,\nif that fails, then it falls back to downloading from the original sources (e.g., GitHub).\n\nBy default, the client makes upto 8 concurrent requests to the server. This can set by the environment variable JULIA_PKG_CONCURRENT_DOWNLOADS.\n\nSince Julia 1.5, https://pkg.julialang.org provided by the JuliaLang organization is used as the default pkg server. In most cases, this should be transparent, but users can still set/unset a pkg server upstream via the environment variable JULIA_PKG_SERVER.\n\n# manually set it to some pkg server\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"pkg.julialang.org\"\n\"pkg.julialang.org\"\n\n# unset to always download data from original sources\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"\"\n\"\"\n\nFor clarification, some sources are not provided by Pkg server\n\npackages/registries fetched via git\n]add https://github.com/JuliaLang/Example.jl.git\n]add Example#v0.5.3 (Note that this is different from ]add Example@0.5.3)\n]registry add https://github.com/JuliaRegistries/General.git, including registries installed by Julia before 1.4.\nartifacts without download info\nTestImages\n\nnote: Note\nIf you have a new registry installed via pkg server, then it's impossible for old Julia versions to update the registry because Julia before 1.4 doesn't know how to fetch new data. Hence, for users that frequently switch between multiple Julia versions, it is recommended to still use git-controlled registries.\n\nFor the deployment of pkg server, please refer to PkgServer.jl.","category":"section"},{"location":"environments/#Working-with-Environments","page":"4. Working with Environment","title":"4. Working with Environment","text":"The following discusses Pkg's interaction with environments. For more on the role, environments play in code loading, including the \"stack\" of environments from which code can be loaded, see this section in the Julia manual.","category":"section"},{"location":"environments/#Creating-your-own-environments","page":"4. Working with Environment","title":"Creating your own environments","text":"So far we have added packages to the default environment at ~/.julia/environments/v1.9. It is however easy to create other, independent, projects. This approach has the benefit of allowing you to check in a Project.toml, and even a Manifest.toml if you wish, into version control (e.g. git) alongside your code. It should be pointed out that when two projects use the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the \"active project\", which package operations manipulate:\n\n(@v1.9) pkg> activate MyProject\nActivating new environment at `~/MyProject/Project.toml`\n\n(MyProject) pkg> st\n    Status `~/MyProject/Project.toml` (empty project)\n\nNote that the REPL prompt changes when the new project is activated. Until a package is added, there are no files in this environment and the directory to the environment might not even be created:\n\njulia> isdir(\"MyProject\")\nfalse\n\n(MyProject) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/MyProject/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~~/MyProject/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling environment...\n  1 dependency successfully precompiled in 2 seconds\n\njulia> readdir(\"MyProject\")\n2-element Vector{String}:\n \"Manifest.toml\"\n \"Project.toml\"\n\njulia> print(read(joinpath(\"MyProject\", \"Project.toml\"), String))\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\njulia> print(read(joinpath(\"MyProject\", \"Manifest.toml\"), String))\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.9.4\"\nmanifest_format = \"2.0\"\nproject_hash = \"2ca1c6c58cb30e79e021fb54e5626c96d05d5fdc\"\n\n[[deps.Example]]\ngit-tree-sha1 = \"46e44e869b4d90b96bd8ed1fdcf32244fddfb6cc\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"0.5.3\"\n\nThis new environment is completely separate from the one we used earlier. See Project.toml and Manifest.toml for a more detailed explanation.","category":"section"},{"location":"environments/#Using-someone-else's-project","page":"4. Working with Environment","title":"Using someone else's project","text":"Simply clone their project using e.g. git clone, cd to the project directory and call\n\nshell> git clone https://github.com/JuliaLang/Example.jl.git\nCloning into 'Example.jl'...\n...\n\n(@v1.9) pkg> activate Example.jl\nActivating project at `~/Example.jl`\n\n(Example) pkg> instantiate\n  No Changes to `~/Example.jl/Project.toml`\n  No Changes to `~/Example.jl/Manifest.toml`\n\nIf the project contains a manifest, this will install the packages in the same state that is given by that manifest. Otherwise, it will resolve the latest versions of the dependencies compatible with the project.\n\nNote that activate by itself does not install missing dependencies. If you only have a Project.toml, a Manifest.toml must be generated by \"resolving\" the environment, then any missing packages must be installed and precompiled. instantiate does all this for you.\n\nIf you already have a resolved Manifest.toml, then you will still need to ensure that the packages are installed and with the correct versions. Again instantiate does this for you.\n\nIn short, instantiate is your friend to make sure an environment is ready to use. If there's nothing to do, instantiate does nothing.\n\nnote: Specifying project on startup\nInstead of using activate from within Julia, you can specify the project on startup using the --project=<path> flag. For example, to run a script from the command line using the environment in the current directory you can run$ julia --project=. myscript.jl","category":"section"},{"location":"environments/#Temporary-environments","page":"4. Working with Environment","title":"Temporary environments","text":"Temporary environments make it easy to start an environment from a blank slate to test a package or set of packages, and have Pkg automatically delete the environment when you're done. For instance, when writing a bug report, you may want to test your minimal reproducible example in a 'clean' environment to ensure it's actually reproducible as written. You might also want a scratch space to try out a new package, or a sandbox to resolve version conflicts between several incompatible packages.\n\n(@v1.9) pkg> activate --temp # requires Julia 1.5 or later\n  Activating new environment at `/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n\n(jl_a31egx) pkg> add Example\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Manifest.toml`\n  [7876af07] + Example v0.5.3","category":"section"},{"location":"environments/#Shared-environments","page":"4. Working with Environment","title":"Shared environments","text":"A \"shared\" environment is simply an environment that exists in ~/.julia/environments. The default v1.9 environment is therefore a shared environment:\n\n(@v1.9) pkg> st\nStatus `~/.julia/environments/v1.9/Project.toml`\n\nShared environments can be activated with the --shared flag to activate:\n\n(@v1.9) pkg> activate --shared mysharedenv\n  Activating project at `~/.julia/environments/mysharedenv`\n\n(@mysharedenv) pkg>\n\nShared environments have a @ before their name in the Pkg REPL prompt.","category":"section"},{"location":"environments/#Environment-Precompilation","page":"4. Working with Environment","title":"Environment Precompilation","text":"Before a package can be imported, Julia will \"precompile\" the source code into an intermediate more efficient cache on disc. This precompilation can be triggered via code loading if the un-imported package is new or has changed since the last cache\n\njulia> using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\nor using Pkg's precompile option, which can precompile the entire environment, or a given dependency, and do so in parallel, which can be significantly faster than the code-load route above.\n\n(@v1.9) pkg> precompile\nPrecompiling environment...\n  23 dependencies successfully precompiled in 36 seconds\n\nHowever, neither of these should be routinely required thanks to Pkg's automatic precompilation.","category":"section"},{"location":"environments/#Automatic-Precompilation","page":"4. Working with Environment","title":"Automatic Precompilation","text":"By default, any package that is added to a project or updated in a Pkg action will be automatically precompiled, along with its dependencies.\n\n(@v1.9) pkg> add Images\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [916415d5] + Images v0.25.2\n    Updating `~/.julia/environments/v1.9/Manifest.toml`\n    ...\nPrecompiling environment...\n  Progress [===================>                     ]  45/97\n  ✓ NaNMath\n  ✓ IntervalSets\n  ◐ CoordinateTransformations\n  ◑ ArnoldiMethod\n  ◑ IntegralArrays\n  ◒ RegionTrees\n  ◐ ChangesOfVariables\n  ◓ PaddedViews\n\nThe exception is the develop command, which neither builds nor precompiles the package. When that happens is left up to the user to decide.\n\nIf a given package version errors during auto-precompilation, Pkg will remember for the following times it automatically tries and will skip that package with a brief warning. Manual precompilation can be used to force these packages to be retried, as pkg> precompile will always retry all packages.\n\nTo disable the auto-precompilation, set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0.\n\nThe indicators next to the package names displayed during precompilation indicate the status of that package's precompilation. \n\n[◐, ◓, ◑, ◒] Animated \"clock\" characters indicate that the package is currently being precompiled.\n✓ A green checkmark indicates that the package has been successfully precompiled (after which that package will disappear from the list). If the checkmark is yellow it means that the package is currently loaded so the session will need to be restarted to access the version that was just precompiled.\n? A question mark character indicates that a PrecompilableError was thrown, indicating that precompilation was disallowed, i.e. __precompile__(false) in that package.\n✗ A cross indicates that the package failed to precompile.","category":"section"},{"location":"environments/#Precompiling-new-versions-of-loaded-packages","page":"4. Working with Environment","title":"Precompiling new versions of loaded packages","text":"If a package that has been updated is already loaded in the session, the precompilation process will go ahead and precompile the new version, and any packages that depend on it, but will note that the package cannot be used until session restart.","category":"section"},{"location":"creating-packages/#creating-packages-tutorial","page":"5. Creating Packages","title":"5. Creating Packages","text":"","category":"section"},{"location":"creating-packages/#Generating-files-for-a-package","page":"5. Creating Packages","title":"Generating files for a package","text":"note: Note\nThe PkgTemplates package offers an easy, repeatable, and customizable way to generate the files for a new package. It can also generate files needed for Documentation, CI, etc. We recommend that you use PkgTemplates for creating new packages instead of using the minimal pkg> generate functionality described below.\n\nTo generate the bare minimum files for a new package, use pkg> generate.\n\n(@v1.8) pkg> generate HelloWorld\n\nThis creates a new project HelloWorld in a subdirectory by the same name, with the following files (visualized with the external tree command):\n\nshell> tree HelloWorld/\nHelloWorld/\n├── Project.toml\n└── src\n    └── HelloWorld.jl\n\n2 directories, 2 files\n\nThe Project.toml file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:\n\nname = \"HelloWorld\"\nuuid = \"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\"\nversion = \"0.1.0\"\nauthors = [\"Some One <someone@email.com>\"]\n\n[deps]\n\nThe content of src/HelloWorld.jl is:\n\nmodule HelloWorld\n\ngreet() = print(\"Hello World!\")\n\nend # module\n\nWe can now activate the project by using the path to the directory where it is installed, and load the package:\n\npkg> activate ./HelloWorld\n\njulia> import HelloWorld\n\njulia> HelloWorld.greet()\nHello World!\n\nFor the rest of the tutorial we enter inside the directory of the project, for convenience:\n\njulia> cd(\"HelloWorld\")","category":"section"},{"location":"creating-packages/#Adding-dependencies-to-the-project","page":"5. Creating Packages","title":"Adding dependencies to the project","text":"Let’s say we want to use the standard library package Random and the registered package JSON in our project. We simply add these packages (note how the prompt now shows the name of the newly generated project, since we activated it):\n\n(HelloWorld) pkg> add Random JSON\n   Resolving package versions...\n    Updating `~/HelloWorld/Project.toml`\n  [682c06a0] + JSON v0.21.3\n  [9a3f8284] + Random\n    Updating `~/HelloWorld/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n ...\n\nBoth Random and JSON got added to the project’s Project.toml file, and the resulting dependencies got added to the Manifest.toml file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies.\n\nWe can now use both Random and JSON in our project. Changing src/HelloWorld.jl to\n\nmodule HelloWorld\n\nimport Random\nimport JSON\n\ngreet() = print(\"Hello World!\")\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module\n\nand reloading the package, the new greet_alien function that uses Random can be called:\n\njulia> HelloWorld.greet_alien()\nHello aT157rHV","category":"section"},{"location":"creating-packages/#Defining-a-public-API","page":"5. Creating Packages","title":"Defining a public API","text":"If you want your package to be useful to other packages and you want folks to be able to easily update to newer version of your package when they come out, it is important to document what behavior will stay consistent across updates.\n\nUnless you note otherwise, the public API of your package is defined as all the behavior you describe about public symbols. A public symbol is a symbol that is exported from your package with the export keyword or marked as public with the public keyword. When you change the behavior of something that was previously public so that the new version no longer conforms to the specifications provided in the old version, you should adjust your package version number according to Julia's variant on SemVer. If you would like to include a symbol in your public API without exporting it into the global namespace of folks who call using YourPackage, you should mark that symbol as public with public that_symbol. Symbols marked as public with the public keyword are just as public as those marked as public with the export keyword, but when folks call using YourPackage, they will still have to qualify access to those symbols with YourPackage.that_symbol.\n\nLet's say we would like our greet function to be part of the public API, but not the greet_alien function. We could the write the following and release it as version 1.0.0.\n\nmodule HelloWorld\n\nexport greet\n\nimport Random\nimport JSON\n\n\"Writes a friendly message.\"\ngreet() = print(\"Hello World!\")\n\n\"Greet an alien by a randomly generated name.\"\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module\n\nThen, if we change greet to\n\n\"Writes a friendly message that is exactly three words long.\"\ngreet() = print(\"Hello Lovely World!\")\n\nWe would release the new version as 1.1.0. This is not breaking because the new implementation conforms to the old documentation, but it does add a new feature, that the message must be three words long.\n\nLater, we may wish to change greet_alien to\n\n\"Greet an alien by the name of \\\"Zork\\\".\"\ngreet_alien() = print(\"Hello Zork\")\n\nAnd also export it by changing\n\nexport greet\n\nto\n\nexport greet, greet_alien\n\nWe should release this new version as 1.2.0 because it adds a new feature greet_alien to the public API. Even though greet_alien was documented before and the new version does not conform to the old documentation, this is not breaking because the old documentation was not attached to a symbol that was exported at the time so that documentation does not apply across released versions.\n\nHowever, if we now wish to change greet to\n\n\"Writes a friendly message that is exactly four words long.\"\ngreet() = print(\"Hello very lovely world\")\n\nwe would need to release the new version as 2.0.0. In version 1.1.0, we specified that the greeting would be three words long, and because greet was exported, that description also applies to all future versions until the next breaking release. Because this new version does not conform to the old specification, it must be tagged as a breaking change.\n\nPlease note that version numbers are free and unlimited. It is okay to use lots of them (e.g. version 6.62.8).","category":"section"},{"location":"creating-packages/#Adding-a-build-step-to-the-package","page":"5. Creating Packages","title":"Adding a build step to the package","text":"The build step is executed the first time a package is installed or when explicitly invoked with build. A package is built by executing the file deps/build.jl.\n\njulia> mkpath(\"deps\");\n\njulia> write(\"deps/build.jl\",\n             \"\"\"\n             println(\"I am being built...\")\n             \"\"\");\n\n(HelloWorld) pkg> build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n\njulia> print(readchomp(\"deps/build.log\"))\nI am being built...\n\nIf the build step fails, the output of the build step is printed to the console\n\njulia> write(\"deps/build.jl\",\n             \"\"\"\n             error(\"Ooops\")\n             \"\"\");\n\n(HelloWorld) pkg> build\n    Building HelloWorld → `~/HelloWorld/deps/build.log`\nERROR: Error building `HelloWorld`:\nERROR: LoadError: Ooops\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] top-level scope\n   @ ~/HelloWorld/deps/build.jl:1\n [3] include(fname::String)\n   @ Base.MainInclude ./client.jl:476\n [4] top-level scope\n   @ none:5\nin expression starting at /home/kc/HelloWorld/deps/build.jl:1\n\nwarning: Warning\nA build step should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the Scratch.jl package.","category":"section"},{"location":"creating-packages/#adding-tests-to-packages","page":"5. Creating Packages","title":"Adding tests to the package","text":"When a package is tested the file test/runtests.jl is executed:\n\njulia> mkpath(\"test\");\n\njulia> write(\"test/runtests.jl\",\n             \"\"\"\n             println(\"Testing...\")\n             \"\"\");\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\nTesting...\n   Testing HelloWorld tests passed\n\nTests are run in a new Julia process, where the package itself, and any test-specific dependencies, are available, see below.\n\nwarning: Warning\nTests should generally not create or modify any files in the package directory. If you need to store some files from the build step, use the Scratch.jl package.","category":"section"},{"location":"creating-packages/#Test-specific-dependencies","page":"5. Creating Packages","title":"Test-specific dependencies","text":"There are two ways of adding test-specific dependencies (dependencies that are not dependencies of the package but will still be available to load when the package is tested).","category":"section"},{"location":"creating-packages/#target-based-test-specific-dependencies","page":"5. Creating Packages","title":"target based test specific dependencies","text":"Using this method of adding test-specific dependencies, the packages are added under an [extras] section and to a test target, e.g. to add Markdown and Test as test dependencies, add the following to the Project.toml file:\n\n[extras]\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Markdown\", \"Test\"]\n\nNote that the only supported targets are test and build, the latter of which (not recommended) can be used for any deps/build.jl scripts.","category":"section"},{"location":"creating-packages/#Alternative-approach:-test/Project.toml-file-test-specific-dependencies","page":"5. Creating Packages","title":"Alternative approach: test/Project.toml file test specific dependencies","text":"note: Note\nThe exact interaction between Project.toml, test/Project.toml and their corresponding Manifest.tomls are not fully worked out and may be subject to change in future versions. The older method of adding test-specific dependencies, described in the previous section, will therefore be supported throughout all Julia 1.X releases.\n\nIn Julia 1.2 and later test dependencies can be declared in test/Project.toml. When running tests, Pkg will automatically merge this and the package Projects to create the test environment.\n\nnote: Note\nIf no test/Project.toml exists Pkg will use the target based test specific dependencies.\n\nTo add a test-specific dependency, i.e. a dependency that is available only when testing, it is thus enough to add this dependency to the test/Project.toml project. This can be done from the Pkg REPL by activating this environment, and then use add as one normally does. Let's add the Test standard library as a test dependency:\n\n(HelloWorld) pkg> activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(test) pkg> add Test\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n  Updating `~/HelloWorld/test/Manifest.toml`\n  [...]\n\nWe can now use Test in the test script and we can see that it gets installed when testing:\n\njulia> write(\"test/runtests.jl\",\n             \"\"\"\n             using Test\n             @test 1 == 1\n             \"\"\");\n\n(test) pkg> activate .\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n  [8dfed614] + Test\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n   Testing HelloWorld tests passed```","category":"section"},{"location":"creating-packages/#Compatibility-on-dependencies","page":"5. Creating Packages","title":"Compatibility on dependencies","text":"Every dependency should in general have a compatibility constraint on it. This is an important topic so there is a separate chapter about it: Compatibility.","category":"section"},{"location":"creating-packages/#Weak-dependencies","page":"5. Creating Packages","title":"Weak dependencies","text":"note: Note\nThis is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.\n\ncompat: Compat\nThe described feature requires Julia 1.9+.\n\nA weak dependency is a dependency that will not automatically install when the package is installed but you can still control what versions of that package are allowed to be installed by setting compatibility on it. These are listed in the project file under the [weakdeps] section:\n\n[weakdeps]\nSomePackage = \"b3785f31-9d33-4cdf-bc73-f646780f1739\"\n\n[compat]\nSomePackage = \"1.2\"\n\nThe current usage of this is almost solely limited to \"extensions\" which is described in the next section.","category":"section"},{"location":"creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)","page":"5. Creating Packages","title":"Conditional loading of code in packages (Extensions)","text":"note: Note\nThis is a somewhat advanced usage of Pkg which can be skipped for people new to Julia and Julia packages.\n\ncompat: Compat\nThe described feature requires Julia 1.9+.\n\nSometimes one wants to make two or more packages work well together, but may be reluctant (perhaps due to increased load times) to make one an unconditional dependency of the other. A package extension is a module in a file (similar to a package) that is automatically loaded when some other set of packages are loaded into the Julia session. This is very similar to functionality that the external package Requires.jl provides, but which is now available directly through Julia, and provides added benefits such as being able to precompile the extension.","category":"section"},{"location":"creating-packages/#Code-structure","page":"5. Creating Packages","title":"Code structure","text":"A useful application of extensions could be for a plotting package that should be able to plot objects from a wide variety of different Julia packages. Adding all those different Julia packages as dependencies of the plotting package could be expensive since they would end up getting loaded even if they were never used. Instead, the code required to plot objects for specific packages can be put into separate files (extensions) and these are loaded only when the packages that define the type(s) we want to plot are loaded.\n\nBelow is an example of how the code can be structured for a use case in which a Plotting package wants to be able to display objects defined in the external package Contour. The file and folder structure shown below is found in the Plotting package.\n\nProject.toml:\n\nname = \"Plotting\"\nversion = \"0.1.0\"\nuuid = \"...\"\n\n[weakdeps]\nContour = \"d38c429a-6771-53c6-b99e-75d170b6e991\"\n\n[extensions]\n# name of extension to the left\n# extension dependencies required to load the extension to the right\n# use a list for multiple extension dependencies\nContourExt = \"Contour\"\n\n[compat]\nContour = \"0.6.2\"\n\nsrc/Plotting.jl:\n\nmodule Plotting\n\nfunction plot(x::Vector)\n    # Some functionality for plotting a vector here\nend\n\nend # module\n\next/ContourExt.jl (can also be in ext/ContourExt/ContourExt.jl):\n\nmodule ContourExt # Should be same name as the file (just like a normal package)\n\nusing Plotting, Contour\n\nfunction Plotting.plot(c::Contour.ContourCollection)\n    # Some functionality for plotting a contour here\nend\n\nend # module\n\nExtensions can have arbitrary names (here ContourExt), following the format of this example is likely a good idea for extensions with a single dependency. In Pkg output, extension names are always shown together with their parent package name.\n\ncompat: Compat\nOften you will put the extension dependencies into the test target so they are loaded when running e.g. Pkg.test(). On earlier Julia versions this requires you to also put the package in the [extras] section. This is unfortunate but the project verifier on older Julia versions will complain if this is not done.\n\nnote: Note\nIf you use a manifest generated by a Julia version that does not know about extensions with a Julia version that does know about them, the extensions will not load. This is because the manifest lacks some information that tells Julia when it should load these packages. So make sure you use a manifest generated at least the Julia version you are using.","category":"section"},{"location":"creating-packages/#Behavior-of-extensions","page":"5. Creating Packages","title":"Behavior of extensions","text":"A user that depends only on Plotting will not pay the cost of the \"extension\" inside the ContourExt module. It is only when the Contour package actually gets loaded that the ContourExt extension is loaded too and provides the new functionality.\n\nIn our example, the new functionality is an additional method, which we add to an existing function from the parent package Plotting. Implementing such methods is among the most standard use cases of package extensions. Within the parent package, the function to extend can even be defined with zero methods, as follows:\n\nfunction plot end\n\nnote: Note\nIf one considers ContourExt as a completely separate package, it could be argued that defining Plotting.plot(c::Contour.ContourCollection) is type piracy since ContourExt owns neither the function Plotting.plot nor the type Contour.ContourCollection. However, for extensions, it is ok to assume that the extension owns the functions in its parent package.\n\nIn other situations, one may need to define new symbols in the extension (types, structs, functions, etc.) instead of reusing those from the parent package. Such symbols are created in a separate module corresponding to the extension, namely ContourExt, and thus not in Plotting itself. If extension symbols are needed in the parent package, one must call Base.get_extension to retrieve them. Here is an example showing how a custom type defined in ContourExt can be accessed in Plotting:\n\next = Base.get_extension(@__MODULE__, :ContourExt)\nif !isnothing(ext)\n    ContourPlotType = ext.ContourPlotType\nend\n\nOn the other hand, accessing extension symbols from a third-party package (i.e. not the parent) is not a recommended practice at the moment.","category":"section"},{"location":"creating-packages/#Backwards-compatibility","page":"5. Creating Packages","title":"Backwards compatibility","text":"This section discusses various methods for using extensions on Julia versions that support them, while simultaneously providing similar functionality on older Julia versions.","category":"section"},{"location":"creating-packages/#Requires.jl","page":"5. Creating Packages","title":"Requires.jl","text":"This section is relevant if you are currently using Requires.jl but want to transition to using extensions (while still having Requires be used on Julia versions that do not support extensions). This is done by making the following changes (using the example above):\n\nAdd the following to the package file. This makes it so that Requires.jl loads and inserts the callback only when extensions are not supported\n# This symbol is only defined on Julia versions that support extensions\nif !isdefined(Base, :get_extension)\nusing Requires\nend\n\n@static if !isdefined(Base, :get_extension)\nfunction __init__()\n    @require Contour = \"d38c429a-6771-53c6-b99e-75d170b6e991\" include(\"../ext/ContourExt.jl\")\nend\nend\nor if you have other things in your __init__() function:\nif !isdefined(Base, :get_extension)\nusing Requires\nend\n\nfunction __init__()\n    # Other init functionality here\n\n    @static if !isdefined(Base, :get_extension)\n        @require Contour = \"d38c429a-6771-53c6-b99e-75d170b6e991\" include(\"../ext/ContourExt.jl\")\n    end\nend\nMake the following change in the conditionally-loaded code in ContourExt.jl:\nisdefined(Base, :get_extension) ? (using Contour) : (using ..Contour)\nAdd Requires to [weakdeps] in your Project.toml file, so that it is listed in both [deps] and [weakdeps]. Julia 1.9+ knows to not install it as a regular dependency, whereas earlier versions will consider it a dependency.\n\nThe package should now work with Requires.jl on Julia versions before extensions were introduced and with extensions on more recent Julia versions.","category":"section"},{"location":"creating-packages/#Transition-from-normal-dependency-to-extension","page":"5. Creating Packages","title":"Transition from normal dependency to extension","text":"This section is relevant if you have a normal dependency that you want to transition be an extension (while still having the dependency be a normal dependency on Julia versions that do not support extensions). This is done by making the following changes (using the example above):\n\nMake sure that the package is both in the [deps] and [weakdeps] section. Newer Julia versions will ignore dependencies in [deps] that are also in [weakdeps].\nAdd the following to your main package file (typically at the bottom):\nif !isdefined(Base, :get_extension)\n  include(\"../ext/ContourExt.jl\")\nend","category":"section"},{"location":"creating-packages/#Using-an-extension-while-supporting-older-Julia-versions","page":"5. Creating Packages","title":"Using an extension while supporting older Julia versions","text":"In the case where one wants to use an extension (without worrying about the feature of the extension being available on older Julia versions) while still supporting older Julia versions the packages under [weakdeps] should be duplicated into [extras]. This is an unfortunate duplication, but without doing this the project verifier under older Julia versions will throw an error if it finds packages under [compat] that is not listed in [extras].","category":"section"},{"location":"creating-packages/#Package-naming-rules","page":"5. Creating Packages","title":"Package naming rules","text":"Package names should be sensible to most Julia users, even to those who are not domain experts. The following rules apply to the General registry but may be useful for other package registries as well.\n\nSince the General registry belongs to the entire community, people may have opinions about your package name when you publish it, especially if it's ambiguous or can be confused with something other than what it is. Usually, you will then get suggestions for a new name that may fit your package better.\n\nAvoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.\nIt's ok to say USA if you're talking about the USA.\nIt's not ok to say PMA, even if you're talking about positive mental attitude.\nAvoid using Julia in your package name or prefixing it with Ju.\nIt is usually clear from context and to your users that the package is a Julia package.\nPackage names already have a .jl extension, which communicates to users that Package.jl is a Julia package.\nHaving Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.\nPackages that provide most of their functionality in association with a new type should have pluralized names.\nDataFrames provides the DataFrame type.\nBloomFilters provides the BloomFilter type.\nIn contrast, JuliaParser provides no new type, but instead new functionality in the JuliaParser.parse() function.\nErr on the side of clarity, even if clarity seems long-winded to you.\nRandomMatrices is a less ambiguous name than RndMat or RMT, even though the latter are shorter.\nA less systematic name may suit a package that implements one of several possible approaches to its domain.\nJulia does not have a single comprehensive plotting package. Instead, Gadfly, PyPlot, Winston and other packages each implement a unique approach based on a particular design philosophy.\nIn contrast, SortingAlgorithms provides a consistent interface to use many well-established sorting algorithms.\nPackages that wrap external libraries or programs can be named after those libraries or programs.\nCPLEX.jl wraps the CPLEX library, which can be identified easily in a web search.\nMATLAB.jl provides an interface to call the MATLAB engine from within Julia.\nAvoid naming a package closely to an existing package\nWebsocket is too close to WebSockets and can be confusing to users. Rather use a new name such as SimpleWebsockets.\nAvoid using a distinctive name that is already in use in a well known, unrelated project.\nDon't use the names Tkinter.jl, TkinterGUI.jl, etc. for a package that is unrelated to the popular tkinter python package, even if it provides bindings to Tcl/Tk. A package name of Tkinter.jl would only be appropriate if the package used Python's library to accomplish its work or was spearheaded by the same community of developers.\nIt's okay to name a package HTTP.jl even though it is unrelated to the popular rust crate http because in most usages the name \"http\" refers to the hypertext transfer protocol, not to the http rust crate.\nIt's okay to name a package OpenSSL.jl if it provides an interface to the OpenSSL library, even without explicit affiliation with the creators of the OpenSSL (provided there's no copyright or trademark infringement etc.)","category":"section"},{"location":"creating-packages/#Registering-packages","page":"5. Creating Packages","title":"Registering packages","text":"Once a package is ready it can be registered with the General Registry (see also the FAQ). Currently, packages are submitted via Registrator. In addition to Registrator, TagBot helps manage the process of tagging releases.","category":"section"},{"location":"creating-packages/#Best-Practices","page":"5. Creating Packages","title":"Best Practices","text":"Packages should avoid mutating their own state (writing to files within their package directory). Packages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by PackageCompiler.jl). To support the various use cases in the Julia package ecosystem, the Pkg developers have created a number of auxiliary packages and techniques to help package authors create self-contained, immutable, and relocatable packages:\n\nArtifacts can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand. Prefer artifacts over attempting to open a file via a path such as joinpath(@__DIR__, \"data\", \"my_dataset.csv\") as this is non-relocatable. Once your package has been precompiled, the result of @__DIR__ will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location. Artifacts can be bundled and accessed easily using the artifact\"name\" string macro.\nScratch.jl provides the notion of \"scratch spaces\", mutable containers of data for packages. Scratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled. For important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg.\nPreferences.jl allows packages to read and write preferences to the top-level Project.toml. These preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior. Packages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that Preferences is available.","category":"section"},{"location":"repl/#REPL-Mode-Reference","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"This section describes available commands in the Pkg REPL. The Pkg REPL mode is mostly meant for interactive use, and for non-interactive use it is recommended to use the functional API, see API Reference.","category":"section"},{"location":"repl/#package-commands","page":"11. REPL Mode Reference","title":"package commands","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-add\" href=\"#repl-add\">\n            <code>add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"add\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-build\" href=\"#repl-build\">\n            <code>build</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"build\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-compat\" href=\"#repl-compat\">\n            <code>compat</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"compat\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-develop\" href=\"#repl-develop\">\n            <code>develop</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"develop\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-free\" href=\"#repl-free\">\n            <code>free</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"free\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-generate\" href=\"#repl-generate\">\n            <code>generate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"generate\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-pin\" href=\"#repl-pin\">\n            <code>pin</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"pin\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-remove\" href=\"#repl-remove\">\n            <code>remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"remove\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-test\" href=\"#repl-test\">\n            <code>test</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"test\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-update\" href=\"#repl-update\">\n            <code>update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"update\"].help\n\n    </section>\n</article>","category":"section"},{"location":"repl/#registry-commands","page":"11. REPL Mode Reference","title":"registry commands","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-add\" href=\"#repl-registry-add\">\n            <code>registry add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry add\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-remove\" href=\"#repl-registry-remove\">\n            <code>registry remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry remove\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-status\" href=\"#repl-registry-status\">\n            <code>registry status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry status\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-update\" href=\"#repl-registry-update\">\n            <code>registry update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry update\"].help\n\n    </section>\n</article>","category":"section"},{"location":"repl/#Other-commands","page":"11. REPL Mode Reference","title":"Other commands","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-activate\" href=\"#repl-activate\">\n            <code>activate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"activate\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-gc\" href=\"#repl-gc\">\n            <code>gc</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"gc\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-help\" href=\"#repl-help\">\n            <code>help</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"help\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-instantiate\" href=\"#repl-instantiate\">\n            <code>instantiate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"instantiate\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-precompile\" href=\"#repl-precompile\">\n            <code>precompile</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"precompile\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-resolve\" href=\"#repl-resolve\">\n            <code>resolve</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"resolve\"].help\n\n    </section>\n</article>\n\n<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-status\" href=\"#repl-status\">\n            <code>status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>\n\nusing Pkg\nDict(Pkg.REPLMode.canonical_names())[\"status\"].help\n\n    </section>\n</article>","category":"section"},{"location":"#**1.**-Introduction","page":"1. Introduction","title":"1. Introduction","text":"Welcome to the documentation for Pkg, Julia's package manager. The documentation covers many things, for example managing package installations, developing packages, working with package registries and more.\n\nThroughout the manual the REPL interface to Pkg, the Pkg REPL mode, is used in the examples. There is also a functional API, which is preferred when not working interactively. This API is documented in the API Reference section.","category":"section"},{"location":"#Background-and-Design","page":"1. Introduction","title":"Background and Design","text":"Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around “environments”: independent sets of packages that can be local to an individual project or shared and selected by name. The exact set of packages and versions in an environment is captured in a manifest file which can be checked into a project repository and tracked in version control, significantly improving reproducibility of projects. If you’ve ever tried to run code you haven’t used in a while only to find that you can’t get anything to work because you’ve updated or uninstalled some of the packages your project was using, you’ll understand the motivation for this approach. In Pkg, since each project maintains its own independent set of package versions, you’ll never have this problem again. Moreover, if you check out a project on a new system, you can simply materialize the environment described by its manifest file and immediately be up and running with a known-good set of dependencies.\n\nSince environments are managed and updated independently from each other, “dependency hell” is significantly alleviated in Pkg. If you want to use the latest and greatest version of some package in a new project but you’re stuck on an older version in a different project, that’s no problem – since they have separate environments they can just use different versions, which are both installed at the same time in different locations on your system. The location of each package version is canonical, so when environments use the same versions of packages, they can share installations, avoiding unnecessary duplication of the package. Old package versions that are no longer used by any environments are periodically “garbage collected” by the package manager.\n\nPkg’s approach to local environments may be familiar to people who have used Python’s virtualenv or Ruby’s bundler. In Julia, instead of hacking the language’s code loading mechanisms to support environments, we have the benefit that Julia natively understands them. In addition, Julia environments are “stackable”: you can overlay one environment with another and thereby have access to additional packages outside of the primary environment. This makes it easy to work on a project, which provides the primary environment, while still having access from the REPL to all your usual dev tools like profilers, debuggers, and so on, just by having an environment including these dev tools later in the load path.\n\nLast but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you'll be back on an official release again.","category":"section"}]
}
